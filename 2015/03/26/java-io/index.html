<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Java_IO_NIO | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="java IO, NIO 相关笔记记录 
IO
NIOChannel
既是可以从通道中读取数据,又可以写数据到通道。但流的读写通常是单向的。
通道可以异步地读写。
从通道读取数据到缓冲区,从缓冲区写入数据到通道,通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。

通道重要实现Java NIO中最重要的通道的实现

FileChannel: 从文件中读写数据。
DatagramChannel: 能通过UDP读写网络中的数据。
SocketChannel: 能通过TCP">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Golang</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">System</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">Reverse</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">BigData</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/ai">Math/AI</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/physical">Physical</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/life">生活规划</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mesos/">Mesos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scikit/">Scikit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SofaMesh/">SofaMesh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TroubleShoot/">TroubleShoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x64-Windows系统总结/">x64 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内网穿透/">内网穿透</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IO"><span class="toc-number">1.</span> <span class="toc-text">IO</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NIO"><span class="toc-number">2.</span> <span class="toc-text">NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Channel"><span class="toc-number">2.1.</span> <span class="toc-text">Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通道重要实现"><span class="toc-number">2.1.1.</span> <span class="toc-text">通道重要实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileChannel"><span class="toc-number">2.1.2.</span> <span class="toc-text">FileChannel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#打开-FileChannel"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">打开 FileChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读取-FileChannel"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">读取 FileChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#写入-FileChannel"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">写入 FileChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关闭-FileChannel"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">关闭 FileChannel</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SocketChannel"><span class="toc-number">2.1.3.</span> <span class="toc-text">SocketChannel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#打开-SocketChannel"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">打开 SocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关闭-SocketChannel"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">关闭 SocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读取-SocketChannel"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">读取 SocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#写入-SocketChannel"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">写入 SocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非阻塞打开-SocketChannel"><span class="toc-number">2.1.3.5.</span> <span class="toc-text">非阻塞打开 SocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非阻塞读取-SocketChannel"><span class="toc-number">2.1.3.6.</span> <span class="toc-text">非阻塞读取 SocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非阻塞写入-SocketChannel"><span class="toc-number">2.1.3.7.</span> <span class="toc-text">非阻塞写入 SocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非阻塞模式与选择器"><span class="toc-number">2.1.3.8.</span> <span class="toc-text">非阻塞模式与选择器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ServerSocketChannel"><span class="toc-number">2.1.4.</span> <span class="toc-text">ServerSocketChannel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#打开-ServerSocketChannel"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">打开 ServerSocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关闭-ServerSocketChannel"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">关闭 ServerSocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#监听连接"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">监听连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非阻塞模式-监听连接"><span class="toc-number">2.1.4.4.</span> <span class="toc-text">非阻塞模式  监听连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DatagramChannel"><span class="toc-number">2.1.5.</span> <span class="toc-text">DatagramChannel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#打开-DatagramChannel"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">打开 DatagramChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接收数据-DatagramChannel"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">接收数据 DatagramChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#发送数据-DatagramChannel"><span class="toc-number">2.1.5.3.</span> <span class="toc-text">发送数据 DatagramChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#连接到特定的地址"><span class="toc-number">2.1.5.4.</span> <span class="toc-text">连接到特定的地址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Buffer"><span class="toc-number">2.2.</span> <span class="toc-text">Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介"><span class="toc-number">2.2.1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#capacity"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">capacity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#position"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">position</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limit"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">limit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer类型"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">Buffer类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer-分配"><span class="toc-number">2.2.2.</span> <span class="toc-text">Buffer 分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer-写数据"><span class="toc-number">2.2.3.</span> <span class="toc-text">Buffer 写数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer-读取数据"><span class="toc-number">2.2.4.</span> <span class="toc-text">Buffer 读取数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flip-方法"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">flip()方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他方法"><span class="toc-number">2.2.5.</span> <span class="toc-text">其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#rewind-方法"><span class="toc-number">2.2.5.0.1.</span> <span class="toc-text">rewind()方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clear-方法"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">clear()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compact-方法"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">compact()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mark-与reset-方法"><span class="toc-number">2.2.5.3.</span> <span class="toc-text">mark()与reset()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#equals-方法"><span class="toc-number">2.2.5.4.</span> <span class="toc-text">equals()方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#compareTo-方法"><span class="toc-number">2.2.5.4.1.</span> <span class="toc-text">compareTo()方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通道的数据传输"><span class="toc-number">2.3.</span> <span class="toc-text">通道的数据传输</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transferFrom-方法"><span class="toc-number">2.3.1.</span> <span class="toc-text">transferFrom()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transferTo-方法"><span class="toc-number">2.3.2.</span> <span class="toc-text">transferTo()方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Selector"><span class="toc-number">2.4.</span> <span class="toc-text">Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建-Selector"><span class="toc-number">2.4.1.</span> <span class="toc-text">创建 Selector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册通道-Selector"><span class="toc-number">2.4.2.</span> <span class="toc-text">注册通道 Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SelectionKey"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">SelectionKey</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择通道-Selector"><span class="toc-number">2.4.3.</span> <span class="toc-text">选择通道 Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#selectedKeys"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">selectedKeys()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他方法-1"><span class="toc-number">2.4.4.</span> <span class="toc-text">其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wakeUp-方法"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">wakeUp()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#close-方法"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">close()方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例"><span class="toc-number">2.4.5.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipe-管道"><span class="toc-number">2.5.</span> <span class="toc-text">Pipe 管道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建管道"><span class="toc-number">2.5.1.</span> <span class="toc-text">创建管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管道写数据"><span class="toc-number">2.5.2.</span> <span class="toc-text">管道写数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管道读取数据"><span class="toc-number">2.5.3.</span> <span class="toc-text">管道读取数据</span></a></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            Java_IO_NIO
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2015/03/26/java-io/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2015-03-25T16:33:02.000Z" itemprop="datePublished">2015-03-26</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/io/">io</a>, <a class="article-tag-link" href="/tags/java/">java</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>java IO, NIO 相关笔记记录<br><a id="more"></a> </p>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p><img src="/2015/03/26/java-io/image-01.png" width="500px"></p>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><ul>
<li>既是可以从通道中读取数据,又可以写数据到通道。但流的读写通常是单向的。</li>
<li>通道可以异步地读写。</li>
<li>从通道读取数据到缓冲区,从缓冲区写入数据到通道,通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li>
</ul>
<h3 id="通道重要实现"><a href="#通道重要实现" class="headerlink" title="通道重要实现"></a>通道重要实现</h3><p>Java NIO中最重要的通道的实现</p>
<ul>
<li>FileChannel: 从文件中读写数据。</li>
<li>DatagramChannel: 能通过UDP读写网络中的数据。</li>
<li>SocketChannel: 能通过TCP读写网络中的数据。</li>
<li>ServerSocketChannel: 可以监听新进来的TCP连接,像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</li>
</ul>
<h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p>Java NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。  </p>
<p>FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。  </p>
<h4 id="打开-FileChannel"><a href="#打开-FileChannel" class="headerlink" title="打开 FileChannel"></a>打开 FileChannel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br></pre></td></tr></table></figure>
<h4 id="读取-FileChannel"><a href="#读取-FileChannel" class="headerlink" title="读取 FileChannel"></a>读取 FileChannel</h4><p>调用多个read()方法之一从FileChannel中读取数据。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line"><span class="comment">//首先，分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。</span></span><br><span class="line"><span class="comment">//然后，调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。</span></span><br><span class="line"><span class="comment">//read()方法返回的int值表示了有多少字节被读到了Buffer中。如果返回-1，表示到了文件末尾。</span></span><br></pre></td></tr></table></figure>
<h4 id="写入-FileChannel"><a href="#写入-FileChannel" class="headerlink" title="写入 FileChannel"></a>写入 FileChannel</h4><p>使用FileChannel.write()方法向FileChannel写数据，该方法的参数是一个Buffer。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意FileChannel.write()是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节</span></span><br><span class="line"><span class="comment">//因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的字节。</span></span><br></pre></td></tr></table></figure>
<h4 id="关闭-FileChannel"><a href="#关闭-FileChannel" class="headerlink" title="关闭 FileChannel"></a>关闭 FileChannel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure>
<h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。可以通过以下2种方式创建SocketChannel</p>
<ul>
<li>打开一个SocketChannel并连接到互联网上的某台服务器。</li>
<li>一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。</li>
</ul>
<h4 id="打开-SocketChannel"><a href="#打开-SocketChannel" class="headerlink" title="打开 SocketChannel"></a>打开 SocketChannel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure>
<h4 id="关闭-SocketChannel"><a href="#关闭-SocketChannel" class="headerlink" title="关闭 SocketChannel"></a>关闭 SocketChannel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.close();</span><br><span class="line"><span class="comment">//当用完SocketChannel之后调用SocketChannel.close()关闭SocketChannel</span></span><br></pre></td></tr></table></figure>
<h4 id="读取-SocketChannel"><a href="#读取-SocketChannel" class="headerlink" title="读取 SocketChannel"></a>读取 SocketChannel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = socketChannel.read(buf);</span><br><span class="line"><span class="comment">//首先，分配一个Buffer。从SocketChannel读取到的数据将会放到这个Buffer中。</span></span><br><span class="line"><span class="comment">//然后，调用SocketChannel.read()。该方法将数据从SocketChannel读到Buffer中。</span></span><br><span class="line"><span class="comment">//read()方法返回的int值表示读了多少字节进Buffer里。如果返回的是-1，表示已经读到了流的末尾（连接关闭了）。</span></span><br></pre></td></tr></table></figure>
<h4 id="写入-SocketChannel"><a href="#写入-SocketChannel" class="headerlink" title="写入 SocketChannel"></a>写入 SocketChannel</h4><p>写数据到SocketChannel用的是SocketChannel.write()方法，该方法以一个Buffer作为参数。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意SocketChannel.write()方法的调用是在一个while循环中的。</span></span><br><span class="line"><span class="comment">//Write()方法无法保证能写多少字节到SocketChannel。</span></span><br><span class="line"><span class="comment">//所以我们重复调用write()直到Buffer没有要写的字节为止。</span></span><br></pre></td></tr></table></figure>
<h4 id="非阻塞打开-SocketChannel"><a href="#非阻塞打开-SocketChannel" class="headerlink" title="非阻塞打开 SocketChannel"></a>非阻塞打开 SocketChannel</h4><p>如果SocketChannel在非阻塞模式下，此时调用connect()，该方法可能在连接建立之前就返回了。<br>为了确定连接是否建立，可以调用finishConnect()的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(! socketChannel.finishConnect() )&#123;</span><br><span class="line">    <span class="comment">//wait, or do something else...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="非阻塞读取-SocketChannel"><a href="#非阻塞读取-SocketChannel" class="headerlink" title="非阻塞读取 SocketChannel"></a>非阻塞读取 SocketChannel</h4><p>非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。</p>
<h4 id="非阻塞写入-SocketChannel"><a href="#非阻塞写入-SocketChannel" class="headerlink" title="非阻塞写入 SocketChannel"></a>非阻塞写入 SocketChannel</h4><p>非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()。</p>
<h4 id="非阻塞模式与选择器"><a href="#非阻塞模式与选择器" class="headerlink" title="非阻塞模式与选择器"></a>非阻塞模式与选择器</h4><p>非阻塞模式与选择器搭配会工作的更好，通过将一或多个SocketChannel注册到Selector<br>可以询问选择器哪个通道已经准备好了读取，写入等。</p>
<h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道, 就像标准IO中的ServerSocket一样。</p>
<h4 id="打开-ServerSocketChannel"><a href="#打开-ServerSocketChannel" class="headerlink" title="打开 ServerSocketChannel"></a>打开 ServerSocketChannel</h4><p>通过调用 ServerSocketChannel.open() 方法来打开ServerSocketChannel  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br></pre></td></tr></table></figure>
<h4 id="关闭-ServerSocketChannel"><a href="#关闭-ServerSocketChannel" class="headerlink" title="关闭 ServerSocketChannel"></a>关闭 ServerSocketChannel</h4><p>通过调用ServerSocketChannel.close() 方法来关闭ServerSocketChannel.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.close();</span><br></pre></td></tr></table></figure>
<h4 id="监听连接"><a href="#监听连接" class="headerlink" title="监听连接"></a>监听连接</h4><p>通过 ServerSocketChannel.accept() 方法监听新进来的连接。<br>当 accept()方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。<br>因此, accept()方法会一直阻塞到有新连接到达。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel =</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//do something with socketChannel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非阻塞模式-监听连接"><a href="#非阻塞模式-监听连接" class="headerlink" title="非阻塞模式  监听连接"></a>非阻塞模式  监听连接</h4><p>ServerSocketChannel可以设置成非阻塞模式。<br>在非阻塞模式下，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是null。<br>因此，需要检查返回的SocketChannel是否是null.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel =</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(socketChannel != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//do something with socketChannel...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><h4 id="打开-DatagramChannel"><a href="#打开-DatagramChannel" class="headerlink" title="打开 DatagramChannel"></a>打开 DatagramChannel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DatagramChannel channel = DatagramChannel.open();</span><br><span class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line"><span class="comment">//DatagramChannel可以在UDP端口9999上接收数据包。</span></span><br></pre></td></tr></table></figure>
<h4 id="接收数据-DatagramChannel"><a href="#接收数据-DatagramChannel" class="headerlink" title="接收数据 DatagramChannel"></a>接收数据 DatagramChannel</h4><p>receive()方法会将接收到的数据包内容复制到指定的Buffer.<br>如果Buffer容不下收到的数据，多出的数据将被丢弃。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">channel.receive(buf);</span><br></pre></td></tr></table></figure>
<h4 id="发送数据-DatagramChannel"><a href="#发送数据-DatagramChannel" class="headerlink" title="发送数据 DatagramChannel"></a>发送数据 DatagramChannel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesSent = channel.send(buf, <span class="keyword">new</span> InetSocketAddress(<span class="string">"jenkov.com"</span>, <span class="number">80</span>));</span><br><span class="line"><span class="comment">//发送一串字符到”jenkov.com”服务器的UDP端口80。 //因为服务端并没有监控这个端口，所以什么也不会发生。也不会通知你发出的数据包是否已收到，因为UDP在数据传送方面没有任何保证。</span></span><br></pre></td></tr></table></figure>
<h4 id="连接到特定的地址"><a href="#连接到特定的地址" class="headerlink" title="连接到特定的地址"></a>连接到特定的地址</h4><p>由于UDP是无连接的，连接到特定地址并不会像TCP通道那样创建一个真正的连接。<br>而是锁住DatagramChannel ，让其只能从特定地址收发数据。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"jenkov.com"</span>, <span class="number">80</span>));</span><br><span class="line"><span class="keyword">int</span> bytesRead = channel.read(buf);</span><br><span class="line"><span class="keyword">int</span> bytesWritten = channel.write(but);</span><br><span class="line"><span class="comment">//当连接后，也可以使用read()和write()方法，就像在用传统的通道一样。只是在数据传送方面没有任何保证。</span></span><br></pre></td></tr></table></figure>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Buffer的基本用法<br>使用Buffer读写数据一般遵循以下四个步骤：</p>
<ul>
<li>写入数据到Buffer</li>
<li>调用flip()方法</li>
<li>从Buffer中读取数据</li>
<li>调用clear()方法或者compact()方法</li>
</ul>
<p>当向buffer写入数据时，buffer会记录下写了多少数据。<br>一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。<br>在读模式下，可以读取之前写入到buffer的所有数据。</p>
<p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。<br>有两种方式能清空缓冲区：调用clear()或compact()方法。 </p>
<ul>
<li>clear()方法会清空整个缓冲区。 </li>
<li>compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//create buffer with capacity of 48 bytes</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">//read into buffer.</span></span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">  buf.flip();  <span class="comment">//make buffer ready for read</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">      System.out.print((<span class="keyword">char</span>) buf.get()); <span class="comment">// read 1 byte at a time</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buf.clear(); <span class="comment">//make buffer ready for writing</span></span><br><span class="line">  bytesRead = inChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure>
<h4 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h4><p>作为一个内存块，Buffer有一个固定的大小值，也叫”capacity”.你只能往里写capacity个byte、long，char等类型。<br>一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p>
<h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><p>当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.</p>
<p>当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。<br>写模式下，limit等于Buffer的capacity。</p>
<p>当切换Buffer到读模式时， limit表示你最多能读到多少数据。<br>因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</p>
<h4 id="Buffer类型"><a href="#Buffer类型" class="headerlink" title="Buffer类型"></a>Buffer类型</h4><p>Java NIO 有以下Buffer类型</p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<h3 id="Buffer-分配"><a href="#Buffer-分配" class="headerlink" title="Buffer 分配"></a>Buffer 分配</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="comment">//一个分配48字节capacity的ByteBuffer</span></span><br><span class="line">CharBuffer buf = CharBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="comment">//分配一个可存储1024个字符的CharBuffer</span></span><br></pre></td></tr></table></figure>
<h3 id="Buffer-写数据"><a href="#Buffer-写数据" class="headerlink" title="Buffer 写数据"></a>Buffer 写数据</h3><ul>
<li>从Channel写到Buffer。</li>
<li>通过Buffer的put()方法写到Buffer里。</li>
</ul>
<p>从Channel写到Buffer的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); </span><br><span class="line"><span class="comment">//从Channel写到Buffer的例子</span></span><br><span class="line">buf.put(<span class="number">127</span>);</span><br><span class="line"><span class="comment">//通过put方法写Buffer的例子</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Buffer-读取数据"><a href="#Buffer-读取数据" class="headerlink" title="Buffer 读取数据"></a>Buffer 读取数据</h3><p>从Buffer中读取数据有两种方式：</p>
<ul>
<li>从Buffer读取数据到Channel。</li>
<li>使用get()方法从Buffer中读取数据。</li>
</ul>
<h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><p>flip方法将Buffer从写模式切换到读模式。<br>调用flip()方法会将position设回0，并将limit设置成之前position的值。<br>换句话说，position现在用于标记读的位置，limit表示之前写进了多少个byte、char等 —— 现在能读取多少个byte、char等。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从Buffer读取数据到Channel的例子</span></span><br><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用get()方法从Buffer中读取数据的例子</span></span><br><span class="line"><span class="keyword">byte</span> aByte = buf.get();</span><br></pre></td></tr></table></figure>
<p>get方法有很多版本，允许你以不同的方式从Buffer中读取数据。<br>例如，从指定position读取，或者从Buffer中读取数据到字节数组。  </p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h5 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h5><p>Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。<br>limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。</p>
<h4 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear()方法"></a>clear()方法</h4><p>一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。<br>可以通过clear()或compact()方法来完成。</p>
<p>如果调用的是clear()方法，position将被设回0，limit被设置成 capacity的值。<br>换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。<br>如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。</p>
<h4 id="compact-方法"><a href="#compact-方法" class="headerlink" title="compact()方法"></a>compact()方法</h4><p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。<br>compact()方法将所有未读的数据拷贝到Buffer起始处。<br>然后将position设到最后一个未读元素正后面。<br>limit属性依然像clear()方法一样，设置成capacity。<br>现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p>
<h4 id="mark-与reset-方法"><a href="#mark-与reset-方法" class="headerlink" title="mark()与reset()方法"></a>mark()与reset()方法</h4><p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。<br>之后可以通过调用Buffer.reset()方法恢复到这个position。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();</span><br><span class="line"><span class="comment">//call buffer.get() a couple of times, e.g. during parsing.</span></span><br><span class="line">buffer.reset();  <span class="comment">//set position back to mark.</span></span><br></pre></td></tr></table></figure>
<h4 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h4><p>当满足下列条件时，表示两个Buffer相等：</p>
<ul>
<li>有相同的类型（byte、char、int等）。</li>
<li>Buffer中剩余的byte、char等的个数相等。</li>
<li>Buffer中所有剩余的byte、char等都相同。</li>
</ul>
<p>如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。</p>
<h5 id="compareTo-方法"><a href="#compareTo-方法" class="headerlink" title="compareTo()方法"></a>compareTo()方法</h5><p>compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer”小于”另一个Buffer：</p>
<ul>
<li>第一个不相等的元素小于另一个Buffer中对应的元素 。</li>
<li>所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。</li>
</ul>
<h2 id="通道的数据传输"><a href="#通道的数据传输" class="headerlink" title="通道的数据传输"></a>通道的数据传输</h2><p>如果两个通道中有一个是FileChannel，那你可以直接将数据从一个channel传输到另外一个channel。<br>SocketChannel的问题在transferTo()方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满</p>
<h3 id="transferFrom-方法"><a href="#transferFrom-方法" class="headerlink" title="transferFrom()方法"></a>transferFrom()方法</h3><p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">toChannel.transferFrom(position, count, fromChannel);</span><br></pre></td></tr></table></figure>
<p>方法的输入参数position表示从position处开始向目标文件写入数据<br>count表示最多传输的字节数,如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。  </p>
<p>此外要注意，在SoketChannel的实现中，SocketChannel只会传输此刻准备好的数据（可能不足count字节）。<br>因此，SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中。</p>
<h3 id="transferTo-方法"><a href="#transferTo-方法" class="headerlink" title="transferTo()方法"></a>transferTo()方法</h3><p>transferTo()方法将数据从FileChannel传输到其他的channel中。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。<br>这样一个单独的线程可以管理多个channel，从而管理多个网络连接。  </p>
<h3 id="创建-Selector"><a href="#创建-Selector" class="headerlink" title="创建 Selector"></a>创建 Selector</h3><p>调用Selector.open()方法创建一个Selector</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>
<h3 id="注册通道-Selector"><a href="#注册通道-Selector" class="headerlink" title="注册通道 Selector"></a>注册通道 Selector</h3><p>为了将Channel和Selector配合使用，必须将channel注册到selector上。通过SelectableChannel.register()方法来实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector,Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure></p>
<p>与Selector一起使用时，Channel必须处于非阻塞模式下。<br>这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。  </p>
<p>注意register()方法的第二个参数。这是一个”interest集合”<br>意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p>
<ul>
<li>Connect : SelectionKey.OP_CONNECT</li>
<li>Accept : SelectionKey.OP_ACCEPT</li>
<li>Read : SelectionKey.OP_READ</li>
<li>Write : SelectionKey.OP_WRITE</li>
</ul>
<p>如果你对不止一种事件感兴趣，那么可以用”位或”操作符将常量连接起来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure></p>
<h4 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h4><p>当向Selector注册Channel时,register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性：</p>
<ul>
<li><p>interest集合<br>  interest集合是你所选择的感兴趣的事件集合</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ready集合<br>  ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个readySet</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readySet = selectionKey.readyOps();</span><br><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Channel</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Selector  </p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure>
</li>
<li><p>附加对象</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="选择通道-Selector"><a href="#选择通道-Selector" class="headerlink" title="选择通道 Selector"></a>选择通道 Selector</h3><ul>
<li>int select()<br>  select()阻塞到至少有一个通道在你注册的事件上就绪了。</li>
<li>int select(long timeout)<br>  select(long timeout)和select()一样，除了最长会阻塞timeout毫秒(参数)。</li>
<li>int selectNow()<br>  selectNow()不会阻塞，不管什么通道就绪都立刻返回</li>
</ul>
<p>select()方法返回的int值表示有多少通道已经就绪。<br>如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。<br>如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道<br>但在每次select()方法调用之间，只有一个通道就绪了。  </p>
<h4 id="selectedKeys"><a href="#selectedKeys" class="headerlink" title="selectedKeys()"></a>selectedKeys()</h4><p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了<br>然后可以通过调用selector的selectedKeys()方法,访问”已选择键集(selected key set)”中的就绪通道。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure>
<p>当像Selector注册Channel时，Channel.register()方法会返回一个SelectionKey 对象。<br>这个对象代表了注册到该Selector的通道。<br>可以通过SelectionKey的selectedKeySet()方法访问这些对象。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以遍历这个已选择的键集合来访问就绪的通道</span></span><br><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。  </p>
<p>注意每次迭代末尾的keyIterator.remove()调用。<br>Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。  </p>
<p>下次该通道变成就绪时，Selector会再次将其放入已选择键集中。  </p>
<p>SelectionKey.channel()方法返回的通道需要转型成你要处理的类型，如ServerSocketChannel或SocketChannel等。  </p>
<h3 id="其他方法-1"><a href="#其他方法-1" class="headerlink" title="其他方法"></a>其他方法</h3><h4 id="wakeUp-方法"><a href="#wakeUp-方法" class="headerlink" title="wakeUp()方法"></a>wakeUp()方法</h4><p>某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。<br>只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。<br>阻塞在select()方法上的线程会立马返回。<br>如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即”醒来(wake up)”。</p>
<h4 id="close-方法"><a href="#close-方法" class="headerlink" title="close()方法"></a>close()方法</h4><p>用完Selector后调用其close()方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>打开一个Selector，注册一个通道注册到这个Selector上(通道的初始化过程略去)<br>然后持续监控这个Selector的四种事件（接受，连接，读，写）是否就绪。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  Set selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Pipe-管道"><a href="#Pipe-管道" class="headerlink" title="Pipe 管道"></a>Pipe 管道</h2><p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。</p>
<h3 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h3><p>通过Pipe.open()方法打开管道。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe pipe = Pipe.open();</span><br></pre></td></tr></table></figure>
<h3 id="管道写数据"><a href="#管道写数据" class="headerlink" title="管道写数据"></a>管道写数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line"></span><br><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">    sinkChannel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="管道读取数据"><a href="#管道读取数据" class="headerlink" title="管道读取数据"></a>管道读取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = sourceChannel.read(buf);</span><br><span class="line"><span class="comment">//read()方法返回的int值会告诉我们多少字节被读进了缓冲区。</span></span><br></pre></td></tr></table></figure>
        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2015/03/26/java-io/';
        this.page.title = 'Java_IO_NIO';
        this.page.identifier = '2015/03/26/java-io/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
