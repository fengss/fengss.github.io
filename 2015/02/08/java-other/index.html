<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>反射&amp;代理&amp;类加载 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="Java周边技术解析
代理静态代理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/**  * 定义一个账户接口  *   * @author Administrator  *   */  public interface Count &amp;#123;      // 查看账户方法    ">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java后端</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">Cpp嵌入式</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Go云原生</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">Linux安全</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">Win安全</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">数据与算法</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/work">工作相关</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">文章标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Net/">Net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nosql/">Nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rust/">Rust</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/嵌入式/">嵌入式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">历史归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#代理"><span class="toc-number">1.</span> <span class="toc-text">代理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#静态代理"><span class="toc-number">1.1.</span> <span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK动态代理"><span class="toc-number">1.2.</span> <span class="toc-text">JDK动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InvocationHandler接口"><span class="toc-number">1.2.1.</span> <span class="toc-text">InvocationHandler接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy类"><span class="toc-number">1.2.2.</span> <span class="toc-text">Proxy类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例"><span class="toc-number">1.2.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CGlib动态代理"><span class="toc-number">1.3.</span> <span class="toc-text">CGlib动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#示例-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aspectj"><span class="toc-number">1.4.</span> <span class="toc-text">Aspectj</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-AOP相同点"><span class="toc-number">1.4.1.</span> <span class="toc-text">Spring AOP相同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-AOP不同点"><span class="toc-number">1.4.2.</span> <span class="toc-text">Spring AOP不同点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aop-运行时生成代理方案选择"><span class="toc-number">1.5.</span> <span class="toc-text">Aop 运行时生成代理方案选择</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类加载"><span class="toc-number">2.</span> <span class="toc-text">类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#图解分析类加载"><span class="toc-number">2.1.</span> <span class="toc-text">图解分析类加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加载"><span class="toc-number">2.2.</span> <span class="toc-text">加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器"><span class="toc-number">2.2.1.</span> <span class="toc-text">类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委派模型"><span class="toc-number">2.2.2.</span> <span class="toc-text">双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工作流程"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优点"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#验证"><span class="toc-number">2.3.</span> <span class="toc-text">验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件格式的验证"><span class="toc-number">2.3.1.</span> <span class="toc-text">文件格式的验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元数据验证"><span class="toc-number">2.3.2.</span> <span class="toc-text">元数据验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字节码验证"><span class="toc-number">2.3.3.</span> <span class="toc-text">字节码验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#符号引用验证"><span class="toc-number">2.3.4.</span> <span class="toc-text">符号引用验证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#准备"><span class="toc-number">2.4.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解析"><span class="toc-number">2.5.</span> <span class="toc-text">解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类或接口的解析"><span class="toc-number">2.5.1.</span> <span class="toc-text">类或接口的解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字段解析"><span class="toc-number">2.5.2.</span> <span class="toc-text">字段解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类方法解析"><span class="toc-number">2.5.3.</span> <span class="toc-text">类方法解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口方法解析"><span class="toc-number">2.5.4.</span> <span class="toc-text">接口方法解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化"><span class="toc-number">2.6.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#clinit-收集产生"><span class="toc-number">2.6.1.</span> <span class="toc-text">clinit() 收集产生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clinit-的产生规则"><span class="toc-number">2.6.2.</span> <span class="toc-text">clinit() 的产生规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的执行顺序-clinit"><span class="toc-number">2.6.3.</span> <span class="toc-text">类的执行顺序 clinit()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口与类的不同-clinit"><span class="toc-number">2.6.4.</span> <span class="toc-text">接口与类的不同 clinit()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clinit-的加锁"><span class="toc-number">2.6.5.</span> <span class="toc-text">clinit() 的加锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">3.</span> <span class="toc-text">参考</span></a></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
           反射&amp;代理&amp;类加载
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2015/02/08/java-other/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2015-02-08T01:08:07.000Z" itemprop="datePublished">2015-02-08</time>
</a>

            

        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>Java周边技术解析<br><a id="more"></a></p>
<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 定义一个账户接口 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Count</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 查看账户方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryCount</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 修改账户方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCount</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountImpl</span> <span class="keyword">implements</span> <span class="title">Count</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryCount</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"查看账户方法..."</span>);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCount</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"修改账户方法..."</span>);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountProxy</span> <span class="keyword">implements</span> <span class="title">Count</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> CountImpl countImpl;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 覆盖默认构造器 </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countImpl </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountProxy</span><span class="params">(CountImpl countImpl)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.countImpl = countImpl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryCount</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"事务处理之前"</span>);  </span><br><span class="line">        <span class="comment">// 调用委托类的方法;  </span></span><br><span class="line">        countImpl.queryCount();  </span><br><span class="line">        System.out.println(<span class="string">"事务处理之后"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCount</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"事务处理之前"</span>);  </span><br><span class="line">        <span class="comment">// 调用委托类的方法;  </span></span><br><span class="line">        countImpl.updateCount();  </span><br><span class="line">        System.out.println(<span class="string">"事务处理之后"</span>);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCount</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        CountImpl countImpl = <span class="keyword">new</span> CountImpl();  </span><br><span class="line">        CountProxy countProxy = <span class="keyword">new</span> CountProxy(countImpl);  </span><br><span class="line">        countProxy.updateCount();  </span><br><span class="line">        countProxy.queryCount();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现每一个代理类只能为一个接口服务，这样一来程序开发中必然会产生过多的代理  </p>
<p>解决这一问题最好的做法是可以通过一个代理类完成全部的代理功能，那么此时就必须使用动态代理完成。</p>
<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>JDK动态代理中包含一个类和一个接口    </p>
<h3 id="InvocationHandler接口"><a href="#InvocationHandler接口" class="headerlink" title="InvocationHandler接口"></a>InvocationHandler接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span> <span class="keyword">throws</span> Throwable</span>; </span><br><span class="line">&#125; </span><br><span class="line">参数说明： </span><br><span class="line">Object proxy：指被代理的对象。 </span><br><span class="line">Method method：要调用的方法 </span><br><span class="line">Object[] args：方法调用时所需要的参数</span><br><span class="line"></span><br><span class="line">可以将InvocationHandler接口的子类想象成一个代理的最终操作类，替换掉ProxySubject。</span><br></pre></td></tr></table></figure>
<h3 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h3><p>Proxy类是专门完成代理的操作类，可以通过此类为一个或多个接口动态地生成实现类，此类提供了如下的操作方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, </span></span></span><br><span class="line"><span class="function"><span class="params">InvocationHandler h)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IllegalArgumentException </span></span><br><span class="line"><span class="function">参数说明： </span></span><br><span class="line"><span class="function">ClassLoader loader：类加载器 </span></span><br><span class="line"><span class="function">Class&lt;?&gt;[] interfaces：得到全部的接口 </span></span><br><span class="line"><span class="function">InvocationHandler h：得到InvocationHandler接口的子类实例</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在Proxy类中的newProxyInstance()方法中需要一个ClassLoader类的实例，ClassLoader实际上对应的是类加载器，在Java中主要有一下三种类加载器;</p>
</blockquote>
<ul>
<li>Booststrap ClassLoader：此加载器采用C++编写，一般开发中是看不到的；</li>
<li>Extendsion ClassLoader：用来进行扩展类的加载，一般对应的是jre\lib\ext目录中的类;</li>
<li>AppClassLoader：(默认)加载classpath指定的类，是最常使用的是一种加载器。  </li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookFacade</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeImpl</span> <span class="keyword">implements</span> <span class="title">BookFacade</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"增加图书方法。。。"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Object target;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 绑定委托对象并返回一个代理类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.target = target;  </span><br><span class="line">        <span class="comment">//取得代理对象  </span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),  </span><br><span class="line">                target.getClass().getInterfaces(), <span class="keyword">this</span>);   <span class="comment">//要绑定接口(这是一个缺陷，cglib弥补了这一缺陷)  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 调用方法 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        Object result=<span class="keyword">null</span>;  </span><br><span class="line">        System.out.println(<span class="string">"事物开始"</span>);  </span><br><span class="line">        <span class="comment">//执行方法  </span></span><br><span class="line">        result=method.invoke(target, args);  </span><br><span class="line">        System.out.println(<span class="string">"事物结束"</span>);  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    BookFacadeProxy proxy = <span class="keyword">new</span> BookFacadeProxy();  </span><br><span class="line">    BookFacade bookProxy = (BookFacade) proxy.bind(<span class="keyword">new</span> BookFacadeImpl());  </span><br><span class="line">    bookProxy.addBook();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CGlib动态代理"><a href="#CGlib动态代理" class="headerlink" title="CGlib动态代理"></a>CGlib动态代理</h2><p>JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理<br>cglib是针对类继承来实现代理的  </p>
<p>他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 一个模拟的add方法 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"add ------------"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] args,  </span></span></span><br><span class="line"><span class="function"><span class="params">            MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        <span class="comment">// 添加切面逻辑（advise），此处是在目标类代码执行之前，即为MethodBeforeAdviceInterceptor。  </span></span><br><span class="line">        System.out.println(<span class="string">"before-------------"</span>);  </span><br><span class="line">        <span class="comment">// 执行目标类add方法  </span></span><br><span class="line">        proxy.invokeSuper(object, args);  </span><br><span class="line">        <span class="comment">// 添加切面逻辑（advise），此处是在目标类代码执行之后，即为MethodAfterAdviceInterceptor。  </span></span><br><span class="line">        System.out.println(<span class="string">"after--------------"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 获得增强之后的目标类，即添加了切入逻辑advice之后的目标类 </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title">getInstance</span><span class="params">(CglibProxy proxy)</span> </span>&#123;  </span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();  </span><br><span class="line">        enhancer.setSuperclass(Base.class);  </span><br><span class="line">        <span class="comment">//回调方法的参数为代理类对象CglibProxy，最后增强目标类调用的是代理类对象CglibProxy中的intercept方法  </span></span><br><span class="line">        enhancer.setCallback(proxy);  </span><br><span class="line">        <span class="comment">// 此刻，base不是单纯的目标类，而是增强过的目标类  </span></span><br><span class="line">        Base base = (Base) enhancer.create();  </span><br><span class="line">        <span class="keyword">return</span> base;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        CglibProxy proxy = <span class="keyword">new</span> CglibProxy();  </span><br><span class="line">        <span class="comment">// base为生成的增强过的目标类  </span></span><br><span class="line">        Base base = Factory.getInstance(proxy);  </span><br><span class="line">        base.add();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Aspectj"><a href="#Aspectj" class="headerlink" title="Aspectj"></a>Aspectj</h2><p>AspectJ 是最早、功能比较强大的 AOP 实现之一  </p>
<h3 id="Spring-AOP相同点"><a href="#Spring-AOP相同点" class="headerlink" title="Spring AOP相同点"></a>Spring AOP相同点</h3><p>Spring AOP 同样需要对目标类进行增强，也就是生成新的 AOP 代理类</p>
<h3 id="Spring-AOP不同点"><a href="#Spring-AOP不同点" class="headerlink" title="Spring AOP不同点"></a>Spring AOP不同点</h3><p>与 AspectJ 不同的是，Spring AOP 无需使用任何特殊命令对 Java源代码进行编译<br>它采用运行时动态地、在内存中临时生成”代理类”的方式来生成 AOP 代理。  </p>
<p>Spring 允许使用 AspectJ Annotation 用于定义方面(Aspect)、切入点(Pointcut)和增强处理(Advice)<br>Spring 框架则可识别并根据这些 Annotation 来生成 AOP 代理。<br>Spring 只是使用了和 AspectJ 5 一样的注解，但并没有使用 AspectJ 的编译器或者织入器(Weaver),底层依然使用的是 Spring AOP，依然是在运行时动态生成 AOP 代理，并不依赖于 AspectJ 的编译器或者织入器。  </p>
<h2 id="Aop-运行时生成代理方案选择"><a href="#Aop-运行时生成代理方案选择" class="headerlink" title="Aop 运行时生成代理方案选择"></a>Aop 运行时生成代理方案选择</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy proxy-target-<span class="class"><span class="keyword">class</span></span>=<span class="string">"true"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//org.springframework.transaction.interceptor.TransactionProxyFactoryBean是org.springframework.aop.framework. ProxyConfig的子类</span></span><br><span class="line"><span class="comment">//所以可以参照ProxyConfig里的一些设置如下所示，将optimize和proxyTargetClass任意一个设置为true都可以强制Spring采用CGLIB代理。</span></span><br></pre></td></tr></table></figure>
<p>proxy-target-class属性设为true:强制使用CGLIB代理;  </p>
<ul>
<li><p>JDK动态代理:其代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。</p>
</li>
<li><p>CGLIB代理:实现原理类似于JDK动态代理，只是它在运行期间生成的代理对象是针对目标类扩展的子类。CGLIB是高效的代码生成包，底层是依靠ASM（开源的java字节码编辑类库）操作字节码实现的，性能比JDK强。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport advisedSupport)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//在此判断使用JDK动态代理还是CGLIB代理   </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (advisedSupport.isOptimize() || advisedSupport.isProxyTargetClass()   </span><br><span class="line"></span><br><span class="line">            || hasNoUserSuppliedProxyInterfaces(advisedSupport)) &#123;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cglibAvailable) &#123;   </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(   </span><br><span class="line"></span><br><span class="line">                    <span class="string">"Cannot proxy target class because CGLIB2 is not available. "</span>  </span><br><span class="line"></span><br><span class="line">                            + <span class="string">"Add CGLIB to the class path or specify proxy interfaces."</span>);   </span><br><span class="line"></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> CglibProxyFactory.createCglibProxy(advisedSupport);   </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(advisedSupport);   </span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>advisedSupport.isOptimize()与advisedSupport.isProxyTargetClass()默认返回都是false,所以在默认情况下目标对象有没有实现接口决定着Spring采取的策略<br>当然可以设置advisedSupport.isOptimize()或者advisedSupport.isProxyTargetClass()返回为true,这样无论目标对象有没有实现接口Spring都会选择使用CGLIB代理。        </p>
<p><br><br>所以在默认情况下,如果一个目标对象如果实现了接口Spring则会选择JDK动态代理策略动态的创建一个接口实现类(动态代理类)来代理目标对象,可以通俗的理解这个动态代理类是目标对象的另外一个版本,所以这两者之间在强制转换的时候会抛出java.lang.ClassCastException。<br>如果目标对象没有实现任何接口,Spring会选择CGLIB代理,其生成的动态代理对象是目标类的子类。  </p>
<p><br><br><br><br><br></p>
<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段  </p>
<p><img src="/2015/02/08/java-other/image-01.png" width="500px"></p>
<h2 id="图解分析类加载"><a href="#图解分析类加载" class="headerlink" title="图解分析类加载"></a>图解分析类加载</h2><p><img src="/2015/02/08/java-other/image-03.png" width="500px"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderProduce</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> d=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是ClassLoaderProduce类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">        String c=<span class="string">"hello"</span>;</span><br><span class="line">        SimpleClass simpleClass=<span class="keyword">new</span> SimpleClass();</span><br><span class="line">        simpleClass.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>  a=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        a=<span class="number">100</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对类进行加载！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我要跑跑跑！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相关解释</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">步骤一：装载ClassLoaderProduce类，在方法区生成动态数据结构(静态变量、静态方法、常量池、类代码)，并且在堆中生成java.lang.Class对象；然后进行链接</span><br><span class="line"></span><br><span class="line">步骤二：初始化：把static&#123;&#125;与静态变量合并存放在类构造器当中，对静态变量赋值。 1-5行执行完毕。</span><br><span class="line"></span><br><span class="line">步骤三：执行main方法，首先在栈里面生成一个main方法的栈祯，定义变量b、c，注意此处的变量b、c存储的常量池存储的变量的地址，如图所示。</span><br><span class="line"></span><br><span class="line">步骤四：创建SimpleClass对象；跟上面步骤类似：加载-链接-初始化。然后，调用run()方法的时候，它会通过classLoader局部变量的地址寻找到类的class对象并且调用run()方法</span><br></pre></td></tr></table></figure>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul>
<li><p>通过一个类的全限定名来获取其定义的二进制字节流。  </p>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。  </p>
</li>
<li><p>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。  </p>
</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li>启动类加载器：Bootstrap ClassLoader,跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下,或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的）</li>
<li>扩展类加载器：Extension ClassLoader,该加载器由sun.misc.Launcher$ExtClassLoader实现,它负责加载JDK\jre\lib\ext目录中,或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类),开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器：Application ClassLoader,该类加载器由sun.misc.Launcher$AppClassLoader来实现,它负责加载用户类路径（ClassPath）所指定的类,开发者可以直接使用该类加载器,如果应用程序中没有自定义过自己的类加载器,一般情况下这个就是程序中默认的类加载器。      </li>
</ul>
<p>如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p>
<p> 1: 在执行非置信代码之前，自动验证数字签名。</p>
<p> 2: 动态地创建符合用户特定需要的定制化构建类。</p>
<p> 3: 从特定的场所取得java class，例如数据库中和网络中。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><img src="/2015/02/08/java-other/image-02.png" width="500px"></p>
<p> 这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器<br> 当然它们之间的父子关系并不是通过继承关系来实现的,而是使用组合关系来复用父加载器中的代码。<br> 该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中,但它并不是一个强制性的约束模型,而是Java设计者们推荐给开发者的一种类的加载器实现方式。</p>
<p>自己写的classloader:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">首先执行loadclass函数,在这个函数里会执行findloadclass从缓存中找是否加载过这个类,如果没有直接调用父类的loadclass,先不找等父级找不到再找findclass,找到则返回</span><br><span class="line"></span><br><span class="line">app class loader</span><br><span class="line"></span><br><span class="line">首先执行loadclass函数,在这个函数里会执行findloadclass从缓存中找是否加载过这个类,如果没有直接调用父类的loadclass,先不找等父级找不到再找findclass,找到则返回</span><br><span class="line"></span><br><span class="line">CLASS_PATH中找</span><br><span class="line"></span><br><span class="line">ext class loader</span><br><span class="line"></span><br><span class="line">首先执行loadclass函数,在这个函数里会执行findloadclass从缓存中找是否加载过这个类,如果没有直接调用父类的loadclass,先不找等父级找不到再找findclass,找到则返回</span><br><span class="line"></span><br><span class="line">/JAVA_HOME/jre/lib/ext  中找</span><br><span class="line"></span><br><span class="line">boot strap class loader</span><br><span class="line"></span><br><span class="line">首先执行loadclass函数,在这个函数里会执行findloadclass从缓存中找是否加载过这个类,</span><br><span class="line"></span><br><span class="line">/JAVA_HOME/jre/lib/ 中找</span><br><span class="line"></span><br><span class="line">如果findclass找到则返回,如果没有则一层层通知下级再去找</span><br></pre></td></tr></table></figure></p>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>1: 如果一个类加载器收到了类加载的请求,它首先不会自己去尝试加载这个类,而是把请求委托给父加载器去完成,依次向上<br>2: 因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中<br>3: 只有当父加载器在它的搜索范围中没有找到所需的类时,即无法完成该加载,子加载器才会尝试自己去加载该类。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>Java类随着它的类加载器(说白了,就是它所在的目录)一起具备了一种带有优先级的层次关系,这对于保证Java程序的稳定运作很重要。<br>例如，类java.lang.Object类存放在JDK\jre\lib下的rt.jar之中<br>因此无论是哪个类加载器要加载此类,最终都会委派给启动类加载器进行加载，<br>这边保证了Object类在程序中的各种类加载器中都是同一个类。  </p>
<p><br><br><br></p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求<br>大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证  </p>
<h3 id="文件格式的验证"><a href="#文件格式的验证" class="headerlink" title="文件格式的验证"></a>文件格式的验证</h3><p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。  </p>
<h3 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h3><p>对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。  </p>
<h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</p>
<h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。  </p>
<p><br><br><br></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段,这些内存都将在方法区中分配  </p>
<p>1: 这时候进行内存分配的仅包括类变量(static),而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p>
<p>2: 这里所设置的初始值通常情况下是数据类型默认的零值(如0、0L、null、false等),而不是被在Java代码中被显式地赋予的值。<br>​    假设一个类变量的定义为:<br>​    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">​    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">3</span>；</span><br><span class="line">​</span><br></pre></td></tr></table></figure></p>
<p>​    那么变量value在准备阶段过后的初始值为0,而不是3<br>​    因为这时候尚未开始执行任何Java方法,而把value赋值为3的putstatic指令是在程序编译后,存放于类构造器<clinit>()方法之中的<br>​    所以把value赋值为3的动作将在初始化阶段才会执行。</clinit></p>
<p><br><br><br></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。  </p>
<ul>
<li>符号引用：符号引用以一组符号来描述所引用的目标,符号可以是任何形式的字面量,只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关,引用的目标并不一定已经加载到了内存中。  </li>
<li>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的,同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用,那说明引用的目标必定已经存在于内存之中了。</li>
</ul>
<p>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行<br>分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。 </p>
<h3 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h3><p>判断所要转化成的直接引用是对数组类型,还是普通的对象类型的引用,从而进行不同的解析。</p>
<h3 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h3><p>对字段进行解析时,会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段<br>如果有,则查找结束;<br>如果没有,则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口,还没有,则按照继承关系从上往下递归搜索其父类,直至查找结束,查找流程如下图  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">11</span>;  </span><br><span class="line">    <span class="keyword">static</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"执行了super类静态语句块"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">33</span>;  </span><br><span class="line">    <span class="keyword">static</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"执行了父类静态语句块"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  </span><br><span class="line">    <span class="keyword">static</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"执行了子类静态语句块"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        System.out.println(Child.m);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行了super类静态语句块</span></span><br><span class="line"><span class="comment">//执行了父类静态语句块</span></span><br><span class="line"><span class="comment">//33</span></span><br></pre></td></tr></table></figure>
<h3 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h3><p>对类方法的解析与对字段解析的搜索步骤差不多,只是多了判断该方法所处的是类还是接口的步骤,而且对类方法的匹配搜索,是先搜索父类,再搜索接口。</p>
<h3 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h3><p>与类方法解析步骤类似,只是接口不会有父类,因此只递归向上搜索父接口就行了。  </p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。  </p>
<ul>
<li>准备阶段,类变量已经被赋过一次系统要求的初始值  </li>
<li>初始化阶段,则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源,或者可以从另一个角度来表达:初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></li>
</ul>
<h3 id="clinit-收集产生"><a href="#clinit-收集产生" class="headerlink" title="clinit() 收集产生"></a>clinit() 收集产生</h3><p>clinit()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的<br>编译器收集的顺序是由语句在源文件中出现的顺序所决定的<br>静态语句块中只能访问到定义在静态语句块之前的变量<br>定义在它之后的变量,在前面的静态语句中可以赋值,但是不能访问。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(a);  <span class="comment">//不可以,必须当public static int a = 1;在前方位置</span></span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="clinit-的产生规则"><a href="#clinit-的产生规则" class="headerlink" title="clinit() 的产生规则"></a>clinit() 的产生规则</h3><p>clinit()方法对于类或接口来说并不是必须的,如果一个类中没有静态语句块,也没有对类变量的赋值操作,那么编译器可以不为这个类生成clinit()方法。</p>
<h3 id="类的执行顺序-clinit"><a href="#类的执行顺序-clinit" class="headerlink" title="类的执行顺序 clinit()"></a>类的执行顺序 clinit()</h3><p>clinit()方法与实例构造器clinit()方法(类的构造函数)不同,它不需要显式地调用父类构造器,虚拟机会保证在子类的clinit()方法执行之前,父类的clinit()方法已经执行完毕。<br>​    因此,在虚拟机中第一个被执行的clinit()方法的类肯定是java.lang.Object。    </p>
<h3 id="接口与类的不同-clinit"><a href="#接口与类的不同-clinit" class="headerlink" title="接口与类的不同 clinit()"></a>接口与类的不同 clinit()</h3><p>接口中不能使用静态语句块，但仍然有类变量(final static)初始化的赋值操作，因此接口与类一样会生成clinit()方法。<br>​    但是接口与类不同的是:执行接口的clinit()方法不需要先执行父接口的clinit()方法,只有当父接口中定义的变量被使用时,父接口才会被初始化。<br>​    另外,接口的实现类在初始化时也一样不会执行接口的clinit()方法。  </p>
<h3 id="clinit-的加锁"><a href="#clinit-的加锁" class="headerlink" title="clinit() 的加锁"></a>clinit() 的加锁</h3><p>虚拟机会保证一个类clinit()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其他线程都需要阻塞等待，直到活动线程执行clinit()方法完毕。<br>如果在一个类的clinit()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。  </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>-<a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener">JVM 类加载</a></p>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2015/02/08/java-other/';
        this.page.title = '反射&amp;代理&amp;类加载';
        this.page.identifier = '2015/02/08/java-other/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
