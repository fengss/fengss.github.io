<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>加密与解密-书籍笔记 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="逆向工程&amp;amp;加密与解密相关详解笔记  
动态调试篇目OD调试器简介主要OD界面展现


快捷键操作  


F7 单步步进,遇到call指令跟进 
F8 单步步过,遇到call指令路过,不跟进 
Ctrl+F9 直到出现ret指令时中断,就是函数的返回语句   
Alt+F9 若进入系统领空,此命令可瞬间回到应用程序领空  
Ctrl + F7 当需要重复按F7的时候,通过Ctrl+F7可直接下,当再次按F7中断
Ctrl + F8 当需要重复按F8的时候,通过Ctrl+F8可直接下,当再">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Golang</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">System</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">BigData</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/ai">Math/AI</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/book">计划</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mesos/">Mesos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scikit/">Scikit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SofaMesh/">SofaMesh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TroubleShoot/">TroubleShoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows内核/">Windows内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows内核驱动/">Windows内核驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内网穿透/">内网穿透</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#动态调试篇目"><span class="toc-number">1.</span> <span class="toc-text">动态调试篇目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OD调试器"><span class="toc-number">1.1.</span> <span class="toc-text">OD调试器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介"><span class="toc-number">1.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例"><span class="toc-number">1.1.2.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#代码逆向基础"><span class="toc-number">2.</span> <span class="toc-text">代码逆向基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#小端序标记法"><span class="toc-number">2.1.</span> <span class="toc-text">小端序标记法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字节序"><span class="toc-number">2.1.1.</span> <span class="toc-text">字节序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IA-32寄存器"><span class="toc-number">2.2.</span> <span class="toc-text">IA-32寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通用寄存器"><span class="toc-number">2.2.1.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#段寄存器"><span class="toc-number">2.2.2.</span> <span class="toc-text">段寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标志寄存器"><span class="toc-number">2.2.3.</span> <span class="toc-text">标志寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指令指针寄存器"><span class="toc-number">2.2.4.</span> <span class="toc-text">指令指针寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈"><span class="toc-number">2.3.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈帧"><span class="toc-number">2.4.</span> <span class="toc-text">栈帧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#示例"><span class="toc-number">2.4.1.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#执行main-amp-生成栈帧"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">执行main&amp;生成栈帧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置局部变量"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">设置局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#add函数参数传递与调用"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">add函数参数传递与调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行add-函数与生成栈帧"><span class="toc-number">2.4.1.4.</span> <span class="toc-text">执行add()函数与生成栈帧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置add-函数的局部变量-x-y"><span class="toc-number">2.4.1.5.</span> <span class="toc-text">设置add()函数的局部变量(x,y)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#add运算"><span class="toc-number">2.4.1.6.</span> <span class="toc-text">add运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除函数add的栈帧-amp-韩式执行完毕返回"><span class="toc-number">2.4.1.7.</span> <span class="toc-text">删除函数add的栈帧&amp;韩式执行完毕返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从栈中删除函数add-的参数-整理栈"><span class="toc-number">2.4.1.8.</span> <span class="toc-text">从栈中删除函数add()的参数(整理栈)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调用printf-函数"><span class="toc-number">2.4.1.9.</span> <span class="toc-text">调用printf()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置返回值"><span class="toc-number">2.4.1.10.</span> <span class="toc-text">设置返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除栈帧-amp-mian-函数终止"><span class="toc-number">2.4.1.11.</span> <span class="toc-text">删除栈帧&amp;mian()函数终止</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程管理工具-ProcessExplorer"><span class="toc-number">2.5.</span> <span class="toc-text">进程管理工具-ProcessExplorer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数调用约定"><span class="toc-number">2.6.</span> <span class="toc-text">函数调用约定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cdecl"><span class="toc-number">2.6.1.</span> <span class="toc-text">cdecl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stdcall"><span class="toc-number">2.6.2.</span> <span class="toc-text">stdcall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastcall"><span class="toc-number">2.6.3.</span> <span class="toc-text">fastcall</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PE文件"><span class="toc-number">3.</span> <span class="toc-text">PE文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PE文件格式"><span class="toc-number">3.1.</span> <span class="toc-text">PE文件格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本结构"><span class="toc-number">3.1.1.</span> <span class="toc-text">基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VA-amp-RVA"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">VA&amp;RVA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PE头"><span class="toc-number">3.1.2.</span> <span class="toc-text">PE头</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DOS头"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">DOS头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DOS存根"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">DOS存根</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NT头"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">NT头</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#NT文件头-IMAGE-FILE-HEADER"><span class="toc-number">3.1.2.3.1.</span> <span class="toc-text">NT文件头:IMAGE_FILE_HEADER</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NT可选头-IMAGE-OPTIONAL-HEADER32"><span class="toc-number">3.1.2.3.2.</span> <span class="toc-text">NT可选头:IMAGE_OPTIONAL_HEADER32</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#节区头"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">节区头</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RVA-TO-RAW"><span class="toc-number">3.1.3.</span> <span class="toc-text">RVA TO RAW</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IAT"><span class="toc-number">3.1.4.</span> <span class="toc-text">IAT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DLL"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">DLL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IMAGE-IMPORT-DESCRIPTOR"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">IMAGE_IMPORT_DESCRIPTOR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#notepad-exe案例"><span class="toc-number">3.1.4.3.</span> <span class="toc-text">notepad.exe案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EAT"><span class="toc-number">3.1.5.</span> <span class="toc-text">EAT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IMAGE-EXPORT-DIRECTORY"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">IMAGE_EXPORT_DIRECTORY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kernel32-dll案例"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">kernel32.dll案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高级PE"><span class="toc-number">3.1.6.</span> <span class="toc-text">高级PE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PEView-exe"><span class="toc-number">3.1.6.1.</span> <span class="toc-text">PEView.exe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PatchedPE"><span class="toc-number">3.1.6.2.</span> <span class="toc-text">PatchedPE</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时压缩"><span class="toc-number">3.2.</span> <span class="toc-text">运行时压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据压缩"><span class="toc-number">3.2.1.</span> <span class="toc-text">数据压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时压缩器"><span class="toc-number">3.2.2.</span> <span class="toc-text">运行时压缩器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#压缩器"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">压缩器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#保护器"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">保护器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调试UPX压缩的notedpad案例"><span class="toc-number">3.3.</span> <span class="toc-text">调试UPX压缩的notedpad案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基址重定位表"><span class="toc-number">3.4.</span> <span class="toc-text">基址重定位表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PE重定位"><span class="toc-number">3.4.1.</span> <span class="toc-text">PE重定位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从可执行文件删除-reloc节区"><span class="toc-number">3.5.</span> <span class="toc-text">从可执行文件删除.reloc节区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UPack-PE文件头分析"><span class="toc-number">3.6.</span> <span class="toc-text">UPack PE文件头分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UPack-查找OEP"><span class="toc-number">3.7.</span> <span class="toc-text">UPack 查找OEP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DLL注入"><span class="toc-number">4.</span> <span class="toc-text">DLL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows消息钩取"><span class="toc-number">4.1.</span> <span class="toc-text">Windows消息钩取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#消息钩子"><span class="toc-number">4.1.1.</span> <span class="toc-text">消息钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SetWindowsHookEx"><span class="toc-number">4.1.2.</span> <span class="toc-text">SetWindowsHookEx()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#键盘消息钩取案例"><span class="toc-number">4.1.3.</span> <span class="toc-text">键盘消息钩取案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#汇编调试HookMain-exe"><span class="toc-number">4.1.4.</span> <span class="toc-text">汇编调试HookMain.exe</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DLL注入-1"><span class="toc-number">4.2.</span> <span class="toc-text">DLL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注入原理"><span class="toc-number">4.2.1.</span> <span class="toc-text">注入原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dll注入的实现方法"><span class="toc-number">4.2.2.</span> <span class="toc-text">Dll注入的实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CreateRemoteThread"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">CreateRemoteThread()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AppInit-DLLs"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">AppInit_DLLs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SetWindowsHookEx-1"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">SetWindowsHookEx()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DLL卸载"><span class="toc-number">4.3.</span> <span class="toc-text">DLL卸载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#工作原理"><span class="toc-number">4.3.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现DLL卸载"><span class="toc-number">4.3.2.</span> <span class="toc-text">实现DLL卸载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#获取进程中加载的Dll信息"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">获取进程中加载的Dll信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取目标进程的句柄"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">获取目标进程的句柄</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取FreeLibrary-Api地址"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">获取FreeLibrary()Api地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在目标进程中运行线程"><span class="toc-number">4.3.2.4.</span> <span class="toc-text">在目标进程中运行线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过修改PE加载DLL"><span class="toc-number">4.4.</span> <span class="toc-text">通过修改PE加载DLL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#具体操作"><span class="toc-number">4.4.1.</span> <span class="toc-text">具体操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#修改导入表的RVA值"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">修改导入表的RVA值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除绑定导入表"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">删除绑定导入表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建新的IDT"><span class="toc-number">4.4.1.3.</span> <span class="toc-text">创建新的IDT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置Name-INT-IAT"><span class="toc-number">4.4.1.4.</span> <span class="toc-text">设置Name,INT,IAT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修改IAT节区的属性值"><span class="toc-number">4.4.1.5.</span> <span class="toc-text">修改IAT节区的属性值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#检测验证"><span class="toc-number">4.4.1.6.</span> <span class="toc-text">检测验证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PE-Tools"><span class="toc-number">4.5.</span> <span class="toc-text">PE Tools</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程内存转储"><span class="toc-number">4.5.1.</span> <span class="toc-text">进程内存转储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码注入"><span class="toc-number">4.6.</span> <span class="toc-text">代码注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#汇编语言注入"><span class="toc-number">4.7.</span> <span class="toc-text">汇编语言注入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#API钩取"><span class="toc-number">5.</span> <span class="toc-text">API钩取</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Api钩取"><span class="toc-number">5.1.</span> <span class="toc-text">Api钩取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#技术图表"><span class="toc-number">5.2.</span> <span class="toc-text">技术图表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法对象"><span class="toc-number">5.2.1.</span> <span class="toc-text">方法对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位置何处"><span class="toc-number">5.2.2.</span> <span class="toc-text">位置何处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#技术如何"><span class="toc-number">5.2.3.</span> <span class="toc-text">技术如何</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#调试"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注入"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">注入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Dll注入"><span class="toc-number">5.2.3.2.1.</span> <span class="toc-text">Dll注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#代码注入-1"><span class="toc-number">5.2.3.2.2.</span> <span class="toc-text">代码注入</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#记事本WriteFile-Api钩取案例"><span class="toc-number">5.3.</span> <span class="toc-text">记事本WriteFile Api钩取案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调试器工作原理"><span class="toc-number">5.3.1.</span> <span class="toc-text">调试器工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试事件"><span class="toc-number">5.3.2.</span> <span class="toc-text">调试事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试技术流程"><span class="toc-number">5.3.3.</span> <span class="toc-text">调试技术流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#练习"><span class="toc-number">5.3.4.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于调试器"><span class="toc-number">5.4.</span> <span class="toc-text">关于调试器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#隐藏进程"><span class="toc-number">5.5.</span> <span class="toc-text">隐藏进程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#64位Windows内核6"><span class="toc-number">6.</span> <span class="toc-text">64位Windows内核6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#64位计算"><span class="toc-number">6.1.</span> <span class="toc-text">64位计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#64位CPU"><span class="toc-number">6.1.1.</span> <span class="toc-text">64位CPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64位OS"><span class="toc-number">6.1.2.</span> <span class="toc-text">64位OS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WOW64"><span class="toc-number">6.1.3.</span> <span class="toc-text">WOW64</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#X64处理器"><span class="toc-number">6.2.</span> <span class="toc-text">X64处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#64位"><span class="toc-number">6.2.1.</span> <span class="toc-text">64位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存"><span class="toc-number">6.2.2.</span> <span class="toc-text">内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通用寄存器-1"><span class="toc-number">6.2.3.</span> <span class="toc-text">通用寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PE32"><span class="toc-number">6.3.</span> <span class="toc-text">PE32+</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PE32-1"><span class="toc-number">6.3.1.</span> <span class="toc-text">PE32+</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IMAGE-NT-HEADERS"><span class="toc-number">6.3.2.</span> <span class="toc-text">IMAGE_NT_HEADERS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IMAGE-FILE-HEADER"><span class="toc-number">6.3.3.</span> <span class="toc-text">IMAGE_FILE_HEADER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IMAGE-OPTIONAL-HEADER"><span class="toc-number">6.3.4.</span> <span class="toc-text">IMAGE_OPTIONAL_HEADER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IMAGE-THUNK-DATA"><span class="toc-number">6.3.5.</span> <span class="toc-text">IMAGE_THUNK_DATA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WinDbg"><span class="toc-number">6.4.</span> <span class="toc-text">WinDbg</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64位调试"><span class="toc-number">6.5.</span> <span class="toc-text">64位调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASLR"><span class="toc-number">6.6.</span> <span class="toc-text">ASLR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InjDll-exe-DLL注入专用"><span class="toc-number">6.7.</span> <span class="toc-text">InjDll.exe DLL注入专用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#高级逆向分析"><span class="toc-number">7.</span> <span class="toc-text">高级逆向分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TLS回调函数"><span class="toc-number">7.1.</span> <span class="toc-text">TLS回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TEB"><span class="toc-number">7.2.</span> <span class="toc-text">TEB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PEB"><span class="toc-number">7.3.</span> <span class="toc-text">PEB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SEH"><span class="toc-number">7.4.</span> <span class="toc-text">SEH</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IA-32指令"><span class="toc-number">7.5.</span> <span class="toc-text">IA-32指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#反调试技术"><span class="toc-number">8.</span> <span class="toc-text">反调试技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#反调试技术-1"><span class="toc-number">8.1.</span> <span class="toc-text">反调试技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态反调试技术"><span class="toc-number">8.2.</span> <span class="toc-text">静态反调试技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态反调试技术"><span class="toc-number">8.3.</span> <span class="toc-text">动态反调试技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高级反调试技术"><span class="toc-number">8.4.</span> <span class="toc-text">高级反调试技术</span></a></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            加密与解密-书籍笔记
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2018/12/08/reverse/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-08T02:39:09.000Z" itemprop="datePublished">2018-12-08</time>
</a>

            

        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>逆向工程&amp;加密与解密相关详解笔记<br><a id="more"></a>  </p>
<h1 id="动态调试篇目"><a href="#动态调试篇目" class="headerlink" title="动态调试篇目"></a>动态调试篇目</h1><h2 id="OD调试器"><a href="#OD调试器" class="headerlink" title="OD调试器"></a>OD调试器</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>主要OD界面展现</p>
<p><img src="/2018/12/08/reverse/image-01.png" width="900px"></p>
<blockquote>
<p>快捷键操作  </p>
</blockquote>
<ul>
<li>F7 单步步进,遇到call指令跟进 </li>
<li>F8 单步步过,遇到call指令路过,不跟进 </li>
<li>Ctrl+F9 直到出现ret指令时中断,就是函数的返回语句   </li>
<li>Alt+F9 若进入系统领空,此命令可瞬间回到应用程序领空  </li>
<li>Ctrl + F7 当需要重复按F7的时候,通过Ctrl+F7可直接下,当再次按F7中断</li>
<li>Ctrl + F8 当需要重复按F8的时候,通过Ctrl+F8可直接下,当再次按F8中断</li>
<li>F9 运行程序  </li>
<li>F2 设置断点  </li>
<li>Ctrl + F2 重新运行此程序  </li>
<li>Ctrl + G 输入win32函数名,例如输入32位ANSI版本GetDlgItemTextA，32位Unicode版本GetDlgItemTextW  </li>
<li>Ctrl + N 查找当前模块的名称</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>需要破解的程序 </p>
<p><img src="/2018/12/08/reverse/image-02.png" width="500px"></p>
<p>此程序的流程是,收入姓名,计算序列号,比较序列号,Y正确对话框,N错误对话框 </p>
<p><img src="/2018/12/08/reverse/image-03.png" width="900px"></p>
<p>此程序相关的展现 </p>
<blockquote>
<p>破解流程  </p>
</blockquote>
<p><img src="/2018/12/08/reverse/1.gif" width="800px"></p>
<p>对于未加壳的程序,无非就是汇编上的一个认知和解除一些逻辑判断  </p>
<h1 id="代码逆向基础"><a href="#代码逆向基础" class="headerlink" title="代码逆向基础"></a>代码逆向基础</h1><h2 id="小端序标记法"><a href="#小端序标记法" class="headerlink" title="小端序标记法"></a>小端序标记法</h2><p>字节序是多字节数据在计算机内存中存储和网络传时各字节的存储顺序，主要分小端序和大端序  </p>
<h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>字节序是多字节数据在计算机内存中存放的顺序, 是学习程序调试技术必须掌握的基本概念   </p>
<p><img src="/2018/12/08/reverse/image-04.png" width="500px"></p>
<p>长度一个字节,无论采用大端序还是小端序,字节顺序都是一样的,但是长度2个字节以上,存储顺序不同,直观感受</p>
<ul>
<li>小端序是地址高位存储数据高位,地址地位存储数据地位  </li>
<li>大端序存储数据,内存段地址低位存储数据的高位,内存地址高位存储数据的低位  </li>
</ul>
<p>但是char数组str中,字符数组的内存地址是连续的,无论大端序还是小端序,存储顺序都相同  </p>
<p>大端序常用于大型UNIX服务器的RISC系列的CPU中,此外网络协议也是经常采用大端序<br>了解这些,对从事X86系列应用程序的开发人员,以及代码逆向分析人员非常重要意义,因为网络传输应用程序使用数据时,往往需要修改字节序,在IntelX86的CPU采用的小端序,所以对windows程序切实掌握小端序十分必要,小端序采用了逆序方式存储数据   </p>
<p><img src="/2018/12/08/reverse/image-05.png" width="500px"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main函数地址401000, 全局变量b,w,dw,str地址分别为40AC40,40AC44,40AC48,40AC4C</span><br></pre></td></tr></table></figure>
<h2 id="IA-32寄存器"><a href="#IA-32寄存器" class="headerlink" title="IA-32寄存器"></a>IA-32寄存器</h2><p>寄存器是CPU内部用来存放数据的一些小型存储区,与我们常说的RAM(随机存储器、内存)略有不同,cpu访问RAM中的数据时要讲过较长的物理路径,所以花费的时间要长一些;而寄存器集成在CPU内部,拥有非常高的读写速度  </p>
<p>IA-32提供非常庞大的汇编指令,需要逐个击破策略,调试时,每当遇到不懂的指令就去翻看Inter提供的用户手册,反复查看就会对众多指令越来越熟悉   </p>
<p><img src="/2018/12/08/reverse/image-06.png" width="500px">  </p>
<p>以上寄存器列表中,学习基本程序运行寄存器的相关内容,程序调试中最常见的寄存器,后期学习有关控制寄存器、内存管理寄存器、调试寄存器知识   </p>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p><img src="/2018/12/08/reverse/image-07.png" width="500px">  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">为了实现对低16位的兼容,各寄存器又分高、低几个独立寄存器,下面以EAX为例讲解  </span><br><span class="line"></span><br><span class="line">EAX:		(0~31) 32位  </span><br><span class="line">AX:		(0~15) EAX的低16位	</span><br><span class="line">AH:		(8~15) AX的高8位</span><br><span class="line">AL:		(0~7)  AX的低8位</span><br><span class="line"></span><br><span class="line">若想全部使用4个字节(32位),则使用EAX  </span><br><span class="line">若只想用2个字节(16位),只要使用EAX的低16位部分AX就可以  </span><br><span class="line"></span><br><span class="line">AX又分高8位的AH和低8位的AL两个独立寄存器</span><br></pre></td></tr></table></figure>
<p>各寄存器名称   </p>
<ul>
<li>ECX:用来循环计数,每执行一次循环,ECX都会减去1  </li>
<li>EAX:一般用在函数返回值中,所有Win32API都先把返回值保存到EAX再返回   </li>
<li>EBX:(DS段中的数据指针)基址寄存器  </li>
<li>EDX:(io指针)数据寄存器   </li>
</ul>
<blockquote>
<p>保存内存地址的指针  </p>
</blockquote>
<ul>
<li>EBP:(SS段中栈内数据指针)扩展基址指针寄存器  </li>
<li>ESI:(字符串操作源指针)源变址寄存器  </li>
<li>EDI:(字符串操作目标指针)目标变址寄存器  </li>
<li>ESP:(SS段中的栈指针)栈指针寄存器   </li>
</ul>
<p>ESP表示栈区域的栈顶地址,某些指令(PUSH,POP,CALL,RET)可以直接用来操作ESP  </p>
<p>EBP表示栈区域的基地址,函数被调用时保存ESP值,函数返回时再把值返回ESP,保证栈不会崩溃(栈帧技术非常重要)   </p>
<p>ESI和EDI与特定指令(LODS,STOS,REP,MOVS等)一起使用,主要用于内存复制   </p>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>段是一种内存保护技术,把内存划分多个区段,并为每个区段赋予起始地址、范围、访问权限等,以保护内存,此外还同分页技术一起将虚拟内存变更为实际物理内存,段内存记录在SDT(段描述符表)中,而段寄存器就持有这些SDT的索引(index)  </p>
<p>各段寄存器名称如下:  </p>
<ul>
<li>CS: code segment,代码段寄存器   </li>
<li>SS: stack segment,栈段寄存器  </li>
<li>DS: data  segment,数据段寄存器  </li>
<li>ES: extra(Data) segment,附加数据段寄存器  </li>
<li>FS: data  segment,数据段寄存器  </li>
<li>GS: data  segment,数据段寄存器  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">顾名思义,CS寄存器存放应用程序代码所在的段的段基址  </span><br><span class="line">SS寄存器存放栈段的段基址   </span><br><span class="line">DS寄存器存放数据段的段基址  </span><br><span class="line">ES,FS,GS寄存器用来存放程序使用的附加数据段的段基址</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/08/reverse/image-08.png" width="500px"></p>
<h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><p>32标志寄存器的名称为EFLAGS,其大小为4个字节32位,由原来的16位FLAGS寄存器扩展而来  </p>
<p><img src="/2018/12/08/reverse/image-09.png" width="400px"></p>
<h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h3><p>EIP: 指令指针寄存器  </p>
<p>保存CPU要执行的指令地址,其大小为32位4个字节,由原来的16位IP寄存器扩展而来   </p>
<p>cpu会读取EIP中一条指令的地址,传送指令会到指令缓冲区后,EIP寄存器的值自动增加,增加的大小即是读取指令的字节大小   </p>
<p>这样CPU每次执行完一条指令就会通过EIP寄存器读取并执行下一条指令,jmp、jcc、call、ret这些特定指令间接修改  </p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈内存在进程中的作用如下  </p>
<ul>
<li>暂时保存函数内的局部变量  </li>
<li>调用函数时传递参数  </li>
<li>保存函数返回后的地址  </li>
</ul>
<p>通过FILO后进先出的原则存储数据  </p>
<p><img src="/2018/12/08/reverse/image-10.png" width="250px"></p>
<p>一个进程,栈顶指针(ESP)初始状态指向栈底端  </p>
<ul>
<li><p>执行PUSH命令将数据压入栈,栈顶指针就会上移到栈顶端  </p>
</li>
<li><p>执行POP命令从栈中弹出数据,若栈为空,则栈顶指针重新移到栈底端       </p>
</li>
</ul>
<p>换言之,栈是一种高地址向低地址扩展的数据结构,所以常常说”栈是逆向扩展的”   </p>
<blockquote>
<p>举例  </p>
</blockquote>
<p><img src="/2018/12/08/reverse/image-11.png" width="400px">  </p>
<p>右下角的栈窗口,栈顶指针值为12FF8C,可以看到ESP指向的地址及值  </p>
<p>在窗口按F7快捷键,执行401000地址处的<code>PUSH 100</code>命令  </p>
<p>ESP值变为12FF88,比原来少了4个字节,并且当前的栈顶指针指向了12FF88地址   </p>
<p>该地址中保存着100这个值,换而言之PUSH命令,数值100压入栈,ESP随着向上移动,即ESP值减去4个字节   </p>
<p><img src="/2018/12/08/reverse/image-12.png" width="400px">  </p>
<p>再按一下F7,执行401005地址处的POP EAX命令,执行完POP EAX命令后,ESP值又增加4个字节,变为12FF8C<br>换言之,从栈中弹出数据后,ESP随之向下移动,向栈压入数据与从栈弹出数据,栈顶指针的变化情形归纳如下   </p>
<p><img src="/2018/12/08/reverse/image-13.png" width="400px">  </p>
<p>栈顶指针在初始化状态下指向栈底,这就是栈的特征  </p>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈帧就是利用EBP(栈帧指针)寄存器访问栈内局部变量、参数、函数返回地址等手段<br>ESP寄存器承担着栈顶指针的作用,而EBP寄存器负责行使栈帧指针的职能   </p>
<p>程序运行中,ESP寄存器随时变化,访问栈中的函数局部变量、参数时,若以ESP为基准编写程序会十分困难,并且很难使CPU引用到正确的地址  </p>
<p><img src="/2018/12/08/reverse/image-14.png" width="500px"></p>
<p>调用某函数时,先把用作基准点(函数起始地址)的ESP值保存到EBP中,并维持在函数内部,这样无论ESP的值如何变化,EBP的值为基准能够安全方为道相关函数的局部函数、参数、返回地址  </p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="/2018/12/08/reverse/image-15.png" width="500px">  </p>
<p>相关调试器界面  </p>
<p><img src="/2018/12/08/reverse/image-16.png" width="500px">   </p>
<p><br><br><br></p>
<h4 id="执行main-amp-生成栈帧"><a href="#执行main-amp-生成栈帧" class="headerlink" title="执行main&amp;生成栈帧"></a>执行main&amp;生成栈帧</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">		<span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/08/reverse/image-17.png" width="300px"></p>
<p>函数main式程序开始执行的地方,main函数的起始地址401020处,密切关注栈的变化  </p>
<p>当前ESP的值为12FF44,EBP值为12FF88,切记地址401250保存在ESP(12FF44)中,它的main函数执行完毕后要返回地址  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00401020	PUSH EBP</span><br><span class="line">00401021	MOVE EBP,ESP</span><br></pre></td></tr></table></figure>
<p>main一开始就生成对应的函数栈帧,PUSH压栈,把EBP值压入栈,main函数中EBP为栈帧指针   </p>
<p><br><br><br></p>
<h4 id="设置局部变量"><a href="#设置局部变量" class="headerlink" title="设置局部变量"></a>设置局部变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>上面的代码转移成如下汇编指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401023	sub 	ESP,8</span><br></pre></td></tr></table></figure></p>
<p>SUB是汇编语言中的一条减法指令,ESP值减去8个字节,ESP值12FF40,减去8个字节变为12FF38  </p>
<p>之所以减去8个字节,是开辟空间,以便将他们保存在栈中,由于局部变量a,b都是long型长整型,分别占据4个字节大小,所以栈中开辟8个字节保存2个变量<br>接下来如下汇编指令  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00401026	MOV DWORD PTR SS:[EBP-4],1 </span><br><span class="line">0040102D	MOV DWORD PTR SS:[EBP-8],2</span><br></pre></td></tr></table></figure>
<p>以上两个指令中的<code>DWORK PTR SS:[EBP-4]</code>看做C语言的指针就可以了  </p>
<p><img src="/2018/12/08/reverse/image-18.png" width="450px"></p>
<p><img src="/2018/12/08/reverse/image-23.png" width="350px">  </p>
<p><br><br><br></p>
<h4 id="add函数参数传递与调用"><a href="#add函数参数传递与调用" class="headerlink" title="add函数参数传递与调用"></a>add函数参数传递与调用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, add(a, b));</span><br></pre></td></tr></table></figure>
<p>转换成汇编语言如下  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00401034	MOV EAX,DWORD PTR SS:[EBP-8]	; [EBP-8] = b</span><br><span class="line">00401037	PUSH EAS			; Arg2 = 0000 0002</span><br><span class="line">00401038	MOV ECX,DWORD PTR SS:[EBP-4] 	; [EBP-4] = a</span><br><span class="line">0040103B 	PUSH ECX 			; Arg1 = 0000 0001</span><br><span class="line">0040103C 	CALL 00401000 			; add()</span><br></pre></td></tr></table></figure>
<p>上面5行汇编代码,描述了调用add()函数的蒸锅过程,地址40103处修改为”CALL 401000”命令,该命令用于调用401000处的函数,而401000处的函数即为add函数   </p>
<p>调用add之前把2个参数压入栈,地址401034~40103B之间的代码即用于此  </p>
<p>注意的是,参数入栈的顺序与C语言源码中的参数顺序恰好相反(函数参数的逆向存储)  </p>
<p>变量b先入栈,接着a再入栈  </p>
<p><img src="/2018/12/08/reverse/image-19.png" width="350px"></p>
<blockquote>
<p>返回地址  </p>
</blockquote>
<p>执行CALL命令进入被调用的函数之前，cpu会把函数的返回地址压入栈,用作函数执行完毕后的返回地址  </p>
<p>在地址40103C处调用add函数,下一条命令的地址为401041,函数add执行完毕后,程序执行流程fa应该返回到401041地址处,即改地址称为add()函数的返回地址  </p>
<p><img src="/2018/12/08/reverse/image-20.png" width="350px"></p>
<p><br><br><br></p>
<h4 id="执行add-函数与生成栈帧"><a href="#执行add-函数与生成栈帧" class="headerlink" title="执行add()函数与生成栈帧"></a>执行add()函数与生成栈帧</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">	<span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数开始时,栈会单独生成与其对应的栈帧  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00401000	PUSH EBP</span><br><span class="line">00401001 	MOV EBP,ESP</span><br></pre></td></tr></table></figure>
<p>先把EBP值保存到栈中,再把当前ESP存储到EBP中,这样函数add的栈帧就生成了   </p>
<p>如此一来,add()函数内部的EBP值始终不变   </p>
<p><img src="/2018/12/08/reverse/image-21.png" width="350px">  </p>
<p>EBP(12ff40)被被分到栈中,然后EBP的值设置为一个新值12FF28  </p>
<p><br><br><br></p>
<h4 id="设置add-函数的局部变量-x-y"><a href="#设置add-函数的局部变量-x-y" class="headerlink" title="设置add()函数的局部变量(x,y)"></a>设置add()函数的局部变量(x,y)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> x=a,y=b;</span><br></pre></td></tr></table></figure>
<p>首先因为2个长整型局部变量x,y所以得执行以下汇编指令 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401003 SUB ESP,8</span><br></pre></td></tr></table></figure>
<p>这样就为x,y开辟了8个字节空间  </p>
<p>然后以下汇编语句  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00401006	MOV EAX,DWORD PTR SS:[EBP+8];	[EBP+8] = param a</span><br><span class="line">00401009	MOV DWORD PTR SS:[EBP-8],EAX;	[EBP-8] = local x</span><br><span class="line">0040100C	MOV ECX,DWORD PTR SS:[EBP+X];	[EBP+C] = param b</span><br><span class="line">0040100F	MOV DWORD PTR SS:[EBP-4],ECX;	[EBP-4] = local y</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/08/reverse/image-22.png" width="350px">  </p>
<p><br><br><br></p>
<h4 id="add运算"><a href="#add运算" class="headerlink" title="add运算"></a>add运算</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (x+y);</span><br></pre></td></tr></table></figure>
<p>汇编翻译如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00401012	MOV EAX,DWORD PTR SS:[EBP-8]; [EBP-8] = local x</span><br><span class="line">00401015	ADD EAX,DWORD PTR SS:[EBP-4]; [EBP-4] = local y</span><br></pre></td></tr></table></figure>
<p>ADD指令为加法指令,变量Y([EBP-4]=2)与EAX原值(x)相加,且运算结果被存储在EAX中,运算完成后EAX中的值为3  </p>
<h4 id="删除函数add的栈帧-amp-韩式执行完毕返回"><a href="#删除函数add的栈帧-amp-韩式执行完毕返回" class="headerlink" title="删除函数add的栈帧&amp;韩式执行完毕返回"></a>删除函数add的栈帧&amp;韩式执行完毕返回</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (x+y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完加法运算后,要返回函数add(),在此之前先删除函数add()的栈帧  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401018	MOV ESP,EBP</span><br></pre></td></tr></table></figure>
<p>上面这条命令把当前的EBP的值赋给ESP,与地址401001处的MOV EBP,ESP命令相对应  </p>
<p>MOV EBP,ESP命令把函数add()开始执行时ESP值(12FF28)放入EBP,函数执行完毕时,使用401018处的MOV ESP,EBP命令再把存储到EBP中的值恢复到ESP中  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040101A	POP EBP</span><br></pre></td></tr></table></figure>
<p>此命令又跟PUSH EBP命令对应,EBP值恢复为12FF40,它是main()函数的EBP值,到底add()函数的栈帧被删除了 </p>
<p><img src="/2018/12/08/reverse/image-24.png" width="350px"></p>
<p>可以看到ESP的值为12FF2C,改地址值为401041,它是执行CALL 401000命令时CPU存储栈中的返回地址   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040101B	RETN</span><br></pre></td></tr></table></figure>
<p>执行了RETN命令,存储在栈中的返回地址即被返回 </p>
<p><img src="/2018/12/08/reverse/image-25.png" width="350px"></p>
<p>应用程序采用如上方式管理栈,不过多数函数嵌套使用,栈都能得到比较好的维护,不会崩溃  </p>
<p>由于函数的局部变量、参数、返回地址等是一次性保存到栈中,利用字符串函数的漏洞等很容易引起栈缓冲区溢出,最终导致程序或系统崩溃   </p>
<p><br><br><br></p>
<h4 id="从栈中删除函数add-的参数-整理栈"><a href="#从栈中删除函数add-的参数-整理栈" class="headerlink" title="从栈中删除函数add()的参数(整理栈)"></a>从栈中删除函数add()的参数(整理栈)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401041 ADD ESP,8</span><br></pre></td></tr></table></figure>
<p>ADD命令将ESP加上8,在7-11图中,12FF30余12FF34处存储的是传递给函数add()的参数a与b,函数add()执行完毕后,就不再需要参数a与b了,所以ESP加上8,从栈中清理  </p>
<p><img src="/2018/12/08/reverse/image-26.png" width="350px"></p>
<p><br><br><br></p>
<h4 id="调用printf-函数"><a href="#调用printf-函数" class="headerlink" title="调用printf()函数"></a>调用printf()函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, add(a,b));</span><br></pre></td></tr></table></figure>
<p>汇编代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00401044	PUSH EAX 	;函数add()返回值</span><br><span class="line">00401045	PUSH 0040B384 	;&quot;%d\n&quot;</span><br><span class="line">0040104A	CALL 00401067 	;printf()</span><br><span class="line">0040104F 	ADD ESP,8</span><br></pre></td></tr></table></figure>
<p>由于printf函数有两个参数,大小为8个字节(32位寄存器+32位常量=64位=8个字节)<br>所以讲ESP加上8个字节,把函数的参数从栈中删除  </p>
<p><br><br><br></p>
<h4 id="设置返回值"><a href="#设置返回值" class="headerlink" title="设置返回值"></a>设置返回值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>汇编如下  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401052 XOR EAX,EAX</span><br></pre></td></tr></table></figure>
<p>XOR命令进行异或运算,2个相同值进行XOR运算结果为0<br>此命令比MOV EAX,0执行速度快,常用于初始化操作   </p>
<p><br><br><br></p>
<h4 id="删除栈帧-amp-mian-函数终止"><a href="#删除栈帧-amp-mian-函数终止" class="headerlink" title="删除栈帧&amp;mian()函数终止"></a>删除栈帧&amp;mian()函数终止</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终主函数终止执行,同add()函数一样,其返回前要从栈中找回与其对应的栈帧  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00401054 	MOV ESP,EBP  </span><br><span class="line">0041056 	POP EBP</span><br></pre></td></tr></table></figure>
<p>执行上面2条命令,main()函数的栈帧即被删除,且局部变量a,b也不再有效,执行至此栈内情况如下  </p>
<p><img src="/2018/12/08/reverse/image-27.png" width="350px"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401057	RETN</span><br></pre></td></tr></table></figure>
<p>执行上面的命令后,主函数执行完毕并返回,程序执行流跳转到返回地址(401250),该地址指向Visual C++的启动函数区域,随时执行进程终止代码  </p>
<p><br><br><br></p>
<h2 id="进程管理工具-ProcessExplorer"><a href="#进程管理工具-ProcessExplorer" class="headerlink" title="进程管理工具-ProcessExplorer"></a>进程管理工具-ProcessExplorer</h2><p>逆向分析代码时常用到这个工具,原因在于它用以以下这些优点   </p>
<ul>
<li>Parent/Child 进程树结构  </li>
<li>以不同颜色(草绿/红色)显示进程运行/终止  </li>
<li>进程的Suspend/Resume功能(挂起/恢复执行)  </li>
<li>进程终止(kill)功能(支持kill process tree功能)  </li>
<li>检索Dll/Handler(检索加载到进程中的Dll或进程占有的句柄)  </li>
</ul>
<h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><p>对函数调用时如何传递参数的一种约定  </p>
<p>之前的案例可以看到,调用函数前先把参数压入栈然后再传递给函数,栈就是定义在进程中的一段内存空间,向下(低地址方向)扩展,其大小被记录在PE头中,也就是说进程运行时确定栈内存的大小(与malloc/new动态分配内存不同)  </p>
<blockquote>
<p>函数执行完成后,栈的参数如何处理?   </p>
</blockquote>
<p>不用管,由于只是临时存储在栈中的值,即使不再使用,清除工作也会浪费CPU资源,下次再向栈存入其他值时,原有值自然被覆盖掉,并且栈内存是固定的,所以既不能也没必要释放内存  </p>
<blockquote>
<p>函数执行完毕后,ESP值如何变化?    </p>
</blockquote>
<p>栈内存固定,ESP用来指示栈当前位置,若ESP指向栈底,则无法再使用该栈,函数调用后如何处理ESP,这就是函数调用约定要解决的问题,主要函数调用约定如下:  </p>
<ul>
<li>cdecl  </li>
<li>stdcall  </li>
<li>fastcall  </li>
</ul>
<h3 id="cdecl"><a href="#cdecl" class="headerlink" title="cdecl"></a>cdecl</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/08/reverse/image-28.png" width="400px"></p>
<p>add()函数的参数1、2以逆序方式压入栈<br>调用add()函数(401000)后使用ADD ESP,8命令整理栈<br>调用者main()函数直接清理其压入栈的函数参数</p>
<h3 id="stdcall"><a href="#stdcall" class="headerlink" title="stdcall"></a>stdcall</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _<span class="function">stdcall <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/08/reverse/image-29.png" width="400px"></p>
<p>调用者add()函数内部清理栈的方式即为stdcall方式  </p>
<p>stdcall好处在于被调用者函数内部存在着栈清理代码,与每次调用函数都要ADD ESP,XXX命令的<code>cdecl</code>方式 相比,代码尺寸要小  </p>
<p>虽然win32 api是使用C语言编写的库,但它使用是stdcall方式,而不是c语言默认的cdecl方式</p>
<h3 id="fastcall"><a href="#fastcall" class="headerlink" title="fastcall"></a>fastcall</h3><p>fastcall和stdcall方式基本类似,但该方式通常会使用寄存器(而非堆内存)去传递那些需要传递给函数的部分参数(前两个)  </p>
<p>若某函数4个参数,则前两个参数分别使用ECX,EDX寄存器传递   </p>
<p>顾名思义,fastcall方式优势对函数的快速调用,所以寄存器速度远比内存快得多   </p>
<blockquote>
<p>lean在视频网公示板上有40个crackme的讲座  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.tuts4you.com/</span><br></pre></td></tr></table></figure>
<h1 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h1><h2 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h2><p>详细讲解Windows操作系统的PE(Portable Executable)文件格式相关知识   </p>
<p>也顺便整理有关进程,内存,Dll等内容,它们是Windows操作系统最核心的部分   </p>
<p><img src="/2018/12/08/reverse/image-30.png" width="450px"></p>
<p>严格地来说,OBJ(对象)文件之外的所有文件都是可执行的</p>
<p>(dll,sys)文件等虽然不能直接在Shell(Explorer.exe)中运行,但可以用其他方法(调试器、服务等)执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJ文件额视为PE文件,但OBJ文件不能以任何形式执行,在代码逆向分析几乎不关注它</span><br></pre></td></tr></table></figure>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>notepad.exe文件运行需要所有信息就存储在这个PE头中<br>如何加载到内存,从何处开始运行,运行中需要的DLL有哪些,需要多大的栈/堆内存<br>大量信息以结构体的形式存储在PE头中<br>学习PE文件格式就是学习PE头中的结构体  </p>
<p><img src="/2018/12/08/reverse/image-31.png" width="450px">  </p>
<p>notepad.ext具有普通PE文件的基本结构,下图描述了notepad.ext文件加载到内存时的情形  </p>
<p>从DOS(DOS Header)到节区头(Section header)是PE头部分,其下是节区合称PE体  </p>
<p>文件中使用偏移(offset),内存中使用VA(Virtual Address,虚拟地址)来表示位置  </p>
<p>文件加载到内存时,情况就会发生变化(节区的大小、位置等)  </p>
<p>文件内容一般可分为:代码(.text),数据(.data),资源(.rsrc),分别保存  </p>
<p><img src="/2018/12/08/reverse/image-32.png" width="450px">  </p>
<p>PE头与各节区的尾部存在一个区域,称为NULL填充  </p>
<p>计算机中为了提高处理文件、内存、网络包的效率,使用 “最小基本单位” 概念  </p>
<p>PE文件中也类似,文件/内存中节区的起始位置应该在各文件/内存最小单位的倍数上,空白区域将用NULL填充  </p>
<h4 id="VA-amp-RVA"><a href="#VA-amp-RVA" class="headerlink" title="VA&amp;RVA"></a>VA&amp;RVA</h4><p>VA指的是进程虚拟内存的绝对地址, RVA(Relative Virtual Address,相对虚拟地址)指从某个基准位置(ImageBase)开始的相对地址</p>
<blockquote>
<p>VA与RVA满足一下换算关系  </p>
</blockquote>
<p>RVA + ImageBase = VA  </p>
<p>PE头内部信息大多以RVA形式存在,原因在于,PE文件(主要是DLL)加载到进程虚拟内存的特定位置,该位置可能已经加载了其他PE文件(DLL)</p>
<p>此时必须通过重定位(Relocation)将其加载到其他空白的位置,若PE头信息使用的是VA,则无法正常访问  </p>
<p>因为使用RVA来定位信息,即使发生了重定向,只要相对于基准位置的相对位置没有变化,就能正常访问到指定信息  </p>
<h3 id="PE头"><a href="#PE头" class="headerlink" title="PE头"></a>PE头</h3><p>PE头有许多结构体组成,主要讲解一下逆向起到关键作用的结构体  </p>
<p><br></p>
<h4 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h4><p>微软充分考虑了PE文件对DOS文件的兼容性,所以PE头最前面添加了一个IMAGE_DOS_HEADER的结构体,用来扩展已有的DOS EXE头  </p>
<p><img src="/2018/12/08/reverse/image-33.png" width="450px"></p>
<p><code>IMAGE_DOS_HEADER</code>结构体的大小为40个字节,在该结构体中2个重要成员  </p>
<ul>
<li>e_magic:Dos签名(signature, 4D5A=&gt;ASCII值”MZ”)    </li>
<li>e_lfanew:指示NT头的偏移(根据不同文件拥有可变值)  </li>
</ul>
<p>所有PE文件开始部分(e_magic)都有DOS签名(“MZ”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一名叫Mark Zbikowski的开发人员设计了DOS可执行文件,MZ取自名字的首字母</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/12/08/reverse/image-34.png" width="450px">  </p>
<p><br></p>
<h4 id="DOS存根"><a href="#DOS存根" class="headerlink" title="DOS存根"></a>DOS存根</h4><p>DOS存根(stub)在DOS头下方,是可选项,且大小不固定,是由代码与数据混合而成  </p>
<p><br></p>
<h4 id="NT头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h4><p><img src="/2018/12/08/reverse/image-35.png" width="450px">  </p>
<p><code>IMAGE_NT_HEADERS</code>结构体由3个成员组成  </p>
<p>第一个成员为签名结构体,值为<code>50450000</code>,另外两个成员分别为文件头(FileHeader)与可选头(OptionalHeader)结构体  </p>
<p><img src="/2018/12/08/reverse/image-36.png" width="450px"></p>
<h5 id="NT文件头-IMAGE-FILE-HEADER"><a href="#NT文件头-IMAGE-FILE-HEADER" class="headerlink" title="NT文件头:IMAGE_FILE_HEADER"></a>NT文件头:<code>IMAGE_FILE_HEADER</code></h5><p><img src="/2018/12/08/reverse/image-37.png" width="450px">  </p>
<p><code>IMAGE_FILE_HEADER</code>有如上四种重要成员,若设置不正确,将导致文件无法正常运行   </p>
<blockquote>
<p>Signature对应于”签名”,FileHeader对应于”COFF文件头”,OptionalHeader对应于”可选文件头”    </p>
</blockquote>
<ul>
<li><p>Machine  </p>
<p>  每个CPU都拥有唯一的Machine码,兼容32位Intel X86芯片的Machine码为<code>014C</code>  </p>
</li>
<li><p>NumberOfSections  </p>
<p>  之前说过PE文件把代码、数据、资源等依据数据分类到各节区中存储  </p>
<p>  NumberOfSections:<code>0003</code>用来指出文件中存在的节区数量</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该值一定要大于0,且当定义的节区数量与实际节区不同时,将发生运行错误</span><br></pre></td></tr></table></figure>
</li>
<li><p>SizeOfOptionalHeader  </p>
<p>  <code>IMAGE_NT_HEADER</code>结构体中的最后一个成员<code>IMAGE_OPTIONAL_HEADER32</code>结构体  </p>
<p>  <code>SizeOfOptionalHeader</code>:<code>0x00E0</code>成员用来指出<code>IMAGE_OPTIONAL_HEADER32</code>结构体的长度   </p>
<p>  widnows的PE装载器需要查看<code>IMAGE_FILE_HEADER</code>的<code>SizeOfOptionalHeader</code>值,从而识别出<code>IMAGE_OPTIONAL_HEADER32</code>结构体的大小   </p>
</li>
</ul>
<ul>
<li><p>Characteristics  </p>
<p>  该子弹用于标识文件的属性,文件是否是可允许的形态,是否为DLL文件等信息,以bit OR形式组合起来  </p>
<p>  <code>0x010F</code></p>
<p>  <img src="/2018/12/08/reverse/image-38.png" width="450px"><br>  <img src="/2018/12/08/reverse/image-39.png" width="450px"></p>
</li>
</ul>
<ul>
<li><p>TimeDateStamp  </p>
<p>  用来记录编译器创建此文件的时间<br>  该成员值不影响文件运行  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x48025278 -&gt;1208111736 -&gt; 2008-04-14 02:35:36</span><br></pre></td></tr></table></figure>
<ul>
<li><p>PointerToSymbolTable是<code>0x00000000</code></p>
<p>  该字段记录了该PE文件中调试信息符号表。由于符号表信息是在程序运行时不需要加载进入内存的，所以这个偏移使用的是相对文件头偏移RA</p>
</li>
</ul>
<ul>
<li><p>NumberOfSymbols是<code>0x00000000</code>   </p>
<p>  该字段记录了该PE文件中调试信息符号表元素个数。对于映像文件，该字段为0（非硬性要求）,，理由在PointerToSymbolTable中已经说明。通过NumberOfSymbols和PointerToSymbolTable，我们可以找到字符串表起始位置，因为字符串表紧跟在符号表之后。</p>
</li>
</ul>
<p><br></p>
<h5 id="NT可选头-IMAGE-OPTIONAL-HEADER32"><a href="#NT可选头-IMAGE-OPTIONAL-HEADER32" class="headerlink" title="NT可选头:IMAGE_OPTIONAL_HEADER32"></a>NT可选头:<code>IMAGE_OPTIONAL_HEADER32</code></h5><p><code>IMAGE_OPTIONAL_HEADER32</code>是PE头结构中最大的 </p>
<p><img src="/2018/12/08/reverse/image-40.png" width="450px"><br><img src="/2018/12/08/reverse/image-41.png" width="450px"></p>
<ul>
<li>Magic  </li>
</ul>
<p><code>IMAGE_OPTIONAL_HEADER32</code>的Magic为10B;<code>IMAGE_OPTIONAL_HEADER64</code>的Magic码为20B  </p>
<ul>
<li>AddressOfEntryPoint  </li>
</ul>
<p><code>AddressOfEntryPoint</code>持有EP的RVA值,该值指出程序最先执行的代码起始地址,相当重要  </p>
<ul>
<li>ImageBase  </li>
</ul>
<p>进程虚拟内存范围是0~FFFFFFFF(32位系统),PE文件被加载到如此到的内存中时,ImageBase指出文件的优先装入地址  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXE,DLL文件装载到用户内存的0~7FFFFFFF中 </span><br><span class="line">SYS文件被载入内核内存的80000000~FFFFFFFF中</span><br></pre></td></tr></table></figure>
<p>使用Vc++/VB/Delphi创建好EXE文件后,其ImageBase的值00400000,Dll文件的ImageBase值为10000000 </p>
<p>执行PE文件时,PE装载器先创建进程,再将文件载入内存,然后把EIP寄存器的值修改为<code>ImageBase+AddressOfEntryPoint</code>  </p>
<ul>
<li>SectionAlignment,FileAlignment  </li>
</ul>
<p>PE文件的Body部分划分若干节区,这些节存储着不同类别的数据  </p>
<p>FlieAlignment指定了节区在磁盘文件中的最小单位  </p>
<p>而SectionAlignment指定了节区在内存中的最小单位  </p>
<p>SectionAlignment,FileAlignment值可能相同,可能不同,磁盘文件或内存节区大小必定为FileAlignment或SectionAlignment值的整数倍  </p>
<ul>
<li>SizeOfImage  </li>
</ul>
<p>加载PE文件到内存时,SizeOfImage指定了PE Image在虚拟内存中所占空间的大小  </p>
<p>一般而言,文件的大小加载到内存的大小是不相同的  </p>
<ul>
<li>SizeOfHeader  </li>
</ul>
<p>SizeOfHeader指出了PE头的大小,该值也必须是FileAlignment的整数倍</p>
<ul>
<li>Subsystem  </li>
</ul>
<p>该Subsystem值用来区分系统驱动文件(<em>.sys)与普通的可执行文件(</em>.exe, .dll)  </p>
<p><img src="/2018/12/08/reverse/image-42.png" width="400px"></p>
<ul>
<li>NumberOfRvaAndSizes  </li>
</ul>
<p>NumberOfRvaAndSizes用来指定DataDirectory(IMAGE_OPTIONAL_HEADER32结构体的最后一个成员)数组的个数  </p>
<p>虽然结构体定义中明确指出了数组个数为IMAGE_NUMBEROF_DIRECTORY_NENTRIES(16)   </p>
<p>但是PE装载器通过查看NumberOfRvaAndSizes值来识别数组大小,换言之,数组大小也可能不是16  </p>
<ul>
<li>DataDirectory  </li>
</ul>
<p><code>DataDirectory</code>是由IMAGE_DATA_DIRECTORY结构体组成的数组,数组的每项都有被定义的值  </p>
<p><img src="/2018/12/08/reverse/image-43.png" width="400px">  </p>
<p>将此处所说的<code>Directory</code>想成为某个结构体数组即可  </p>
<p>重点关注<code>EXPORT/IMPORT/RESOURCE/TLS Directory</code>  </p>
<p>特别需要注意的是<code>IMPORT</code>与<code>EXPORT Directory</code>,它们是PE头中非常重要的部分  </p>
<p><br></p>
<h4 id="节区头"><a href="#节区头" class="headerlink" title="节区头"></a>节区头</h4><p>节区头定义了各节区属性,PE文件中的code(代码)、data(数据)、resource(资源)等按照属性分类存储在不同节区,一定有着某些好处  </p>
<p>PE文件创建成多个节区结构的好处是:这样可以保证程序的安全性   </p>
<p>若把code与data放在一个节区中相互纠缠很容易引发安全问题,即使忽略过程的烦琐    </p>
<p>假如data字符串写入数据,某个原因溢出,那么旗下的code(指令)就被覆盖了,应用程序就会崩溃  </p>
<p>PE文件格式的设计者把具有相似属性的数据统一保存在一个被称为”节区”的地方,然后把各节区属性记录在节区头中(节区属性中有文件/内存的起始位置、大小、访问权限等)  </p>
<p><img src="/2018/12/08/reverse/image-44.png" width="450px">  </p>
<p><code>IMAGE_SECTION_HEADER</code>  </p>
<p>节区头饰由IMAGE_SECTION_HEADER结构体组成的数组,某个结构体对应一个节区  </p>
<p><img src="/2018/12/08/reverse/image-45.png" width="450px">  </p>
<p>以下是<code>IMAGE_SECTION_HEADER</code>结构体中重要成员   </p>
<p><img src="/2018/12/08/reverse/image-46.png" width="450px">  </p>
<p>VirtualAddress与PointerToRawData不带有任何值,分别由(定义在IMAGE_OPTIONAL_HEADER32中的)SectionAlignment,FileAlignment确定   </p>
<p>VirtualSize与SizeOfRawData一般具有不同的值,即磁盘文件中节区的大小与加载到内存中的节区大小是不同的  </p>
<blockquote>
<p>Characterisitics的值  </p>
</blockquote>
<p><img src="/2018/12/08/reverse/image-47.png" width="450px">  </p>
<p>Name字段,PE规范未明确规定节区的Name,所以可以向其中放入任何值,甚至可以填充NULL值  </p>
<blockquote>
<p>最后各结构体成员  </p>
</blockquote>
<p><img src="/2018/12/08/reverse/image-48.png" width="450px">  </p>
<p><br></p>
<h3 id="RVA-TO-RAW"><a href="#RVA-TO-RAW" class="headerlink" title="RVA TO RAW"></a>RVA TO RAW</h3><p>理解了节区头后,下面是PE文件从磁盘到内存映射的内容, PE文件加载到内存时,每个节区都要准确完成内存地址与文件偏移间的映射,这类映射称为<code>RVA to RAW</code></p>
<ul>
<li>查找RVA所在节区  </li>
<li>使用简单的公式计算文件偏移(RAW)  </li>
</ul>
<p><img src="/2018/12/08/reverse/image-50.png" width="450px"></p>
<blockquote>
<p>测试练习   </p>
</blockquote>
<p><img src="/2018/12/08/reverse/image-49.png" width="450px"></p>
<p><img src="/2018/12/08/reverse/image-51.png" width="450px"></p>
<p>学习RVA与RAW(磁盘文件偏移)相互变化是PE头最基本的内容  </p>
<p><br><br><br></p>
<h3 id="IAT"><a href="#IAT" class="headerlink" title="IAT"></a>IAT</h3><p>IAT(Import Address Table)导入地址表  </p>
<p>IAT保存的内容与windows操作系统的核心进程、内存、DLL结构等有关  </p>
<p>只要理解了IAT就掌握了windows操作系统的根基,简而言之IAT是一种表格,用来记录程序正在使用哪些库中的哪些函数  </p>
<p><br></p>
<h4 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h4><p>Dll支撑起了整座Windows OS大厦,Dll中文翻译”动态链接库”  </p>
<p>16位的DOS时代不存在DLL概念,只有”库(Library)”一说法,比如在使用C语言中的printf()函数时,编译器会将C库中读取相应函数的二进制代码,然后插入到应用程序  </p>
<p>这样可执行程序就包含着printf()函数的二进制代码,windows os支持多任务,若采用这种包含库方式,非常没有效率  </p>
<p>随后就引入了DLL概念  </p>
<ul>
<li><p>不要把库包含到程序中,单独组成DLL文件,需要时调用即可  </p>
</li>
<li><p>内存映射技术事加载后的DLL代码资源能够在多个进程实现共享  </p>
</li>
<li><p>更新库只需要替换相关的DLL文件即可   </p>
</li>
</ul>
<p>加载DLL的方式实际上有两种  </p>
<ul>
<li><p>显式链接,程序使用DLL时加载,使用完毕后释放内存   </p>
</li>
<li><p>隐式链接,程序开始时即一同加载DLL,程序终止时再来释放占用的内存  </p>
</li>
</ul>
<p>IAT提供的机制即与隐式链接有关  </p>
<p><img src="/2018/12/08/reverse/image-52.png" width="450px"></p>
<p>notepad.exe进程内存中的CreateFileW()函数(位于kernel32.dll库中)的地址  </p>
<p>地址<code>01001104</code>是notepad.exe中.text节区的内存区域(更确切地说是IAT内存区域)  </p>
<p><code>01001104</code>地址值为<code>7C8107F0</code>,而<code>7C8107F0</code>地址即是加载到notepad.exe进程内存中的CreateFileW()函数(位于kernel32.dll库中)的地址  </p>
<blockquote>
<p>为何不直接<code>call 7C8107F0</code></p>
</blockquote>
<p>因为notepad.ext程序不知道要运行在哪种windows(xp, vista, 7)、哪种语言(ENG, JPN, KOR等),哪种服务包(Service Pack)下  </p>
<p>上面列举的系统,kernel32.dll的版本各不相同,CreateFileW()函数的位置(地址)也不相同,为了确保在所有环境都能正常调用CreateFileW()函数,编译器准备了要保存CreateFileW()函数实际地址的位置(01001104),并仅记下CALL DWORD PTR DS:[1001104]形式的指令</p>
<p>执行文件时,PE装载器将CreateFileW()函数的地址写到01001104位置  </p>
<hr>

<p>编译器不直接<code>call 7C8107F0</code>还有一个原因在于DLL重定位,DLL文件的ImageBase值一般为100000000</p>
<p>比如某个程序使用a.dll与b.dll时,PE装载器先将a.dll装载到内存100000000(ImageBase)处,然后尝试把b.dll也装载到该处,但是由于该地址已经装载了a.dll,所以PE装载器查找其他空白的内存空间(ex:3E000000),然后将b.dll装载进去   </p>
<p>这就是所谓的DLL重定位,无法对实际地址硬编码，另一个在于PE头中表示地址时不使用VA而是RVA  </p>
<p><br></p>
<h4 id="IMAGE-IMPORT-DESCRIPTOR"><a href="#IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="IMAGE_IMPORT_DESCRIPTOR"></a><code>IMAGE_IMPORT_DESCRIPTOR</code></h4><p>IMAGE_IMPORT_DESCRIPTOR结构体中记录着PE文件要导入哪些文件  </p>
<ul>
<li>Import:导入,向库提供服务(函数)  </li>
<li>Export:导出,从库向其他PE文件提供服务(函数)  </li>
</ul>
<p><img src="/2018/12/08/reverse/image-53.png" width="450px">  </p>
<p>执行一个普通程序往往需要导入多个库,导入多少库就存在多少个IMAGE_IMPORT_DESCRIPTOR结构体,这些结构体形成数组,且结构体数组最后以NULL结构体结束  </p>
<blockquote>
<p>结构体重要成员  </p>
</blockquote>
<ul>
<li>OriginalFirstThunk,INT(<code>Import Name Table</code>)的地址(RVA)  </li>
<li>Name,库名称字符串的地址(RVA)  </li>
<li>FirstThunk:IAT(<code>Import Address Table</code>)的地址(RVA)  </li>
</ul>
<p><img src="/2018/12/08/reverse/image-54.png" width="450px">    </p>
<p>上图描述了notepad.exe的kernel32.dll的IMAGE_IMPORT_DESCRIPTOR结构  </p>
<p>PE装载器把导入函数输入至IAT的顺序   </p>
<ul>
<li>1:读取<code>IMAGE_IMPORT_DESCRIPTOR</code>的Name成员,获取库名称字符串(“kernel32.dll”)  </li>
<li><p>2:装在相应库</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt; LoadLibrary(&quot;kernel32.dll&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>3:读取<code>IMAGE_IMPORT_DESCRIPTOR</code>(IID)的OriginalFirstThunk成员,获取INT地址    </p>
</li>
<li>4:逐一读取INT中的数组值,获取相应IMAGE_IMPORT_BY_NAME地址(RVA)   </li>
<li><p>5:使用IMAGE_IMPORT_BY_NAME的Hint(ordinal)或Name项,获取相应函数的起始地址    </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt; GetProcessAddress(&quot;GetCurrentThreadld&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>6:读取<code>IMAGE_IMPORT_DESCRIPTOR</code>(IID)的FirstThunk(IAT)成员,获取IAT地址  </p>
</li>
<li>7:将上面获取的函数地址输入相应IAT数组值  </li>
<li>8:重复以上4~7步骤,查找INT结束(遇到NULL时)  </li>
</ul>
<p><br></p>
<h4 id="notepad-exe案例"><a href="#notepad-exe案例" class="headerlink" title="notepad.exe案例"></a>notepad.exe案例</h4><p>IMAGE_IMPORT_DESCRIPTOR结构体数组,不在PE头而在PE体,但其查找位置的信息在PE头,IMAGE_OPTIONAL_HEADER32.DataDirectory[1].VirtualAddress的值即是IMAGE_IMPORT_DESCRIPTOR结构体数组的起始地址(RVA)  </p>
<p>IMAGE_IMPORT_DESCRIPTOR结构体数组也被称为IMPORT Directory Table(只有了解上述称谓,与他人交流才没有障碍)  </p>
<p>IMAGE_OPTIONAL_HEADER32.DataDirectory[1]结构体的值如下图(第一个4字节为虚拟地址,第二个4字节为Size成员)  </p>
<p><img src="/2018/12/08/reverse/image-55.png" width="400px"></p>
<p>整理上图的DataDirectory结构体数组的信息如下图  </p>
<p><img src="/2018/12/08/reverse/image-56.png" width="450px"></p>
<p>在上上图看到因为RVA是7604,故文件偏移为6A04(RVA to RAW公式)  </p>
<p><img src="/2018/12/08/reverse/image-57.png" width="450px">  </p>
<p>阴影部分为全部的IMAGE_IMPORT_DESCRIPTOR的结构体数组,粗线框内的部分是结构体数组的第一个元素(也可以看到数组最后以NULL结构体组成)  </p>
<p>以下是粗线框中IMAGE_IMPORT_DESCRIPTOR结构体的各个成员  </p>
<p><img src="/2018/12/08/reverse/image-58.png" width="450px">  </p>
<ul>
<li>库名称(Name)  </li>
</ul>
<p>Name是一个字符串指针，指向导入函数所属的库文件名称</p>
<p>(RVA:7AAC-&gt;RVA:6EAC)处的字符串comdlg32.dll</p>
<p><img src="/2018/12/08/reverse/image-59.png" width="450px">  </p>
<ul>
<li>OriginalFirstThunk-INT  </li>
</ul>
<p>INT是一个包含导入函数信息(Ordinal,Name)的结构体指针数组,只有获得了这些信息,才能加载到进程内存的库准确求得响应函数的起始地址(EAT相关内容)  </p>
<p>(RVA:7990-&gt;RAW:6D90)  </p>
<p>INT是IMAGE_IMPORT_BY_NAME结构体指针数组,数组的第一个元素指向函数Ordinal值000F,函数名为PageSetupDlgW </p>
<p><img src="/2018/12/08/reverse/image-60.png" width="450px"></p>
<ul>
<li>FirstThunk - IAT(Import Address Table)  </li>
</ul>
<p>IAT的RVA:12C4即为RAW:6C4  </p>
<p>文件偏移 6C4~6EB区域即为IAT数组区域,对应于comdg32.dll库<br>它与INT类似,由结构指针数组组成,且以NULL结尾  </p>
<p>IAT的第一个元素值被硬编码76324906,该值无实际意义,notepad.exe文件加载到内存时,准确的地址值会被取代该值   </p>
<p><img src="/2018/12/08/reverse/image-61.png" width="450px"></p>
<p>以下用OD实际查看notepad.exe的IAT  </p>
<p><img src="/2018/12/08/reverse/image-75.png" width="450px">  </p>
<p>notepad.exe的ImageBase的值为01000000,所以comdlg32.dll!PageSetupDlgW函数的IAT地址为010012C4,其值为76324906,是API准确的起始地址值  </p>
<p><br></p>
<h3 id="EAT"><a href="#EAT" class="headerlink" title="EAT"></a>EAT</h3><p>“库”是为了方便其他程序调用而集中包含相关函数的文件(DLL/SYS),Win32Api是具有代表性的库,其中的Kernel32.dll文件被称为最核心的库文件  </p>
<p>EAT是核心机制,使不同应用程序可调用库文件中提供的函数,只有通过EAT才能准确求得从相应库总导出函数的起始位置   </p>
<p>与之前IAT一样,PE文件内的特定结构体(IMAGE_EXPORT_DIRECTORY)保存着导出信息,且PE文件中仅有一个用来说明库EAT的IMAGE_EXPORT_DIRECTORY结构体  </p>
<hr> 

<p>在PE文件的PE头中寻找IMAGE_EXPORT_DIRECTORY结构体的位置   </p>
<p>IMAGE_OPTIONAL_HEADER32.DataDirectory[0].VirtualAddress值即为IMAGE_EXPORT_DIRECTORY结构体数组的起始地址(也是RVA的值)  </p>
<p><img src="/2018/12/08/reverse/image-62.png" width="450px">  </p>
<p>上图显示kernel32.dll文件的IMAGE_OPTIONAL_HEADER32.DataDirectory[0];(第一个4字节为VirtualAddress,第二个4字节为Size成员)  </p>
<p>下图是IMAGE_OPTIONAL_HEADER32.DataDirectory结构体数组信息  </p>
<p><img src="/2018/12/08/reverse/image-63.png" width="450px"></p>
<p>由于RVA的值为262C,所以文件偏移为1A2C</p>
<p><br></p>
<h4 id="IMAGE-EXPORT-DIRECTORY"><a href="#IMAGE-EXPORT-DIRECTORY" class="headerlink" title="IMAGE_EXPORT_DIRECTORY"></a>IMAGE_EXPORT_DIRECTORY</h4><blockquote>
<p>IMAGE_EXPORT_DIRECTORY结构体如下  </p>
</blockquote>
<p><img src="/2018/12/08/reverse/image-65.png" width="450px">  </p>
<p>全部地址均为RVA  </p>
<p><img src="/2018/12/08/reverse/image-66.png" width="550px"></p>
<p>例如从库中喊去函数地址的API为GetProcAddress()函数,该API引用EAT来获取指定API的地址  </p>
<p>GetProcAddress()Api拥有函数名称,以下是获取函数地址的步骤  </p>
<ul>
<li>1:利用AddressOfNames成员转到 “函数名称数组”  </li>
<li>2: “函数名称数组” 中存储字符串地址,通过比较(strcmp)字符串,查找指定的函数名称(此时数组的索引称为name_index)  </li>
<li>3:利用AddressOfNameOrdinals成员,转到orinal数组   </li>
<li>4:在ordinal数组中通过name_index查找相应的ordinal值  </li>
<li>5:利用AddressOfFunctions成员转到 “函数地址数组” (EAT)  </li>
<li>6:在 “函数地址数组” 中求刚刚得到的ordinal用作数组索引,获得指定函数的起始地址   </li>
</ul>
<p>以上描述的是kernel32.dll文件的情形,kernel32.dll中素有导出函数均有相应名称  </p>
<p>AddressOfNameOrdinals数组的值以index=ordinal的形式存在,但并不是所有的DLL文件都如此   </p>
<p>导出函数也有一些函数没有名称(仅通过ordinal导出),AddressOfNameOrdinals数组的值为index!=ordinal,所以按照上面的顺序才能获得正确的函数地址  </p>
<p><br></p>
<h4 id="kernel32-dll案例"><a href="#kernel32-dll案例" class="headerlink" title="kernel32.dll案例"></a>kernel32.dll案例</h4><p>kernel32.dll文件中的EAT中查找AddAtomW函数   </p>
<p>kernel32.dll的IMAGE_EXPORT_DIRECTORY结构体RAW为1A2C,使用Hex Editor进入1A2C偏移处 </p>
<p><img src="/2018/12/08/reverse/image-67.png" width="450px"></p>
<p>深色部分是IMAGE_EXPORT_DIRECTORY结构体区域,以下是各个成员  </p>
<p><img src="/2018/12/08/reverse/image-68.png" width="450px"><br><img src="/2018/12/08/reverse/image-69.png" width="450px">  </p>
<blockquote>
<p>1:函数名称数组  </p>
</blockquote>
<p>AddressOfNames成员值为RVA=353C,即RAW=293C  </p>
<p><img src="/2018/12/08/reverse/image-70.png" width="550px">  </p>
<p>此处4个字节RVA组成的数组,数组元素个数为NumberOfNames(3BA)  </p>
<blockquote>
<p>2:查找指定函数名称   </p>
</blockquote>
<p>要查找的函数字符串为”AddAtomW”; (RAV:4BBD-&gt;RAW:3FBD)   </p>
<p>进入相应地址就会看到”AddAtomW”字符串,  </p>
<p><img src="/2018/12/08/reverse/image-71.png" width="450px"></p>
<blockquote>
<p>3:Ordinal数组  </p>
</blockquote>
<p>下面查找”AddAtomW”函数的Ordinal值, AddressOfNameOrdinal成员值为RVA:4424-&gt;RVA:3824  </p>
<p>申诉部分是由多2个字节的数组(ordinal数组中各元素大小为2个字节)</p>
<p><img src="/2018/12/08/reverse/image-72.png" width="550px">  </p>
<blockquote>
<p>4:ordinal  </p>
</blockquote>
<p>将2中求得index值(2)应用到3中的Ordinal数组即可求得Ordinal(2)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddressOfNameOrdinals[index] = ordinal(index=2, ordinal=2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>5:函数地址数组 - EAT  </p>
</blockquote>
<p>最后查找AddAtomW的实际函数地址,AddressOfFunctions成员的值为RVA:2654-&gt;RVA:1A54  </p>
<p><img src="/2018/12/08/reverse/image-73.png" width="450px">  </p>
<blockquote>
<p>6:AddAtomW函数地址  </p>
</blockquote>
<p>为了获取”AddAtomW”函数的地址,Ordinal上图数组索引得到RVA=00326F1  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddressOfFunctions[ordinal] = RVA(ordinal=2, RVA=326F1)</span><br></pre></td></tr></table></figure>
<p>Kernel32.dll的ImageBase=7C7D0000<br>因此AddAtomW函数的时机地址(VA)为7C8026F1(7C7D0000+326F1 = 7C8026F1)</p>
<p>下图使用OD验证</p>
<p><img src="/2018/12/08/reverse/image-74.png" width="450px"></p>
<p>7C8026F1地址(VA)处出现的就是要查找AddAtomW函数<br>以上过程就是查找Export函数地址的方法,与使用GetProcAddress()Api获取指定函数地址的方法一致   </p>
<p><br></p>
<h3 id="高级PE"><a href="#高级PE" class="headerlink" title="高级PE"></a>高级PE</h3><p>之前学习的PE规范各结构体成员,前面仅抽取代码逆向分析息息相关的成员进行了说明   </p>
<p>其中IAT/EAT相关内容是运行时压缩器(Run-time Packer)、反调试、DLL注入、API钩取等多种中高级逆向主题的基础知识  </p>
<p>希望多连续IAT/EAT的地址,再找到文件/内存中的实际地址  </p>
<p>只有掌握这些才能学到高级逆向技术  </p>
<h4 id="PEView-exe"><a href="#PEView-exe" class="headerlink" title="PEView.exe"></a>PEView.exe</h4><p><img src="/2018/12/08/reverse/image-76.png" width="450px"></p>
<p>PEView中,PE头按不同结构体分类组织起来,非常方便查看,也能非常容易地在RVA于文件偏移间转换  </p>
<h4 id="PatchedPE"><a href="#PatchedPE" class="headerlink" title="PatchedPE"></a>PatchedPE</h4><p>PE规范只是一个建议性质的书面标准,查看各结构体内部会发现,许多成员未被使用,所以文件只要符合PE规范就是PE文件  </p>
<p>利用这点Patched PE就是指这样的PE文件,这些PE文件仍然符合PE规范,但附带的PE头非常具有创意  </p>
<p>PatchedPE文件能够帮助打破对PE文件的固有概念  </p>
<p><br><br><br></p>
<h2 id="运行时压缩"><a href="#运行时压缩" class="headerlink" title="运行时压缩"></a>运行时压缩</h2><p>为了理解这项技术,需要掌握PE文件格式、操作系统的基本知识(进程、内存、DLL等)  </p>
<p>同时需要了解有关压缩/解压缩算法的基本内容  </p>
<h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>数据压缩在数码世界(只要不是压缩过的信息)任何信息都能轻松压缩  </p>
<p>不论哪种形态的文件(数据)都是二进制(0或1)组成的  </p>
<p>只要使用合适的压缩算法,就能缩减其大小  </p>
<p>若压缩的文件能100%恢复,则称为<code>无损压缩</code>,若不能恢复原状则称为<code>有损压缩</code>  </p>
<blockquote>
<p>无损压缩  </p>
</blockquote>
<p>无损压缩算法<code>Run-length</code>,<code>Lempel-Ziv</code>,<code>Huffman</code>等,此外其他许多压缩算法都是上面3种压缩算法的基础上改造而来  </p>
<p>压缩器类似7-zip等,然后各自特有的技术(压缩率,压缩/解压时间)  </p>
<blockquote>
<p>有损压缩  </p>
</blockquote>
<p>有损压缩允许压缩文件(数据)时损失一定信息,以此换区高压缩率  </p>
<p>压缩多媒体文件(jpg, mp3, mp4)大多数使用这种有损压缩方式  </p>
<p>虽然这类压缩文件与原文件存在差异,但是人类几乎分不出微小差别  </p>
<p>mp3核心算法删除超越人类听觉范围(20~20000Hz)的波长区段来所见(不需要的)数据大小  </p>
<p><br></p>
<h3 id="运行时压缩器"><a href="#运行时压缩器" class="headerlink" title="运行时压缩器"></a>运行时压缩器</h3><p>运行时压缩器针对可执行PE文件而言,内部解压缩代码,文件在运行瞬间于内存中解压缩后执行  </p>
<p>运行时压缩文件也是PE文件,内部含有原PE文件与解码程序  </p>
<p><img src="/2018/12/08/reverse/image-77.png" width="450px"></p>
<blockquote>
<p> 压缩器  </p>
</blockquote>
<p>把普通PE文件创建成运行时压缩文件的实用程序称为”压缩器”   </p>
<blockquote>
<p>保护器  </p>
</blockquote>
<p>经过反逆向技术特别处理的压缩为称为”保护器”  </p>
<h4 id="压缩器"><a href="#压缩器" class="headerlink" title="压缩器"></a>压缩器</h4><p>PE压缩器指可执行文件的压缩器,运行时压缩器,pe文件的专用压缩器  </p>
<ul>
<li><p>使用目的  </p>
<ul>
<li>缩减PE文件的大小  </li>
<li>隐藏PE文件内部代码与资源  </li>
</ul>
</li>
<li><p>使用现状  </p>
<p>  现状实用程序,打补丁文件,普通程序等广泛应用运行时压缩  </p>
</li>
<li><p>压缩器种类  </p>
<p>  一类是单纯用于压缩普通PE文件的压缩器<br>  另一类是对源文件进行较大变形、严重破坏PE头,意图稍嫌不纯的压缩器(Virtus,Worm等)  </p>
</li>
</ul>
<h4 id="保护器"><a href="#保护器" class="headerlink" title="保护器"></a>保护器</h4><ul>
<li><p>使用目的  </p>
<ul>
<li>防止破解  </li>
<li>保护代码与资源  </li>
</ul>
</li>
<li><p>使用现状  </p>
<p>  防止游戏破解工具运行  </p>
</li>
<li><p>保护器种类  </p>
<p>  公用程序、商业程序     </p>
</li>
</ul>
<p><img src="/2018/12/08/reverse/image-78.png" width="600px"></p>
<p><br></p>
<h2 id="调试UPX压缩的notedpad案例"><a href="#调试UPX压缩的notedpad案例" class="headerlink" title="调试UPX压缩的notedpad案例"></a>调试UPX压缩的notedpad案例</h2><p><br></p>
<h2 id="基址重定位表"><a href="#基址重定位表" class="headerlink" title="基址重定位表"></a>基址重定位表</h2><p>PE在重定位过程会用到基址重定位表(Base Relocation Table)  </p>
<h3 id="PE重定位"><a href="#PE重定位" class="headerlink" title="PE重定位"></a>PE重定位</h3><p>向进程虚拟内存加载PE文件(EXE/DLL/SYS)时,文件会被加载到PE头的ImageBase所指的地址处  </p>
<p>若加载的是DLL文件,且在ImageBase位置处已经加载了其他DLL(Sys)文件,那么PE加载器个在其会将其加载到其他为被占用的空间,这就涉及到PE文件重定位的问题  </p>
<p>PE重定位是指PE文件无法加载到ImageBase所指位置,而是被加载到其他地址时发生的一系列处理行为  </p>
<p><br></p>
<h2 id="从可执行文件删除-reloc节区"><a href="#从可执行文件删除-reloc节区" class="headerlink" title="从可执行文件删除.reloc节区"></a>从可执行文件删除.reloc节区</h2><h2 id="UPack-PE文件头分析"><a href="#UPack-PE文件头分析" class="headerlink" title="UPack PE文件头分析"></a>UPack PE文件头分析</h2><h2 id="UPack-查找OEP"><a href="#UPack-查找OEP" class="headerlink" title="UPack 查找OEP"></a>UPack 查找OEP</h2><h1 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h1><h2 id="Windows消息钩取"><a href="#Windows消息钩取" class="headerlink" title="Windows消息钩取"></a>Windows消息钩取</h2><p>Hook翻译成钩子,泛指钓取所需东西而使用的一切工具,也延伸发展为”偷看或截取信息时所用的手段或工具”  </p>
<p><img src="/2018/12/08/reverse/image-79.png" width="650px">  </p>
<p>偷看或操作信息的行为就是人们常说的”钩取”  </p>
<p>钩取技术广泛应用于计算机领域,其实不仅可以查看来往于”OS-应用程序-用户”之间的全部信息,也可以操作他们,并且神不知鬼不觉,具体方法很多,最基本的就是 “消息钩子”  </p>
<h3 id="消息钩子"><a href="#消息钩子" class="headerlink" title="消息钩子"></a>消息钩子</h3><p>windows操作系统向用户提供GUI(图形用户界面),以事件驱动方式工作,在操作系统中借助键盘、鼠标、选择菜单、按钮以及移动鼠标、改变窗口大小与位置等都是事件  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">发生这样的时间,os会事先定义好的消息发送给相应的应用程序</span><br><span class="line">应用程序分析收到信息后执行相应动作</span><br><span class="line"></span><br><span class="line">也就是说,敲击键盘时,消息会从OS移动到应用程序</span><br><span class="line">所谓的&quot;消息钩子&quot;,就在此间偷看这些信息</span><br></pre></td></tr></table></figure>
<p>常规windows消息流  </p>
<ul>
<li>发生键盘输入事件时,WM_KEYDOWN消息被添加到了[OS message queue]  </li>
<li>os判断哪个应用程序中发生了事件,然后从[OS message queue]取出消息,被添加到相应应用程序的[application message queue]中  </li>
<li>应用程序(如笔记本)监视吱声的[application message queue],发现新添加的WM_KEYDOWN消息后,调用相应的事件处理程序处理  </li>
</ul>
<p>OS消息队列与应用程序消息队列之间存在一条”钩链”(Hook Chain)<br>设置好键盘消息钩子之后,处于”钩链”中的键盘消息钩子会比应用程序先看到相应信息  </p>
<p>在键盘消息钩子函数内部,除了可以看到消息之外,还可以修改消息本身,而且还能对消息实施拦截,阻止消息传递  </p>
<p><img src="/2018/12/08/reverse/image-80.png" width="300px">  </p>
<p>具有代表性的是MS Visual Studio中提供的SPY++<br>十分强大的消息钩取程序,能够查看操作系统来往的所有消息  </p>
<h3 id="SetWindowsHookEx"><a href="#SetWindowsHookEx" class="headerlink" title="SetWindowsHookEx()"></a>SetWindowsHookEx()</h3><p>使用<code>SetWindowsHookEx()</code> Api可轻松实现消息钩子,定义如下:</p>
<p><img src="/2018/12/08/reverse/image-81.png" width="400px">  </p>
<p>钩子过程(<code>hook procedure</code>)是由操作系统调用的回调函数, 安装消息”钩子”时,”钩子”的过程需要存在于某个DLL内部<br>且该DLL的示例句柄(<code>instance handler</code>)即是hMod  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SetWindowsHookEx()设置好钩子之后,在某个进程中生成指定消息时</span><br><span class="line">操作系统会将相关的DLL文件强制注入(injection)相应进程</span><br><span class="line">然后调用注册的&quot;钩子&quot;过程</span><br><span class="line">注入进程时用户根本不需要做什么,很方便</span><br></pre></td></tr></table></figure>
<h3 id="键盘消息钩取案例"><a href="#键盘消息钩取案例" class="headerlink" title="键盘消息钩取案例"></a>键盘消息钩取案例</h3><p><img src="/2018/12/08/reverse/image-82.png" width="450px"></p>
<p>KeyHook.dll文件是一个含有钩子过程(KeyBoardProc)的dll文件</p>
<p>HookMain.exe加载KeyHook.dll文件后使用SetWindowsHookEx()安装键盘钩子(KeyboardProc)  </p>
<p>若其他进程(explorer.exe, iexpolre.exe, notepad.exe)发生了键盘输入事件  </p>
<p>OS就会强制将KeyHook.dll加载到相应进程的内存,然后调用KeyboardProc()函数  </p>
<blockquote>
<p>运行HookMain.exe-安装键盘钩子  </p>
</blockquote>
<p><img src="/2018/12/08/reverse/image-83.png" width="400px">  </p>
<blockquote>
<p>运行Notepad.exe程序  </p>
</blockquote>
<p>notepad.exe忽略了用户键盘的输入,可以看到KeyHook.dll已加载其中    </p>
<p><img src="/2018/12/08/reverse/image-84.png" width="400px">  </p>
<blockquote>
<p>HookMain源码相关  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"conio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	DEF_DLL_NAME		<span class="meta-string">"KeyHook.dll"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	DEF_HOOKSTART		<span class="meta-string">"HookStart"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	DEF_HOOKSTOP		<span class="meta-string">"HookStop"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*PFN_HOOKSTART)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*PFN_HOOKSTOP)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HMODULE			hDll = <span class="literal">NULL</span>;</span><br><span class="line">	PFN_HOOKSTART	HookStart = <span class="literal">NULL</span>;</span><br><span class="line">	PFN_HOOKSTOP	HookStop = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span>			ch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载KeyHook.dll</span></span><br><span class="line">	hDll = LoadLibraryA(DEF_DLL_NAME);</span><br><span class="line">    <span class="keyword">if</span>( hDll == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"LoadLibrary(%s) failed!!! [%d]"</span>, DEF_DLL_NAME, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取导出函数地址</span></span><br><span class="line">	HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);</span><br><span class="line">	HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始钩取</span></span><br><span class="line">	HookStart();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待知道用户输入“q”</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"press 'q' to quit!\n"</span>);</span><br><span class="line">	<span class="keyword">while</span>( _getch() != <span class="string">'q'</span> )	;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止钩取</span></span><br><span class="line">	HookStop();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 卸载KeyHook.dll</span></span><br><span class="line">	FreeLibrary(hDll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载KeyHook.dll文件,然后调用HookStart()函数开始钩取  </p>
<p>用户输入 “q” 时,调用HookStop()终止钩取  </p>
<blockquote>
<p>KeyHook.cpp源码  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_PROCESS_NAME		<span class="meta-string">"notepad.exe"</span></span></span><br><span class="line"></span><br><span class="line">HINSTANCE g_hInstance = <span class="literal">NULL</span>;</span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">HWND g_hWnd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>( dwReason )</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">			g_hInstance = hinstDLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">			<span class="keyword">break</span>;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">KeyboardProc</span><span class="params">(<span class="keyword">int</span> nCode, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> szPath[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">	<span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( nCode &gt;= <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// bit 31 : 0 =&gt; press, 1 =&gt; release</span></span><br><span class="line">		<span class="keyword">if</span>( !(lParam &amp; <span class="number">0x80000000</span>) )</span><br><span class="line">		&#123;</span><br><span class="line">			GetModuleFileNameA(<span class="literal">NULL</span>, szPath, MAX_PATH);</span><br><span class="line">			p = <span class="built_in">strrchr</span>(szPath, <span class="string">'\\'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//比较当前进程名称,若是notepad.exe,则消息不会传递给应用程序(或下一个"钩子")</span></span><br><span class="line">			<span class="keyword">if</span>( !_stricmp(p + <span class="number">1</span>, DEF_PROCESS_NAME) )</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//若非notepad.exe,则调用CallNextHookEx()函数,将消息传递给应用程序(或下一个钩子)</span></span><br><span class="line">	<span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	__declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">HookStart</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">HookStop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>( g_hHook )</span><br><span class="line">		&#123;</span><br><span class="line">			UnhookWindowsHookEx(g_hHook);</span><br><span class="line">			g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>DLL的代码很简单,调用导出函数HookStart()时<br>SetWindowsHookEx()函数就会将KeyboardProc()添加到键盘钩链  </p>
<hr>  

<p>安装好键盘”钩子”后,无论哪个进程,只要发生键盘输入事件  </p>
<p>OS就强制将Keyhook.dll注入相应进程</p>
<p><br></p>
<h3 id="汇编调试HookMain-exe"><a href="#汇编调试HookMain-exe" class="headerlink" title="汇编调试HookMain.exe"></a>汇编调试HookMain.exe</h3><p><img src="/2018/12/08/reverse/image-85.png" width="500px">  </p>
<p><br></p>
<h2 id="DLL注入-1"><a href="#DLL注入-1" class="headerlink" title="DLL注入"></a>DLL注入</h2><p>DLL注入是渗透其他进程的最简单有效的方法  </p>
<p>借助DLL注入技术,可以钩取API,改进程序,修复Bug等  </p>
<h3 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h3><p>Dll注入是向运行中的其他进程强制插入特定的DLL文件  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dll注入命令其他进程自行调用LoadLibrary()Api,加载用户指定的DLL文件</span><br><span class="line"></span><br><span class="line">Dll注入与一般的dll加载区别在于</span><br><span class="line">加载的模板进程是其自身或其他进程</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/08/reverse/image-86.png" width="400px">  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myhack.dll已强制插入notepad进程(本来notepad并不会加载myhack.dll)  </span><br><span class="line">加载到notepad.exe进程中的myhack.dll与预计加载到notepad.exe进程中的dll(kernel32/user32)一样</span><br><span class="line">拥有访问notepad.exe进程内存的权限,这样用户就可以做任何想做的事了</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/08/reverse/image-87.png" width="500px">  </p>
<p>各个状态</p>
<p><img src="/2018/12/08/reverse/image-88.png" width="500px">  </p>
<hr>


<p>使用<code>LoadLibrary()</code> API加载某个DLL时,该DLL中的DllMain()函数就会被调用执行  </p>
<p>Dll注入工作原理就是从外部促使目标进程调用<code>LoadLibrary()</code>Api(与一般的Dll加载相同) </p>
<p>所以会强制调用Dll的<code>DllMain()</code>函数</p>
<p>并且被注入的Dll拥有目标进程内存的访问权限,用户可以随意操作(修复Bug、调价功能等)  </p>
<p><br></p>
<h3 id="Dll注入的实现方法"><a href="#Dll注入的实现方法" class="headerlink" title="Dll注入的实现方法"></a>Dll注入的实现方法</h3><ul>
<li>创建远程线程(<code>CreateRemoteThread</code>)   </li>
<li>使用注册表(<code>AppInit_DLLs值</code>)  </li>
<li>消息钩取(<code>SetWindowsHookEx()</code>)  </li>
</ul>
<h4 id="CreateRemoteThread"><a href="#CreateRemoteThread" class="headerlink" title="CreateRemoteThread()"></a>CreateRemoteThread()</h4><p>本方法来源<code>《Windows核心编程》</code>中介绍过</p>
<p>接下来演示<code>myhack.dll</code>注入到<code>notepad.exe</code>进程,被注入的<code>myhack.dll</code>是用来联网并下载<code>http://www.naver.com/index.html</code>文件的  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"urlmon.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_URL     	(<span class="meta-string">L"http://www.naver.com/index.html"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_FILE_NAME   (<span class="meta-string">L"index.html"</span>)</span></span><br><span class="line"></span><br><span class="line">HMODULE g_hMod = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCHAR szPath[_MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !GetModuleFileName( g_hMod, szPath, MAX_PATH ) )</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">	</span><br><span class="line">    TCHAR *p = _tcsrchr( szPath, <span class="string">'\\'</span> );</span><br><span class="line">    <span class="keyword">if</span>( !p )</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    _tcscpy_s(p+<span class="number">1</span>, _MAX_PATH, DEF_FILE_NAME);</span><br><span class="line"></span><br><span class="line">    URLDownloadToFile(<span class="literal">NULL</span>, DEF_URL, szPath, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    g_hMod = (HMODULE)hinstDLL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH : </span><br><span class="line">        OutputDebugString(<span class="string">L"&lt;myhack.dll&gt; Injection!!!"</span>);</span><br><span class="line">        hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        CloseHandle(hThread);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把<code>InjectDLL.exe</code>和<code>myhack.dll</code>分别赋值到工作文件夹<br><img src="/2018/12/08/reverse/image-89.png" width="350px">  </p>
<p>然后运行<code>notepad.exe</code>程序,再运行<code>Process Explorer</code>(或windows任务管理器)获取notepad.exe进程的PID  </p>
<p><img src="/2018/12/08/reverse/image-90.png" width="350px">  </p>
<p>然后运行<code>debugView</code>,用来捕获并显示系统中运行进程输出的所有调试字符串  </p>
<p><img src="/2018/12/08/reverse/image-91.png" width="350px">  </p>
<p><code>myhack.dll</code>注入是用来向目标进程注入DLL文件的实用小程序 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID luid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, </span><br><span class="line">			              &amp;hToken) )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L"OpenProcessToken error: %u\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !LookupPrivilegeValue(<span class="literal">NULL</span>,           <span class="comment">// lookup privilege on local system</span></span><br><span class="line">                              lpszPrivilege,  <span class="comment">// privilege to lookup </span></span><br><span class="line">                              &amp;luid) )        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L"LookupPrivilegeValue error: %u\n"</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    <span class="keyword">if</span>( bEnablePrivilege )</span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line">    <span class="keyword">if</span>( !AdjustTokenPrivileges(hToken, </span><br><span class="line">                               FALSE, </span><br><span class="line">                               &amp;tp, </span><br><span class="line">                               <span class="keyword">sizeof</span>(TOKEN_PRIVILEGES), </span><br><span class="line">                               (PTOKEN_PRIVILEGES) <span class="literal">NULL</span>, </span><br><span class="line">                               (PDWORD) <span class="literal">NULL</span>) )</span><br><span class="line">    &#123; </span><br><span class="line">        _tprintf(<span class="string">L"AdjustTokenPrivileges error: %u\n"</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( GetLastError() == ERROR_NOT_ALL_ASSIGNED )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L"The token does not have the specified privilege. \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>, hThread = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hMod = <span class="literal">NULL</span>;</span><br><span class="line">    LPVOID pRemoteBuf = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">    LPTHREAD_START_ROUTINE pThreadProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #1. 使用dwPid获取目标进程(notepad.exe)句柄</span></span><br><span class="line">    <span class="keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L"OpenProcess(%d) failed!!! [%d]\n"</span>, dwPID, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #2. 在目标进程(notepad.exe)内存分配szDllName大小的内存</span></span><br><span class="line">    pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #3. 将myhack.dll路径写入分配的内存</span></span><br><span class="line">    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #4. LoadLibraryA() API 的地址</span></span><br><span class="line">    hMod = GetModuleHandle(<span class="string">L"kernel32.dll"</span>);</span><br><span class="line">    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="string">"LoadLibraryW"</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// #5. notepad.exe 进程中运行线程</span></span><br><span class="line">    hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);	</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, TCHAR *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L"USAGE : %s &lt;pid&gt; &lt;dll_path&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change privilege</span></span><br><span class="line">    <span class="keyword">if</span>( !SetPrivilege(SE_DEBUG_NAME, TRUE) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject dll</span></span><br><span class="line">    <span class="keyword">if</span>( InjectDll((DWORD)_tstol(argv[<span class="number">1</span>]), argv[<span class="number">2</span>]) )</span><br><span class="line">        _tprintf(<span class="string">L"InjectDll(\"%s\") success!!!\n"</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _tprintf(<span class="string">L"InjectDll(\"%s\") failed!!!\n"</span>, argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/08/reverse/image-92.png" width="350px">  </p>
<p>确认DLL注入成功 </p>
<p><img src="/2018/12/08/reverse/image-93.png" width="350px">  </p>
<p>再用<code>Porcess Explorer</code>确认  </p>
<p><img src="/2018/12/08/reverse/image-94.png" width="450px">  </p>
<p>最终结果确认  </p>
<p><img src="/2018/12/08/reverse/image-95.png" width="350px">  </p>
<p><br></p>
<h4 id="AppInit-DLLs"><a href="#AppInit-DLLs" class="headerlink" title="AppInit_DLLs"></a>AppInit_DLLs</h4><p>进行第二种方法,使用注册表,windows操作系统注册表默认提供了AppInit_DLLs与LoadAppInit_DLLs两个注册表项  </p>
<p><img src="/2018/12/08/reverse/image-96.png" width="550px">  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myhack2.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_CMD  <span class="meta-string">L"c:\\Program Files\\Internet Explorer\\iexplore.exe"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_ADDR <span class="meta-string">L"http://www.naver.com"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_DST_PROC <span class="meta-string">L"notepad.exe"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCHAR szCmd[MAX_PATH]  = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    TCHAR szPath[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    TCHAR *p = <span class="literal">NULL</span>;</span><br><span class="line">    STARTUPINFO si = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(STARTUPINFO);</span><br><span class="line">    si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">    si.wShowWindow = SW_HIDE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH : </span><br><span class="line">        <span class="keyword">if</span>( !GetModuleFileName( <span class="literal">NULL</span>, szPath, MAX_PATH ) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>( !(p = _tcsrchr(szPath, <span class="string">'\\'</span>)) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( _tcsicmp(p+<span class="number">1</span>, DEF_DST_PROC) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        wsprintf(szCmd, <span class="string">L"%s %s"</span>, DEF_CMD, DEF_ADDR);</span><br><span class="line">        <span class="keyword">if</span>( !CreateProcess(<span class="literal">NULL</span>, (LPTSTR)(LPCTSTR)szCmd, </span><br><span class="line">                            <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, </span><br><span class="line">                            NORMAL_PRIORITY_CLASS, </span><br><span class="line">                            <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pi.hProcess != <span class="literal">NULL</span> )</span><br><span class="line">            CloseHandle(pi.hProcess);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准备好Dll复制到合适位置  </p>
<p><img src="/2018/12/08/reverse/image-97.png" width="400px"> </p>
<p>修改注册表项</p>
<p>regedit.exe进入以下路径  </p>
<p><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows</code></p>
<p>编辑修改<code>AppInit_DLLs</code>表项值  </p>
<p><img src="/2018/12/08/reverse/image-98.png" width="350px">   </p>
<p>然后修改<code>LoadAppInit_DLLs</code>注册表项的值为1  </p>
<p><img src="/2018/12/08/reverse/image-99.png" width="350px">   </p>
<p>注册表项修改完毕后,重启系统,使修改生效<br>当重启完成可以看到相关的情况  </p>
<p><img src="/2018/12/08/reverse/image-100.png" width="350px"> </p>
<h4 id="SetWindowsHookEx-1"><a href="#SetWindowsHookEx-1" class="headerlink" title="SetWindowsHookEx()"></a>SetWindowsHookEx()</h4><p>注入Dll第三个方法就是消息钩取,即用SetWindowsHookEx()Api安装好消息”钩子”  </p>
<p>然后由OS将制定Dll(含钩子进程)强制注入相应进程  </p>
<p><br><br><br></p>
<h2 id="DLL卸载"><a href="#DLL卸载" class="headerlink" title="DLL卸载"></a>DLL卸载</h2><p>dll卸载是将强制插入进程的Dll弹出技术,其工作原理与使用<code>CreateRemoteThread</code>Api进行Dll注入的原理类似  </p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><code>CreateRemoteThread()</code> Api进行Dll注入的工作原理如下:  </p>
<p>驱使目标进程调用<code>LoadLibrary()</code>Api  </p>
<p>同样,Dll卸载工作原理也简单:   </p>
<p>驱使目标进程调用<code>FreeLibrary()</code>Api  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">也就说将FreeLibrary()Api的地址传递给CreateRemoteThread()的IpStartAddress参数</span><br><span class="line">并把要卸载Dll句柄传递给IpParameter参数</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/08/reverse/image-101.png" width="400px">  </p>
<h3 id="实现DLL卸载"><a href="#实现DLL卸载" class="headerlink" title="实现DLL卸载"></a>实现DLL卸载</h3><p>EjectDll.exe程序,用来从目标程序(notepad.exe)卸载指定Dll文件(myhack.dll) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EjectDll.exe</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlhelp32.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_PROC_NAME	(<span class="meta-string">L"notepad.exe"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_DLL_NAME	(<span class="meta-string">L"myhack.dll"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">FindProcessID</span><span class="params">(LPCTSTR szProcessName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwPID = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    HANDLE hSnapShot = INVALID_HANDLE_VALUE;</span><br><span class="line">    PROCESSENTRY32 pe;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得系统快照</span></span><br><span class="line">    pe.dwSize = <span class="keyword">sizeof</span>( PROCESSENTRY32 );</span><br><span class="line">    hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找进程</span></span><br><span class="line">    Process32First(hSnapShot, &amp;pe);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!_tcsicmp(szProcessName, (LPCTSTR)pe.szExeFile))</span><br><span class="line">        &#123;</span><br><span class="line">            dwPID = pe.th32ProcessID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Process32Next(hSnapShot, &amp;pe));</span><br><span class="line"></span><br><span class="line">    CloseHandle(hSnapShot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dwPID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID luid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, </span><br><span class="line">			              &amp;hToken) )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L"OpenProcessToken error: %u\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !LookupPrivilegeValue(<span class="literal">NULL</span>,           <span class="comment">// lookup privilege on local system</span></span><br><span class="line">                              lpszPrivilege,  <span class="comment">// privilege to lookup </span></span><br><span class="line">                              &amp;luid) )        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L"LookupPrivilegeValue error: %u\n"</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    <span class="keyword">if</span>( bEnablePrivilege )</span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line">    <span class="keyword">if</span>( !AdjustTokenPrivileges(hToken, </span><br><span class="line">                               FALSE, </span><br><span class="line">                               &amp;tp, </span><br><span class="line">                               <span class="keyword">sizeof</span>(TOKEN_PRIVILEGES), </span><br><span class="line">                               (PTOKEN_PRIVILEGES) <span class="literal">NULL</span>, </span><br><span class="line">                               (PDWORD) <span class="literal">NULL</span>) )</span><br><span class="line">    &#123; </span><br><span class="line">        _tprintf(<span class="string">L"AdjustTokenPrivileges error: %u\n"</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( GetLastError() == ERROR_NOT_ALL_ASSIGNED )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L"The token does not have the specified privilege. \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">EjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDllName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bMore = FALSE, bFound = FALSE;</span><br><span class="line">    HANDLE hSnapshot, hProcess, hThread;</span><br><span class="line">    HMODULE hModule = <span class="literal">NULL</span>;</span><br><span class="line">    MODULEENTRY32 me = &#123; <span class="keyword">sizeof</span>(me) &#125;;</span><br><span class="line">    LPTHREAD_START_ROUTINE pThreadProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dwPID = notepad 进程 ID</span></span><br><span class="line">    <span class="comment">//  使用 TH32CS_SNAPMODULE 参数 获取加载到 notepad 的 DLL名称</span></span><br><span class="line">    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID);</span><br><span class="line"></span><br><span class="line">    bMore = Module32First(hSnapshot, &amp;me);</span><br><span class="line">    <span class="keyword">for</span>( ; bMore ; bMore = Module32Next(hSnapshot, &amp;me) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( !_tcsicmp((LPCTSTR)me.szModule, szDllName) || </span><br><span class="line">            !_tcsicmp((LPCTSTR)me.szExePath, szDllName) )</span><br><span class="line">        &#123;</span><br><span class="line">            bFound = TRUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !bFound )</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hSnapshot);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L"OpenProcess(%d) failed!!! [%d]\n"</span>, dwPID, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hModule = GetModuleHandle(<span class="string">L"kernel32.dll"</span>);</span><br><span class="line">    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, <span class="string">"FreeLibrary"</span>);</span><br><span class="line">    hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, </span><br><span class="line">                                 pThreadProc, me.modBaseAddr, </span><br><span class="line">                                 <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);	</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    CloseHandle(hSnapshot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    DWORD dwPID = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 查找 process</span></span><br><span class="line">    dwPID = FindProcessID(DEF_PROC_NAME);</span><br><span class="line">    <span class="keyword">if</span>( dwPID == <span class="number">0xFFFFFFFF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L"There is no &lt;%s&gt; process!\n"</span>, DEF_PROC_NAME);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _tprintf(<span class="string">L"PID of \"%s\" is %d\n"</span>, DEF_PROC_NAME, dwPID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改 privilege</span></span><br><span class="line">    <span class="keyword">if</span>( !SetPrivilege(SE_DEBUG_NAME, TRUE) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eject dll</span></span><br><span class="line">    <span class="keyword">if</span>( EjectDll(dwPID, DEF_DLL_NAME) )</span><br><span class="line">        _tprintf(<span class="string">L"EjectDll(%d, \"%s\") success!!!\n"</span>, dwPID, DEF_DLL_NAME);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _tprintf(<span class="string">L"EjectDll(%d, \"%s\") failed!!!\n"</span>, dwPID, DEF_DLL_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取进程中加载的Dll信息"><a href="#获取进程中加载的Dll信息" class="headerlink" title="获取进程中加载的Dll信息"></a>获取进程中加载的Dll信息</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, <span class="literal">NULL</span> );</span><br></pre></td></tr></table></figure>
<p>使用<code>CreateToolhelp32Snapshot</code>Api可以获取加载到进程的Dll信息  </p>
<p>将获取的hSnapshot句柄传递给Module32First()/Module32Next()函数后,即可设置与MODULEENTRY32结构体相关的模块信息  </p>
<p><img src="/2018/12/08/reverse/image-102.png" width="400px"><br><img src="/2018/12/08/reverse/image-103.png" width="400px">  </p>
<ul>
<li>szModule成员表示DLL的名称  </li>
<li>modBaseAddr成员表示相应DLL被加载的地址(进程虚拟内存)  </li>
</ul>
<p>EjectDll()函数的for循环中比较szModule与希望卸载的Dll文件名称,能够准确查找到相应模块的信息  </p>
<h4 id="获取目标进程的句柄"><a href="#获取目标进程的句柄" class="headerlink" title="获取目标进程的句柄"></a>获取目标进程的句柄</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hProcess = openProcess(PROCESS_ALL_ACCESS, FALSE, dwPID);</span><br></pre></td></tr></table></figure>
<p>该语句使用进程ID来获取目标进程(notepad)的进程句柄(下面用获得的进程句柄调用CreateRemoteThread() API)  </p>
<h4 id="获取FreeLibrary-Api地址"><a href="#获取FreeLibrary-Api地址" class="headerlink" title="获取FreeLibrary()Api地址"></a>获取<code>FreeLibrary()</code>Api地址</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hModule = GetModuleHandle(<span class="string">L"kernel32.dll"</span>);</span><br><span class="line">pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, <span class="string">"FreeLibrary"</span>);</span><br></pre></td></tr></table></figure>
<p>若驱使notepad进程自己调用FreeLibrary,则需要先得到FreeLibrary的地址<br>然后加载到EjectDll.exe进程中的kernel32!FreeLibrary地址  </p>
<h4 id="在目标进程中运行线程"><a href="#在目标进程中运行线程" class="headerlink" title="在目标进程中运行线程"></a>在目标进程中运行线程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, </span><br><span class="line">                                 pThreadProc, me.modBaseAddr, </span><br><span class="line">                                 <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>pThreadProc参数是FreeLibrary()Api的地址,me.modBaseAddr参数是要卸载的DLL的加载地址<br>将线程函数指定为FreeLibrary函数,并把DLL加载地址传递给线程参数<br>这样就在目标进程中成功调用了FreeLibrary()Api</p>
<p>(CreateRemoteThread()API原意是在外部进程调用执行线程函数,只不过这里的线程函数换成了FreeLibrary()函数)  </p>
<p><br><br><br></p>
<h2 id="通过修改PE加载DLL"><a href="#通过修改PE加载DLL" class="headerlink" title="通过修改PE加载DLL"></a>通过修改PE加载DLL</h2><p><img src="/2018/12/08/reverse/image-104.png" width="350px">  </p>
<p>如上看<code>Import Directory Table</code>中TextView.exe导入的Dll文件为<code>Kernel32.dll</code>,<code>User32.dll</code>,<code>Shell32.dll</code>  </p>
<p>TextView_patched.exe是修改TextView.exe文件IDT后得到的文件  </p>
<p><img src="/2018/12/08/reverse/image-105.png" width="350px">  </p>
<p>IDT除了原来的4个DLL文件外,还新增了myhack3.dll文件,这样运行TextView_Patched.exe文件的时候,会自动加载myhack3.dll文件  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shlobj.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Wininet.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"Wininet.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_BUF_SIZE            (4096)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_URL                 <span class="meta-string">L"http://www.google.com/index.html"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_INDEX_FILE          <span class="meta-string">L"index.html"</span></span></span><br><span class="line"></span><br><span class="line">HWND g_hWnd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// IDT Çü½ÄÀ» À§ÇÑ dummy export function...</span></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">dummy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">DownloadURL</span><span class="params">(LPCTSTR szURL, LPCTSTR szFile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL            bRet = FALSE;</span><br><span class="line">    HINTERNET	    hInternet = <span class="literal">NULL</span>, hURL = <span class="literal">NULL</span>;</span><br><span class="line">    BYTE            pBuf[DEF_BUF_SIZE] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    DWORD           dwBytesRead = <span class="number">0</span>;</span><br><span class="line">    FILE            *pFile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">errno_t</span>         err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    hInternet = InternetOpen(<span class="string">L"ReverseCore"</span>, </span><br><span class="line">                             INTERNET_OPEN_TYPE_PRECONFIG, </span><br><span class="line">                             <span class="literal">NULL</span>, </span><br><span class="line">                             <span class="literal">NULL</span>, </span><br><span class="line">                             <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> == hInternet )</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugString(<span class="string">L"InternetOpen() failed!"</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hURL = InternetOpenUrl(hInternet,</span><br><span class="line">                           szURL,</span><br><span class="line">                           <span class="literal">NULL</span>,</span><br><span class="line">                           <span class="number">0</span>,</span><br><span class="line">                           INTERNET_FLAG_RELOAD,</span><br><span class="line">                           <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> == hURL )</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugString(<span class="string">L"InternetOpenUrl() failed!"</span>);</span><br><span class="line">        <span class="keyword">goto</span> _DownloadURL_EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( err = _tfopen_s(&amp;pFile, szFile, <span class="string">L"wt"</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugString(<span class="string">L"fopen() failed!"</span>);</span><br><span class="line">        <span class="keyword">goto</span> _DownloadURL_EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( InternetReadFile(hURL, pBuf, DEF_BUF_SIZE, &amp;dwBytesRead) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( !dwBytesRead )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        fwrite(pBuf, dwBytesRead, <span class="number">1</span>, pFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bRet = TRUE;</span><br><span class="line"></span><br><span class="line">_DownloadURL_EXIT:</span><br><span class="line">    <span class="keyword">if</span>( pFile )</span><br><span class="line">        fclose(pFile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( hURL )</span><br><span class="line">        InternetCloseHandle(hURL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( hInternet )</span><br><span class="line">        InternetCloseHandle(hInternet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL CALLBACK <span class="title">EnumWindowsProc</span><span class="params">(HWND hWnd, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwPID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    GetWindowThreadProcessId(hWnd, &amp;dwPID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( dwPID == (DWORD)lParam )</span><br><span class="line">    &#123;</span><br><span class="line">        g_hWnd = hWnd;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HWND <span class="title">GetWindowHandleFromPID</span><span class="params">(DWORD dwPID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EnumWindows(EnumWindowsProc, dwPID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> g_hWnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">DropFile</span><span class="params">(LPCTSTR wcsFile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HWND            hWnd = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD           dwBufSize = <span class="number">0</span>;</span><br><span class="line">    BYTE            *pBuf = <span class="literal">NULL</span>; </span><br><span class="line">	DROPFILES		*pDrop = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span>            szFile[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    HANDLE          hMem = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    WideCharToMultiByte(CP_ACP, <span class="number">0</span>, wcsFile, <span class="number">-1</span>,</span><br><span class="line">                        szFile, MAX_PATH, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    dwBufSize = <span class="keyword">sizeof</span>(DROPFILES) + <span class="built_in">strlen</span>(szFile) + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( !(hMem = GlobalAlloc(GMEM_ZEROINIT, dwBufSize)) )</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugString(<span class="string">L"GlobalAlloc() failed!!!"</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pBuf = (LPBYTE)GlobalLock(hMem);</span><br><span class="line"></span><br><span class="line">    pDrop = (DROPFILES*)pBuf; </span><br><span class="line">    pDrop-&gt;pFiles = <span class="keyword">sizeof</span>(DROPFILES);</span><br><span class="line">    strcpy_s((<span class="keyword">char</span>*)(pBuf + <span class="keyword">sizeof</span>(DROPFILES)), <span class="built_in">strlen</span>(szFile)+<span class="number">1</span>, szFile);</span><br><span class="line"></span><br><span class="line">    GlobalUnlock(hMem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !(hWnd = GetWindowHandleFromPID(GetCurrentProcessId())) )</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugString(<span class="string">L"GetWndHandleFromPID() failed!!!"</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PostMessage(hWnd, WM_DROPFILES, (WPARAM)pBuf, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCHAR szPath[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    TCHAR *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    OutputDebugString(<span class="string">L"ThreadProc() start..."</span>);</span><br><span class="line"></span><br><span class="line">    GetModuleFileName(<span class="literal">NULL</span>, szPath, <span class="keyword">sizeof</span>(szPath));</span><br><span class="line">    </span><br><span class="line">    if( p = _tcsrchr(szPath, L'\\') )</span><br><span class="line">    &#123;</span><br><span class="line">        _tcscpy_s(p+<span class="number">1</span>, wcslen(DEF_INDEX_FILE)+<span class="number">1</span>, DEF_INDEX_FILE);</span><br><span class="line"></span><br><span class="line">        OutputDebugString(<span class="string">L"DownloadURL()"</span>);</span><br><span class="line">        <span class="keyword">if</span>( DownloadURL(DEF_URL, szPath) )</span><br><span class="line">        &#123;</span><br><span class="line">            OutputDebugString(<span class="string">L"DropFlie()"</span>);</span><br><span class="line">            DropFile(szPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OutputDebugString(<span class="string">L"ThreadProc() end..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH : </span><br><span class="line">            CloseHandle(CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><h4 id="修改导入表的RVA值"><a href="#修改导入表的RVA值" class="headerlink" title="修改导入表的RVA值"></a>修改导入表的RVA值</h4><h4 id="删除绑定导入表"><a href="#删除绑定导入表" class="headerlink" title="删除绑定导入表"></a>删除绑定导入表</h4><h4 id="创建新的IDT"><a href="#创建新的IDT" class="headerlink" title="创建新的IDT"></a>创建新的IDT</h4><h4 id="设置Name-INT-IAT"><a href="#设置Name-INT-IAT" class="headerlink" title="设置Name,INT,IAT"></a>设置Name,INT,IAT</h4><h4 id="修改IAT节区的属性值"><a href="#修改IAT节区的属性值" class="headerlink" title="修改IAT节区的属性值"></a>修改IAT节区的属性值</h4><h4 id="检测验证"><a href="#检测验证" class="headerlink" title="检测验证"></a>检测验证</h4><h2 id="PE-Tools"><a href="#PE-Tools" class="headerlink" title="PE Tools"></a>PE Tools</h2><p>强大的PE文件编辑工具,具有内存转储,PE文件头编辑、PE重建等丰富多样的功能<br>并且支持插件,带有插件编写示例  </p>
<h3 id="进程内存转储"><a href="#进程内存转储" class="headerlink" title="进程内存转储"></a>进程内存转储</h3><p>转储(<code>dump</code>),意为”将内存中的内容转存到文件”<br>这种转储技术主要用来查看正在运行的进程内存中的内容<br>文件是运行时解压缩文件时,其只有在内存中才以解压缩形态存在  </p>
<p>借助转储技术可以轻松查看与源文件类似的代码与数据  </p>
<p><img src="/2018/12/08/reverse/image-117.png" width="400px"></p>
<ul>
<li><p>Dump Full<br>  完整转储，并从ImageBase地址开始转储SizeOFImage大小的区域</p>
</li>
<li><p>Dump Partial<br>  部分转储,指定地址开始转储指定大小的部分  </p>
</li>
<li><p>Dump Region<br>  区域转储</p>
</li>
</ul>
<h2 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h2><p>代码注入是一种向目标进程插入独立运行代码并使之运行的技术  </p>
<p>一般调用CreateRemoteThread()API以远程线程形式运行插入的代码,所以也被称为线程注入  </p>
<p><img src="/2018/12/08/reverse/image-118.png" width="400px"></p>
<p>代码以线程过程(Thread Procedure)形式插入,而代码中使用的数据则以线程参数的形式传入<br>也就是说代码和数据是分别注入的  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CodeInjection.cpp</span></span><br><span class="line"><span class="comment">// reversecore@gmail.com</span></span><br><span class="line"><span class="comment">// http://www.reversecore.com</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">THREAD_PARAM</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FARPROC pFunc[<span class="number">2</span>];               <span class="comment">// LoadLibraryA(), GetProcAddress()</span></span><br><span class="line">    <span class="keyword">char</span>    szBuf[<span class="number">4</span>][<span class="number">128</span>];          <span class="comment">// "user32.dll", "MessageBoxA", "www.reversecore.com", "ReverseCore"</span></span><br><span class="line">&#125; THREAD_PARAM, *PTHREAD_PARAM;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span> <span class="params">(WINAPI *PFLOADLIBRARYA)</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCSTR lpLibFileName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span> <span class="params">(WINAPI *PFGETPROCADDRESS)</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCSTR lpProcName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI *PFMESSAGEBOXA)</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">    UINT uType</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PTHREAD_PARAM   pParam      = (PTHREAD_PARAM)lParam;</span><br><span class="line">    HMODULE         hMod        = <span class="literal">NULL</span>;</span><br><span class="line">    FARPROC         pFunc       = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoadLibrary()</span></span><br><span class="line">    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[<span class="number">0</span>])(pParam-&gt;szBuf[<span class="number">0</span>]);    <span class="comment">// "user32.dll"</span></span><br><span class="line">    <span class="keyword">if</span>( !hMod )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GetProcAddress()</span></span><br><span class="line">    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[<span class="number">1</span>])(hMod, pParam-&gt;szBuf[<span class="number">1</span>]);  <span class="comment">// "MessageBoxA"</span></span><br><span class="line">    <span class="keyword">if</span>( !pFunc )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MessageBoxA()</span></span><br><span class="line">    ((PFMESSAGEBOXA)pFunc)(<span class="literal">NULL</span>, pParam-&gt;szBuf[<span class="number">2</span>], pParam-&gt;szBuf[<span class="number">3</span>], MB_OK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InjectCode</span><span class="params">(DWORD dwPID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE         hMod            = <span class="literal">NULL</span>;</span><br><span class="line">    THREAD_PARAM    param           = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    HANDLE          hProcess        = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE          hThread         = <span class="literal">NULL</span>;</span><br><span class="line">    LPVOID          pRemoteBuf[<span class="number">2</span>]   = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    DWORD           dwSize          = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    hMod = GetModuleHandleA(<span class="string">"kernel32.dll"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set THREAD_PARAM</span></span><br><span class="line">    param.pFunc[<span class="number">0</span>] = GetProcAddress(hMod, <span class="string">"LoadLibraryA"</span>);</span><br><span class="line">    param.pFunc[<span class="number">1</span>] = GetProcAddress(hMod, <span class="string">"GetProcAddress"</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">0</span>], <span class="string">"user32.dll"</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">1</span>], <span class="string">"MessageBoxA"</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">2</span>], <span class="string">"www.reversecore.com"</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">3</span>], <span class="string">"ReverseCore"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open Process</span></span><br><span class="line">    <span class="keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS,   <span class="comment">// dwDesiredAccess</span></span><br><span class="line">                                  FALSE,                <span class="comment">// bInheritHandle</span></span><br><span class="line">                                  dwPID)) )             <span class="comment">// dwProcessId</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"OpenProcess() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocation for THREAD_PARAM</span></span><br><span class="line">    dwSize = <span class="keyword">sizeof</span>(THREAD_PARAM);</span><br><span class="line">    <span class="keyword">if</span>( !(pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx(hProcess,          <span class="comment">// hProcess</span></span><br><span class="line">                                      <span class="literal">NULL</span>,                 <span class="comment">// lpAddress</span></span><br><span class="line">                                      dwSize,               <span class="comment">// dwSize</span></span><br><span class="line">                                      MEM_COMMIT,           <span class="comment">// flAllocationType</span></span><br><span class="line">                                      PAGE_READWRITE)) )    <span class="comment">// flProtect</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"VirtualAllocEx() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !WriteProcessMemory(hProcess,                       <span class="comment">// hProcess</span></span><br><span class="line">                            pRemoteBuf[<span class="number">0</span>],                  <span class="comment">// lpBaseAddress</span></span><br><span class="line">                            (LPVOID)&amp;param,                 <span class="comment">// lpBuffer</span></span><br><span class="line">                            dwSize,                         <span class="comment">// nSize</span></span><br><span class="line">                            <span class="literal">NULL</span>) )                         <span class="comment">// [out] lpNumberOfBytesWritten</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WriteProcessMemory() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocation for ThreadProc()</span></span><br><span class="line">    dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;</span><br><span class="line">    <span class="keyword">if</span>( !(pRemoteBuf[<span class="number">1</span>] = VirtualAllocEx(hProcess,          <span class="comment">// hProcess</span></span><br><span class="line">                                      <span class="literal">NULL</span>,                 <span class="comment">// lpAddress</span></span><br><span class="line">                                      dwSize,               <span class="comment">// dwSize</span></span><br><span class="line">                                      MEM_COMMIT,           <span class="comment">// flAllocationType</span></span><br><span class="line">                                      PAGE_EXECUTE_READWRITE)) )    <span class="comment">// flProtect</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"VirtualAllocEx() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !WriteProcessMemory(hProcess,                       <span class="comment">// hProcess</span></span><br><span class="line">                            pRemoteBuf[<span class="number">1</span>],                  <span class="comment">// lpBaseAddress</span></span><br><span class="line">                            (LPVOID)ThreadProc,             <span class="comment">// lpBuffer</span></span><br><span class="line">                            dwSize,                         <span class="comment">// nSize</span></span><br><span class="line">                            <span class="literal">NULL</span>) )                         <span class="comment">// [out] lpNumberOfBytesWritten</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WriteProcessMemory() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !(hThread = CreateRemoteThread(hProcess,            <span class="comment">// hProcess</span></span><br><span class="line">                                       <span class="literal">NULL</span>,                <span class="comment">// lpThreadAttributes</span></span><br><span class="line">                                       <span class="number">0</span>,                   <span class="comment">// dwStackSize</span></span><br><span class="line">                                       (LPTHREAD_START_ROUTINE)pRemoteBuf[<span class="number">1</span>],     <span class="comment">// dwStackSize</span></span><br><span class="line">                                       pRemoteBuf[<span class="number">0</span>],       <span class="comment">// lpParameter</span></span><br><span class="line">                                       <span class="number">0</span>,                   <span class="comment">// dwCreationFlags</span></span><br><span class="line">                                       <span class="literal">NULL</span>)) )             <span class="comment">// lpThreadId</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CreateRemoteThread() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);	</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID luid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, </span><br><span class="line">			              &amp;hToken) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"OpenProcessToken error: %u\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !LookupPrivilegeValue(<span class="literal">NULL</span>,           <span class="comment">// lookup privilege on local system</span></span><br><span class="line">                              lpszPrivilege,  <span class="comment">// privilege to lookup </span></span><br><span class="line">                              &amp;luid) )        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"LookupPrivilegeValue error: %u\n"</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    <span class="keyword">if</span>( bEnablePrivilege )</span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line">    <span class="keyword">if</span>( !AdjustTokenPrivileges(hToken, </span><br><span class="line">                               FALSE, </span><br><span class="line">                               &amp;tp, </span><br><span class="line">                               <span class="keyword">sizeof</span>(TOKEN_PRIVILEGES), </span><br><span class="line">                               (PTOKEN_PRIVILEGES) <span class="literal">NULL</span>, </span><br><span class="line">                               (PDWORD) <span class="literal">NULL</span>) )</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"AdjustTokenPrivileges error: %u\n"</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( GetLastError() == ERROR_NOT_ALL_ASSIGNED )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The token does not have the specified privilege. \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwPID     = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( argc != <span class="number">2</span> )</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"\n USAGE  : %s &lt;pid&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// change privilege</span></span><br><span class="line">	<span class="keyword">if</span>( !SetPrivilege(SE_DEBUG_NAME, TRUE) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// code injection</span></span><br><span class="line">    dwPID = (DWORD)atol(argv[<span class="number">1</span>]);</span><br><span class="line">    InjectCode(dwPID);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码与DLL注入很相似,InjectCode函数的set THREAD_PARAM部分用来设置THREAD_PARAM结构体变量<br>他们会注入目标进程,并且以参数形式传递给ThreadProc()线程函数  </p>
<blockquote>
<p>调用一些列API函数,其核心API归纳整理  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OpenProcess();</span><br><span class="line"></span><br><span class="line"><span class="comment">// data: THREAD_PARAM </span></span><br><span class="line">VirtualAllEx();</span><br><span class="line">WriteProcessMemory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// code: ThreadProc()</span></span><br><span class="line">VirtualAllocEx();</span><br><span class="line">WriteProcessMemory();</span><br><span class="line"></span><br><span class="line">CreateRemoteThread();</span><br></pre></td></tr></table></figure>
<p>分别为data与code分配内存,并将他们注入目标进程，最后调用CreateRemoteThread()API,执行远程线程  </p>
<h2 id="汇编语言注入"><a href="#汇编语言注入" class="headerlink" title="汇编语言注入"></a>汇编语言注入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CodeInjection2.cpp</span></span><br><span class="line"><span class="comment">// reversecore@gmail.com</span></span><br><span class="line"><span class="comment">// http://www.reversecore.com</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">THREAD_PARAM</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FARPROC pFunc[<span class="number">2</span>];               <span class="comment">// LoadLibraryA(), GetProcAddress()</span></span><br><span class="line">&#125; THREAD_PARAM, *PTHREAD_PARAM;</span><br><span class="line"></span><br><span class="line">BYTE g_InjectionCode[] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x55</span>, <span class="number">0x8B</span>, <span class="number">0xEC</span>, <span class="number">0x8B</span>, <span class="number">0x75</span>, <span class="number">0x08</span>, <span class="number">0x68</span>, <span class="number">0x6C</span>, <span class="number">0x6C</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x68</span>, <span class="number">0x33</span>, <span class="number">0x32</span>, <span class="number">0x2E</span>, <span class="number">0x64</span>, <span class="number">0x68</span>, <span class="number">0x75</span>, <span class="number">0x73</span>, <span class="number">0x65</span>,</span><br><span class="line">    <span class="number">0x72</span>, <span class="number">0x54</span>, <span class="number">0xFF</span>, <span class="number">0x16</span>, <span class="number">0x68</span>, <span class="number">0x6F</span>, <span class="number">0x78</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0x68</span>,</span><br><span class="line">    <span class="number">0x61</span>, <span class="number">0x67</span>, <span class="number">0x65</span>, <span class="number">0x42</span>, <span class="number">0x68</span>, <span class="number">0x4D</span>, <span class="number">0x65</span>, <span class="number">0x73</span>, <span class="number">0x73</span>, <span class="number">0x54</span>,</span><br><span class="line">    <span class="number">0x50</span>, <span class="number">0xFF</span>, <span class="number">0x56</span>, <span class="number">0x04</span>, <span class="number">0x6A</span>, <span class="number">0x00</span>, <span class="number">0xE8</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x52</span>, <span class="number">0x65</span>, <span class="number">0x76</span>, <span class="number">0x65</span>, <span class="number">0x72</span>, <span class="number">0x73</span>, <span class="number">0x65</span>, <span class="number">0x43</span>, <span class="number">0x6F</span>,</span><br><span class="line">    <span class="number">0x72</span>, <span class="number">0x65</span>, <span class="number">0x00</span>, <span class="number">0xE8</span>, <span class="number">0x14</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x77</span>, <span class="number">0x77</span>,</span><br><span class="line">    <span class="number">0x77</span>, <span class="number">0x2E</span>, <span class="number">0x72</span>, <span class="number">0x65</span>, <span class="number">0x76</span>, <span class="number">0x65</span>, <span class="number">0x72</span>, <span class="number">0x73</span>, <span class="number">0x65</span>, <span class="number">0x63</span>,</span><br><span class="line">    <span class="number">0x6F</span>, <span class="number">0x72</span>, <span class="number">0x65</span>, <span class="number">0x2E</span>, <span class="number">0x63</span>, <span class="number">0x6F</span>, <span class="number">0x6D</span>, <span class="number">0x00</span>, <span class="number">0x6A</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xFF</span>, <span class="number">0xD0</span>, <span class="number">0x33</span>, <span class="number">0xC0</span>, <span class="number">0x8B</span>, <span class="number">0xE5</span>, <span class="number">0x5D</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">004010ED    55               PUSH EBP</span></span><br><span class="line"><span class="comment">004010EE    8BEC             MOV EBP,ESP</span></span><br><span class="line"><span class="comment">004010F0    8B75 08          MOV ESI,DWORD PTR SS:[EBP+8]       ; ESI = pParam           </span></span><br><span class="line"><span class="comment">004010F3    68 6C6C0000      PUSH 6C6C                      </span></span><br><span class="line"><span class="comment">004010F8    68 33322E64      PUSH 642E3233</span></span><br><span class="line"><span class="comment">004010FD    68 75736572      PUSH 72657375</span></span><br><span class="line"><span class="comment">00401102    54               PUSH ESP                           ; - "user32.dll"</span></span><br><span class="line"><span class="comment">00401103    FF16             CALL DWORD PTR DS:[ESI]            ; LoadLibraryA("user32.dll")</span></span><br><span class="line"><span class="comment">00401105    68 6F784100      PUSH 41786F</span></span><br><span class="line"><span class="comment">0040110A    68 61676542      PUSH 42656761</span></span><br><span class="line"><span class="comment">0040110F    68 4D657373      PUSH 7373654D</span></span><br><span class="line"><span class="comment">00401114    54               PUSH ESP                           ; - "MessageBoxA"</span></span><br><span class="line"><span class="comment">00401115    50               PUSH EAX                           ; - hMod</span></span><br><span class="line"><span class="comment">00401116    FF56 04          CALL DWORD PTR DS:[ESI+4]          ; GetProcAddress(hMod, "MessageBoxA")</span></span><br><span class="line"><span class="comment">00401119    6A 00            PUSH 0                             ; - MB_OK (0)</span></span><br><span class="line"><span class="comment">0040111B    E8 0C000000      CALL 0040112C</span></span><br><span class="line"><span class="comment">00401120                     &lt;ASCII&gt;                            ; - "ReverseCore", 0</span></span><br><span class="line"><span class="comment">0040112C    E8 14000000      CALL 00401145</span></span><br><span class="line"><span class="comment">00401131                     &lt;ASCII&gt;                            ; - "www.reversecore.com", 0</span></span><br><span class="line"><span class="comment">00401145    6A 00            PUSH 0                             ; - hWnd (0)</span></span><br><span class="line"><span class="comment">00401147    FFD0             CALL EAX                           ; MessageBoxA(0, "www.reversecore.com", "ReverseCore", 0)</span></span><br><span class="line"><span class="comment">00401149    33C0             XOR EAX,EAX                        </span></span><br><span class="line"><span class="comment">0040114B    8BE5             MOV ESP,EBP</span></span><br><span class="line"><span class="comment">0040114D    5D               POP EBP                            </span></span><br><span class="line"><span class="comment">0040114E    C3               RETN</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID luid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, </span><br><span class="line">			              &amp;hToken) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"OpenProcessToken error: %u\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !LookupPrivilegeValue(<span class="literal">NULL</span>,           <span class="comment">// lookup privilege on local system</span></span><br><span class="line">                              lpszPrivilege,  <span class="comment">// privilege to lookup </span></span><br><span class="line">                              &amp;luid) )        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"LookupPrivilegeValue error: %u\n"</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    <span class="keyword">if</span>( bEnablePrivilege )</span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line">    <span class="keyword">if</span>( !AdjustTokenPrivileges(hToken, </span><br><span class="line">                               FALSE, </span><br><span class="line">                               &amp;tp, </span><br><span class="line">                               <span class="keyword">sizeof</span>(TOKEN_PRIVILEGES), </span><br><span class="line">                               (PTOKEN_PRIVILEGES) <span class="literal">NULL</span>, </span><br><span class="line">                               (PDWORD) <span class="literal">NULL</span>) )</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"AdjustTokenPrivileges error: %u\n"</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( GetLastError() == ERROR_NOT_ALL_ASSIGNED )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The token does not have the specified privilege. \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InjectCode</span><span class="params">(DWORD dwPID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE         hMod            = <span class="literal">NULL</span>;</span><br><span class="line">    THREAD_PARAM    param           = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    HANDLE          hProcess        = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE          hThread         = <span class="literal">NULL</span>;</span><br><span class="line">    LPVOID          pRemoteBuf[<span class="number">2</span>]   = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    hMod = GetModuleHandleA(<span class="string">"kernel32.dll"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set THREAD_PARAM</span></span><br><span class="line">    param.pFunc[<span class="number">0</span>] = GetProcAddress(hMod, <span class="string">"LoadLibraryA"</span>);</span><br><span class="line">    param.pFunc[<span class="number">1</span>] = GetProcAddress(hMod, <span class="string">"GetProcAddress"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open Process</span></span><br><span class="line">    <span class="keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS,               <span class="comment">// dwDesiredAccess</span></span><br><span class="line">                                  FALSE,                            <span class="comment">// bInheritHandle</span></span><br><span class="line">                                  dwPID)) )                         <span class="comment">// dwProcessId</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"OpenProcess() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocation for THREAD_PARAM</span></span><br><span class="line">    <span class="keyword">if</span>( !(pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx(hProcess,                  <span class="comment">// hProcess</span></span><br><span class="line">                                         <span class="literal">NULL</span>,                      <span class="comment">// lpAddress</span></span><br><span class="line">                                         <span class="keyword">sizeof</span>(THREAD_PARAM),      <span class="comment">// dwSize</span></span><br><span class="line">                                         MEM_COMMIT,                <span class="comment">// flAllocationType</span></span><br><span class="line">                                         PAGE_READWRITE)) )         <span class="comment">// flProtect</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"VirtualAllocEx() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !WriteProcessMemory(hProcess,                               <span class="comment">// hProcess</span></span><br><span class="line">                            pRemoteBuf[<span class="number">0</span>],                          <span class="comment">// lpBaseAddress</span></span><br><span class="line">                            (LPVOID)&amp;param,                         <span class="comment">// lpBuffer</span></span><br><span class="line">                            <span class="keyword">sizeof</span>(THREAD_PARAM),                   <span class="comment">// nSize</span></span><br><span class="line">                            <span class="literal">NULL</span>) )                                 <span class="comment">// [out] lpNumberOfBytesWritten</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WriteProcessMemory() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocation for ThreadProc()</span></span><br><span class="line">    <span class="keyword">if</span>( !(pRemoteBuf[<span class="number">1</span>] = VirtualAllocEx(hProcess,                  <span class="comment">// hProcess</span></span><br><span class="line">                                         <span class="literal">NULL</span>,                      <span class="comment">// lpAddress</span></span><br><span class="line">                                         <span class="keyword">sizeof</span>(g_InjectionCode),   <span class="comment">// dwSize</span></span><br><span class="line">                                         MEM_COMMIT,                <span class="comment">// flAllocationType</span></span><br><span class="line">                                         PAGE_EXECUTE_READWRITE)) ) <span class="comment">// flProtect</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"VirtualAllocEx() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !WriteProcessMemory(hProcess,                               <span class="comment">// hProcess</span></span><br><span class="line">                            pRemoteBuf[<span class="number">1</span>],                          <span class="comment">// lpBaseAddress</span></span><br><span class="line">                            (LPVOID)&amp;g_InjectionCode,               <span class="comment">// lpBuffer</span></span><br><span class="line">                            <span class="keyword">sizeof</span>(g_InjectionCode),                <span class="comment">// nSize</span></span><br><span class="line">                            <span class="literal">NULL</span>) )                                 <span class="comment">// [out] lpNumberOfBytesWritten</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WriteProcessMemory() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !(hThread = CreateRemoteThread(hProcess,                    <span class="comment">// hProcess</span></span><br><span class="line">                                       <span class="literal">NULL</span>,                        <span class="comment">// lpThreadAttributes</span></span><br><span class="line">                                       <span class="number">0</span>,                           <span class="comment">// dwStackSize</span></span><br><span class="line">                                       (LPTHREAD_START_ROUTINE)pRemoteBuf[<span class="number">1</span>],</span><br><span class="line">                                       pRemoteBuf[<span class="number">0</span>],               <span class="comment">// lpParameter</span></span><br><span class="line">                                       <span class="number">0</span>,                           <span class="comment">// dwCreationFlags</span></span><br><span class="line">                                       <span class="literal">NULL</span>)) )                     <span class="comment">// lpThreadId</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CreateRemoteThread() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);	</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwPID     = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( argc != <span class="number">2</span> )</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"\n USAGE  : %s &lt;pid&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// change privilege</span></span><br><span class="line">	<span class="keyword">if</span>( !SetPrivilege(SE_DEBUG_NAME, TRUE) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// code injection</span></span><br><span class="line">    dwPID = (DWORD)atol(argv[<span class="number">1</span>]);</span><br><span class="line">    InjectCode(dwPID);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="API钩取"><a href="#API钩取" class="headerlink" title="API钩取"></a>API钩取</h1><p>Api应用程序编程接口   </p>
<p>WindowsOS中，用户程序要使用系统资源(内存、文件、网络、视频、音频等)时无法直接访问  </p>
<p>这些资源都是由Windows os直接管理,出于多种考虑(稳定性、安全、效率等)  </p>
<p>WindowsOS禁止用户程序直接访问他们,用户程序需要使用这些资源时,必须向系统内核(Kernel)申请  </p>
<p>申请的方法就是使用微软提供的Win32 Api(或OS开发公司提供的Api)  </p>
<p>也就是说若没有Api函数,则不能创建出任何有意义的应用程序(因为它不能访问进程、线程、内存、文件、网络、注册表、图片、音频以及其他系统资源)  </p>
<p><img src="/2018/12/08/reverse/image-106.png" width="500px"></p>
<p>用户模式中的应用程序代码要访问系统资源时,由ntdll.dll向内核模式提出访问申请  </p>
<blockquote>
<p>下面notepad.exe打开c:\abc.txt文件  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-  msvcrt!fopen()</span><br><span class="line">	kernel32!CreateFileW()</span><br><span class="line">		ntdll!ZwCreatefile()</span><br><span class="line">			ntdll!KiFastSystemCall()</span><br><span class="line">				SYSENTER</span><br><span class="line">					-&gt; 进入内核模式</span><br></pre></td></tr></table></figure>
<p>如上所述,使用常规系统资源的Api会经由Kernel32.dll与ntdll.dll不断向下调用,最后通过SYSENTER命令进入内核模式  </p>
<h2 id="Api钩取"><a href="#Api钩取" class="headerlink" title="Api钩取"></a>Api钩取</h2><p>钩取(Hook)是一种截取信息,更改程序执行流向,添加新功能的技术  </p>
<p>钩取的整个流程  </p>
<ul>
<li>使用反汇编器/调试器把握程序的结构与工作原理  </li>
<li>开发需要的 “钩子” 代码,用于修改Bug、改善程序功能  </li>
<li>灵活操作可执行文件与进程内存,设置 “钩子” 代码  </li>
</ul>
<p>Api钩取技术优势如下  </p>
<ul>
<li>在Api调用前/后运行用户的 “钩子” 代码  </li>
<li>查看或操作传递给Api的参数或Api函数的返回值  </li>
<li>取消对Api的调用,或更改执行流运行用户代码  </li>
</ul>
<blockquote>
<p>正常调用Api  </p>
</blockquote>
<p><img src="/2018/12/08/reverse/image-107.png" width="450px">  </p>
<blockquote>
<p>钩取Api调用  </p>
</blockquote>
<p>用户先使用Dll技术将hook.dll注入目标进程的内存空间,然后hook!MyCreateFile()钩取对kernel32!CreateFile()的调用,这样每当目标进程要调用kernel32!CreateFile() API时都会先调用hook!MyCreateFile();</p>
<p><img src="/2018/12/08/reverse/image-108.png" width="450px">  </p>
<h2 id="技术图表"><a href="#技术图表" class="headerlink" title="技术图表"></a>技术图表</h2><p><img src="/2018/12/08/reverse/image-109.png" width="450px">  </p>
<p>涵盖了API钩取的所有技术内容  </p>
<h3 id="方法对象"><a href="#方法对象" class="headerlink" title="方法对象"></a>方法对象</h3><p>API钩取的方法分类,根据针对的对象不同,API钩取方法大致可以分类静态方法和动态方法  </p>
<p>静态方法针对的是”文件”,而动态方法针对的是进程内存<br>一般API钩取技术指动态方法,当然在某些非常特殊的情形下也可以使用静态方法</p>
<p><img src="/2018/12/08/reverse/image-110.png" width="450px">  </p>
<h3 id="位置何处"><a href="#位置何处" class="headerlink" title="位置何处"></a>位置何处</h3><p>IAT  </p>
<p>IAT将其内部的API地址更改为钩取函数地址,该方法的优点是实现起来非常简单,缺点是无法钩取不在IAT而在程序中使用的API(如:动态加载并使用DLL)  </p>
<p>代码  </p>
<p>系统库(<code>*.dll</code>)映射到进程内存时,从中查找API的实际地址，并直接修改代码,该方法应用范围广泛,具体实现以下几种选择:  </p>
<ul>
<li>使用JMP指令修改起始代码   </li>
<li>覆写函数局部  </li>
<li>仅更改必需部分的局部  </li>
</ul>
<p>EAT  </p>
<p>将记录在Dll的EAT中的API起始地址更改为钩取函数地址,也可以实现API钩取  </p>
<p>这种方法概念上看非常简单,但具体实现不如前面的Code方法简单、强大,所以修改EAT的这种方法并不常用  </p>
<h3 id="技术如何"><a href="#技术如何" class="headerlink" title="技术如何"></a>技术如何</h3><p>项目部进程内存设置钩取函数的具体技术,大致分为调试法与注入法两类  </p>
<p>注入法又细分为代码注入与DLL注入两种  </p>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>调试发通过调试目标进程钩取API(那不是仅仅调试,怎么API钩取?)  </p>
<p>调试器拥有被调整者(被调试进程)的所有权限(执行控制、内存访问等)   </p>
<p>所以可以向被调试进程的内存任意设置钩取函数  </p>
<p>也就是说利用调试API附加到目标进程,然后(执行处于暂停状态)设置钩取函数，这样重启运行时就能完全实现API钩取了(Xp以上的系统也可在被调试者终止之前分离(Deatch)调试器)  </p>
<h4 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h4><p>注入技术是一种想目标进程内存区域进行渗透的技术,根据注入对象的不同,可细分为Dll注入和代码注入两种,其中Dll注入技术最为广泛  </p>
<h5 id="Dll注入"><a href="#Dll注入" class="headerlink" title="Dll注入"></a>Dll注入</h5><p>Dll注入技术可以驱使目标进程强制加载用户指定的Dll文件,使用该技术时  </p>
<p>先在要注入的Dll中创建钩取代码与设置代码  </p>
<p>然后在DllMain()中调用设置代码，注入的同时科技完成Api钩取</p>
<h5 id="代码注入-1"><a href="#代码注入-1" class="headerlink" title="代码注入"></a>代码注入</h5><p>代码注入技术比Dll注入更发达(更复杂)，广泛应用于恶意代码(病毒,shellCode等)<br>(杀毒软件能有效检测出Dll注入操作,却很难探测到代码注入操作,所以恶意代码大量使用代码注入技术,以防被杀毒软件查杀)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">代码注入实现更复杂</span><br><span class="line">不像Dll注入技术那样针对是完整的PE映像</span><br><span class="line">而是在执行代码与数据被注入的状态下直接获取自身所需API地址来使用</span><br><span class="line"></span><br><span class="line">访问代码中的内存地址时必须十分小心</span><br><span class="line">防止访问到错误地址</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="记事本WriteFile-Api钩取案例"><a href="#记事本WriteFile-Api钩取案例" class="headerlink" title="记事本WriteFile Api钩取案例"></a>记事本WriteFile Api钩取案例</h2><p>由于该技术借助了”调试”钩取,所以能够进行与用户交互性的钩取操作  </p>
<p><img src="/2018/12/08/reverse/image-111.png" width="450px"></p>
<h3 id="调试器工作原理"><a href="#调试器工作原理" class="headerlink" title="调试器工作原理"></a>调试器工作原理</h3><p>调试进程经过注册后,每当被调试者发送调试时间(Debug Event)时<br>OS就会暂停其运行,并向调试器报告相应事件<br>调试器对相应事件做适当处理,事被调试这继续运行   </p>
<p><img src="/2018/12/08/reverse/image-112.png" width="450px">  </p>
<ul>
<li>一般异常也属于调试事件   </li>
<li>若相应进程处于非调试,调试事件也会在其自身的异常处理或OS的异常处理机制中被处理掉  </li>
<li>调试器无法处理或不关心的调试事件最终由OS处理   </li>
</ul>
<h3 id="调试事件"><a href="#调试事件" class="headerlink" title="调试事件"></a>调试事件</h3><p><img src="/2018/12/08/reverse/image-113.png" width="250px">  </p>
<p><img src="/2018/12/08/reverse/image-114.png" width="250px"></p>
<p>下面是异常列表  </p>
<p><img src="/2018/12/08/reverse/image-115.png" width="350px">  </p>
<p>上面各类异常,调试器必须处理的是EXCEPTION_BREAKPOINT异常<br>端点对应的汇编指令为INT3, IA-32指令为0xCC  </p>
<p>调试器实现端点的方法非常简单,找到要设置断点的代码在内存的起始地址,只要把1个字节修改为0xCC就可以了  </p>
<p>想要继续调试,再将它恢复原值即可  </p>
<p>通过调试钩取API技术就是利用了端点这一特性 </p>
<h3 id="调试技术流程"><a href="#调试技术流程" class="headerlink" title="调试技术流程"></a>调试技术流程</h3><ul>
<li>对想钩取的进程进行附加操作,使之成为被调试者  </li>
<li>“钩子” :是API起始地址的第一个字节修改为0xCC  </li>
<li>调用相应API时,控制权转移到调试器  </li>
<li>执行需要的操作(操作参数、返回值等)  </li>
<li>脱钩:将0xCC恢复原值(为了正常运行Api)  </li>
<li>运行相应API(无0xCC的正常状态)</li>
<li>“钩子” :再次修改为0xCC(为了继续钩取)  </li>
<li>控制权返回被调试者  </li>
</ul>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line">LPVOID g_pfWriteFile = <span class="literal">NULL</span>;</span><br><span class="line">CREATE_PROCESS_DEBUG_INFO g_cpdi;</span><br><span class="line">BYTE g_chINT3 = <span class="number">0xCC</span>, g_chOrgByte = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">OnCreateProcessDebugEvent</span><span class="params">(LPDEBUG_EVENT pde)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取 WriteFile() Api地址</span></span><br><span class="line">    g_pfWriteFile = GetProcAddress(GetModuleHandleA(<span class="string">"kernel32.dll"</span>), <span class="string">"WriteFile"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// API Hook - WriteFile()</span></span><br><span class="line">    <span class="comment">//   更改第一个字节为0xCC(INT3)</span></span><br><span class="line">    <span class="comment">//   (orginal byte 是g_ch0rgByte备份)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;g_cpdi, &amp;pde-&gt;u.CreateProcessInfo, <span class="keyword">sizeof</span>(CREATE_PROCESS_DEBUG_INFO));</span><br><span class="line">    ReadProcessMemory(g_cpdi.hProcess, g_pfWriteFile, </span><br><span class="line">                      &amp;g_chOrgByte, <span class="keyword">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line">    WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, </span><br><span class="line">                       &amp;g_chINT3, <span class="keyword">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">OnExceptionDebugEvent</span><span class="params">(LPDEBUG_EVENT pde)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CONTEXT ctx;</span><br><span class="line">    PBYTE lpBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwNumOfBytesToWrite, dwAddrOfBuffer, i;</span><br><span class="line">    PEXCEPTION_RECORD per = &amp;pde-&gt;u.Exception.ExceptionRecord;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是断点异常(INT 3)时</span></span><br><span class="line">    <span class="keyword">if</span>( EXCEPTION_BREAKPOINT == per-&gt;ExceptionCode )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 断点地址为WriteFile() API地址</span></span><br><span class="line">        <span class="keyword">if</span>( g_pfWriteFile == per-&gt;ExceptionAddress )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// #1. Unhook</span></span><br><span class="line">            <span class="comment">//   将0xCC恢复为original byte</span></span><br><span class="line">            WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, </span><br><span class="line">                               &amp;g_chOrgByte, <span class="keyword">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #2. 获取线程上下文</span></span><br><span class="line">            ctx.ContextFlags = CONTEXT_CONTROL;</span><br><span class="line">            GetThreadContext(g_cpdi.hThread, &amp;ctx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #3.  获取 WriteFile()的param 2、3值</span></span><br><span class="line">            <span class="comment">//   函数参数存在于相应进程的栈</span></span><br><span class="line">            <span class="comment">//   param 2 : ESP + 0x8</span></span><br><span class="line">            <span class="comment">//   param 3 : ESP + 0xC</span></span><br><span class="line">            ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + <span class="number">0x8</span>), </span><br><span class="line">                              &amp;dwAddrOfBuffer, <span class="keyword">sizeof</span>(DWORD), <span class="literal">NULL</span>);</span><br><span class="line">            ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + <span class="number">0xC</span>), </span><br><span class="line">                              &amp;dwNumOfBytesToWrite, <span class="keyword">sizeof</span>(DWORD), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #4. 分配临时缓冲区</span></span><br><span class="line">            lpBuffer = (PBYTE)<span class="built_in">malloc</span>(dwNumOfBytesToWrite+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">memset</span>(lpBuffer, <span class="number">0</span>, dwNumOfBytesToWrite+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #5. 复制 WriteFile() 缓冲区到临时缓冲区</span></span><br><span class="line">            ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, </span><br><span class="line">                              lpBuffer, dwNumOfBytesToWrite, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n### original string ###\n%s\n"</span>, lpBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #6. 将小写字母转换为大写字母  </span></span><br><span class="line">            <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; dwNumOfBytesToWrite; i++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( <span class="number">0x61</span> &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= <span class="number">0x7A</span> )</span><br><span class="line">                    lpBuffer[i] -= <span class="number">0x20</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n### converted string ###\n%s\n"</span>, lpBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #7. 将变换后的缓冲区复制到WriteFile()缓冲区</span></span><br><span class="line">            WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, </span><br><span class="line">                               lpBuffer, dwNumOfBytesToWrite, <span class="literal">NULL</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// #8. 释放临时缓冲区</span></span><br><span class="line">            <span class="built_in">free</span>(lpBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #9. 将线程上下文的EIP更改为WriteFile()首地址</span></span><br><span class="line">            <span class="comment">//   当前为WriteFile()+1位置,INT3命令之后</span></span><br><span class="line">            ctx.Eip = (DWORD)g_pfWriteFile;</span><br><span class="line">            SetThreadContext(g_cpdi.hThread, &amp;ctx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #10. 运行被调试进程</span></span><br><span class="line">            ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE);</span><br><span class="line">            Sleep(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #11. API Hook</span></span><br><span class="line">            WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, </span><br><span class="line">                               &amp;g_chINT3, <span class="keyword">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DebugLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DEBUG_EVENT de;</span><br><span class="line">    DWORD dwContinueStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待被调试者发送时间</span></span><br><span class="line">    <span class="keyword">while</span>( WaitForDebugEvent(&amp;de, INFINITE) )</span><br><span class="line">    &#123;</span><br><span class="line">        dwContinueStatus = DBG_CONTINUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 被调试进程生成或者附加事件</span></span><br><span class="line">        <span class="keyword">if</span>( CREATE_PROCESS_DEBUG_EVENT == de.dwDebugEventCode )</span><br><span class="line">        &#123;</span><br><span class="line">            OnCreateProcessDebugEvent(&amp;de);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异常事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( OnExceptionDebugEvent(&amp;de) )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被调试进程 终止事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 被调试者终止 - 调试器终止</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次运行被调试者</span></span><br><span class="line">        ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwPID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( argc != <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nUSAGE : hookdbg.exe &lt;pid&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach Process</span></span><br><span class="line">    dwPID = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>( !DebugActiveProcess(dwPID) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"DebugActiveProcess(%d) failed!!!\n"</span></span><br><span class="line">               <span class="string">"Error Code = %d\n"</span>, dwPID, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试器循环</span></span><br><span class="line">    DebugLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于调试器"><a href="#关于调试器" class="headerlink" title="关于调试器"></a>关于调试器</h2><h2 id="隐藏进程"><a href="#隐藏进程" class="headerlink" title="隐藏进程"></a>隐藏进程</h2><p><br></p>
<h1 id="64位Windows内核6"><a href="#64位Windows内核6" class="headerlink" title="64位Windows内核6"></a>64位Windows内核6</h1><h2 id="64位计算"><a href="#64位计算" class="headerlink" title="64位计算"></a>64位计算</h2><p>80386是Intel 1985年推出的cpu芯片,32位微处理器,当时由于价格高昂、支持的OS少,几乎没有得到普及  </p>
<p>随着1995年微软发布32位OS windows 95,计算机正式进入32位计算机时代  </p>
<p>Windows 95向下兼容支持16位程序,已有的DOS应用程序大部分能够稳定运行  </p>
<p>经过几年16位/32位混用的过渡期,OS进入Windows 2000/xp时代,32位应用程序开始成为主流,并且延续至今  </p>
<p>后续纷纷开发64位版本,这就是64位CPU于64位OS共同构成的64位计算机环境 </p>
<h3 id="64位CPU"><a href="#64位CPU" class="headerlink" title="64位CPU"></a>64位CPU</h3><p>IA-64是Intel与HP合作的产物,设计初衷大幅度提高计算机性能,霸占整个PC与服务器市场从而抛弃向下兼容的特性  </p>
<p>此后AMD发布AMD64,兼容IA-32的64位芯片在PC市场大受欢迎  </p>
<p>为了应对这种情况,Intel从AMD购买许可,发布了与AMD64兼容的EM64T,后来改名为Intel64,  </p>
<p>最近Intel退出的Core 2 Duo,i7/i5/i3等CPU就是Intel64系列  </p>
<p><img src="/2018/12/08/reverse/image-119.png" width="450px"></p>
<h3 id="64位OS"><a href="#64位OS" class="headerlink" title="64位OS"></a>64位OS</h3><p>PC中使用windows64位操作系统有Windows XP/Vista/7的64位版本  </p>
<p>微软认为向下兼容32位是决定64位OS成败的关键,支持32位也被看作64位OS的核心功能  </p>
<p>所以现有32位源程序可以很容易移植到64位系统上  </p>
<p><img src="/2018/12/08/reverse/image-120.png" width="450px">  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ILP32: integer, long, Pointer-32位  </span><br><span class="line">LLP: Longlong, Pointer-64位  </span><br><span class="line">LP64: Long, Pointer-64位</span><br></pre></td></tr></table></figure>
<h3 id="WOW64"><a href="#WOW64" class="headerlink" title="WOW64"></a>WOW64</h3><p>WOW64(Windows on windows64)是一种64位OS中支持运行现有32位应用程序的机制  </p>
<p>64位Windows中,32位应用程序与64位应用程序都可以正常运行  </p>
<p>64位应用程序会加载kernel32.dll(64位)与ntdll.dll(64位)<br>而32位应用程序则加载kernel32.dll(32位)与ntdll.dll(32位)  </p>
<p>WOW64会在中间将ntdll.dll(32位)的请求(API调用)重定向到ntdll.dll(64位)  </p>
<p><img src="/2018/12/08/reverse/image-121.png" width="350px"><br><img src="/2018/12/08/reverse/image-122.png" width="400px"></p>
<blockquote>
<p>文件夹结构  </p>
</blockquote>
<p>64位windows的文件夹结构中,开发人员与逆向分析人员都需要知道System32文件夹  </p>
<p>系统文件夹在64位环境中名称也为System32,并且为了向下兼容32位,单独提供了SysWOW64文件夹  </p>
<p><img src="/2018/12/08/reverse/image-123.png" width="350px"></p>
<ul>
<li>System32文件夹中的kernel32.dll是64位    </li>
<li>SysWOW64文件夹中的kernel32.dll是32位  </li>
</ul>
<blockquote>
<p>设置Visual Studio环境   </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置管理器-&gt;活动解决方案平台  </span><br><span class="line"></span><br><span class="line">新建解决方案平台-&gt;选择新平台(x64)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="X64处理器"><a href="#X64处理器" class="headerlink" title="X64处理器"></a>X64处理器</h2><p>为了保持向下兼容,X64在原有X86基础上扩展而来,要在X64系统进行代码逆向分析,必须先了解X64的新增或变更的内容  </p>
<h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><p>64位系统中的内存地址为64位(8个字节),使用64位大小的指针  </p>
<p>含有绝对地址(VA)的指令大小比原来增加了4个字节  </p>
<p>同样寄存器的大小以及栈的基本单位也变为64位  </p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>x64的进程虚拟内存的实际大小为16TB(内核空间与用户空间各占8TB)  </p>
<p>与x86的4GB相比,大小增加了非常多  </p>
<p><img src="/2018/12/08/reverse/image-124.png" width="450px"></p>
<h3 id="通用寄存器-1"><a href="#通用寄存器-1" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>x64系统中,通用寄存器的大小扩展到64位(8个字节),数量也增加到18个(R8~R15寄存器)  </p>
<p>x64系统下所有通用寄存器的名称均以字母”R”开头  </p>
<p><img src="/2018/12/08/reverse/image-125.png" width="450px">  </p>
<p><br></p>
<h2 id="PE32"><a href="#PE32" class="headerlink" title="PE32+"></a>PE32+</h2><p>64位Windows OS中的进程虚拟内存为16TB,其中低位8TB的给用户模式,高位的8TB分给内核模式  </p>
<h3 id="PE32-1"><a href="#PE32-1" class="headerlink" title="PE32+"></a>PE32+</h3><p>64位本地模式中运行的PE文件格式被称为PE32+(PE+,PE64)<br>为了保持向下兼容性,PE32+在原32位PE文件(PE32)基础上扩展而来</p>
<p>以下介绍与原PE文件格式的不同  </p>
<h3 id="IMAGE-NT-HEADERS"><a href="#IMAGE-NT-HEADERS" class="headerlink" title="IMAGE_NT_HEADERS"></a>IMAGE_NT_HEADERS</h3><p><img src="/2018/12/08/reverse/image-126.png" width="500px">  </p>
<p>PE32+使用<code>IMAGE_NT_HEADER64</code>结构体,而PE32使用的是<code>IMAGE_NT_HEADER32</code>结构体  </p>
<p>这两种结构体区别在于第三个成员,前者为<code>ONAL_HEADER64</code>,后者为<code>IMAGE_OPTIONAL_HEADER32</code>  </p>
<p>后面的#ifdef_WIN64预处理,根据系统类型选择<code>IMAGE_NT_HEADERS</code>还是<code>PIMAGE_NT_HEADERS</code>  </p>
<h3 id="IMAGE-FILE-HEADER"><a href="#IMAGE-FILE-HEADER" class="headerlink" title="IMAGE_FILE_HEADER"></a>IMAGE_FILE_HEADER</h3><p>PE32+中的IMAGE_FILE_HEADER结构体的Machine字段值发生了变化  </p>
<p>PE32中该Machine的值固定位014C,适用于x64的PE32+文件的Machine值8664  </p>
<p><img src="/2018/12/08/reverse/image-127.png" width="500px"></p>
<p>多个Machine值,对应不同类型CPU,预留出0200(IA-64),8664(x64),014C(x86)这三个值就行了  </p>
<h3 id="IMAGE-OPTIONAL-HEADER"><a href="#IMAGE-OPTIONAL-HEADER" class="headerlink" title="IMAGE_OPTIONAL_HEADER"></a>IMAGE_OPTIONAL_HEADER</h3><p>与原来的PE32相比,PE32+中变化最大的部分就是IMAGE_OPTIONAL_HEADER结构体  </p>
<p><img src="/2018/12/08/reverse/image-128.png" width="450px"><br><img src="/2018/12/08/reverse/image-129.png" width="450px">    </p>
<blockquote>
<p>Magic  </p>
</blockquote>
<p>PE32中的Magic值为010B,PE32+为020B  </p>
<p>WindowsPE装载器通过检查该字段来区分IMAGE_OPTIONAL_HEADER结构体是32位还是64位  </p>
<blockquote>
<p>BaseOfData  </p>
</blockquote>
<p>PE32文件中该字段用于指示数据节的起始地址(RVA),而PE32+文件中删除了该字段  </p>
<blockquote>
<p>ImageBase  </p>
</blockquote>
<p>ImageBase字段数据类型由原来的双字(DWORD),变为ULONGLONG类型(8个字节)  </p>
<p>适应增大的进程虚拟内存  </p>
<p>借助该字段,PE32+文件能够加载到64位进程的虚拟内存空间(16TB)的任何位置<br>(EXE/DLL文件被加载到低位的8TB用户区域,SYS文件被加载到高位的8TB内核区域)  </p>
<p><img src="/2018/12/08/reverse/image-130.png" width="450px">  </p>
<blockquote>
<p>栈&amp;堆  </p>
</blockquote>
<p>堆和栈相关字段(SizeOfStackReserve, SizeOfStackCommit, SizeOfHeapReserve, SizeOfHeapCommit)的数据类型变为ULONGLONG类型(8个字节),增大进程虚拟内存相适应  </p>
<h3 id="IMAGE-THUNK-DATA"><a href="#IMAGE-THUNK-DATA" class="headerlink" title="IMAGE_THUNK_DATA"></a>IMAGE_THUNK_DATA</h3><p>IMAGE_THUNK_DATA结构体的大小由原来的4个字节变为8个字节   </p>
<p><img src="/2018/12/08/reverse/image-131.png" width="450px"><br><img src="/2018/12/08/reverse/image-132.png" width="450px">  </p>
<p>IMAGE_IMPORT_DESCRIPTOR结构体的OriginalFirstThunk(INT)与FirstThunk(IAT)字段值都指向IMAGE_THUNK_DATA结构体数组的RVA  </p>
<p><img src="/2018/12/08/reverse/image-133.png" width="450px">  </p>
<p>PE32文件跟踪INT,IAT值会见到IMAGE_THUNK_DATA32结构体(大小为4个字节)数组<br>而PE32+会出现IMAGE_THUNK_DATA64结构体(大小为8个字节)数组  </p>
<p><img src="/2018/12/08/reverse/image-134.png" width="450px">  </p>
<p>所以跟踪IAT时注意数组元素大小  </p>
<p>途中画圈部分一个位INT,另一个IAT  </p>
<p>装载PE文件时,OS的PE装载器会向IAT中写入真正的API入口地址(VA)  </p>
<p>64位OS中地址(指针)大小为8个字节(64位),所以IMAGE_THUNK_DATA结构体大小只能增长到8个字节  </p>
<h2 id="WinDbg"><a href="#WinDbg" class="headerlink" title="WinDbg"></a>WinDbg</h2><h2 id="64位调试"><a href="#64位调试" class="headerlink" title="64位调试"></a>64位调试</h2><h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><h2 id="InjDll-exe-DLL注入专用"><a href="#InjDll-exe-DLL注入专用" class="headerlink" title="InjDll.exe DLL注入专用"></a>InjDll.exe DLL注入专用</h2><h1 id="高级逆向分析"><a href="#高级逆向分析" class="headerlink" title="高级逆向分析"></a>高级逆向分析</h1><h2 id="TLS回调函数"><a href="#TLS回调函数" class="headerlink" title="TLS回调函数"></a>TLS回调函数</h2><h2 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h2><h2 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h2><h2 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h2><h2 id="IA-32指令"><a href="#IA-32指令" class="headerlink" title="IA-32指令"></a>IA-32指令</h2><h1 id="反调试技术"><a href="#反调试技术" class="headerlink" title="反调试技术"></a>反调试技术</h1><h2 id="反调试技术-1"><a href="#反调试技术-1" class="headerlink" title="反调试技术"></a>反调试技术</h2><h2 id="静态反调试技术"><a href="#静态反调试技术" class="headerlink" title="静态反调试技术"></a>静态反调试技术</h2><h2 id="动态反调试技术"><a href="#动态反调试技术" class="headerlink" title="动态反调试技术"></a>动态反调试技术</h2><h2 id="高级反调试技术"><a href="#高级反调试技术" class="headerlink" title="高级反调试技术"></a>高级反调试技术</h2>
        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2018/12/08/reverse/';
        this.page.title = '加密与解密-书籍笔记';
        this.page.identifier = '2018/12/08/reverse/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
