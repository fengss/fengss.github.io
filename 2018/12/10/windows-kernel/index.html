<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Windows系统解析 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="Windows内核解析笔记
数据类型常见数据类型123456789101112131415161718192021222324252627282930313233343536WORD：                16位无符号整形数据　　DWORD：             32位无符号整型数据（DWORD32）　　DWORD64：         64位无符号整型数据　　INT：                       32位有符号整型数据类型　　INT_PTR：            ">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Golang</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">System</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">BigData</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/ai">Math/AI</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/book">计划</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mesos/">Mesos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scikit/">Scikit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SofaMesh/">SofaMesh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TroubleShoot/">TroubleShoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows内核/">Windows内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows内核驱动/">Windows内核驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内网穿透/">内网穿透</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#数据类型"><span class="toc-number">1.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#常见数据类型"><span class="toc-number">1.1.</span> <span class="toc-text">常见数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows数据类型命名规律"><span class="toc-number">1.2.</span> <span class="toc-text">Windows数据类型命名规律</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows参数简写"><span class="toc-number">1.3.</span> <span class="toc-text">Windows参数简写</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程"><span class="toc-number">2.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows应用程序"><span class="toc-number">2.1.</span> <span class="toc-text">Windows应用程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-C-嵌入的启动函数"><span class="toc-number">2.2.</span> <span class="toc-text">C/C++嵌入的启动函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#案例代码"><span class="toc-number">2.2.1.</span> <span class="toc-text">案例代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程实例句柄"><span class="toc-number">2.3.</span> <span class="toc-text">进程实例句柄</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#【DumpModule程序】获取进程与DLL库的基地址"><span class="toc-number">2.3.1.</span> <span class="toc-text">【DumpModule程序】获取进程与DLL库的基地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程环境变量"><span class="toc-number">2.4.</span> <span class="toc-text">进程环境变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#【Environ程序】获取环境变量示例"><span class="toc-number">2.4.1.</span> <span class="toc-text">【Environ程序】获取环境变量示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程的关联性（亲缘性）"><span class="toc-number">2.5.</span> <span class="toc-text">进程的关联性（亲缘性）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#【GetLogicCPU程序】——调用GetLogicalProcessorInformation获取CPU信息的例子"><span class="toc-number">2.5.1.</span> <span class="toc-text">【GetLogicCPU程序】——调用GetLogicalProcessorInformation获取CPU信息的例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程的错误模式"><span class="toc-number">2.6.</span> <span class="toc-text">进程的错误模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程当前所在的驱动器和目录"><span class="toc-number">2.7.</span> <span class="toc-text">进程当前所在的驱动器和目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统版本"><span class="toc-number">2.8.</span> <span class="toc-text">系统版本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#【VersionInfo程序】测试主机系统是不是Win8-1版本"><span class="toc-number">2.8.1.</span> <span class="toc-text">【VersionInfo程序】测试主机系统是不是Win8.1版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ProcessInfo示例"><span class="toc-number">2.9.</span> <span class="toc-text">ProcessInfo示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ProcessInfo-cpp"><span class="toc-number">2.9.1.</span> <span class="toc-text">ProcessInfo.cpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ToolHelp-h"><span class="toc-number">2.9.2.</span> <span class="toc-text">ToolHelp.h</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程池"><span class="toc-number">2.10.</span> <span class="toc-text">进程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作业对象"><span class="toc-number">2.10.1.</span> <span class="toc-text">作业对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建作业"><span class="toc-number">2.10.2.</span> <span class="toc-text">创建作业</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置作业对象的属性"><span class="toc-number">2.10.3.</span> <span class="toc-text">设置作业对象的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将进程放入作业中"><span class="toc-number">2.10.4.</span> <span class="toc-text">将进程放入作业中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作业对象事件和完成端口"><span class="toc-number">2.10.5.</span> <span class="toc-text">作业对象事件和完成端口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程"><span class="toc-number">3.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程基础"><span class="toc-number">3.1.</span> <span class="toc-text">线程基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主线程"><span class="toc-number">3.2.</span> <span class="toc-text">主线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程函数-线程入口函数"><span class="toc-number">3.3.</span> <span class="toc-text">线程函数(线程入口函数)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CreateThread函数"><span class="toc-number">3.4.</span> <span class="toc-text">CreateThread函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#终止运行线程"><span class="toc-number">3.5.</span> <span class="toc-text">终止运行线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程内幕"><span class="toc-number">3.6.</span> <span class="toc-text">线程内幕</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-C-运行库注意事项"><span class="toc-number">3.6.1.</span> <span class="toc-text">C/C++运行库注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#beginThreadex的内部实现"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">_beginThreadex的内部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#endthreadex的内部实现"><span class="toc-number">3.6.1.2.</span> <span class="toc-text">_endthreadex的内部实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#了解自己"><span class="toc-number">3.6.2.</span> <span class="toc-text">了解自己</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程调度"><span class="toc-number">3.7.</span> <span class="toc-text">线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的挂起和恢复"><span class="toc-number">3.7.1.</span> <span class="toc-text">线程的挂起和恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的挂起和恢复"><span class="toc-number">3.7.2.</span> <span class="toc-text">进程的挂起和恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#睡眠"><span class="toc-number">3.7.3.</span> <span class="toc-text">睡眠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切换到另一个线程"><span class="toc-number">3.7.4.</span> <span class="toc-text">切换到另一个线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONTEXT结构"><span class="toc-number">3.7.5.</span> <span class="toc-text">CONTEXT结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的优先级"><span class="toc-number">3.8.</span> <span class="toc-text">线程的优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从抽象角度看优先级"><span class="toc-number">3.8.1.</span> <span class="toc-text">从抽象角度看优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优先级编程"><span class="toc-number">3.8.2.</span> <span class="toc-text">优先级编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#亲缘性"><span class="toc-number">3.8.3.</span> <span class="toc-text">亲缘性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程同步"><span class="toc-number">3.9.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原子访问：Interlocked系列函数"><span class="toc-number">3.9.1.</span> <span class="toc-text">原子访问：Interlocked系列函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高速缓存行"><span class="toc-number">3.9.2.</span> <span class="toc-text">高速缓存行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#多处理器下的读写问题"><span class="toc-number">3.9.2.1.</span> <span class="toc-text">多处理器下的读写问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高级线程同步"><span class="toc-number">3.9.3.</span> <span class="toc-text">高级线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关键段-临界区"><span class="toc-number">3.9.4.</span> <span class="toc-text">关键段(临界区)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关键段和旋转锁"><span class="toc-number">3.9.4.1.</span> <span class="toc-text">关键段和旋转锁</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO"><span class="toc-number">4.</span> <span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">4.1.</span> <span class="toc-text">简介</span></a></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            Windows系统解析
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2018/12/10/windows-kernel/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-10T03:06:21.000Z" itemprop="datePublished">2018-12-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Windows内核/">Windows内核</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>Windows内核解析笔记<br><a id="more"></a></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">WORD：                16位无符号整形数据</span><br><span class="line">　　DWORD：             32位无符号整型数据（DWORD32）</span><br><span class="line">　　DWORD64：         64位无符号整型数据</span><br><span class="line">　　INT：                       32位有符号整型数据类型</span><br><span class="line">　　INT_PTR：             指向INT数据类型的指针类型</span><br><span class="line">　　INT32：                  32位符号整型</span><br><span class="line">　　INT64：                  64位符号整型</span><br><span class="line">　　UINT：                    无符号INT</span><br><span class="line">　　LONG：                 32位符号整型（LONG32）</span><br><span class="line">　　ULONG：              无符号LONG</span><br><span class="line">　　LONGLONG：      64位符号整型（LONG64）</span><br><span class="line">　　SHORT：              无符号短整型（16位）</span><br><span class="line">　　LPARAM：           消息的L参数</span><br><span class="line">　　WPARAM：         消息的W参数</span><br><span class="line">　　HANDLE：           对象的句柄，最基本的句柄类型</span><br><span class="line">　　HICON：               图标的句柄</span><br><span class="line">　　HINSTANCE：    程序实例的句柄</span><br><span class="line">　　HKEY：                注册表键的句柄</span><br><span class="line">　　HMODULE：       模块的句柄</span><br><span class="line">　　HWND：              窗口的句柄</span><br><span class="line">　　LPSTR：              字符指针，也就是字符串变量</span><br><span class="line">　　LPCSTR：           字符串常量</span><br><span class="line">　　LPCTSTR：         根据环境配置，如果定义了UNICODE宏，则是LPCWSTR类型，否则则为LPCSTR类型</span><br><span class="line">　　LPCWSTR：       UNICODE字符串常量</span><br><span class="line">　　LPDWORD：      指向DWORD类型数据的指针</span><br><span class="line">　　CHAR：               8比特字节</span><br><span class="line">　　TCHAR：             如果定义了UNICODE，则为WCHAR，否则为CHAR</span><br><span class="line">　　UCHAR：            无符号CHAR</span><br><span class="line">　　WCHAR：           16位Unicode字符</span><br><span class="line">　　BOOL：                布尔型变量</span><br><span class="line">　　BYTE：                 字节类型（8位）</span><br><span class="line">　　CONST：             常量</span><br><span class="line">　　FLOAT：              浮点数据类型</span><br><span class="line">　　SIZE_T：              表示内存大小，以字节为单位，其最大值是CPU最大寻址范围</span><br><span class="line">　　VOID：                 无类型，相当于标准C语言中的void</span><br><span class="line">　　WINAPI：             Windows API的函数调用方式，常见于SDK头文件中对API函数的声明中，相当于_stdcall（更严格地说，这不是数据类型，而是一种函数调用约定</span><br></pre></td></tr></table></figure>
<h2 id="Windows数据类型命名规律"><a href="#Windows数据类型命名规律" class="headerlink" title="Windows数据类型命名规律"></a>Windows数据类型命名规律</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型包括：BYTE、CHAR、WORD、SHORT、INT等。</span><br><span class="line">指针类型的命令方式一般是在其指向的数据类型前加“LP”或“P”，比如指向DWORD的指针类型为“LPDWORD”和“PDWORD”</span><br><span class="line">各种句柄类型的命名方式一般都是在对象名前加“H”，比如位图（BITMAP）对应的句柄类型为“HBITMAP”。</span><br><span class="line">无符号类型一般是以“U”开头，比如“INT”是符号类型，“UINT”是无符号类型</span><br><span class="line">根据这些命名规律以及自己的经验看到一些没见过的数据类型也就能知道它的代表的意思</span><br></pre></td></tr></table></figure>
<h2 id="Windows参数简写"><a href="#Windows参数简写" class="headerlink" title="Windows参数简写"></a>Windows参数简写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1、  b 布尔</span><br><span class="line">2、 by BYTE</span><br><span class="line">3、 c chr 或WCHAR TCHAR</span><br><span class="line">4、 n short</span><br><span class="line">5、 i int</span><br><span class="line">6、 x、y 分别表示x 坐标，y 坐标</span><br><span class="line">7、 cx、cy 分别表示x 方向长度和y 方向长度</span><br><span class="line">8、 b 或f BOOL(int),f 代表“flag”</span><br><span class="line">9、 w WORD(无符号short)</span><br><span class="line">10、l LONG 长整数</span><br><span class="line">11、dw DWORD 无符号长整数</span><br><span class="line">12、fn function 函数</span><br><span class="line">13、s string 字符串</span><br><span class="line">14、sz 以0 字节结尾的字符串</span><br><span class="line">15、h 句柄</span><br><span class="line">16、p 指针</span><br><span class="line">17、lpfn 指向函数的长指针</span><br><span class="line">18、cb 字节数</span><br><span class="line">19、lpsz 指向以0 结尾的字符串的长指针</span><br><span class="line">20、g_ 全局变量</span><br><span class="line">21、c_ 常量</span><br><span class="line">22、m_ 类数据成员</span><br><span class="line">23、s_ 静态变量</span><br><span class="line">24、CS_ 类风格选项</span><br><span class="line">25、CW_ 创建窗口选项</span><br><span class="line">26、DT_ 绘制文本选项</span><br><span class="line">27、IDI_ 图标ID 号 </span><br><span class="line">28、IDC_ 光标ID 号</span><br><span class="line">29、MB_ 消息框选项</span><br><span class="line">30、SND_ 声音选项</span><br><span class="line">31、WM_ 窗口消息</span><br><span class="line">32、WS_ 窗口风格</span><br><span class="line">33、rc 矩形</span><br></pre></td></tr></table></figure>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程定义为一个正在运行的程序实例,由两部分组成  </p>
<ul>
<li><p>一个是操作系统用来管理进程的内核对象,内核对象也是系统用来存放关于进程的统计信息的地方  </p>
</li>
<li><p>另一个是地址空间,它包含所有可执行模块或DLL模块的代码和数据,包含动态内存分配空间,如线程堆栈和堆分配空间  </p>
</li>
</ul>
<p>进程要完成某项操作,必须拥有一个在它的环境中运行的线程,该线程负责执行包含在进程的地址空间中的代码  </p>
<p>单个进程包含若干个线程,所有这些线程都执行进程地址空间中的代码  </p>
<p>为此每个线程都有它自己的一组CPU寄存器和它自己的堆栈  </p>
<p><img src="/2018/12/10/windows-kernel/image-01.png" width="350px"></p>
<p>当创建一个进程时,线程会自动创建它的第一个线程,称为主线程  </p>
<p>然后该线程可以创建其他线程,而这些线程又能创建更多的线程  </p>
<h2 id="Windows应用程序"><a href="#Windows应用程序" class="headerlink" title="Windows应用程序"></a>Windows应用程序</h2><p>Windows两种:GUI图形用户界面的应用程序,CUI控制台用户界面的应用程序  </p>
<p>CUI的链接程序开关为:<code>SUBSYSTEM:CONDOLE</code><br>GUI的链接程序开发为:<code>SUBSYSTEM:WINDOWS</code>  </p>
<blockquote>
<p>进入点函数  </p>
</blockquote>
<p>应用程序启动运行时调用的进入点函数   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HINSTANCE hinstExe, </span></span></span><br><span class="line"><span class="function"><span class="params">	HINSTANCE,</span></span></span><br><span class="line"><span class="function"><span class="params">	PSTR pszCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> nCmdShow)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">wWinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HINSTANCE hinstExe,</span></span></span><br><span class="line"><span class="function"><span class="params">	HINSTANCE,</span></span></span><br><span class="line"><span class="function"><span class="params">	PWSTR pszCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> nCmdShow)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">char</span> *argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">char</span> *envp[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">wmain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">wchar_t</span> *argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">wchar_t</span> *envp[])</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/10/windows-kernel/image-02.png" width="450px"> </p>
<p>根据链接程序开关,选择不同的函数  </p>
<p>以及C/C++运行期全局变量 </p>
<p><img src="/2018/12/10/windows-kernel/image-03.png" width="450px">  </p>
<p>最新的应用程序类型和相应的入口点函数  </p>
<table>
<thead>
<tr>
<th>应用程序类型</th>
<th>C\C++入口点函数</th>
<th>嵌入可执行文件的启动函数</th>
<th>链接器开关</th>
</tr>
</thead>
<tbody>
<tr>
<td>处理ANSI字符(串)的<strong>GUI程序</strong></td>
<td>_tWinMain(WinMain)</td>
<td>WinMainCRTStartup</td>
<td>/SUBSYSTEM:WINDOWS</td>
</tr>
<tr>
<td>处理Unicode字符(串)的GUI程序</td>
<td>_tWinMain(wWinMain)</td>
<td>wWinMainCRTStartup</td>
<td>…</td>
</tr>
<tr>
<td>处理ANSI字符(串)的<strong>CUI程序</strong></td>
<td>_tmain(Main)</td>
<td>mainCRTStartup</td>
<td>/SUBSYSTEM:CONSOLE</td>
</tr>
<tr>
<td>处理Unicode字符(串)的CUI程序</td>
<td>_tmain(Wmain)</td>
<td>wmainCRTStartup</td>
<td>…</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="C-C-嵌入的启动函数"><a href="#C-C-嵌入的启动函数" class="headerlink" title="C/C++嵌入的启动函数"></a>C/C++嵌入的启动函数</h2><p>C/C++应用程序中，进程启动过程<code>wWinMainCRTStartup()→_tmainCRTStartup()→wWinMain()</code>。</p>
<p>由此可见操作系统并不调用我们写的入口点函数(如_tWinMain),而是调用C/C++运行期的启动函数（如wWinMainCRTStartup）。</p>
<p>wWinMainCRTStartup的作用：——启动函数要进行一些额外的操作：</p>
<ul>
<li><p>A、检索指向新进程的完整命令行的指针。</p>
</li>
<li><p>B、检索指向新进程的环境变量的指针。</p>
</li>
<li><p>C、对C/C + +运行期的全局变量进行初始化。如果包含了Stdlib.h 文件，代码就能访问这些变量。（如<strong>environ、</strong>argv等，见课本第69页，表4-2）</p>
</li>
<li><p>D、对C 运行期内存单元分配函数（malloc 和calloc）和其他低层输入/输出程序使用的堆进行初始化。这样就可以调用malloc和free之类的C库函数。</p>
</li>
<li><p>E、为所有全局和静态C++类对象调用构造函数。以确保已经声明的任何C++全局对象和静态对象能够在代码执行以前正确地创建。</p>
</li>
<li><p>F、如果是GUI程序，这里还将调用GetStartupinfo(&amp;StartupInfo)函数，以获取一个进程的启动信息。</p>
</li>
</ul>
<pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> GetStartupInfo(&amp;StartupInfo);</span><br><span class="line"></span><br><span class="line">Int nMainRetVal= WinMain((HINSTANCE)&amp;__ImageBase,<span class="literal">NULL</span>,pszCommandLine,</span><br><span class="line">	(StartupInfo.dwFlags &amp;STARTF_USESHOWWINDOW)?StartupInfo.wShowWindow:SW_SHWODEFAULT);</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li>G、调用我们写的入口函数（如WinMain）等函数，该入口函数返回后，嵌入的启动函数会调用C运行库exit函数，该函数将调用由_onexit添加的回调函数（调用顺序与添加顺序相反），然后清除全局对象和静态变量，最后调用系统ExitProcess函数，退出进程。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果链接器选项的“入口点”不设置的话（默认情况）</span><br><span class="line">C/C++程序入口点是被嵌入到可执行文件的WinMainCRTStartup启动函数（注意，不是WinMain）。</span><br><span class="line">如果设定入口点为我们指定的函数，这时不再嵌入那些启动函数。</span><br><span class="line">因此，所有的初始化和退出时清理全局变量的操作也得由我们自己来完成。</span><br><span class="line">（这对于纯API应用程序来说，有很好用的）</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义启动函数  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GRS_USEPRINTF();</span><br><span class="line">	GRS_PRINTF(_T(<span class="string">"-&gt;fn1\n"</span>));</span><br><span class="line">	_tsystem(_T(<span class="string">"PAUSE"</span>));</span><br><span class="line">	FreeConsole();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GRS_USEPRINTF();</span><br><span class="line">	GRS_PRINTF(_T(<span class="string">"-&gt;fn2"</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GRS_USEPRINTF();</span><br><span class="line">	GRS_PRINTF(_T(<span class="string">"-&gt;fn3"</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GRS_USEPRINTF();</span><br><span class="line">	GRS_PRINTF(_T(<span class="string">"fn4"</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR pszCmdLine, <span class="keyword">int</span> nShowCmd) &#123;</span><br><span class="line">	AllocConsole(); <span class="comment">//为进程分配一个新的控制台（注意一个进程只可以拥用一个控制台的关联）</span></span><br><span class="line">	GRS_USEPRINTF();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为WinMainCRTStartup函数会调用WinMain函数，但WinMain执行完毕后，</span></span><br><span class="line">	<span class="comment">//WinMainCRTStartup会继续调用由_onexit注册的回调函数且调用顺序与</span></span><br><span class="line">	<span class="comment">//注册函数的顺序相反，所以当WinMain退出后，fn4、fn3、fn2、fn1会依次被调用。</span></span><br><span class="line">	<span class="comment">//但注意，这4个函数只有在退出WinMain后才被调用。</span></span><br><span class="line">	_onexit(fn1);</span><br><span class="line">	_onexit(fn2);</span><br><span class="line">	_onexit(fn3);</span><br><span class="line">	_onexit(fn4);</span><br><span class="line"></span><br><span class="line">	GRS_PRINTF(_T(<span class="string">"HelloWorld!\n"</span>))</span><br><span class="line">	GRS_PRINTF(_T(<span class="string">"注意哦，我是第1个被输出的语句！\n"</span>));</span><br><span class="line">	GRS_PRINTF(_T(<span class="string">"回调函数的注册顺序：fn1-&gt;fn2-&gt;fn3-&gt;fn4\n"</span>));</span><br><span class="line">	GRS_PRINTF(_T(<span class="string">"回调函数的执行顺序："</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="进程实例句柄"><a href="#进程实例句柄" class="headerlink" title="进程实例句柄"></a>进程实例句柄</h2><p>加载到进程地址空间的每个可执行文件或Dll文件均被赋予一个独一无二的实例句柄   </p>
<p>对于加载资源的函数都需要该句柄的值  </p>
<p>例如可执行文件的映像来加载图标资源  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HICON <span class="title">LoadIcon</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HINSTANCE hinst,</span></span></span><br><span class="line"><span class="function"><span class="params">	PCTSTR pszIcon)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数指明哪个文件(可执行文件或DLL文件)包含你想加载的资源  </p>
<p>许多应用程序在全局变量中保存(w)WinMain的hinstExec参数,这样就很容易被所有可执行文件的代码访问  </p>
<hr>

<ul>
<li>GetModuleHandle函数——获取可执行文件或DLL文件被加载到进程地址空间的位置</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>LPCTSTR lpModuleName</td>
<td>为NULL，获得主调进程的可执行文件的基地址，注意在DLL内部用这参数获得到是仍是宿主进程的基地址，而不是DLL模块的基地址！不为NULL，如GetModuleHandle(TEXT(“kernel32.dll”))，将获取Kernel32模块的基地址。（注意，这是在DLL外部调用的，与上面不同！）</td>
</tr>
<tr>
<td>返回值</td>
<td>成功——返回模块的基地址失败——返回NULL，可以GetLastError获取错误代码信息。</td>
</tr>
<tr>
<td>两大特征</td>
<td>①<strong>只检查主调进程的地址空间</strong>，如果主调进程没有使用任何通话对话框函数，则GetModuleHandle(TEXT(“ComDlg32.dll”))将返回NULL，即使其他进程己经将该库加载到内存里。②如果传递NULL参数，将返回可执行文件的基地址，即使在一个DLL文件内部调用，<strong>返回值仍然是可执行文件的基地址，而非DLL文件的基地址！</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>GetModuleHandleEx函数</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DWORD  dwFlags</td>
<td>①为0，则当调用该函数时，模块的引用计数自动增加，调用者在使用完模块句柄后，必须调用一次FreeLibrary。②如果是GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,则同GetModuleHandle相同，不增加引用计数③如果是GET_MODULE_HANDLE_EX_FLAG_PIN,则模块一直映射在调用该函数的进程中，直到该进程结束，不管调用多少次FreeLibrary④如果是GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,则lpModuleName是模块中的一个地址。</td>
</tr>
<tr>
<td>LPCTSTR lpModuleName</td>
<td>与GetModuleHandle参数一样</td>
</tr>
<tr>
<td>HMODULE *phModule</td>
<td>存储要找的句柄</td>
</tr>
<tr>
<td>返回值</td>
<td>成功——返回非0失败——返回0，可以GetLastError获取错误代码信息。</td>
</tr>
<tr>
<td>备注</td>
<td>_ImageBase、GetModuleHandleEx与GetModuleHandle不同，<strong>会根据代码放置的模块，来决定是获得可执行文件或DLL库的基地址</strong></td>
</tr>
</tbody>
</table>
<p>注意：进程的实例句柄，可以在“链接器”→“高级”→“基址”中指定（如0x00400000），同时 “随机基址”设为“否”</p>
<p><br></p>
<h3 id="【DumpModule程序】获取进程与DLL库的基地址"><a href="#【DumpModule程序】获取进程与DLL库的基地址" class="headerlink" title="【DumpModule程序】获取进程与DLL库的基地址"></a>【DumpModule程序】获取进程与DLL库的基地址</h3><blockquote>
<p>DLL端</p>
</blockquote>
<p>先准备好DLL文件做运行时动态链接,或者成lib+头文件在加载时动态链接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建头文件DumpModule.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> API_EXPORT </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPORT   extern <span class="meta-string">"C"</span> __declspec(dllexport)          <span class="comment">//当头文件供动态库本身使用时</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPORT    extern <span class="meta-string">"C"</span> __declspec(dllimport)         <span class="comment">//当头文件供调用库的程序使用时</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> API_EXPORT </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPORT   __declspec(dllexport)                      <span class="comment">//当头文件供动态库本身使用时</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPORT   __declspec(dllimport)                      <span class="comment">//当头文件供调用库的程序使用时</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllexport) <span class="function"><span class="keyword">void</span>  <span class="title">DumpModule</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> API_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DumpModule.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span>  <span class="keyword">const</span> IMAGE_DOS_HEADER __ImageBase;</span><br><span class="line"></span><br><span class="line">HINSTANCE hDll;</span><br><span class="line"><span class="comment">//入口和退出点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hInstance, DWORD fdwReason, PVOID pvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hDll = hInstance;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在DLL中用两种不同的方法来获取可执行程序及DLL库基地址</span></span><br><span class="line"><span class="comment">//注意两点：</span></span><br><span class="line"><span class="comment">//1、无论GetModuleHandle放在DLL中，还是可执行文件中，获取的都是可执行文件的基地址</span></span><br><span class="line"><span class="comment">//2、__ImageBase、GetMoudleHandleEx，会根据代码放置位置，也决定是获得可执行文件</span></span><br><span class="line"><span class="comment">//或DLL库的基地址。</span></span><br><span class="line"><span class="function">EXPORT <span class="keyword">void</span> <span class="title">DumpModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//先获取可执行文件的基地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"可执行文件的基地址："</span>);</span><br><span class="line">	<span class="comment">//利用GetModuleHandle来获取</span></span><br><span class="line">	HMODULE hModule = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"GetModuleHandle(NULL) = 0x%X\r\n\r\n"</span>, hModule);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"利用3种方法获取文件或（DLL库）的基地址，\r\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"因以下代码在DLL中调用，所以获取的是DLL的基地址：\r\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先获取DLL或被加载的基地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"方法1：通过DllMain参数获取的基地址 = 0x%X\r\n"</span>, hDll);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方法2：利用链接器的伪变量__ImageBase来获取</span></span><br><span class="line">	<span class="comment">//printf("方法2：伪变量__ImageBase = 0x%X\r\n", (HINSTANCE)&amp;__ImageBase);</span></span><br><span class="line">	<span class="comment">//方法3：利用GetModuleEx函数来获取</span></span><br><span class="line">	hModule = <span class="literal">NULL</span>;</span><br><span class="line">	GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,</span><br><span class="line">		(PCTSTR)DumpModule, &amp;hModule);  <span class="comment">//将DumpModule自身的地址传进去</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"方法3：GetModuleHandleEx =0x%X\r\n"</span>, hModule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用端  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"..\DumpDll\\DumpModule.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"DumpDll.dll"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain() &#123;</span><br><span class="line">	<span class="comment">//在加载时动态链接中，应用程序像调用本地函数一样对导出的DLL函数进行显示调用。</span></span><br><span class="line">	<span class="comment">//要使用加载时动态链接，需要在编译和链接应用程序时提供头文件和导入库文件(.lib)。</span></span><br><span class="line">	<span class="comment">//当这样做的时候，链接器将向系统提供加载DLL所需的信息，并在加载时解析导出的DLL函数的位置；</span></span><br><span class="line">	DumpModule();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//在运行时动态链接中，应用程序调用LoadLibrary函数或LoadLibraryEx函数以在运行时加载DLL。</span></span><br><span class="line">	<span class="comment">//成功加载DLL后，可以使用GetProcAddress函数获得要调用的导出的DLL函数的地址。</span></span><br><span class="line">	<span class="comment">//在使用运行时动态链接时，不需要使用导入库文件。</span></span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Dump)</span><span class="params">()</span></span>;</span><br><span class="line">	HMODULE hDll = LoadLibrary(TEXT(<span class="string">"DumpDll.dll"</span>));</span><br><span class="line">	<span class="keyword">if</span> (hDll != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Dump dump = (Dump)GetProcAddress(hDll, <span class="string">"DumpModule"</span>);</span><br><span class="line">		<span class="keyword">if</span> (dump != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dump();</span><br><span class="line">		&#125;</span><br><span class="line">		FreeLibrary(hDll);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/10/windows-kernel/image-06.png" width="600px"></p>
<p><br></p>
<h2 id="进程环境变量"><a href="#进程环境变量" class="headerlink" title="进程环境变量"></a>进程环境变量</h2><ul>
<li>（1）环境变量的格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**=::=::\...             //****不能作为环境变量使用，与进程当前目录有关**</span><br><span class="line"></span><br><span class="line">varName1=VarValue1\0   //注意**等号前、后的空格**也算是变量名或值的一部分。</span><br><span class="line"></span><br><span class="line">varName2=varValue2\0</span><br><span class="line"></span><br><span class="line">varName3=varValue3\0</span><br><span class="line"></span><br><span class="line">varNameX=varValueX\0</span><br><span class="line"></span><br><span class="line">**\0                    //****字符串的最后以\0结束，含前面的字符，最后共有2个\0**</span><br></pre></td></tr></table></figure>
<ul>
<li><p>（2）<strong>GetEnvironmentStrings</strong>（获取<strong>完整</strong>的环境块）和<strong>FreeEnvironmentStrings</strong>释放函数</p>
</li>
<li><p>（3）CUI程序中入口参数TCHAR* env[]指向环境块的字符串指针数组，但以等号开头的无无效字符串己被移除且数组最后一个元素为NULL。</p>
</li>
<li><p>（4）获取或设置环境变量的值</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>注册表项</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetEnvironmentVariable</td>
<td>获取环境变量的值或判断环境变量是否存在</td>
</tr>
<tr>
<td>SetEnvironmentVariable</td>
<td>添加、修改环境删除环境变量：当第2个参数pszValue=NULL时，表示删除</td>
</tr>
</tbody>
</table>
<ul>
<li>（5）扩展环境变量字符串，并使用当前用户定义的值来替换这些环境变量字符串</li>
</ul>
<table>
<thead>
<tr>
<th>ExpandEnvironmentStrings函数</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>参数</td>
<td>描述</td>
</tr>
<tr>
<td>PCTSTR pszSrc</td>
<td>指向包含“可替换环境变量字符串”的指针</td>
</tr>
<tr>
<td>PTSTR pszDst</td>
<td>用于接收扩展字符串的一个缓冲区地址</td>
</tr>
<tr>
<td>DWORD chSize</td>
<td>上述缓冲区的可容纳的最大字符数</td>
</tr>
<tr>
<td>返回值</td>
<td>保存到缓冲区实际的字符数。如果chSize小于此值,%%变量不会扩展，通常用两次调用ExpandEnvironmentStrings（第1次将pszDst设为NULL，chSize设为0，返回实际的字符数，第2次根据返回值分配缓冲区大小，chSize填入第1次的返回值）</td>
</tr>
</tbody>
</table>
<ul>
<li>（6）注册表中的环境变量列表</li>
</ul>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>注册表项</th>
</tr>
</thead>
<tbody>
<tr>
<td>系统环境变量</td>
<td>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment</td>
</tr>
<tr>
<td>当前用户环境变量</td>
<td>HKEY_CURRENT_USER\Environment</td>
</tr>
</tbody>
</table>
<ul>
<li>（7）与环境变量块有关的消息：——当更新注册表中的环境变量  </li>
</ul>
<p>希望通知应用程序时，可发送：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SendMessage(HWND_BROADCAST,WM_SETTINTCHANGE,<span class="number">0</span>,(LPARAM)TEXT(<span class="string">"Enviroment"</span>));</span><br></pre></td></tr></table></figure></p>
<ul>
<li>（8）通常<strong>子进程会继承父进程的环境块</strong>，但父进程可以控制哪些环境变量允许被继承。但子进程不会继承父进程的当前目录，同时子进程的环境块是父进程的副本，换言之在子进程中添加、删除或修改变量并不影响父进程的环境块。</li>
</ul>
<p><br></p>
<h3 id="【Environ程序】获取环境变量示例"><a href="#【Environ程序】获取环境变量示例" class="headerlink" title="【Environ程序】获取环境变量示例"></a>【Environ程序】获取环境变量示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessEnv.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用控制台程序下的环境变量参数来显示环境变量。</span></span><br><span class="line"><span class="comment">//注意：pEnvBlock是个数组，元素类型是指向TCHAR字符串的指针。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DumpEnvVariables</span><span class="params">(PTSTR pEnvBlock[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">	PTSTR* pElement = (PTSTR*)pEnvBlock;</span><br><span class="line">	PTSTR pCurrent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pElement != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pCurrent = (PTSTR)(*pElement);</span><br><span class="line">		<span class="keyword">if</span> (pCurrent == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			pElement = <span class="literal">NULL</span>; <span class="comment">//没有更多的环境变量了</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_tprintf(TEXT(<span class="string">"[%u] %s\r\n"</span>), current, pCurrent);</span><br><span class="line">			current++;</span><br><span class="line">			pElement++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用GetEnvironmentStrings函数来获得环境变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DumpEnvStrings</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PTSTR pEnvBlock = GetEnvironmentStrings();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解析环境变量块的格式</span></span><br><span class="line">	<span class="comment">// =::=::\</span></span><br><span class="line">    <span class="comment">// =...</span></span><br><span class="line">	<span class="comment">// varName=varValue\0</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// varNameX=varValue\0\0  //注意最后一个变量后面有两个的\0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意：某些字符串是以'='开始的，下列是从网络共享中启动应用程序的例子</span></span><br><span class="line">	<span class="comment">//[0] =::=::\</span></span><br><span class="line">    <span class="comment">//[1] =C:=C:\Windows\System32</span></span><br><span class="line">	<span class="comment">//[2] =ExitCode=00000000</span></span><br><span class="line"></span><br><span class="line">	TCHAR szName[MAX_PATH];</span><br><span class="line">	TCHAR szValue[MAX_PATH];</span><br><span class="line">	PTSTR pszCurrent = pEnvBlock;</span><br><span class="line">	PCTSTR  pszPos = <span class="literal">NULL</span>;</span><br><span class="line">	HRESULT hr = S_OK;</span><br><span class="line">	<span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pszCurrent != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 跳过如下格式的无意义字符串</span></span><br><span class="line">		<span class="comment">// "=::=::\"</span></span><br><span class="line">		<span class="keyword">if</span> (*pszCurrent != TEXT(<span class="string">'='</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//查找'='分隔符，即用来分隔变量名和值的等号</span></span><br><span class="line">			pszPos = _tcschr(pszCurrent, TEXT(<span class="string">'='</span>)); <span class="comment">//pszPos指向等号</span></span><br><span class="line">			pszPos++; <span class="comment">//指向“值”的第1个字符</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//拷贝变量名</span></span><br><span class="line">			<span class="keyword">size_t</span> cbNameLength =      <span class="comment">//长度不包含等号</span></span><br><span class="line">				(<span class="keyword">size_t</span>)pszPos - (<span class="keyword">size_t</span>)pszCurrent - <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">			hr = StringCbCopyN(szName, MAX_PATH, pszCurrent, cbNameLength); <span class="comment">//注意：字节函数</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (FAILED(hr))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//拷贝变量的值（最后一个字符带NULL），同时允许截断字符串            </span></span><br><span class="line">			hr = StringCchCopyN(szValue, MAX_PATH, pszPos, _tcslen(pszPos) + <span class="number">1</span>); <span class="comment">//字符函数</span></span><br><span class="line">			<span class="keyword">if</span> (SUCCEEDED(hr))</span><br><span class="line">			&#123;</span><br><span class="line">				_tprintf(TEXT(<span class="string">"[%u] %s=%s\r\n"</span>), current, szName, szValue);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//发生某种错误，可能被截断</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (hr == STRSAFE_E_INSUFFICIENT_BUFFER) <span class="comment">//指定的缓冲区太小时</span></span><br><span class="line">			&#123;</span><br><span class="line">				_tprintf(TEXT(<span class="string">"[%u] %s=%s...\r\n"</span>), current, szName, szValue);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;   <span class="comment">//这项可能永远不会发生</span></span><br><span class="line">				_tprintf(TEXT(<span class="string">"[%u] %s=???\r\n"</span>), current, szName);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_tprintf(TEXT(<span class="string">"[%u] %s\r\n"</span>), current, pszCurrent);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//下一个变量</span></span><br><span class="line">		current++;</span><br><span class="line">		<span class="comment">//将pszCurrent移到下一个变量的位置</span></span><br><span class="line">		<span class="keyword">while</span> (*pszCurrent != TEXT(<span class="string">'\0'</span>))</span><br><span class="line">			pszCurrent++;</span><br><span class="line">		pszCurrent++;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断是否是最后一个字符</span></span><br><span class="line">		<span class="keyword">if</span> (*pszCurrent == TEXT(<span class="string">'\0'</span>))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FreeEnvironmentStrings(pEnvBlock);<span class="comment">//不要忘了释放环境变量内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得环境变量示例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintEnvironmentVariable</span><span class="params">(PCTSTR pszVariableName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PTSTR pszValue = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取“值”所需的内存大小</span></span><br><span class="line">	DWORD dwResult = GetEnvironmentVariable(pszVariableName, pszValue, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dwResult != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//分配用于存储“值”的内存</span></span><br><span class="line">		DWORD size = dwResult * <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">		pszValue = (PTSTR)<span class="built_in">malloc</span>(size);</span><br><span class="line">		GetEnvironmentVariable(pszVariableName, pszValue, size);</span><br><span class="line">		_tprintf(TEXT(<span class="string">"%s=%s\n"</span>), pszVariableName, pszValue);</span><br><span class="line">		<span class="built_in">free</span>(pszValue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		_tprintf(TEXT(<span class="string">"'%s'=&lt;unknown value&gt;\n"</span>), pszVariableName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ExpandEnvironmentStrings示例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExpandDemo</span><span class="params">(LPCTSTR pszExpandString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//第1次调用获取所示缓冲区大小（字符数）</span></span><br><span class="line">	DWORD chValue = ExpandEnvironmentStrings(pszExpandString, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	PTSTR pszBuffer = <span class="keyword">new</span> TCHAR[chValue];</span><br><span class="line">	<span class="comment">//第2次调用，将指定的“可替换字符串”替换为相应的值</span></span><br><span class="line">	chValue = ExpandEnvironmentStrings(pszExpandString, pszBuffer, chValue);</span><br><span class="line">	_tprintf(TEXT(<span class="string">"%s\r\n"</span>), pszBuffer);</span><br><span class="line">	<span class="keyword">delete</span>[] pszBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用带参env[]参数的main函数</span></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, TCHAR* argv[], TCHAR* env[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//DumpEnvVariables(env); //利用env[]显示环境变量</span></span><br><span class="line">	<span class="comment">//DumpEnvStrings(); //利用GetEnvironmentStrings</span></span><br><span class="line">	ExpandDemo(TEXT(<span class="string">"PATH='%PATH%'"</span>));</span><br><span class="line">	_tprintf(TEXT(<span class="string">"\r\n"</span>));</span><br><span class="line">	PrintEnvironmentVariable(TEXT(<span class="string">"ProgramFiles"</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/10/windows-kernel/image-04.png" width="600px"></p>
<p><br></p>
<h2 id="进程的关联性（亲缘性）"><a href="#进程的关联性（亲缘性）" class="headerlink" title="进程的关联性（亲缘性）"></a>进程的关联性（亲缘性）</h2><ul>
<li><p>（1）可以通过调用SetProcessAffinityMask将进程中线程的调度运行限定在多核系统的某几个特定的CPU上（CPU子集）</p>
</li>
<li><p>（2）此函数的第二个参数dwProcessAffinityMask是一个位向量，每一个二进制位对应表示相应序号的CPU，当该位为1时表示使用这个序号的CPU，否则就是不使用这个CPU。</p>
</li>
<li><p>（3）CPU序号从0～31，对应无符号32位值的相应位。</p>
</li>
<li><p>（4）通过调用GetSystemInfo方法可以得到系统中CPU的个数（多核CPU被认为是独立的CPU）。在Vista以上系统中通过调用GetLogicalProcessorInformation方法可以得到关于CPU的详细信息，包括NUMA、SMT、Catch等信息</p>
</li>
<li><p>（5）子进程继承了父进程的关联性（第7章会讨论）</p>
</li>
</ul>
<p><br></p>
<h3 id="【GetLogicCPU程序】——调用GetLogicalProcessorInformation获取CPU信息的例子"><a href="#【GetLogicCPU程序】——调用GetLogicalProcessorInformation获取CPU信息的例子" class="headerlink" title="【GetLogicCPU程序】——调用GetLogicalProcessorInformation获取CPU信息的例子"></a>【GetLogicCPU程序】——调用GetLogicalProcessorInformation获取CPU信息的例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessCpu.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRS_USEPRINTF() TCHAR pBuf[1024]=&#123;&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRS_PRINTF(...)  \</span></span><br><span class="line">        StringCchPrintf(pBuf, <span class="number">1024</span>, __VA_ARGS__);\</span><br><span class="line">        WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE), pBuf, lstrlen(pBuf), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRS_ALLOC(cbSize)      HeapAlloc(GetProcessHeap(),0,cbSize);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRS_CALLOC(cbSize)     HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,cbSize);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRS_SAFEFREE(p)        <span class="meta-keyword">if</span> (NULL !=p)&#123;HeapFree(GetProcessHeap(),0,p);p=NULL;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//GetLogicalProcessorInformation函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BOOL WINAPI GetLogicalProcessorInformation(</span></span><br><span class="line"><span class="comment">   _Out_   PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer,</span></span><br><span class="line"><span class="comment">   _Inout_ PDWORD                                ReturnLength</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI * LPFN_GLPI)</span><span class="params">(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION, PDWORD)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">CountBits</span><span class="params">(ULONG_PTR bitMask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD LSHIFT = <span class="keyword">sizeof</span>(ULONG_PTR) * <span class="number">8</span> - <span class="number">1</span>; <span class="comment">//32位计算机中指针长度为4，64位中为8字节</span></span><br><span class="line">	DWORD bitSetCount = <span class="number">0</span>;</span><br><span class="line">	DWORD bitTest = <span class="number">1</span> &lt;&lt; LSHIFT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt;= LSHIFT; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		bitSetCount += ((bitMask&amp;bitTest) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">		bitTest &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bitSetCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line">	GRS_USEPRINTF();</span><br><span class="line"></span><br><span class="line">	LPFN_GLPI  Glpi;</span><br><span class="line">	Glpi = (LPFN_GLPI)GetProcAddress(GetModuleHandle(_T(<span class="string">"kernel32"</span>)),</span><br><span class="line">		<span class="string">"GetLogicalProcessorInformation"</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == Glpi)</span><br><span class="line">	&#123;</span><br><span class="line">		GRS_PRINTF(_T(<span class="string">"\n不支持GetLogicalProcessorInformation函数！"</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BOOL bDone = FALSE;</span><br><span class="line">	PSYSTEM_LOGICAL_PROCESSOR_INFORMATION pBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	DWORD iRetLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!bDone)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD rc = Glpi(pBuffer, &amp;iRetLength);</span><br><span class="line">		<span class="keyword">if</span> (FALSE == rc)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (GetLastError() == ERROR_INSUFFICIENT_BUFFER)</span><br><span class="line">			&#123;</span><br><span class="line">				GRS_SAFEFREE(pBuffer);</span><br><span class="line">				pBuffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)GRS_CALLOC(iRetLength);</span><br><span class="line">				<span class="keyword">if</span> (<span class="literal">NULL</span> == pBuffer)</span><br><span class="line">				&#123;</span><br><span class="line">					GRS_PRINTF(_T(<span class="string">"\n错误：分配内存失败！"</span>));</span><br><span class="line">					<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				GRS_PRINTF(_T(<span class="string">"\n错误：%d"</span>), GetLastError());</span><br><span class="line">				<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> bDone = TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD procCoreCount = <span class="number">0</span>;</span><br><span class="line">	DWORD procCacheCount = <span class="number">0</span>;</span><br><span class="line">	DWORD procNumaCount = <span class="number">0</span>;</span><br><span class="line">	DWORD procPackageCount = <span class="number">0</span>;</span><br><span class="line">	DWORD byteOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	PSYSTEM_LOGICAL_PROCESSOR_INFORMATION ptr = pBuffer;</span><br><span class="line">	<span class="keyword">while</span> (byteOffset &lt; iRetLength)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span> (ptr-&gt;Relationship)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> RelationNumaNode:</span><br><span class="line">			procNumaCount++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> RelationProcessorCore:     <span class="comment">//单个CPU的核数</span></span><br><span class="line">			<span class="keyword">if</span> (ptr-&gt;ProcessorCore.Flags)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//超线程或SMT启用时，处理器在同一核上运行</span></span><br><span class="line">				procCoreCount++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//处理器有不同的核</span></span><br><span class="line">				procCoreCount += CountBits(ptr-&gt;ProcessorMask);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> RelationCache:</span><br><span class="line">			<span class="comment">//每个缓存中，是一个CACHE_DESCRIPTOR结构</span></span><br><span class="line">			procCacheCount++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> RelationProcessorPackage: <span class="comment">//CPU数量</span></span><br><span class="line">			procPackageCount++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			GRS_PRINTF(_T(<span class="string">"\n错误：不支持LOGICAL_PROCESSOR_RELATIONSHIP值.\n"</span>));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		byteOffset += <span class="keyword">sizeof</span>(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);</span><br><span class="line">		ptr++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	GRS_PRINTF(_T(<span class="string">"GetLogicalProcessorInformation结果：\n"</span>));</span><br><span class="line">	GRS_PRINTF(_T(<span class="string">"NUMA节点数量：\t%d\n"</span>), procNumaCount);</span><br><span class="line">	GRS_PRINTF(_T(<span class="string">"核的数量：\t%d\n"</span>), procCoreCount);</span><br><span class="line">	GRS_PRINTF(_T(<span class="string">"CPU的数量：\t%d\n"</span>), procPackageCount);</span><br><span class="line">	GRS_PRINTF(_T(<span class="string">"缓存的数量：\t%d\n"</span>), procCacheCount);</span><br><span class="line"></span><br><span class="line">	GRS_SAFEFREE(pBuffer);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/10/windows-kernel/image-07.png" width="600px"></p>
<p><br></p>
<h2 id="进程的错误模式"><a href="#进程的错误模式" class="headerlink" title="进程的错误模式"></a>进程的错误模式</h2><ul>
<li><p>（1）调用SetErrorMode告诉系统如何处理错误（如磁盘介质、未处理异常、文件查找以及数据对齐等错误。</p>
</li>
<li><p>（2）SetErrorMode函数的参数——可根据下列标志按位或运算</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SEM_FAILCRITICALERRORS</td>
<td>系统不显示严重错误处理程序（critical-error-handler）消息框，而是将错误返回主调给进程。</td>
</tr>
<tr>
<td>SEM_NOGPFAULTERRORBOX</td>
<td>系统不显示常规保护错误（general-protection-fault）消息框。此标志只应该由调试程序设置； 该调试程序用一个异常处理程序来自行处理常规保护错误。</td>
</tr>
<tr>
<td>SEM_NOOPENFILEERRORBOX</td>
<td>系统查找文件失败时，不显示消息框</td>
</tr>
<tr>
<td>SEM_NOALIGNMENTFAULTEXCEPT</td>
<td>系统自动修复内存对齐错误，并使应用程序看不到这些错误。此标志对x86/x64处理器无效</td>
</tr>
</tbody>
</table>
<ul>
<li>（3）默认情况下，<strong>子进程会继承父进程的错误模式标志</strong>。在创建子进程时，可以在CreateProcess中指定CREATE_DEFAULT_ERROR_MODE来阻止子进程继承其错误模式</li>
</ul>
<p><br> </p>
<h2 id="进程当前所在的驱动器和目录"><a href="#进程当前所在的驱动器和目录" class="headerlink" title="进程当前所在的驱动器和目录"></a>进程当前所在的驱动器和目录</h2><p>（1）系统跟踪记录着进程的当前驱动器和目录，但并没记录每个驱动器的当前目录。但可以通过环境变量来提供这种支持。设硬盘上有3个盘符，分别为C、D、E，环境变量如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=C:=C:\Utiltity\Bin</span><br><span class="line"></span><br><span class="line">=D:=D:\Program Files</span><br></pre></td></tr></table></figure>
<p>则表示进程C在驱动器的当前目录为\Utility\Bin，在D驱动器的当前目录为\Program Files。而E没被记录在环境变量中，所以当前目录默认为E的根目录。</p>
<p>（2）进程在查找文件时的顺序（如果没指定完整的路径名时）</p>
<p>   ①查找当前工作目录，即系统内部跟踪记录的、可用GetCurrentDirectory获取的那个。</p>
<p>   ②如果没有，则从环境块中查找指定驱动器号下的当前目录。如果找到不该驱动器号，则以盘符的根目录作为当前目录来查找文件。</p>
<p>（3）Windows<strong>文件函数</strong>（如CreateFile）不会添加或更改驱动器号的环境变量。（注意，SetCurrentDirectory是可以去改变的哦）。</p>
<p>（4）子进程不会自动继承父进程的当前目录（current directories），而是默认为各驱动器的根目录。</p>
<p>（5）获得指定驱动器当前完整的目录GetFullPathName</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>LPCTSTR lpFileName</td>
<td>驱动器名或文件名：如TEXT(“C:”)或TEXT(“XXX.exe”)，文件名后缀默认为.exe</td>
</tr>
<tr>
<td>DWORD nBufferLength</td>
<td>接收缓冲区大小（以字符数为单位），一般为MAX_PATH</td>
</tr>
<tr>
<td>LPTSTR lpBuffer</td>
<td>接收缓冲区</td>
</tr>
<tr>
<td>LPTSTR *lpFilePart</td>
<td>指向上述缓冲区接收到的完整路径（含文件名）中文件名开始的地址指针</td>
</tr>
<tr>
<td>返回值</td>
<td>成功：返回实际接收到的字符数（不含\0）失败：0，可GetLastError获得更多信息</td>
</tr>
</tbody>
</table>
<p>  如：DWORD cchLength = GetFullPathName(TEXT(“C:”),MAX_PATH,szCurDir,NULL);</p>
<p><br></p>
<h2 id="系统版本"><a href="#系统版本" class="headerlink" title="系统版本"></a>系统版本</h2><p>（1）GetVersionEx函数和OSVERSIONINFOEX结构体</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>dwOSVersionInfoSize</td>
<td>结构体大小，sizeof(OSVERSIONINFOEX)或sizeof(OSVERSIONINFO)</td>
</tr>
<tr>
<td>dwMajorVersion</td>
<td>主版本号</td>
</tr>
<tr>
<td>dwMinorVersion</td>
<td>次版本号</td>
</tr>
<tr>
<td>dwBuildNumber</td>
<td>当前系统的构建版本号</td>
</tr>
<tr>
<td>dwPlatformID</td>
<td>当前系统支持的套件(suite)VER_PLATFORM_WIN32s：Win32sVER_PLATFROM_WIN32_WINDOWS：Win95或Win98VER_PLATFORM_WIN32_NT：Win NT、Win2000、WinXp、Win Server2003以及Win Vista</td>
</tr>
<tr>
<td>szCSDVersion</td>
<td>此字段包含额外的文本，提供了与己安的操作系统有关的更多信息</td>
</tr>
<tr>
<td>wServicePackMajor</td>
<td>最新安装的Service Pack的主版本号</td>
</tr>
<tr>
<td>wServicePackMinor</td>
<td>最新安装的Service Pack的次版本号</td>
</tr>
<tr>
<td>wSuiteMask</td>
<td>当前系统上可用的Suite(s)，如VER_SUITE_SINGLEUSERTS：每个用户一个终端服务会话VER_SUITE_PERSONAL：用来区别Vista的Home或Professional版本</td>
</tr>
<tr>
<td>wProductType</td>
<td>指出安装的是以下操作系统产品中的哪一个：VER_NT_WORKSTATION、VER_NT_SERVER、VER_NT_DOMAIN_CONTROLLER</td>
</tr>
<tr>
<td>wReserved</td>
<td>保留，供将来使用</td>
</tr>
</tbody>
</table>
<p>（2）比较主机系统的版本与应用程序要求的版本：VerifyVersionInfo函数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>POSVERSIONINFOEX lpVersionInfo</td>
<td>指向OSVERSIONINFOEX结构体，要初始化结构体大小字段及其他要检查的字段，如要检查操作系统是否是Vista时，要将dwMajorVersion指定为6，dwMinorVersion指定为0，dwPaltformID设为VER_PLATFORM_WIN32_NT。</td>
</tr>
<tr>
<td>DWORD             dwTypeMask</td>
<td>指出了我们要初始化哪些成员，可以按以将以下标志按位或运算：VER_MINORVERSION、VER_MAJORVERSION、VER_BUILDNUMBER、VER_PLATFORMID、VER_SERVICEPACKMINOR、VER_SERVICEPACKMAJOR、VER_SUITENAME、VER_PRODUCT_TYPE</td>
</tr>
<tr>
<td>DWORDLONG    dwlConditionMask</td>
<td>64位值，决定如何将系统版本信息与我们希望的版本信息进行比较，可以用VER_SET_CONDITION宏来组合出恰当的位组，如<strong>系统的主版本号是大于或小于或等于我们要求的版本号</strong>，还有次版本号、及其他字段的情况等。</td>
</tr>
<tr>
<td>返回值</td>
<td>非0：表示满足要求0：不符合要求或调用函数不正确，可以调用GetLastError来进一步判断。如果返回ERROR_OLD_WIN_VERSION，表示函数调用是正确的，但不符合我们的要求。</td>
</tr>
</tbody>
</table>
<p>★VER_SET_CONDITION宏</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ULONGLONG dwlConditionMask</td>
<td>64位的条件掩码变量，用来保存后面的dyTypeBitMask和dwConditionMask 位操作的结果</td>
</tr>
<tr>
<td>DWORD     dwTypeBitMask</td>
<td>指定要比较的是哪个成员，为了比较多个成员，必须多次调用VET_SET_CONDITION宏，一个成员调用一次，所有结果保存在dwlConditionMask变量中。</td>
</tr>
<tr>
<td>BYTE      dwConditionMask</td>
<td>要进行何种比较：VER_EQUAL：等于；VER_GREATER：大于；VER_LESS：小于VER_GREATER_EQUAL：大于等于；VER_LESS_EQUAL：小于等于注意：在比较VER_SUITENAME信息时，要用VER_AND：所有套件产品都必须安装VER_OR：至少安装了其中的一个套件产品</td>
</tr>
</tbody>
</table>
<p>【附表】Windows版本号参考</p>
<table>
<thead>
<tr>
<th>Operating System</th>
<th>Version</th>
<th>PlatformID</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows 8.1</td>
<td>6.3</td>
<td>VER_PLATFORM_WIN32_NT</td>
</tr>
<tr>
<td>Windows 8</td>
<td>6.2</td>
<td>VER_PLATFORM_WIN32_NT</td>
</tr>
<tr>
<td>Windows 7</td>
<td>6.1</td>
<td>VER_PLATFORM_WIN32_NT</td>
</tr>
<tr>
<td>Windows Server 2008 R2</td>
<td>6.1</td>
<td>VER_PLATFORM_WIN32_NT</td>
</tr>
<tr>
<td>Windows Server 2008</td>
<td>6.0</td>
<td>VER_PLATFORM_WIN32_NT</td>
</tr>
<tr>
<td>Windows Vista</td>
<td>6.0</td>
<td>VER_PLATFORM_WIN32_NT</td>
</tr>
<tr>
<td>Windows Server 2003 R2</td>
<td>5.2</td>
<td>VER_PLATFORM_WIN32_NT</td>
</tr>
<tr>
<td>Windows Server 2003</td>
<td>5.2</td>
<td>VER_PLATFORM_WIN32_NT</td>
</tr>
<tr>
<td>Windows XP 64-Bit Edition</td>
<td>5.2</td>
<td>VER_PLATFORM_WIN32_NT</td>
</tr>
<tr>
<td>Windows XP</td>
<td>5.1</td>
<td>VER_PLATFORM_WIN32_NT</td>
</tr>
<tr>
<td>Windows 2000</td>
<td>5.0</td>
<td>VER_PLATFORM_WIN32_NT</td>
</tr>
<tr>
<td>Windows NT 4.0</td>
<td>4.0</td>
<td>VER_PLATFORM_WIN32_NT</td>
</tr>
<tr>
<td>Windows NT 3.51</td>
<td>3.51 ?</td>
<td>VER_PLATFORM_WIN32_NT</td>
</tr>
<tr>
<td>Windows Millennium Edition</td>
<td>4.90</td>
<td>VER_PLATFORM_WIN32_WINDOWS (=1)</td>
</tr>
<tr>
<td>Windows 98</td>
<td>4.10</td>
<td>VER_PLATFORM_WIN32_WINDOWS</td>
</tr>
<tr>
<td>Windows 95</td>
<td>4.0</td>
<td>VER_PLATFORM_WIN32_WINDOWS</td>
</tr>
<tr>
<td>Windows 3.1</td>
<td>3.1 ?</td>
<td>VER_PLATFORM_WIN32s (=0)</td>
</tr>
</tbody>
</table>
<p>（3）建议用来替代GetVersion和GetVersionEx的API（须包含versionhelpers.h）</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>IsWindowsXPOrGreater</td>
<td>版本号是高于或等于WinXP？</td>
</tr>
<tr>
<td>IsWindowsXPSP1OrGreater</td>
<td>版本号是高于或等于WinXP(SP1)？</td>
</tr>
<tr>
<td>IsWindowsXPSP2OrGreater</td>
<td>版本号是高于或等于WinXP(SP2)？</td>
</tr>
<tr>
<td>IsWindowsXPSP3OrGreater</td>
<td>版本号是高于或等于WinXP(SP3)？</td>
</tr>
<tr>
<td>IsWindowsVistaOrGreater</td>
<td>版本号是高于或等于Win Vista？</td>
</tr>
<tr>
<td>IsWindowsVistaSP1OrGreater</td>
<td>版本号是高于或等于Win Vista（sp1）？</td>
</tr>
<tr>
<td>IsWindowsVistaSP2OrGreater</td>
<td>版本号是高于或等于Win Vista（sp2）？</td>
</tr>
<tr>
<td>IsWindows7OrGreater</td>
<td>版本号是高于或等于Win 7？</td>
</tr>
<tr>
<td>IsWindows7SP1OrGreater</td>
<td>版本号是高于或等于Win 7(sp1)？</td>
</tr>
<tr>
<td>IsWindows8OrGreater</td>
<td>版本号是高于或等于Win 8？</td>
</tr>
<tr>
<td>IsWindows8Point1OrGreater</td>
<td>版本号是高于或等于Win 8.1？</td>
</tr>
<tr>
<td>IsWindows10OrGreater</td>
<td>版本号是高于或等于Win 10？</td>
</tr>
<tr>
<td>IsWindowsServer</td>
<td>是否是服务器版本</td>
</tr>
<tr>
<td>IsWindowsVersionOrGreater</td>
<td>当前系统的版本号是否匹配或高于目前编译器己知版本</td>
</tr>
</tbody>
</table>
<h3 id="【VersionInfo程序】测试主机系统是不是Win8-1版本"><a href="#【VersionInfo程序】测试主机系统是不是Win8-1版本" class="headerlink" title="【VersionInfo程序】测试主机系统是不是Win8.1版本"></a>【VersionInfo程序】测试主机系统是不是Win8.1版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SystemVersion.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;VersionHelpers.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IsWindows8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化OSVERSIONINFOEX结构体,并设置为Win8.1</span></span><br><span class="line">    OSVERSIONINFOEX osver = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    osver.dwOSVersionInfoSize = <span class="keyword">sizeof</span>(osver);</span><br><span class="line">    osver.dwMajorVersion = <span class="number">6</span>;</span><br><span class="line">    osver.dwMinorVersion = <span class="number">3</span>;</span><br><span class="line">    osver.dwPlatformId = VER_PLATFORM_WIN32_NT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备条件掩码变量</span></span><br><span class="line">    DWORDLONG dwlConditionMask = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//多次调用VER_SET_CONDITION宏来组合条件掩码变量</span></span><br><span class="line">    VER_SET_CONDITION(dwlConditionMask, VER_MAJORVERSION, VER_EQUAL); <span class="comment">//主版本号</span></span><br><span class="line">    VER_SET_CONDITION(dwlConditionMask, VER_MINORVERSION, VER_EQUAL); <span class="comment">//次版本号</span></span><br><span class="line">    VER_SET_CONDITION(dwlConditionMask, VER_PLATFORMID, VER_EQUAL);   <span class="comment">//平台ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//版本测试</span></span><br><span class="line">    <span class="keyword">if</span> (VerifyVersionInfo(&amp;osver,VER_MAJORVERSION| VER_MINORVERSION|VER_PLATFORMID,</span><br><span class="line">            dwlConditionMask))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"当前操作系统正好是Win8.1！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"当前操作系统不是Win8.1！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//利用VerifyVersionInfo函数判断</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"利用VerifyVersionInfo函数判断：\n"</span>);</span><br><span class="line">    IsWindows8();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用VersionHelpers.h中的函数判断</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n利用VersionHelpers.h中的函数：\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (IsWindows8Point1OrGreater())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"当前操作系统等于或高于Win8.1版本！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"当前操作系统低于Win8.1版本！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><img src="/2018/12/10/windows-kernel/image-08.png" width="500px"></p>
<h2 id="ProcessInfo示例"><a href="#ProcessInfo示例" class="headerlink" title="ProcessInfo示例"></a>ProcessInfo示例</h2><blockquote>
<p> 自定义函数  </p>
</blockquote>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetProcessIntegrityLevel</td>
<td>1、获取进程完整性级别和代码策略：分别在GetTokenInformation中   TokenIntegrityLevel及TokenMandatoryPolicy<br>2、获取资源完整性级别及资源策略：调用API—GetSecurityInfo传入LABEL_SECURITY_INFORMATION，然后从SACL中获取</td>
</tr>
<tr>
<td>GetProcessElevation</td>
<td>1、获取令牌提升的类型：GetTokenInformation(…,TokenElevationType,…)<br>分别对应TokenElevationTypeDefault、TokenEvationTypeLimited、Token、TokenElevationTypeFull2、判断当前进程是否以管理员身份运行</td>
</tr>
<tr>
<td>StartElevatedProcess</td>
<td>手动提升权限，利用ShellExecuteEx函数，结构体SHELLEXECUTEINFO参数中lpVert=TEXT(“runas”),lpFile = szExecutable(应用程序文件名)</td>
</tr>
<tr>
<td>GetProcessCmdLine</td>
<td>1、获取远程进程的命令行（注意，与GetCommandLine不同，该函数不仅仅获得当前进程的命令行，还可以获得远程进程的命令行）<br>2、该函数是通过NT内核的函数NtQueryInformationProcess获得远程进程的环境块来实现的</td>
</tr>
<tr>
<td>GetProcessOwner</td>
<td>获取进程属主：通过GetTokenInformation传入TokenUser</td>
</tr>
<tr>
<td>GetModulePreferredBaseAddr</td>
<td>获取某进程中指定模块首选的装载基址。<br>通过调用Toolhelp32ReadProcessMemory来获取进程DOS及NT头结构。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>CToolhelp类</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>EnablePrivilege</td>
<td>提升进程权限</td>
</tr>
<tr>
<td>CreateSnapshot</td>
<td>创建进程快照，可以用来枚举系统正在运行的进程<br>该函数是通过调用CreateToolhelp32Snapshot来实现的。</td>
</tr>
<tr>
<td>ProcessFirst、ProcessNext</td>
<td>进程快照中的第1个和下一个进程，通过调用Process32First及Process32Next实现</td>
</tr>
<tr>
<td>ModuleFirst、ModuleNext</td>
<td>进程快照中含所有的模块，这个函数分别获得第1个及下一个。<br>通过Module32First及Module32Next来实现</td>
</tr>
<tr>
<td>ThreadFirst、ThreadNext</td>
<td>进程快照中含所有的正在运行的线程，分别获取第1个和下一个线程。<br>通过Thread32First及Thread32Next实现。</td>
</tr>
<tr>
<td>HeapListFirst、HeapListNext</td>
<td>进程快照中所有的堆，分别获取堆链表中的第1个和下一个堆。通过Heap32ListFirst及Heap32ListNext实现</td>
</tr>
<tr>
<td>HowManyHeaps</td>
<td>进程快照中共有多少个堆</td>
</tr>
<tr>
<td>HeapFirst、HeapNext</td>
<td>指定进程中的第1个堆和下一个堆，通过Heap32First和Heap32Next实现</td>
</tr>
<tr>
<td>IsAHeap</td>
<td>判断给定的地址是否在指定进程的堆中，通过VirtualQueryEx实现</td>
</tr>
<tr>
<td>HowManyBlockInHeap</td>
<td>获得指定进程共有多少个堆</td>
</tr>
<tr>
<td>RetriveTokenInformationClass</td>
<td>获得令牌中指定的信息，要用自定义的FreeTokenInformation来释放内存。</td>
</tr>
</tbody>
</table>
<h3 id="ProcessInfo-cpp"><a href="#ProcessInfo-cpp" class="headerlink" title="ProcessInfo.cpp"></a>ProcessInfo.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">Module:  ProcessInfo.cpp</span></span><br><span class="line"><span class="comment">Notices: Copyright(c) 2008 Jeffrey Richter &amp; Christophe Nasarre</span></span><br><span class="line"><span class="comment">************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"..\\..\\CommonFiles\CmnHdr.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"..\\..\\CommonFiles\ToolHelp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"resource.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Shlwapi.h&gt;    //for StrFormatKBSize</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winternl.h&gt;   //for Windows internal declarations</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aclapi.h&gt;     //for ACL management</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ShlObj.h&gt;     //for IsUserAnAdmin</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  comment(lib,<span class="meta-string">"shlwapi.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">//静态变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Token类型：默认——即禁用UAC，完全访问权限—未筛选，受限——筛选的</span></span><br><span class="line">TOKEN_ELEVATION_TYPE s_elevationType = TokenElevationTypeDefault; </span><br><span class="line">BOOL                 s_bIsAdmin         = FALSE;</span><br><span class="line"><span class="keyword">const</span>     <span class="keyword">int</span>        s_cchAddress     = <span class="keyword">sizeof</span>(PVOID) * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//在编辑框控件中增加文本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddText</span><span class="params">(HWND hwnd, PCTSTR pszFormat, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, pszFormat);</span><br><span class="line">    TCHAR sz[<span class="number">100</span> * <span class="number">1024</span>];</span><br><span class="line">    Edit_GetText(hwnd, sz, _countof(sz));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//_tcschr从一个字符串中查找字符,返回str中的第一个字符c出现的位置</span></span><br><span class="line">    <span class="comment">//开始的字符串的指针</span></span><br><span class="line">    _vstprintf_s(_tcschr(sz, TEXT(<span class="string">'\0'</span>)),   <span class="comment">//wchar_t *buffer,</span></span><br><span class="line">                  _countof(sz)-_tcslen(sz), <span class="comment">//size_t numberOfElements,</span></span><br><span class="line">                  pszFormat,                <span class="comment">//const wchar_t *format,</span></span><br><span class="line">                  argList);                    <span class="comment">//va_list argptr</span></span><br><span class="line">    Edit_SetText(hwnd, sz);</span><br><span class="line">    va_end(argList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//获取进程完整性级别及代码策略、资源的完整性级别及资源策略</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetProcessIntegrityLevel</span><span class="params">(HANDLE hProcess, PDWORD pIntegrityLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">    PDWORD pPolicy, PDWORD pResourceIntegrityLevel, PDWORD pResourcePolicy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bReturn = FALSE;</span><br><span class="line">    HANDLE hToken = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!OpenProcessToken(hProcess, TOKEN_READ, &amp;hToken))</span><br><span class="line">        <span class="keyword">return</span> bReturn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先，计算接收进程完整性级别信息的缓冲区大小</span></span><br><span class="line">    DWORD dwNeededSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!GetTokenInformation(hToken,TokenIntegrityLevel,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;dwNeededSize))&#123;</span><br><span class="line">        PTOKEN_MANDATORY_LABEL pTokenInfo = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (ERROR_INSUFFICIENT_BUFFER == GetLastError())&#123;</span><br><span class="line">            <span class="comment">//接着，根据dwNeededSize分配内存</span></span><br><span class="line">            pTokenInfo = (PTOKEN_MANDATORY_LABEL)LocalAlloc(<span class="number">0</span>, dwNeededSize);&#123;</span><br><span class="line">                <span class="comment">//最后，获得完整性级别</span></span><br><span class="line">                <span class="keyword">if</span> (GetTokenInformation(hToken,TokenIntegrityLevel,</span><br><span class="line">                             pTokenInfo,dwNeededSize,&amp;dwNeededSize))&#123;</span><br><span class="line">                    <span class="comment">//SID:S-1-5-21-917267712-1342860078-1792151419-500</span></span><br><span class="line">                    <span class="comment">//第1项：S表示字符串SID，第2项1表示SID的版本号，第3项5表示授权机构ID</span></span><br><span class="line">                    <span class="comment">//而后面的21-917267712-1342860078-1792151419就是以下函数要获取的子授</span></span><br><span class="line">                    <span class="comment">//限机构ID（一般为用来标志域的），最后一项为500为帐号和组，这里表示administrator用户</span></span><br><span class="line">                    *pIntegrityLevel = *GetSidSubAuthority(pTokenInfo-&gt;Label.Sid,</span><br><span class="line">                                          (*GetSidSubAuthorityCount(pTokenInfo-&gt;Label.Sid) - <span class="number">1</span>));</span><br><span class="line">                    </span><br><span class="line">                    bReturn = TRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//释放内存</span></span><br><span class="line">                LocalFree(pTokenInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果进程完整性级别用可，就尝试获取代码策略</span></span><br><span class="line">    <span class="keyword">if</span> (bReturn)&#123;</span><br><span class="line">        *pPolicy = TOKEN_MANDATORY_POLICY_OFF;</span><br><span class="line">        dwNeededSize = <span class="keyword">sizeof</span>(DWORD);</span><br><span class="line">        GetTokenInformation(hToken, TokenMandatoryPolicy, pPolicy, dwNeededSize, &amp;dwNeededSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看资源策略</span></span><br><span class="line">    *pResourceIntegrityLevel = <span class="number">0</span>; <span class="comment">//0表示没有显式设置</span></span><br><span class="line">    *pResourcePolicy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    PACL pSACL = <span class="literal">NULL</span>;</span><br><span class="line">    PSECURITY_DESCRIPTOR pSD = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwResult = ERROR_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从SACL中查找资源策略：no-read-up/no-write-up</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != hToken)&#123;</span><br><span class="line">        <span class="comment">//获取指定对象SD的副本,要用 LocalFree（pSD）</span></span><br><span class="line">        dwResult = GetSecurityInfo(hProcess, SE_KERNEL_OBJECT,</span><br><span class="line">                        LABEL_SECURITY_INFORMATION,</span><br><span class="line">                        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, </span><br><span class="line">                        &amp;pSACL, &amp;pSD);</span><br><span class="line">        <span class="keyword">if</span> (ERROR_SUCCESS == dwResult)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> != pSACL)&#123;</span><br><span class="line">                SYSTEM_MANDATORY_LABEL_ACE* pACE = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="comment">//SD中SACL列表中的第1项表示资源完整性及策略</span></span><br><span class="line">                <span class="keyword">if</span> ((pSACL-&gt;AceCount &gt; <span class="number">0</span>) &amp;&amp; (GetAce(pSACL, <span class="number">0</span>, (PVOID*)&amp;pACE)))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (pACE != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        SID* pSID = (SID*)(&amp;pACE-&gt;SidStart);</span><br><span class="line">                        *pResourceIntegrityLevel = pSID-&gt;SubAuthority[<span class="number">0</span>]; <span class="comment">//第1个子授权项表示完整性级别</span></span><br><span class="line">                        *pResourcePolicy = pACE-&gt;Mask; <span class="comment">//资源策略NO-WRITE-UP/NO-READ-UP</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pSD != <span class="literal">NULL</span>)LocalFree(pSD); <span class="comment">//清理内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CloseHandle(hToken);<span class="comment">//关闭hToken句柄</span></span><br><span class="line">    <span class="keyword">return</span> bReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">GetProcessIntegrityLevel</span><span class="params">(DWORD PID, PDWORD pIntegrityLevel, PDWORD pPolicy,</span></span></span><br><span class="line"><span class="function"><span class="params">    PDWORD pResourceIntegrityLevel, PDWORD pResourcePolicy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bReturn = FALSE;</span><br><span class="line">    <span class="comment">//合法性检查</span></span><br><span class="line">    <span class="keyword">if</span> ((PID &lt;= <span class="number">0</span>) || (pIntegrityLevel == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否可以获取进程信息</span></span><br><span class="line">    HANDLE hProcess = OpenProcess(READ_CONTROL | PROCESS_QUERY_INFORMATION,</span><br><span class="line">                                    FALSE, PID);</span><br><span class="line">    <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    bReturn = GetProcessIntegrityLevel(hProcess, pIntegrityLevel, pPolicy, </span><br><span class="line">                                         pResourceIntegrityLevel, pResourcePolicy);</span><br><span class="line">    CloseHandle(hProcess); <span class="comment">//关闭进程句柄</span></span><br><span class="line">    <span class="keyword">return</span> bReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dlg_PopulateProcessList</span><span class="params">(HWND hwnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HWND hwndList = GetDlgItem(hwnd, IDC_PROCESSMODULELIST);</span><br><span class="line">    SetWindowRedraw(hwndList, FALSE);</span><br><span class="line">    ComboBox_ResetContent(hwndList); <span class="comment">//重置下拉列表框</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//the Processes：所有运行中的进程，参数函数的第2个参数省略，默认为0</span></span><br><span class="line">    <span class="function">CToolhelp  <span class="title">thProcesses</span><span class="params">(TH32CS_SNAPPROCESS)</span></span>;</span><br><span class="line">    <span class="comment">//存放快照进程信息的一个结构体</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    dwSize:结构体大小,cntUsage：此进程的引用计数。th32ProcessID:进程ID</span></span><br><span class="line"><span class="comment">    th32DefaultHeapID:进程默认堆ID(总是为0)　th32ModuleID:总是为0</span></span><br><span class="line"><span class="comment">    cnTreads进程开启的线程性 th32ParentProcessID：父进程ID</span></span><br><span class="line"><span class="comment">    pcPriClass:线程基础优先级 dwFlags总是0 szExeFile进程的可执行文件名称</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PROCESSENTRY32 pe = &#123; <span class="keyword">sizeof</span>(pe) &#125;;</span><br><span class="line"></span><br><span class="line">    TCHAR sz[<span class="number">1024</span>];</span><br><span class="line">    BOOL fOk = thProcesses.ProcessFirst(&amp;pe);</span><br><span class="line">    <span class="keyword">for</span> (; fOk; fOk = thProcesses.ProcessNext(&amp;pe))</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//进程名称（不含路径）和ID</span></span><br><span class="line">        <span class="comment">//_tcsrchr从一个字符串中查找字符'\'最后出现位置（指针）</span></span><br><span class="line">        PCTSTR pszExeFile = _tcsrchr(pe.szExeFile, TEXT(<span class="string">'\\'</span>));</span><br><span class="line">        <span class="keyword">if</span> (pszExeFile == <span class="literal">NULL</span>)</span><br><span class="line">            pszExeFile = pe.szExeFile;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pszExeFile++;<span class="comment">//跳过'\'，指定进程名称</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//追加代码/资源完整性级别和策略</span></span><br><span class="line">        DWORD dwCodeIntergrityLevel = <span class="number">0</span>;</span><br><span class="line">        DWORD dwCodePolicy = TOKEN_MANDATORY_POLICY_OFF;</span><br><span class="line">        DWORD dwResourcePolicy = <span class="number">0</span>;</span><br><span class="line">        DWORD dwResourceIntegrityLevel = <span class="number">0</span>;</span><br><span class="line">        TCHAR szCodeDetails[<span class="number">256</span>];</span><br><span class="line">        TCHAR szResourceDetails[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        szCodeDetails[<span class="number">0</span>] = TEXT(<span class="string">'\0'</span>);</span><br><span class="line">        szResourceDetails[<span class="number">0</span>] = TEXT(<span class="string">'\0'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (GetProcessIntegrityLevel(pe.th32ProcessID,&amp;dwCodeIntergrityLevel,&amp;dwCodePolicy,</span><br><span class="line">                 &amp;dwResourceIntegrityLevel,&amp;dwResourcePolicy))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//进程完整性级别及代码策略</span></span><br><span class="line">            <span class="keyword">switch</span> (dwCodeIntergrityLevel) </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> SECURITY_MANDATORY_LOW_RID:</span><br><span class="line">                _tcscpy_s(szCodeDetails, _countof(szCodeDetails), TEXT(<span class="string">"- Low "</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SECURITY_MANDATORY_MEDIUM_RID:</span><br><span class="line">                _tcscpy_s(szCodeDetails, _countof(szCodeDetails), TEXT(<span class="string">"- Medium "</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SECURITY_MANDATORY_HIGH_RID:</span><br><span class="line">                _tcscpy_s(szCodeDetails, _countof(szCodeDetails), TEXT(<span class="string">"- High "</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SECURITY_MANDATORY_SYSTEM_RID:</span><br><span class="line">                _tcscpy_s(szCodeDetails, _countof(szCodeDetails), TEXT(<span class="string">"- System "</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                _tcscpy_s(szCodeDetails, _countof(szCodeDetails), TEXT(<span class="string">"- ??? "</span>));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dwCodePolicy == TOKEN_MANDATORY_POLICY_OFF)  <span class="comment">//0</span></span><br><span class="line">                _tcscat_s(szCodeDetails, _countof(szCodeDetails), TEXT(<span class="string">" + no policy"</span>));</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((dwCodePolicy &amp; TOKEN_MANDATORY_POLICY_VALID_MASK)==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    _tcscat_s(szCodeDetails, _countof(szCodeDetails), TEXT(<span class="string">" + ???"</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dwCodePolicy &amp; TOKEN_MANDATORY_POLICY_NO_WRITE_UP)</span><br><span class="line">                    &#123;</span><br><span class="line">                        _tcscat_s(szCodeDetails, _countof(szCodeDetails), TEXT(<span class="string">" + no write-up"</span>));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (dwCodePolicy &amp; TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN)</span><br><span class="line">                    &#123;</span><br><span class="line">                        _tcscat_s(szCodeDetails, _countof(szCodeDetails), TEXT(<span class="string">" + new process min"</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//资源完整性级别及代码策略</span></span><br><span class="line">            <span class="keyword">switch</span> (dwResourceIntegrityLevel)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> SECURITY_MANDATORY_LOW_RID:</span><br><span class="line">                _tcscpy_s(szResourceDetails, _countof(szResourceDetails), TEXT(<span class="string">"Low"</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SECURITY_MANDATORY_MEDIUM_RID:</span><br><span class="line">                _tcscpy_s(szResourceDetails, _countof(szResourceDetails), TEXT(<span class="string">"Medium"</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SECURITY_MANDATORY_HIGH_RID:</span><br><span class="line">                _tcscpy_s(szResourceDetails, _countof(szResourceDetails), TEXT(<span class="string">"High"</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SECURITY_MANDATORY_SYSTEM_RID:</span><br><span class="line">                _tcscpy_s(szResourceDetails, _countof(szResourceDetails), TEXT(<span class="string">"System"</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                _tcscpy_s(szResourceDetails, _countof(szResourceDetails), TEXT(<span class="string">"Not Set"</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                _tcscpy_s(szResourceDetails, _countof(szResourceDetails), TEXT(<span class="string">"???"</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dwResourcePolicy == <span class="number">0</span>)&#123;  <span class="comment">//没有策略</span></span><br><span class="line">                _tcscat_s(szResourceDetails, _countof(szResourceDetails), TEXT(<span class="string">" + 0 policy"</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> ((dwResourcePolicy &amp; TOKEN_MANDATORY_POLICY_VALID_MASK)==<span class="number">0</span>)&#123;</span><br><span class="line">                    _tcscat_s(szResourceDetails, _countof(szResourceDetails), TEXT(<span class="string">" + ???"</span>));</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((dwResourcePolicy &amp; SYSTEM_MANDATORY_LABEL_NO_WRITE_UP) ==</span><br><span class="line">                        SYSTEM_MANDATORY_LABEL_NO_WRITE_UP)&#123;</span><br><span class="line">                        _tcscat_s(szResourceDetails, _countof(szResourceDetails), TEXT(<span class="string">" + no write-up"</span>));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ((dwResourcePolicy &amp; SYSTEM_MANDATORY_LABEL_NO_READ_UP) ==</span><br><span class="line">                        SYSTEM_MANDATORY_LABEL_NO_READ_UP)&#123;</span><br><span class="line">                        _tcscat_s(szResourceDetails, _countof(szResourceDetails), TEXT(<span class="string">" + no read-up"</span>));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ((dwResourcePolicy &amp; SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP) ==</span><br><span class="line">                        SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP)&#123;</span><br><span class="line">                        _tcscat_s(szResourceDetails, _countof(szResourceDetails), TEXT(<span class="string">" + no excute-up"</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        StringCchPrintf(sz, _countof(sz), TEXT(<span class="string">"%s (0x%08X) %s    [%s]"</span>),</span><br><span class="line">                            pszExeFile,pe.th32ProcessID,szCodeDetails,szResourceDetails);</span><br><span class="line">        <span class="keyword">int</span> n = ComboBox_AddString(hwndList, sz);</span><br><span class="line">        ComboBox_SetItemData(hwndList, n, pe.th32ProcessID);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">//End for</span></span><br><span class="line"></span><br><span class="line">    ComboBox_SetCurSel(hwndList, <span class="number">0</span>);</span><br><span class="line">    SetWindowRedraw(hwndList, TRUE);</span><br><span class="line">    InvalidateRect(hwndList, <span class="literal">NULL</span>, FALSE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dlg_PopulateModuleList</span><span class="params">(HWND hwnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HWND hwndModuleHelp = GetDlgItem(hwnd, IDC_MODULEHELP);</span><br><span class="line">    ListBox_ResetContent(hwndModuleHelp);</span><br><span class="line"></span><br><span class="line">    <span class="function">CToolhelp <span class="title">thProcesses</span><span class="params">(TH32CS_SNAPPROCESS)</span></span>;</span><br><span class="line">    PROCESSENTRY32 pe = &#123; <span class="keyword">sizeof</span>(pe) &#125;;</span><br><span class="line">    <span class="comment">//增加全部进程的所有模块到列表框中</span></span><br><span class="line">    BOOL fOk = thProcesses.ProcessFirst(&amp;pe);</span><br><span class="line">    <span class="keyword">for</span> (; fOk;fOk=thProcesses.ProcessNext(&amp;pe))&#123;</span><br><span class="line">        <span class="function">CToolhelp <span class="title">thModules</span><span class="params">(TH32CS_SNAPMODULE, pe.th32ProcessID)</span></span>;</span><br><span class="line">        MODULEENTRY32 me = &#123; <span class="keyword">sizeof</span>(me) &#125;;</span><br><span class="line">        BOOL fOk = thModules.ModuleFirst(&amp;me);</span><br><span class="line">        <span class="keyword">for</span> (; fOk;fOk=thModules.ModuleNext(&amp;me))&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            LB_FINDSTRING:从指定开始表项序号查找某表项的文本字符串的前面包括指定的字符串则结束，</span></span><br><span class="line"><span class="comment">                          找不到则转到列表框第一项继续查找，直到查完所有表项，如果wParam为-1则从</span></span><br><span class="line"><span class="comment">                          列表框第一项开始查找，如果找到则返回表项序号，否则返回LB_ERR。</span></span><br><span class="line"><span class="comment">                          如：表项字符串为"abc123"和指定字串"ABC"就算匹配。</span></span><br><span class="line"><span class="comment">            LB_FINDSTRINGEXACT:与LB_FINDSTRING不同，本操作必须整个字符串相同。如果找到则返回表项序号，</span></span><br><span class="line"><span class="comment">                          否则返回LB_ERR。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">int</span> n = ListBox_FindStringExact(hwndModuleHelp, <span class="number">-1</span>, me.szExePath);</span><br><span class="line">            <span class="keyword">if</span> (LB_ERR==n)&#123;</span><br><span class="line">                ListBox_AddString(hwndModuleHelp, me.szExePath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    HWND hwndList = GetDlgItem(hwnd, IDC_PROCESSMODULELIST);</span><br><span class="line">    SetWindowRedraw(hwndList, FALSE);</span><br><span class="line">    ComboBox_ResetContent(hwndList);</span><br><span class="line">    <span class="keyword">int</span> nNumModules = ListBox_GetCount(hwndModuleHelp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nNumModules;i++)&#123;</span><br><span class="line">        TCHAR sz[<span class="number">1024</span>];</span><br><span class="line">        ListBox_GetText(hwndModuleHelp, i, sz);</span><br><span class="line">        <span class="comment">//将模块名称（不含路径）增加到组合列表框中</span></span><br><span class="line">        <span class="keyword">int</span> nIndex = ComboBox_AddString(hwndList, _tcsrchr(sz, TEXT(<span class="string">'\\'</span>)) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将列表框索引号关联到组合框中新加入的这项。</span></span><br><span class="line">        ComboBox_SetItemData(hwndList, nIndex, i);</span><br><span class="line">    &#125;</span><br><span class="line">    ComboBox_SetCurSel(hwndList, <span class="number">0</span>);<span class="comment">//选择组合列表框中的第1项</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟用户选中第1项，并把结果显示在编辑框中</span></span><br><span class="line">    <span class="comment">//发送CBN_SELCHANGE消息</span></span><br><span class="line">    FORWARD_WM_COMMAND(hwnd, IDC_PROCESSMODULELIST, hwndList, CBN_SELCHANGE, SendMessage);</span><br><span class="line"></span><br><span class="line">    SetWindowRedraw(hwndList, TRUE); <span class="comment">//重绘组合列表框</span></span><br><span class="line">    InvalidateRect(hwndList, <span class="literal">NULL</span>, FALSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//获取令牌提升的类型及判断当前进程是否以管理员身份运行</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetProcessElevation</span><span class="params">(TOKEN_ELEVATION_TYPE* pElevationType, BOOL* pIsAdmin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE  hToken = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD   dwSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得当前进程的Token</span></span><br><span class="line">    <span class="keyword">if</span> (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &amp;hToken))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    BOOL bResult = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取提升类型</span></span><br><span class="line">    <span class="keyword">if</span> (GetTokenInformation(hToken,TokenElevationType,pElevationType,</span><br><span class="line">                                 <span class="keyword">sizeof</span>(TOKEN_ELEVATION_TYPE),&amp;dwSize))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建管理员组的SID</span></span><br><span class="line">        byte adminSID[SECURITY_MAX_SID_SIZE];</span><br><span class="line">        dwSize = <span class="keyword">sizeof</span>(adminSID);</span><br><span class="line">        CreateWellKnownSid(WinBuiltinAdministratorsSid, <span class="literal">NULL</span>, &amp;adminSID, &amp;dwSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//筛选令牌</span></span><br><span class="line">        <span class="keyword">if</span> (*pElevationType == TokenElevationTypeLimited)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//取得与筛选令牌关联的未筛选令牌</span></span><br><span class="line">            HANDLE hUnfilteredToken = <span class="literal">NULL</span>;</span><br><span class="line">            GetTokenInformation(hToken, TokenLinkedToken,</span><br><span class="line">                (LPVOID)&amp;hUnfilteredToken, <span class="keyword">sizeof</span>(HANDLE), &amp;dwSize);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过初始未被筛选的令牌判断是否包含管理员SID</span></span><br><span class="line">            <span class="keyword">if</span> (CheckTokenMembership(hUnfilteredToken, &amp;adminSID, pIsAdmin))</span><br><span class="line">                bResult = TRUE;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//关闭未筛选的令牌</span></span><br><span class="line">            CloseHandle(hUnfilteredToken);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>   <span class="comment">//非筛选令牌</span></span><br><span class="line">        &#123;</span><br><span class="line">            *pIsAdmin = IsUserAnAdmin();</span><br><span class="line">            bResult = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭当前进程的令牌</span></span><br><span class="line">    CloseHandle(hToken);</span><br><span class="line">    <span class="keyword">return</span> bResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//手动提升权限</span></span><br><span class="line"><span class="function">DWORD <span class="title">StartElevatedProcess</span><span class="params">(LPCTSTR szExecutable, LPCTSTR szCmdLine)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化结构体</span></span><br><span class="line">    SHELLEXECUTEINFO sei = &#123; <span class="keyword">sizeof</span>(SHELLEXECUTEINFO) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求管理员身份</span></span><br><span class="line">    sei.lpVerb = TEXT(<span class="string">"runas"</span>); <span class="comment">//run administrator?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入要提高权限的应用程序名</span></span><br><span class="line">    sei.lpFile = szExecutable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入命令行参数</span></span><br><span class="line">    sei.lpParameters = szCmdLine;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//窗口正常显示，否则新启动的进程，其窗口将被隐藏</span></span><br><span class="line">    sei.nShow = SW_SHOWNORMAL;</span><br><span class="line"></span><br><span class="line">    ShellExecuteEx(&amp;sei);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (GetLastError());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PEB(Process Environment Block)是一个未公开的结构体</span></span><br><span class="line"><span class="comment">https://msdn.microsoft.com/en-us/library/windows/desktop/aa813741(v=vs.85).aspx</span></span><br><span class="line"><span class="comment">typedef struct _PEB &#123;</span></span><br><span class="line"><span class="comment">    BYTE                          Reserved1[2];   //2字节</span></span><br><span class="line"><span class="comment">    BYTE                          BeingDebugged;  //1</span></span><br><span class="line"><span class="comment">    BYTE                          Reserved2[1];   //1</span></span><br><span class="line"><span class="comment">    PVOID                         Reserved3[2];   //2*4=8</span></span><br><span class="line"><span class="comment">    PPEB_LDR_DATA                 Ldr;            //4</span></span><br><span class="line"><span class="comment">    PRTL_USER_PROCESS_PARAMETERS  ProcessParameters; //进程参数，如command line</span></span><br><span class="line"><span class="comment">    BYTE                          Reserved4[104];</span></span><br><span class="line"><span class="comment">    PVOID                         Reserved5[52];</span></span><br><span class="line"><span class="comment">    PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;</span></span><br><span class="line"><span class="comment">    BYTE                          Reserved6[128];</span></span><br><span class="line"><span class="comment">    PVOID                         Reserved7[1];</span></span><br><span class="line"><span class="comment">    ULONG                         SessionId;</span></span><br><span class="line"><span class="comment">&#125; PEB, *PPEB;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">typedef struct _RTL_USER_PROCESS_PARAMETERS &#123;</span></span><br><span class="line"><span class="comment">    BYTE           Reserved1[16]; //16字节</span></span><br><span class="line"><span class="comment">    PVOID          Reserved2[10]; //10*4=40字节</span></span><br><span class="line"><span class="comment">    UNICODE_STRING ImagePathName; //2+2+4字节，进程映射文件的路径</span></span><br><span class="line"><span class="comment">    UNICODE_STRING CommandLine;   //2+2+4字节，其中最后4字节为命令行参数指针</span></span><br><span class="line"><span class="comment">&#125; RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//以上两个结构体的简化版本分别如下，</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  _<span class="title">tag_PEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD Filler[<span class="number">4</span>];  <span class="comment">//用来填充的，4*4=16字节</span></span><br><span class="line">    DWORD InfoBlockAddress; <span class="comment">//进程命令行</span></span><br><span class="line">&#125;__PEB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_INFOBLOCK</span> &#123;</span></span><br><span class="line">    DWORD Filler[<span class="number">17</span>]; <span class="comment">//17*4=68字节填充</span></span><br><span class="line">    DWORD wszCmdLineAddress;</span><br><span class="line">&#125;__INFOBLOCK;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NtQueryInformationProcess在winternl.h中定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(CALLBACK* PFN_NTQUERYINFORMATIONPROCESS)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">                PROCESSINFOCLASS ProcessInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                PVOID ProcessInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">                ULONG ProcessInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">                PULONG ReturnLength OPTIONAL)</span></span>;</span><br><span class="line"></span><br><span class="line">NTSTATUS _NtQueryInformationProcess(</span><br><span class="line">    HANDLE hProcess,</span><br><span class="line">    PROCESSINFOCLASS pic,</span><br><span class="line">    PVOID pPI,</span><br><span class="line">    ULONG cbSize,</span><br><span class="line">    PULONG pLength)</span><br><span class="line">&#123;</span><br><span class="line">    HMODULE hNtDll = LoadLibrary(TEXT(<span class="string">"ntdll.dll"</span>));</span><br><span class="line">    <span class="keyword">if</span> (hNtDll == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    NTSTATUS lStatus = <span class="number">-1</span>;  <span class="comment">//默认的错误代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意，以下函数名是非Unicode的</span></span><br><span class="line">    PFN_NTQUERYINFORMATIONPROCESS pfnNtQIP =</span><br><span class="line">        (PFN_NTQUERYINFORMATIONPROCESS)GetProcAddress(hNtDll, <span class="string">"NtQueryInformationProcess"</span>);</span><br><span class="line">    <span class="keyword">if</span> (pfnNtQIP!=<span class="literal">NULL</span>)</span><br><span class="line">        lStatus = pfnNtQIP(hProcess, pic, pPI, cbSize, pLength);</span><br><span class="line">    </span><br><span class="line">    FreeLibrary(hNtDll);</span><br><span class="line">    <span class="keyword">return</span> lStatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PROCESS_BASIC_INFORMATION：</span></span><br><span class="line"><span class="comment">typedef struct</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    DWORD ExitStatus; // 接收进程终止状态</span></span><br><span class="line"><span class="comment">    DWORD PebBaseAddress; // 接收进程环境块地址</span></span><br><span class="line"><span class="comment">    DWORD AffinityMask; // 接收进程关联掩码</span></span><br><span class="line"><span class="comment">    DWORD BasePriority; // 接收进程的优先级类</span></span><br><span class="line"><span class="comment">    ULONG UniqueProcessId; // 接收进程ID</span></span><br><span class="line"><span class="comment">    ULONG InheritedFromUniqueProcessId; //接收父进程ID</span></span><br><span class="line"><span class="comment">&#125; PROCESS_BASIC_INFORMATION;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetProcessCmdLine</span><span class="params">(HANDLE hProcess, LPTSTR szCmdLine, DWORD Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((hProcess == <span class="literal">NULL</span>) || (szCmdLine == <span class="literal">NULL</span>) || (Size == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//0：获取环境块地址</span></span><br><span class="line">    <span class="keyword">int</span> iReturn = <span class="number">1</span>;</span><br><span class="line">    DWORD dwSize;</span><br><span class="line">    SIZE_T size;</span><br><span class="line"></span><br><span class="line">    PROCESS_BASIC_INFORMATION pbi;</span><br><span class="line">    <span class="comment">//可以将指定类型的进程信息拷贝到pbi所指向的缓冲区</span></span><br><span class="line">    <span class="comment">//XP中PEB的地址总是在0x7FFDF000，但Vista以后就不一定了</span></span><br><span class="line">    iReturn = _NtQueryInformationProcess(     <span class="comment">//见上面的定义部分</span></span><br><span class="line">        hProcess, ProcessBasicInformation, &amp;pbi, <span class="keyword">sizeof</span>(pbi), &amp;dwSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//NtQueryInformationProcess失败时将返回负数</span></span><br><span class="line">    <span class="keyword">if</span> (iReturn&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//1.查找进程环境块PEB</span></span><br><span class="line">        __PEB PEB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//size = dwSize;</span></span><br><span class="line">        <span class="comment">/*ReadProcessMemory各参数：</span></span><br><span class="line"><span class="comment">         hProcess [in]要读取的另一个进程句柄</span></span><br><span class="line"><span class="comment">         pvAddressRemote [in]要读取另一个进程的内存地址。 从具体何处读取</span></span><br><span class="line"><span class="comment">         pvBufferLocal [out]本地进程中内存地址. 函数将读取的内容写入此处</span></span><br><span class="line"><span class="comment">        dwSize [in]要传送的字节数。要写入多少</span></span><br><span class="line"><span class="comment">        pdwNumBytesRead [out]实际传送的字节数. 函数返回时报告实际写入多少</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (!ReadProcessMemory(hProcess, pbi.PebBaseAddress, &amp;PEB,</span><br><span class="line">            <span class="keyword">sizeof</span>(PEB), &amp;size))</span><br><span class="line">            <span class="keyword">return</span> FALSE; <span class="comment">//如果有需要也可以GetLastError</span></span><br><span class="line">        <span class="comment">//2.从PEB中获取指向一个包含CmdLine指针的信息块</span></span><br><span class="line">        __INFOBLOCK Block;</span><br><span class="line">        <span class="keyword">if</span> (!ReadProcessMemory(hProcess, (LPVOID)PEB.InfoBlockAddress,</span><br><span class="line">            &amp;Block, <span class="keyword">sizeof</span>(Block), &amp;size))</span><br><span class="line">            <span class="keyword">return</span> FALSE;  <span class="comment">//如果有需要也可以GetLastError</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取指定进程的命令行参数</span></span><br><span class="line">        <span class="keyword">wchar_t</span> wszCmdLine[MAX_PATH + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!ReadProcessMemory(hProcess, (LPVOID)Block.wszCmdLineAddress,</span><br><span class="line">            wszCmdLine,MAX_PATH*<span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>), &amp;size))</span><br><span class="line">            <span class="keyword">return</span> FALSE;  <span class="comment">//如果有需要也可以GetLastError</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.跳过应用程序名</span></span><br><span class="line">        <span class="comment">//    可能是空的，"C:\...\app.exe" </span></span><br><span class="line">        <span class="keyword">wchar_t</span>*  pPos = wszCmdLine;</span><br><span class="line">        if (*pPos!=L'0')</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*pPos==<span class="string">'"'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到下一个"字符</span></span><br><span class="line">                pPos = wcschr(&amp;pPos[<span class="number">1</span>], L'<span class="string">"');</span></span><br><span class="line"><span class="string">            &#125; else&#123;</span></span><br><span class="line"><span class="string">                //查找下一个空格</span></span><br><span class="line"><span class="string">                pPos = wcschr(&amp;pPos[1], L' ');</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            //跳过"</span>或空格字符，找到命令行真正的参数（除应用程序自身路径及文件名外）</span><br><span class="line">            <span class="keyword">if</span> (pPos != <span class="literal">NULL</span>)</span><br><span class="line">                pPos++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拷贝到szCmdLine参数所指定的缓冲区中</span></span><br><span class="line">        <span class="keyword">if</span> (pPos!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*pPos != L'\<span class="number">0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">#ifdef UNICODE</span><br><span class="line">                <span class="comment">//两者都是Unicode，（环境块的命令行永远是UNICODE）</span></span><br><span class="line">                _tcscpy_s(szCmdLine, Size, pPos);</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">                <span class="comment">//from Unicode to Ansi</span></span><br><span class="line">                MultiByteToWideChar(CP_ACP, <span class="number">0</span>, szCmdLine, Size, pPos, wcslen(pPos));</span><br><span class="line">#endif</span><br><span class="line">            &#125; <span class="keyword">else</span> szCmdLine[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> szCmdLine[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL GetProcessCmdLine(DWORD PID, LPTSTR szCmdLine, DWORD Size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((PID &lt;= <span class="number">0</span>) || (szCmdLine == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否可以获取到进程信息</span></span><br><span class="line">    HANDLE hProcess =</span><br><span class="line">        OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, PID);</span><br><span class="line">    <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    BOOL bReturn = GetProcessCmdLine(hProcess, szCmdLine, Size);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hProcess); <span class="comment">//关闭句柄</span></span><br><span class="line">    <span class="keyword">return</span> bReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">BOOL GetProcessOwner(HANDLE hProcess, LPTSTR szOwner, <span class="keyword">size_t</span> cchSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//合法性检查</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="literal">NULL</span> == szOwner) || (cchSize == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认值</span></span><br><span class="line">    szOwner[<span class="number">0</span>] = TEXT(<span class="string">'\0'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取进程的令牌</span></span><br><span class="line">    HANDLE hToken = <span class="literal">NULL</span>;</span><br><span class="line">    CToolhelp::EnablePrivilege(SE_TCB_NAME, TRUE);</span><br><span class="line">    <span class="keyword">if</span> (!OpenProcessToken(hProcess,TOKEN_QUERY,&amp;hToken))</span><br><span class="line">    &#123;</span><br><span class="line">        CToolhelp::EnablePrivilege(SE_TCB_NAME, FALSE);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD cbti = <span class="number">0</span>;</span><br><span class="line">    PTOKEN_USER ptiUser = (PTOKEN_USER)CToolhelp::RetrieveTokenInformationClass(hToken, </span><br><span class="line">                                                TokenUser,&amp;cbti);</span><br><span class="line">    <span class="keyword">if</span> (ptiUser!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SID_NAME_USE snu;</span><br><span class="line">        TCHAR szUser[MAX_PATH];</span><br><span class="line">        DWORD chUser = MAX_PATH;</span><br><span class="line">        PDWORD  pcchUser = &amp;chUser;</span><br><span class="line">        TCHAR  szDomain[MAX_PATH];</span><br><span class="line">        DWORD  chDomain = MAX_PATH;</span><br><span class="line">        PDWORD pcchDomain = &amp;chDomain;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从用户SID去用户名和域名</span></span><br><span class="line">        <span class="keyword">if</span> (LookupAccountSid(<span class="literal">NULL</span>,</span><br><span class="line">                    ptiUser-&gt;User.Sid,</span><br><span class="line">                    szUser,</span><br><span class="line">                    pcchUser,</span><br><span class="line">                    szDomain,</span><br><span class="line">                    pcchDomain,</span><br><span class="line">                    &amp;snu</span><br><span class="line">                    ))</span><br><span class="line">        &#123;</span><br><span class="line">               <span class="comment">//创建属主字符串，比如\\DomainName\UserName</span></span><br><span class="line">            _tcscpy_s(szOwner, cchSize, TEXT(<span class="string">"\\\\"</span>));</span><br><span class="line">            _tcscat_s(szOwner, cchSize, szDomain);</span><br><span class="line">            _tcscat_s(szOwner, cchSize, TEXT(<span class="string">"\\"</span>));</span><br><span class="line">            _tcscat_s(szOwner, cchSize, szUser);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CToolhelp::FreeTokenInformation((PVOID*)&amp;ptiUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CloseHandle(hToken);</span><br><span class="line">    CToolhelp::EnablePrivilege(SE_TCB_NAME, FALSE);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL GetProcessOwner(DWORD PID, LPTSTR szOwner, DWORD cchSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//合法性检查</span></span><br><span class="line">    <span class="keyword">if</span> ((PID &lt;= <span class="number">0</span>) || (szOwner == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否可以获得进程的信息</span></span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, PID);</span><br><span class="line">    <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    BOOL bReturn = GetProcessOwner(hProcess, szOwner, cchSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭进程句柄</span></span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//dwProcessID:进程ID；pvModuleRemote进程中指定模块的地址</span></span><br><span class="line"><span class="comment">//返回模块首选的基地址</span></span><br><span class="line">PVOID GetModulePreferredBaseAddr(DWORD dwProcessID, PVOID pvModuleRemote)&#123;</span><br><span class="line">    PVOID pvModulePreferredBaseAddr = <span class="literal">NULL</span>;</span><br><span class="line">    IMAGE_DOS_HEADER  idh;</span><br><span class="line">    IMAGE_NT_HEADERS  inth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取远程模块的DOS头</span></span><br><span class="line">    Toolhelp32ReadProcessMemory(dwProcessID, pvModuleRemote, &amp;idh, <span class="keyword">sizeof</span>(idh), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证是否是DOS头部</span></span><br><span class="line">    <span class="keyword">if</span> (idh.e_magic == IMAGE_DOS_SIGNATURE)&#123;</span><br><span class="line">        <span class="comment">//读取远程模块的NT头</span></span><br><span class="line">        Toolhelp32ReadProcessMemory(dwProcessID, (PBYTE)pvModuleRemote + idh.e_lfanew, &amp;inth,</span><br><span class="line">                                    <span class="keyword">sizeof</span>(inth), <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//验证是否是NT image header</span></span><br><span class="line">        <span class="keyword">if</span> (inth.Signature == IMAGE_NT_SIGNATURE)&#123;</span><br><span class="line">            <span class="comment">//有效的NT头，获取首先的基地址</span></span><br><span class="line">            pvModulePreferredBaseAddr = (PVOID)inth.OptionalHeader.ImageBase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (pvModulePreferredBaseAddr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//hwnd：进程信息要显示的窗口，dwProcessID进程ID</span></span><br><span class="line">VOID ShowProcessInfo(HWND hwnd, DWORD dwProcessID)</span><br><span class="line">&#123;</span><br><span class="line">    SetWindowText(hwnd, TEXT(<span class="string">""</span>)); <span class="comment">//清除编辑框的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//SNAP-ALL,在快照中包含系统中所有的进程和线程,再加上指定的进程中所有堆和所有模块</span></span><br><span class="line">    CToolhelp th(TH32CS_SNAPALL, dwProcessID); <span class="comment">//SNAP-ALL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示进程详细的信息</span></span><br><span class="line">    PROCESSENTRY32 pe = &#123; <span class="keyword">sizeof</span>(pe) &#125;;</span><br><span class="line">    BOOL fOk = th.ProcessFirst(&amp;pe);</span><br><span class="line">    <span class="keyword">for</span> (; fOk; fOk = th.ProcessNext(&amp;pe))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pe.th32ProcessID == dwProcessID)</span><br><span class="line">        &#123;</span><br><span class="line">            TCHAR szCmdLine[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">if</span> (GetProcessCmdLine(dwProcessID, szCmdLine, _countof(szCmdLine)))</span><br><span class="line">            &#123;</span><br><span class="line">                AddText(hwnd,</span><br><span class="line">                        TEXT(<span class="string">"CommandLine:%s %s\r\n"</span>), pe.szExeFile, szCmdLine);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                AddText(hwnd,</span><br><span class="line">                        TEXT(<span class="string">"FileName:%s\r\n"</span>), pe.szExeFile);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AddText(hwnd, TEXT(<span class="string">"  PID=%08X, ParentPID=%08X, "</span>)</span><br><span class="line">                    TEXT(<span class="string">"PriorityClass=%d, Threads=%d, Heaps=%d\r\n"</span>),</span><br><span class="line">                    pe.th32ProcessID, pe.th32ParentProcessID,</span><br><span class="line">                    pe.pcPriClassBase, pe.cntThreads, th.HowManyHeaps());</span><br><span class="line">            TCHAR szOwner[MAX_PATH + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (GetProcessOwner(dwProcessID, szOwner, MAX_PATH))</span><br><span class="line">                AddText(hwnd, TEXT(<span class="string">"Owner:%s\r\n"</span>), szOwner);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示指定进程中所有的模块    </span></span><br><span class="line">    AddText(hwnd, TEXT(<span class="string">"\r\nModules Information:\r\n"</span>)</span><br><span class="line">            TEXT(<span class="string">"  Usage  %-*s(%-*s)  %10s   Module\r\n"</span>),</span><br><span class="line">            s_cchAddress, TEXT(<span class="string">"BaseAddr"</span>),</span><br><span class="line">            s_cchAddress, TEXT(<span class="string">"ImagAddr"</span>), TEXT(<span class="string">"Size"</span>));</span><br><span class="line"></span><br><span class="line">    MODULEENTRY32 me = &#123; <span class="keyword">sizeof</span>(me) &#125;;</span><br><span class="line">    fOk = th.ModuleFirst(&amp;me);</span><br><span class="line">    <span class="keyword">for</span> (; fOk; fOk = th.ModuleNext(&amp;me))&#123;</span><br><span class="line">        <span class="keyword">if</span> (me.ProccntUsage == <span class="number">65535</span>)&#123;  <span class="comment">//全局模块的使用计数。通常这一项也是没有意义的，被设置为0xFFFF。</span></span><br><span class="line">            <span class="comment">//表示该模块是显式加载的而且不能被卸载</span></span><br><span class="line">            AddText(hwnd, TEXT(<span class="string">"  Fixed"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            AddText(hwnd, TEXT(<span class="string">"  %5d"</span>), me.ProccntUsage); <span class="comment">//使用计数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//格式化size字段（单位kb);</span></span><br><span class="line">        TCHAR szFormattedSize[<span class="number">64</span>];</span><br><span class="line">        <span class="comment">//将数字转化为字符串，单位为Kb </span></span><br><span class="line">        <span class="comment">//第1个参数：要转换的数字；第2个参数：接收缓冲区；第3个参数：缓冲区大小（字符为单位）</span></span><br><span class="line">        <span class="keyword">if</span> (StrFormatKBSize(me.modBaseSize, szFormattedSize, _countof(szFormattedSize)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            StringCchPrintf(szFormattedSize, _countof(szFormattedSize),</span><br><span class="line">                            TEXT(<span class="string">"%10u"</span>), me.modBaseSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PVOID pvPreferredBaseAddr =</span><br><span class="line">            GetModulePreferredBaseAddr(pe.th32ProcessID, me.modBaseAddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (me.modBaseAddr == pvPreferredBaseAddr)&#123;</span><br><span class="line">            AddText(hwnd, TEXT(<span class="string">"  %p %*s   %10s  %s\r\n"</span>),</span><br><span class="line">                    me.modBaseAddr, s_cchAddress, TEXT(<span class="string">""</span>), szFormattedSize, me.szExePath);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            AddText(hwnd, TEXT(<span class="string">"  %p(%p)   %10s  %s\r\n"</span>),</span><br><span class="line">                    me.modBaseAddr, pvPreferredBaseAddr, szFormattedSize, me.szExePath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示进程中的线程信息</span></span><br><span class="line">    AddText(hwnd, TEXT(<span class="string">"\r\nThread Information:\r\n"</span>)</span><br><span class="line">                  TEXT(<span class="string">"     TID       Priority\r\n"</span>));</span><br><span class="line">    THREADENTRY32 te = &#123; <span class="keyword">sizeof</span>(te) &#125;;</span><br><span class="line">    fOk = th.ThreadFirst(&amp;te);</span><br><span class="line">    <span class="keyword">for</span> (; fOk;fOk=th.ThreadNext(&amp;te))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (te.th32OwnerProcessID == dwProcessID)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nPriority = te.tpBasePri + te.tpDeltaPri;</span><br><span class="line">            <span class="keyword">if</span> ((te.tpBasePri&lt;<span class="number">16</span>) &amp;&amp; (nPriority&gt;<span class="number">15</span>)) nPriority = <span class="number">15</span>;</span><br><span class="line">            <span class="keyword">if</span> ((te.tpBasePri&gt;<span class="number">15</span>) &amp;&amp; (nPriority&gt;<span class="number">31</span>)) nPriority = <span class="number">31</span>;</span><br><span class="line">            <span class="keyword">if</span> ((te.tpBasePri&lt;<span class="number">16</span>) &amp;&amp; (nPriority&lt;<span class="number">1</span> )) nPriority =  <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((te.tpBasePri&gt;<span class="number">15</span>) &amp;&amp; (nPriority&lt;<span class="number">16</span>)) nPriority = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">            AddText(hwnd, TEXT(<span class="string">"  %08X       %2d\r\n"</span>),</span><br><span class="line">                    te.th32ThreadID,nPriority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//显示模块被哪些进程加载</span></span><br><span class="line">VOID ShowModuleInfo(HWND hwnd, PCTSTR pszModulePath)</span><br><span class="line">&#123;</span><br><span class="line">    SetWindowText(hwnd, TEXT(<span class="string">""</span>)); <span class="comment">//清除编辑框内容</span></span><br><span class="line"></span><br><span class="line">    CToolhelp thProcesses(TH32CS_SNAPPROCESS);</span><br><span class="line">    PROCESSENTRY32 pe = &#123; <span class="keyword">sizeof</span>(pe) &#125;;</span><br><span class="line">    BOOL fOk = thProcesses.ProcessFirst(&amp;pe);</span><br><span class="line">    AddText(hwnd, TEXT(<span class="string">"PathName:%s\r\n\r\n"</span>), pszModulePath);</span><br><span class="line">    AddText(hwnd, TEXT(<span class="string">"Process Information:\r\n"</span>));</span><br><span class="line">    AddText(hwnd, TEXT(<span class="string">"     PID    %-*s  Process\r\n"</span>), s_cchAddress, TEXT(<span class="string">"BaseAddr"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; fOk;fOk=thProcesses.ProcessNext(&amp;pe))&#123;</span><br><span class="line">        CToolhelp thModules(TH32CS_SNAPMODULE, pe.th32ProcessID);</span><br><span class="line">        MODULEENTRY32 me = &#123; <span class="keyword">sizeof</span>(me) &#125;;</span><br><span class="line">        BOOL fOk = thModules.ModuleFirst(&amp;me);</span><br><span class="line">        <span class="keyword">for</span> (; fOk;fOk=thModules.ModuleNext(&amp;me))&#123;</span><br><span class="line">            <span class="comment">//查找指定的模块被哪些进程加载</span></span><br><span class="line">            <span class="keyword">if</span> (_tcscmp(pszModulePath,me.szExePath) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//显示被加载到的进程ID，模块的基地址及进程名称</span></span><br><span class="line">                AddText(hwnd, TEXT(<span class="string">"  %08X  %p  %s\r\n"</span>),</span><br><span class="line">                        pe.th32ProcessID,me.modBaseAddr,pe.szExeFile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">void</span> Dlg_OnCommand(HWND hwnd, <span class="keyword">int</span> id, HWND hwndCtrl, UINT codeNotify)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> BOOL s_fProcesses = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (id)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> IDCANCEL:</span><br><span class="line">        EndDialog(hwnd, id);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以管理员身份重启应用程序</span></span><br><span class="line">    <span class="keyword">case</span> IDC_BTN_SYSTEM_PROCESSES:&#123;  <span class="comment">//case分支里定义变量，要加大括号！</span></span><br><span class="line">            <span class="comment">//在提升权限之前先隐藏自己</span></span><br><span class="line">            ShowWindow(hwnd, SW_HIDE);</span><br><span class="line"></span><br><span class="line">            TCHAR szApplication[MAX_PATH];</span><br><span class="line">            DWORD  cchLength = _countof(szApplication);</span><br><span class="line">            <span class="comment">//获取进程的完整映射名称</span></span><br><span class="line">            <span class="comment">//第2个参为0表示使用Win32路径格式,PROCESS_NAME_NATIVE,表示使用本地系统路径格式</span></span><br><span class="line">            <span class="comment">//第4个参数：返回字符串中字符的个数（不含\0)</span></span><br><span class="line">            QueryFullProcessImageName(GetCurrentProcess(), <span class="number">0</span>, szApplication, &amp;cchLength);</span><br><span class="line"></span><br><span class="line">            DWORD dwStatus = StartElevatedProcess(szApplication, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dwStatus == S_OK)</span><br><span class="line">                ExitProcess(<span class="number">0</span>);  <span class="comment">//退出本进程</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//否则，新进程如果启动失败时，重新显示本进程的主窗口</span></span><br><span class="line">            ShowWindow(hwnd, SW_SHOWNORMAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IDM_PROCESSES: <span class="comment">//Processes菜单项</span></span><br><span class="line">        s_fProcesses = TRUE;              </span><br><span class="line">        EnableMenuItem(GetMenu(hwnd), IDM_VMMAP, MF_BYCOMMAND | MF_ENABLED);<span class="comment">//MF_BYCOMMAND：通过ID定位</span></span><br><span class="line">        DrawMenuBar(hwnd);</span><br><span class="line">        Dlg_PopulateProcessList(hwnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IDM_MODULES:   <span class="comment">//Modules菜单项</span></span><br><span class="line">        EnableMenuItem(GetMenu(hwnd), IDM_VMMAP, MF_BYCOMMAND | MF_GRAYED);</span><br><span class="line">        DrawMenuBar(hwnd);</span><br><span class="line">        s_fProcesses = FALSE;</span><br><span class="line"></span><br><span class="line">        Dlg_PopulateModuleList(hwnd);        </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//会用到第14章虚拟内存映射的小程序，用来遍历进程的地址空间，并列出区域及区域内的块</span></span><br><span class="line">    <span class="keyword">case</span> IDM_VMMAP:     <span class="comment">//VMMAP菜单项</span></span><br><span class="line">        &#123;</span><br><span class="line">            TCHAR szCmdLine[<span class="number">32</span>];</span><br><span class="line">            HWND hwndCB = GetDlgItem(hwnd, IDC_PROCESSMODULELIST); <span class="comment">//下拉列表框</span></span><br><span class="line">            DWORD dwProcessID = (DWORD)</span><br><span class="line">                ComboBox_GetItemData(hwndCB, ComboBox_GetCurSel(hwndCB));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//命令行参数中传入所选的进程ID</span></span><br><span class="line">            StringCchPrintf(szCmdLine, _countof(szCmdLine), TEXT(<span class="string">"%d"</span>), dwProcessID);</span><br><span class="line"></span><br><span class="line">            DWORD dwStatus =             <span class="comment">//"14-VMMap.exe"</span></span><br><span class="line">                StartElevatedProcess(TEXT(<span class="string">"\"14-VMMap.exe\""</span>), szCmdLine);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//以管理员身份运行14-VMMap.exe程序时，会进行提升权限的询问，如果是用户拒绝</span></span><br><span class="line">            <span class="comment">//则显示下列消息框。</span></span><br><span class="line">            <span class="keyword">if</span> (dwStatus == ERROR_CANCELLED)</span><br><span class="line">                chMB(<span class="string">"Failed to run 14-VMMAP.exe: you refused access."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IDC_PROCESSMODULELIST:</span><br><span class="line">        <span class="keyword">if</span> (codeNotify == CBN_SELCHANGE)</span><br><span class="line">        &#123;</span><br><span class="line">            DWORD dw = ComboBox_GetCurSel(hwndCtrl);</span><br><span class="line">            dw = (DWORD)ComboBox_GetItemData(hwndCtrl, dw); <span class="comment">//ProcessID</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s_fProcesses)&#123;</span><br><span class="line">                ShowProcessInfo(GetDlgItem(hwnd, IDC_RESULTS), dw);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TCHAR szMoudlePath[<span class="number">1024</span>];</span><br><span class="line">                ListBox_GetText(GetDlgItem(hwnd, IDC_MODULEHELP), dw, szMoudlePath);</span><br><span class="line">                ShowModuleInfo(GetDlgItem(hwnd, IDC_RESULTS), szMoudlePath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">BOOL Dlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">    chSETDLGICONS(hwnd, IDI_PROCESSINFO);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当提升权限或禁用UAC时，管理员特权被设置为TRUE</span></span><br><span class="line">    BOOL bCanReadSystemProcesses = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示是否正在运行“Filter Token”</span></span><br><span class="line">    <span class="keyword">if</span> (GetProcessElevation(&amp;s_elevationType, &amp;s_bIsAdmin))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提升标题的前缀</span></span><br><span class="line">        TCHAR szTitle[<span class="number">64</span>];</span><br><span class="line">        <span class="keyword">switch</span> (s_elevationType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//默认用户或禁用UAC</span></span><br><span class="line">        <span class="keyword">case</span> TokenElevationTypeDefault:</span><br><span class="line">            <span class="keyword">if</span> (IsUserAnAdmin())&#123;</span><br><span class="line">                _tcscpy_s(szTitle, _countof(szTitle), TEXT(<span class="string">"Default Administrator:"</span>));</span><br><span class="line">                bCanReadSystemProcesses = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                _tcscpy_s(szTitle, _countof(szTitle), TEXT(<span class="string">"Default:"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//进程权限被提升成功</span></span><br><span class="line">        <span class="keyword">case</span> TokenElevationTypeFull:</span><br><span class="line">            <span class="keyword">if</span> (IsUserAnAdmin())&#123;</span><br><span class="line">                _tcscpy_s(szTitle, _countof(szTitle), TEXT(<span class="string">"Elevated Administrator:"</span>));</span><br><span class="line">                bCanReadSystemProcesses = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                _tcscpy_s(szTitle, _countof(szTitle), TEXT(<span class="string">"Elevated:"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//进程运行于受限（筛选令牌）下</span></span><br><span class="line">        <span class="keyword">case</span> TokenElevationTypeLimited:</span><br><span class="line">            <span class="keyword">if</span> (IsUserAnAdmin())&#123;</span><br><span class="line">                _tcscpy_s(szTitle, _countof(szTitle), TEXT(<span class="string">"Filtered Administrator:"</span>));</span><br><span class="line">                bCanReadSystemProcesses = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                _tcscpy_s(szTitle, _countof(szTitle), TEXT(<span class="string">"Filtered:"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据提升类型更新对话框标题</span></span><br><span class="line">        GetWindowText(hwnd, _tcschr(szTitle, TEXT(<span class="string">'\0'</span>)), </span><br><span class="line">                       _countof(szTitle)-_tcslen(szTitle));</span><br><span class="line">        SetWindowText(hwnd, szTitle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增加“循牌”图标，以允许用户以提升的权限来运行程序</span></span><br><span class="line">        <span class="keyword">if</span> (!bCanReadSystemProcesses)&#123;</span><br><span class="line">            <span class="comment">//SendMessage(hwndCtrl, BCM_SETSHIELD, 0, (LPARAM)fRequired)</span></span><br><span class="line">            Button_SetElevationRequiredState(</span><br><span class="line">                GetDlgItem(hwnd, IDC_BTN_SYSTEM_PROCESSES),</span><br><span class="line">                !bCanReadSystemProcesses);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//己经提升权类，则隐茂按钮</span></span><br><span class="line">            ShowWindow(GetDlgItem(hwnd, IDC_BTN_SYSTEM_PROCESSES), SW_HIDE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将组合列表框扩展到整个对话框的宽度</span></span><br><span class="line">            MoveWindow(GetDlgItem(hwnd, IDC_BTN_SYSTEM_PROCESSES),</span><br><span class="line">                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, FALSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//隐藏“模块帮助”列表框</span></span><br><span class="line">    ShowWindow(GetDlgItem(hwnd, IDC_MODULEHELP), SW_HIDE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使输出窗口使用等宽字体</span></span><br><span class="line">    SetWindowFont(GetDlgItem(hwnd, IDC_RESULTS), </span><br><span class="line">             GetStockFont(ANSI_FIXED_FONT),FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认下，显示运行中的进程</span></span><br><span class="line">    Dlg_PopulateProcessList(hwnd);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">BOOL Dlg_OnSize(HWND hwnd, UINT state, <span class="keyword">int</span> cx, <span class="keyword">int</span> cy)</span><br><span class="line">&#123;</span><br><span class="line">    RECT  btnRect;</span><br><span class="line">    HWND hwndCtrl = GetDlgItem(hwnd, IDC_BTN_SYSTEM_PROCESSES);</span><br><span class="line">    GetClientRect(hwndCtrl, &amp;btnRect);</span><br><span class="line"></span><br><span class="line">    RECT rc;</span><br><span class="line">    <span class="keyword">int</span> n = LOWORD(GetDialogBaseUnits()); <span class="comment">//字符的宽度</span></span><br><span class="line"></span><br><span class="line">    hwndCtrl = GetDlgItem(hwnd, IDC_PROCESSMODULELIST);</span><br><span class="line">    GetClientRect(hwndCtrl, &amp;rc);</span><br><span class="line"></span><br><span class="line">    SetWindowPos(hwndCtrl, <span class="literal">NULL</span>,</span><br><span class="line">                 n+n + btnRect.right, <span class="comment">//x=按钮宽度+一个字符宽</span></span><br><span class="line">                 n,                 <span class="comment">//y=一个字符的高度</span></span><br><span class="line">                 cx - n - n -n - btnRect.right,<span class="comment">//Combox宽度，右边距留一字符宽度</span></span><br><span class="line">                 rc.bottom, </span><br><span class="line">                 SWP_NOZORDER);</span><br><span class="line"></span><br><span class="line">    hwndCtrl = GetDlgItem(hwnd, IDC_RESULTS);</span><br><span class="line">    SetWindowPos(hwndCtrl, <span class="literal">NULL</span>,</span><br><span class="line">                 n,</span><br><span class="line">                 n + rc.bottom + n,</span><br><span class="line">                 cx - n - n,</span><br><span class="line">                 cy - (n + rc.bottom + n) - n,</span><br><span class="line">                SWP_NOZORDER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">INT_PTR WINAPI Dlg_Proc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">        chHANDLE_DLGMSG(hwnd, WM_INITDIALOG, Dlg_OnInitDialog);</span><br><span class="line">        chHANDLE_DLGMSG(hwnd, WM_SIZE, Dlg_OnSize);</span><br><span class="line">        chHANDLE_DLGMSG(hwnd, WM_COMMAND, Dlg_OnCommand);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">int</span> WINAPI _tWinMain(HINSTANCE hInstanceExe, HINSTANCE, PTSTR pszCmdLine, <span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//打开调试权限以允许应用程序查看服务应用</span></span><br><span class="line">    CToolhelp::EnablePrivilege(SE_DEBUG_NAME, TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开访问SACL权限</span></span><br><span class="line">    CToolhelp::EnablePrivilege(SE_SECURITY_NAME, TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示主窗口</span></span><br><span class="line">    DialogBox(hInstanceExe, MAKEINTRESOURCE(IDD_PROCESSINFO), <span class="literal">NULL</span>, Dlg_Proc);</span><br><span class="line"></span><br><span class="line">    CToolhelp::EnablePrivilege(SE_DEBUG_NAME, FALSE);</span><br><span class="line">    CToolhelp::EnablePrivilege(SE_SECURITY_NAME, FALSE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ToolHelp-h"><a href="#ToolHelp-h" class="headerlink" title="ToolHelp.h"></a>ToolHelp.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">Module:  Toolhelp.h</span></span><br><span class="line"><span class="comment">Notices: Copyright (c) 2008 Jeffrey Richter &amp; Christophe Nasarre</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CmnHdr.h"</span>     <span class="comment">/* See Appendix A. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CToolhelp</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   HANDLE m_hSnapshot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   CToolhelp(DWORD dwFlags = <span class="number">0</span>, DWORD dwProcessID = <span class="number">0</span>);</span><br><span class="line">   ~CToolhelp();</span><br><span class="line"></span><br><span class="line">   <span class="function">BOOL <span class="title">CreateSnapshot</span><span class="params">(DWORD dwFlags, DWORD dwProcessID = <span class="number">0</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function">BOOL <span class="title">ProcessFirst</span><span class="params">(PPROCESSENTRY32 ppe)</span> <span class="keyword">const</span></span>;</span><br><span class="line">   <span class="function">BOOL <span class="title">ProcessNext</span><span class="params">(PPROCESSENTRY32 ppe)</span> <span class="keyword">const</span></span>;</span><br><span class="line">   <span class="function">BOOL <span class="title">ProcessFind</span><span class="params">(DWORD dwProcessId, PPROCESSENTRY32 ppe)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">BOOL <span class="title">ModuleFirst</span><span class="params">(PMODULEENTRY32 pme)</span> <span class="keyword">const</span></span>;</span><br><span class="line">   <span class="function">BOOL <span class="title">ModuleNext</span><span class="params">(PMODULEENTRY32 pme)</span> <span class="keyword">const</span></span>;</span><br><span class="line">   <span class="function">BOOL <span class="title">ModuleFind</span><span class="params">(PVOID pvBaseAddr, PMODULEENTRY32 pme)</span> <span class="keyword">const</span></span>;</span><br><span class="line">   <span class="function">BOOL <span class="title">ModuleFind</span><span class="params">(PTSTR pszModName, PMODULEENTRY32 pme)</span> <span class="keyword">const</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function">BOOL <span class="title">ThreadFirst</span><span class="params">(PTHREADENTRY32 pte)</span> <span class="keyword">const</span></span>;</span><br><span class="line">   <span class="function">BOOL <span class="title">ThreadNext</span><span class="params">(PTHREADENTRY32 pte)</span> <span class="keyword">const</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function">BOOL <span class="title">HeapListFirst</span><span class="params">(PHEAPLIST32 phl)</span> <span class="keyword">const</span></span>;</span><br><span class="line">   <span class="function">BOOL <span class="title">HeapListNext</span><span class="params">(PHEAPLIST32 phl)</span> <span class="keyword">const</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">int</span>  <span class="title">HowManyHeaps</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Note: The heap block functions do not reference a snapshot and</span></span><br><span class="line">   <span class="comment">// just walk the process's heap from the beginning each time. Infinite </span></span><br><span class="line">   <span class="comment">// loops can occur if the target process changes its heap while the</span></span><br><span class="line">   <span class="comment">// functions below are enumerating the blocks in the heap.</span></span><br><span class="line">   <span class="function">BOOL <span class="title">HeapFirst</span><span class="params">(PHEAPENTRY32 phe, DWORD dwProcessID, </span></span></span><br><span class="line"><span class="function"><span class="params">      UINT_PTR dwHeapID)</span> <span class="keyword">const</span></span>;</span><br><span class="line">   <span class="function">BOOL <span class="title">HeapNext</span><span class="params">(PHEAPENTRY32 phe)</span> <span class="keyword">const</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">int</span>  <span class="title">HowManyBlocksInHeap</span><span class="params">(DWORD dwProcessID, DWORD dwHeapId)</span> <span class="keyword">const</span></span>;</span><br><span class="line">   <span class="function">BOOL <span class="title">IsAHeap</span><span class="params">(HANDLE hProcess, PVOID pvBlock, PDWORD pdwFlags)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">static</span> BOOL <span class="title">EnablePrivilege</span><span class="params">(PCTSTR szPrivilege, BOOL fEnable = TRUE)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> BOOL <span class="title">ReadProcessMemory</span><span class="params">(DWORD dwProcessID, LPCVOID pvBaseAddress, </span></span></span><br><span class="line"><span class="function"><span class="params">      PVOID pvBuffer, SIZE_T cbRead, SIZE_T* pNumberOfBytesRead = <span class="literal">NULL</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> CToolhelp::CToolhelp(DWORD dwFlags, DWORD dwProcessID) &#123;</span><br><span class="line"></span><br><span class="line">   m_hSnapshot = INVALID_HANDLE_VALUE;</span><br><span class="line">   CreateSnapshot(dwFlags, dwProcessID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> CToolhelp::~CToolhelp() &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (m_hSnapshot != INVALID_HANDLE_VALUE)</span><br><span class="line">      CloseHandle(m_hSnapshot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::CreateSnapshot(DWORD dwFlags, DWORD dwProcessID) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (m_hSnapshot != INVALID_HANDLE_VALUE)</span><br><span class="line">      CloseHandle(m_hSnapshot);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (dwFlags == <span class="number">0</span>) &#123;</span><br><span class="line">      m_hSnapshot = INVALID_HANDLE_VALUE;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      m_hSnapshot = CreateToolhelp32Snapshot(dwFlags, dwProcessID);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>(m_hSnapshot != INVALID_HANDLE_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::EnablePrivilege(PCTSTR szPrivilege, BOOL fEnable) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Enabling the debug privilege allows the application to see</span></span><br><span class="line">   <span class="comment">// information about service applications</span></span><br><span class="line">   BOOL fOk = FALSE;    <span class="comment">// Assume function fails</span></span><br><span class="line">   HANDLE hToken;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Try to open this process's access token</span></span><br><span class="line">   <span class="keyword">if</span> (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, </span><br><span class="line">      &amp;hToken)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Attempt to modify the given privilege</span></span><br><span class="line">      TOKEN_PRIVILEGES tp;</span><br><span class="line">      tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">      LookupPrivilegeValue(<span class="literal">NULL</span>, szPrivilege, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line">      tp.Privileges[<span class="number">0</span>].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : <span class="number">0</span>;</span><br><span class="line">      AdjustTokenPrivileges(hToken, FALSE, &amp;tp, <span class="keyword">sizeof</span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      fOk = (GetLastError() == ERROR_SUCCESS);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Don't forget to close the token handle</span></span><br><span class="line">      CloseHandle(hToken);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>(fOk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::ReadProcessMemory(DWORD dwProcessID, </span><br><span class="line">   LPCVOID pvBaseAddress, PVOID pvBuffer, SIZE_T cbRead, </span><br><span class="line">   SIZE_T* pNumberOfBytesRead) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(Toolhelp32ReadProcessMemory(dwProcessID, pvBaseAddress, pvBuffer, </span><br><span class="line">      cbRead, pNumberOfBytesRead));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::ProcessFirst(PPROCESSENTRY32 ppe) <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">   BOOL fOk = Process32First(m_hSnapshot, ppe);</span><br><span class="line">   <span class="keyword">if</span> (fOk &amp;&amp; (ppe-&gt;th32ProcessID == <span class="number">0</span>))</span><br><span class="line">      fOk = ProcessNext(ppe); <span class="comment">// Remove the "[System Process]" (PID = 0)</span></span><br><span class="line">   <span class="keyword">return</span>(fOk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::ProcessNext(PPROCESSENTRY32 ppe) <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">   BOOL fOk = Process32Next(m_hSnapshot, ppe);</span><br><span class="line">   <span class="keyword">if</span> (fOk &amp;&amp; (ppe-&gt;th32ProcessID == <span class="number">0</span>))</span><br><span class="line">      fOk = ProcessNext(ppe); <span class="comment">// Remove the "[System Process]" (PID = 0)</span></span><br><span class="line">   <span class="keyword">return</span>(fOk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::ProcessFind(DWORD dwProcessId, PPROCESSENTRY32 ppe) </span><br><span class="line">   <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">   BOOL fFound = FALSE;</span><br><span class="line">   <span class="keyword">for</span> (BOOL fOk = ProcessFirst(ppe); fOk; fOk = ProcessNext(ppe)) &#123;</span><br><span class="line">      fFound = (ppe-&gt;th32ProcessID == dwProcessId);</span><br><span class="line">      <span class="keyword">if</span> (fFound) <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>(fFound);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::ModuleFirst(PMODULEENTRY32 pme) <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(Module32First(m_hSnapshot, pme));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::ModuleNext(PMODULEENTRY32 pme) <span class="keyword">const</span> &#123;</span><br><span class="line">   <span class="keyword">return</span>(Module32Next(m_hSnapshot, pme));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::ModuleFind(PVOID pvBaseAddr, PMODULEENTRY32 pme) <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">   BOOL fFound = FALSE;</span><br><span class="line">   <span class="keyword">for</span> (BOOL fOk = ModuleFirst(pme); fOk; fOk = ModuleNext(pme)) &#123;</span><br><span class="line">      fFound = (pme-&gt;modBaseAddr == pvBaseAddr);</span><br><span class="line">      <span class="keyword">if</span> (fFound) <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>(fFound);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::ModuleFind(PTSTR pszModName, PMODULEENTRY32 pme) <span class="keyword">const</span> &#123;</span><br><span class="line">   BOOL fFound = FALSE;</span><br><span class="line">   <span class="keyword">for</span> (BOOL fOk = ModuleFirst(pme); fOk; fOk = ModuleNext(pme)) &#123;</span><br><span class="line">      fFound = (lstrcmpi(pme-&gt;szModule,  pszModName) == <span class="number">0</span>) || </span><br><span class="line">               (lstrcmpi(pme-&gt;szExePath, pszModName) == <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (fFound) <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>(fFound);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::ThreadFirst(PTHREADENTRY32 pte) <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(Thread32First(m_hSnapshot, pte));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::ThreadNext(PTHREADENTRY32 pte) <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(Thread32Next(m_hSnapshot, pte));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> CToolhelp::HowManyHeaps() <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> nHowManyHeaps = <span class="number">0</span>;</span><br><span class="line">   HEAPLIST32 hl = &#123; <span class="keyword">sizeof</span>(hl) &#125;;</span><br><span class="line">   <span class="keyword">for</span> (BOOL fOk = HeapListFirst(&amp;hl); fOk; fOk = HeapListNext(&amp;hl))</span><br><span class="line">      nHowManyHeaps++;</span><br><span class="line">   <span class="keyword">return</span>(nHowManyHeaps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> CToolhelp::HowManyBlocksInHeap(DWORD dwProcessID, </span><br><span class="line">   DWORD dwHeapID) <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> nHowManyBlocksInHeap = <span class="number">0</span>;</span><br><span class="line">   HEAPENTRY32 he = &#123; <span class="keyword">sizeof</span>(he) &#125;;</span><br><span class="line">   BOOL fOk = HeapFirst(&amp;he, dwProcessID, dwHeapID);</span><br><span class="line">   <span class="keyword">for</span> (; fOk; fOk = HeapNext(&amp;he))</span><br><span class="line">      nHowManyBlocksInHeap++;</span><br><span class="line">   <span class="keyword">return</span>(nHowManyBlocksInHeap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::HeapListFirst(PHEAPLIST32 phl) <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(Heap32ListFirst(m_hSnapshot, phl));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::HeapListNext(PHEAPLIST32 phl) <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(Heap32ListNext(m_hSnapshot, phl));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::HeapFirst(PHEAPENTRY32 phe, DWORD dwProcessID, </span><br><span class="line">   UINT_PTR dwHeapID) <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(Heap32First(phe, dwProcessID, dwHeapID));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::HeapNext(PHEAPENTRY32 phe) <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(Heap32Next(phe));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> BOOL CToolhelp::IsAHeap(HANDLE hProcess, PVOID pvBlock, </span><br><span class="line">   PDWORD pdwFlags) <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">   HEAPLIST32 hl = &#123; <span class="keyword">sizeof</span>(hl) &#125;;</span><br><span class="line">   <span class="keyword">for</span> (BOOL fOkHL = HeapListFirst(&amp;hl); fOkHL; fOkHL = HeapListNext(&amp;hl)) &#123;</span><br><span class="line">      HEAPENTRY32 he = &#123; <span class="keyword">sizeof</span>(he) &#125;;</span><br><span class="line">      BOOL fOkHE = HeapFirst(&amp;he, hl.th32ProcessID, hl.th32HeapID);</span><br><span class="line">      <span class="keyword">for</span> (; fOkHE; fOkHE = HeapNext(&amp;he)) &#123;</span><br><span class="line">         MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line">         VirtualQueryEx(hProcess, (PVOID) he.dwAddress, &amp;mbi, <span class="keyword">sizeof</span>(mbi));</span><br><span class="line">         <span class="keyword">if</span> (chINRANGE(mbi.AllocationBase, pvBlock, </span><br><span class="line">            (PBYTE) mbi.AllocationBase + mbi.RegionSize)) &#123;</span><br><span class="line"></span><br><span class="line">            *pdwFlags = hl.dwFlags;</span><br><span class="line">            <span class="keyword">return</span>(TRUE);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>(FALSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////// End of File //////////////////////////////////</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><h3 id="作业对象"><a href="#作业对象" class="headerlink" title="作业对象"></a>作业对象</h3><ul>
<li><p>什么是作业对象  </p>
<ul>
<li><p>①进程的父子关系只存在于创建的子进程的那一刻，Windows并不一直维护着这种父子关系，这使得管理进程并不是件容易的事。</p>
</li>
<li><p>②作业对象是用于将一组进程作为一个管理单元的内核对象，本质上可以理解为其实就是进程池对象，可将作业对象看作是进程的容器。</p>
</li>
<li><p>③作来对象可以用来限制一组进程的占用内存数量、占用CPU周期数、进程优先级等的一个“沙箱”。</p>
</li>
<li><p>④最终可以通过作业对象将该对象中的所有进程全部关闭（普通方法很难控制）</p>
</li>
<li><p>⑤通过结合一个完成端口对象并利用一个线程实时动态的监控作业对象的执行（如得到一些消卢，以便及时响应作业对象中的进程变化情况）</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2018/12/10/windows-kernel/image-09.png" width="300px">  </p>
<ul>
<li><p>作业对象的基本用法 </p>
<ul>
<li><p>①CreateJobObject (创建作业对象)   </p>
</li>
<li><p>②IsProcessInJob (进程是否己经与某个作业对象关联)  </p>
</li>
</ul>
</li>
</ul>
<p>　　- ③SetInformationJobObject (设置作业对象或进程的限制)  </p>
<p>　　- ④AssignProcessToJobObject (将进程添加到作业中)   </p>
<p>　　- ⑤QueryInformationJobObject (查询作业对象中施加的限制)  </p>
<p>　　- ⑥TerminateJobObject (“杀死”作业中所有的进程)  </p>
<p>　　- ⑦CloseHandle (关闭作业对象句柄，导致所有进程不能访问作业对象，但作业仍存在！)  </p>
<p>　　- ⑧在需要时可以通过OpenJobObject方法打开一个指定名称的作业对象句柄。  </p>
<p>【StartRestrictedProcess函数】</p>
<h3 id="创建作业"><a href="#创建作业" class="headerlink" title="创建作业"></a>创建作业</h3><ul>
<li><p>（1）CreateJobObject(PSECURITY_ATTRIBUTES psa,PCTSTR pszName);</p>
</li>
<li><p>（2）IsProcessInJob——判断进程是否己与一个作业关联</p>
</li>
</ul>
<p>　　- ①如果进程己关联到一个作业，就无法再将当前进程再从作业中移除，这点可以确保进程无法摆脱对它施加的影响。</p>
<p>　　- ②通过资源管理器启动的应用程序默认会自动同一个专用作业关联，此作业的名称使用了“PCA”字符串（Program Compatibility Assistant）为前缀。Windows之所以提供这个特性，为了检测兼容性问题，当启动一个老版本的应用程序时（即Vista以前的版本），就会触发兼容性助手这个进程来发出警告。</p>
<p>　　- ③为了摆脱“PCA”前缀作业的关联，有两种方法：一种是通过命令行而不是资源管理中启动一个进程，还有一种方法是在CreateProcess的dwCreationFlags参数加入一个CREATE_BREAKAWAY_FROM_JOB及在基本限制结构体中的LimitFlags成员加入JOB_OBJECT_LIMITBREAKWAY_OK的标志，即如果没有指定标志，将子进程将默认与父进程的作业关联。</p>
<ul>
<li>（3）OpenJobObject函数——打开作业对象的句柄</li>
</ul>
<h3 id="设置作业对象的属性"><a href="#设置作业对象的属性" class="headerlink" title="设置作业对象的属性"></a>设置作业对象的属性</h3><p>（1）SetInformationJobObject函数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hJob</td>
<td>作业对象句柄</td>
</tr>
<tr>
<td>JobObjectInformationClass</td>
<td><strong>限制的类型</strong>①<strong>JobObjectBasicLimitInformation</strong>：设置作业对象的基本信息（如进程作业集大小、进程亲缘性、进程CPU时间限制值、同时活动的进程数量等）②<strong>JobObjectBasicUIRestrictions</strong>：对作业中的进程UI基本限制（如指定桌面，限制调用ExitWindows函数，限制剪切板读写操作等）。③<strong>JobObjectEndOfJobTimeInformatio</strong>n：指定当作业时间限制到达时，系统采取什么动作（如：通知与作业对象绑定的完成端口一个超时事件）④<strong>JobObjectEntendedLimitInformation</strong>:作业进程的扩展限制信息（如限进作业中的进程<strong>不要弹出异常对话框（同时要指定结构体的LimitFlags为JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION，这相当于给每个进程调用SetErrorMode）</strong>、限制进程的内存使用量等）⑤JobObjectSecurityLimitInformation：限制作业对象中的进程安全属性（如关闭一些组的特权、关闭某些特权等）。但这实现这个限制，作业对象所属进程或线程要具备更改这些作业进程完全属性的权限。</td>
</tr>
<tr>
<td>PVOID pJobObjectInformation</td>
<td>指向一个结构体，包含具体的限制</td>
</tr>
<tr>
<td>cbJobObjectInformationSize</td>
<td>上述结构体的大小</td>
</tr>
</tbody>
</table>
<p>（2）参数pJobObjectInformation中常用到的结构体</p>
<p>①【基本限制】：JOBOBJECT_BASIC_LIMIT_INFORMATION结构体</p>
<p><strong>（注意：如果也设置了扩展结构，则该结构要在扩展结构之后设置，见【JobIOCP程序】）</strong></p>
<table>
<thead>
<tr>
<th>成员</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>PerProcessUserTimeLimit</td>
<td>表示分配给每个进程的用户模式<strong>执行时间（即占用CPU实际的时间）</strong>，单位100ns。</td>
<td>如果一个进程累计的执行时间超时过该限额，进程会被终止。可以在作业运行期定期改变该值</td>
</tr>
<tr>
<td>PerJobUserTimeLimit</td>
<td>分配给作业的用户模式执行时间</td>
<td>超时作业会被终止</td>
</tr>
<tr>
<td>LimitFlags</td>
<td>哪些限制对作业有效</td>
<td>具体看后面说明</td>
</tr>
<tr>
<td>MinimumWorkingSetSizeMaximumWorkingSetSize</td>
<td>限制作业对象里的进程的最小、最大工作集</td>
<td>工作集：进程虚拟空间中<strong>实际被映射到物理内存页面</strong>的那部分被称为工作集。</td>
</tr>
<tr>
<td>ActiveProcessLimit</td>
<td>表示作业中可以同时运行的最大进程数量</td>
<td>超过限额创建的新进程将提示“配额不足”的错误。</td>
</tr>
<tr>
<td>Affinity</td>
<td>表示能够运行的进程的CPU子集</td>
<td>单独的进程可以在此基础上进一步限制</td>
</tr>
<tr>
<td>PriorityClass</td>
<td>表示作业中所有进程的优先级</td>
<td>单独进程不能SetPriorityClass或GetPriorityClass，这可能不能成功设置或获取到真实的进程优先级</td>
</tr>
<tr>
<td>SchedulingClass</td>
<td>当多个<strong>作业</strong>具有相同优先级作业的调度（<strong>注意是作业，不是进程或线程</strong>）</td>
<td>优先级（0-9，默认5），值越大，CPU时间越长</td>
</tr>
</tbody>
</table>
<p>　　说明：</p>
<p>  　　A、当想让该结构的成员生效，还需在LimitFlags中加入相应的标志位</p>
<p>  　　B、每次设置JOB_OBJECT_LIMIT_JOB_TIME，作业会扣除己终止运行的进程的CPU时间统计信息，从而显示当前活动的进程使用了多少CPU时间。</p>
<p> 　　 C、改变作业的CPU关联性时，又不想重置CPU时间统计信息，可用JOB_OBJECT_LIMIT_AFFINITY | JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME，但必须取消JOB_OBJECT_LIMIT_JOB_TIME，因为这与JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME是互斥的。</p>
<p>　　②【扩展限制】：基本（JOBOBJECT_BASIC_LIMIT_INFORMATION）+内存限制</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>IoInfo</td>
<td>保留不用。IO计数器</td>
<td></td>
</tr>
<tr>
<td>ProcessMemoryLimit</td>
<td>每个进程能使用的内存量</td>
<td>LimitFlags需含有：JOB_OBJECT_LIMIT_PROCESS_MEMORY</td>
</tr>
<tr>
<td>JobMemoryLimit</td>
<td>作业（所有进程）能使用的内存量</td>
<td>LimitFlags需含有：JOB_OBJECT_LIMIT_JOB_MEMORY</td>
</tr>
<tr>
<td>PeakProcessMemoryUsed</td>
<td>只读。单个进己使用的内存空间大小</td>
<td></td>
</tr>
<tr>
<td>PeakJobMemoryUsed</td>
<td>只读。作业全部进程己使用的内存空间大小</td>
</tr>
</tbody>
</table>
<p>　　③【基本UI限制】JOBOBJECT_BASIC_UI_RESTRICTIONS结构体中使用的标志位</p>
<table>
<thead>
<tr>
<th>标志位（值）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>JOB_OBJECT_UILIMIT_EXITWINDOWS</td>
<td>防止进程通过<strong>ExitWindowsEx</strong>函数退出、关闭、重启或关闭系统电源</td>
</tr>
<tr>
<td>JOB_OBJECT_UILIMIT_READCLIPBOARDJOB_OBJECT_UILIMIT_WRITECLIPBOARD</td>
<td>防止进程读、写剪切板的内容</td>
</tr>
<tr>
<td>JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS</td>
<td>防止进程通过SystemParametersInfor函数来改变系统参数</td>
</tr>
<tr>
<td>JOB_OBJECT_UILIMIT_DISPLAYSETTINGS</td>
<td>防止进程通过ChangeDisplaySettings函数来改变显示设置</td>
</tr>
<tr>
<td>JOB_OBJECT_UILIMIT_GLOBALATOMS</td>
<td>防止进程访问全局的基本结构表，为作业分配自己的基本结构表，作业中进程只能访问该表。</td>
</tr>
<tr>
<td>JOB_OBJECT_UILIMIT_DESKTOP</td>
<td>防止进程使用CreateDesktop或SwitchDesktop函数创建或转换桌面</td>
</tr>
<tr>
<td><strong>JOB_OBJECT_UILIMIT_HANDLES</strong></td>
<td>防止进程使用作业外部的进程创建的用户对象的句柄（如HWND）注意：A、当把Spy++放到一个作业内部运行，加了这个标志，Spy++将看不到其他进程的窗口（如记事本的窗口），只能看到他自己的窗口。B、这个限制是单向的，即作业外部进程可以看到作业内部进程创建的用户对象。C、但有时需要作业内部的进程向外部进程的一个窗口发送消息，这里可以在作业外部调用UserHandleGrandAccess给作业内部的某个进程授权访问给定窗口的权限。但该函数不能在作业内部使用，这是为了防止进程自己给自己授权。</td>
</tr>
</tbody>
</table>
<p>　　④【安全性限制】XP（不包括XP）之后的系统不再支持该限制，需要为每个进程单独指定安全设置。</p>
<h3 id="将进程放入作业中"><a href="#将进程放入作业中" class="headerlink" title="将进程放入作业中"></a>将进程放入作业中</h3><p>（1）AssignProcessToJobObject(hJob,hProcess);</p>
<p> 　　① CreateProcess时<strong>须使用CREATE_SUSPENDED将主线程挂起</strong>，才能加入作业中。</p>
<p> 　　②在加入作业之前可以先通过IsProcessInJob子进程是否己在其他作业对象中。</p>
<p>（2）让新进程独立出来</p>
<p>　　当作业中的进程生成另一个进程的时，新进程会自动成为父进程所属的作业。但可以通过下面两种方法改变这种特性：</p>
<p>　　①打开<strong>JOBOBJECT_BASIC_LIMIT_INFROMATION</strong> 的LimitFlags成员的JOB_OBJECT_BREAKAWAY_OK标志，告诉系统，新生成的进程可以在作业外部运行。同时使用CREATE_BREAKAWAY_FROM_JOB 标志调用CreateProcess创建新进程。</p>
<p>　　②打开JOBOBJECT_BASIC_LIMIT_INFROMATION 的LimitFlags成员的<strong>JOB_OBJECT_SILENT_BREAKAWAY_OK</strong>标志，告诉系统，新生成的进程可以在作业外部运行。但此后CreateProcess新进程时<strong>不必使用</strong>CREATE_BREAKAWAY_FROM_JOB 标志。</p>
<p><strong>5.5</strong> <strong>终止作业中的所有线程</strong></p>
<p>（1）TerminateJobObject相当于在对作业对象中的所有进程调用一次TerminateProcess，这种方式很暴力，可能引起资源没被正确释放就直接退出（当然最后操作系统会帮忙清理）。</p>
<p>（2）实际中放入作业对象的进程往往也是自行开发的进程，完全可以用诸如等待Event对象的方式来优雅地退出。</p>
<p>（3）查询限制和统计信息：QueryInformationJobObject</p>
<p>　　①函数原型</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hJob</td>
<td>作业外部进程：通过该函数是传入hJob就可查询指定作业的限制。作业内部进程：调用时可传入NULL</td>
</tr>
<tr>
<td>JobObjectInfoClass</td>
<td>查看的限制或统计信息的类型JobObjectBasicAccountingInformation：基本统计信息JobObjectBasicAndIoAccountingInformation：基本+I/O统计信息JobObjectBasicLimitInformation：基本限制信息JobObjectBasicProcessIdList：获取当前作业中所有进程ID集JobObjectBasicUIRestrictions：基本UI限制信息JobObjectExtendedLimitInformation：扩展限制信息JobObjectSecurityLimitInformation：安全限制信息</td>
</tr>
<tr>
<td>lpJobObjectInfo</td>
<td>返回指向特定类型信息的结构体缓冲区的指针</td>
</tr>
<tr>
<td>cbJobObjectInfoLength</td>
<td>该数据结构的大小（以字节为单位）</td>
</tr>
<tr>
<td>lpReturnLength</td>
<td>缓冲区中实际填入的字节数</td>
</tr>
</tbody>
</table>
<p>　　②JOBOBJECT_BASIC_ACCOUNTING_INFORMATION结构体</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>TotalUserTime</td>
<td>指出作业中进程己使用多少用户模式的CPU时间</td>
</tr>
<tr>
<td>TotalKernelTime</td>
<td>指出作业中进程己使用多少内核模式的CPU时间</td>
</tr>
<tr>
<td>ThisPeriodTotalUserTime</td>
<td>与TotalUserTime一样，不同的是，如果调用SetInformationJobObject来更改基本限额信息，同时没有使用JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME标志时，这个值总为0.</td>
</tr>
<tr>
<td>ThisPeriodTotalKernelTime</td>
<td>与ThisPeriodTotalUserTime一样，不同的是这个值显示的是内核CPU时间。</td>
</tr>
<tr>
<td>TotalPageFaultCount</td>
<td>指出作业中进程产生的页面错误总数</td>
</tr>
<tr>
<td>TotalProcesses</td>
<td>指出所有进程的总数（含己退出的进程）</td>
</tr>
<tr>
<td>ActiveProcesses</td>
<td>指出作业中当前进程总数</td>
</tr>
<tr>
<td>TotalTerminatedProcesses</td>
<td>指出因己超过预定CPU时间限制而被“杀死”的进程数</td>
</tr>
</tbody>
</table>
<p>　　③JOBOBJECT_BASIC_AND_<strong>IO</strong>_ACCOUNTING_INFORMATION结构体中的<strong>IO_COUNTERS</strong>成员</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ReadOperationCountWriteOperationCountOtherOperationCount</td>
<td>作业中进程己执行的读、写IO操作的次数及非读/写操作的次数</td>
</tr>
<tr>
<td>ReadTransferCountWriteTransferCountOtherTransferCount</td>
<td>上述操作期间传输的字节总数</td>
</tr>
</tbody>
</table>
<p>★<strong>GetProcessIoCounters函数</strong>可获得未放入作为业的那些进程的信息</p>
<p>   　　GetProcessIoCounters(hProcess,pIoCounters);</p>
<p>　　④JOBOBJECT_BASIC_PROCESS_ID_LIST结构体</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NumberOfAssignedProcesses</td>
<td>作业中的进程数量（由我们指定一个估计的值）</td>
</tr>
<tr>
<td>NumberOfProcessIdsInList</td>
<td>函数调用以后，将ProcessIDList中实际的元素个数返回在这个变量中。</td>
</tr>
<tr>
<td>DWORD ProcessIdList[1]</td>
<td>进程ID集</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;  //for _alloca函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取作业中当前的进程ID集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnumProcessIdsInJob</span><span class="params">(HANDLE hJob)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先假设作业中的进程不会超过10个</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX_PROCESS_IDS = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算结构体和ID集所需的空间大小</span></span><br><span class="line">    DWORD cb = <span class="keyword">sizeof</span>(JOBOBJECT_BASIC_PROCESS_ID_LIST) +</span><br><span class="line">        (MAX_PROCESS_IDS - <span class="number">1</span>)*<span class="keyword">sizeof</span>(DWORD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配内存，注意_alloca是在栈（而不是堆上分配的，所以不需要释放）</span></span><br><span class="line">    PJOBOBJECT_BASIC_PROCESS_ID_LIST pjobpil =</span><br><span class="line">        (PJOBOBJECT_BASIC_PROCESS_ID_LIST)_alloca(cb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//估计最多的进程数</span></span><br><span class="line">    pjobpil-&gt;NumberOfAssignedProcesses = MAX_PROCESS_IDS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    QueryInformationJobObject(hJob, JobObjectBasicProcessIdList, pjobpil, cb, &amp;cb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示进程ID集</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD x = <span class="number">0</span>; x &lt; pjobpil-&gt;NumberOfProcessIdsInList; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(TEXT(<span class="string">"process%d(ID=%d)\n"</span>),x+<span class="number">1</span>,pjobpil-&gt;ProcessIdList[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用作业对象对进程进程管理的演示</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StartRestrictedProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//检查进程是否己经关联到一个作业对象中了</span></span><br><span class="line">    <span class="comment">//如果己经关联，就没办法再换到另一个作业对象中去</span></span><br><span class="line">    BOOL bInJob = FALSE;</span><br><span class="line">    IsProcessInJob(GetCurrentProcess(), <span class="literal">NULL</span>, &amp;bInJob);</span><br><span class="line">    <span class="keyword">if</span> (bInJob)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Process already in a job\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建作业内核对象</span></span><br><span class="line">    HANDLE hjob = CreateJobObject(<span class="literal">NULL</span>, TEXT(<span class="string">"MyRestrictedProcessJob"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在作业中放入线程对象的一些限制规则</span></span><br><span class="line">    <span class="comment">//首先，设置基本限制</span></span><br><span class="line">    JOBOBJECT_BASIC_LIMIT_INFORMATION jobli = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进程总是运行在“空闲”优先级</span></span><br><span class="line">    jobli.PriorityClass = IDLE_PRIORITY_CLASS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该作业对象在用户模式下不能超过1秒的CPU时间（课本这里错了吧，应该1ms)</span></span><br><span class="line">    <span class="comment">//jobli.PerJobUserTimeLimit.QuadPart = 2000* 10000; //多少个tick（1tick=100ns）</span></span><br><span class="line">    <span class="comment">//jobli.PerProcessUserTimeLimit.QuadPart = 1*10000; //1ms</span></span><br><span class="line">    jobli.PerJobUserTimeLimit.QuadPart = <span class="number">1000</span>*<span class="number">10000</span>I64;</span><br><span class="line">                                    <span class="comment">//10000tick=10000*100ns=1ms</span></span><br><span class="line">    <span class="comment">//这里只增加了以上两个限制</span></span><br><span class="line">    jobli.LimitFlags = JOB_OBJECT_LIMIT_PRIORITY_CLASS |</span><br><span class="line">                       JOB_OBJECT_LIMIT_JOB_TIME;</span><br><span class="line">    SetInformationJobObject(hjob, JobObjectBasicLimitInformation,</span><br><span class="line">                            &amp;jobli, <span class="keyword">sizeof</span>(jobli));</span><br><span class="line">    <span class="comment">//其次，设置UI限制</span></span><br><span class="line">    JOBOBJECT_BASIC_UI_RESTRICTIONS jobuir;</span><br><span class="line">    jobuir.UIRestrictionsClass = JOB_OBJECT_UILIMIT_NONE; <span class="comment">//初始化为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//进程不能访问用户对象（如窗口句柄）</span></span><br><span class="line">    jobuir.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_HANDLES;</span><br><span class="line">    <span class="comment">//进程不能关闭系统</span></span><br><span class="line">    jobuir.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_EXITWINDOWS;</span><br><span class="line"></span><br><span class="line">    SetInformationJobObject(hjob, JobObjectBasicUIRestrictions,</span><br><span class="line">                            &amp;jobuir, <span class="keyword">sizeof</span>(jobuir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建子进程并加入作业对象中</span></span><br><span class="line">    <span class="comment">//    Note:进程被创建后，其线程要立刻挂起，在加入作业对象前不能执行</span></span><br><span class="line">    <span class="comment">//         任何代码，这是作业对象的要求。否则，进程执行的那部分代码</span></span><br><span class="line">    <span class="comment">//         可能就不受作业对象的限制。</span></span><br><span class="line"></span><br><span class="line">    STARTUPINFO si = &#123; <span class="keyword">sizeof</span>(si) &#125;;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line">    TCHAR szCmdLine[<span class="number">8</span>];</span><br><span class="line">    _tcscpy_s(szCmdLine, _countof(szCmdLine), TEXT(<span class="string">"CMD"</span>));</span><br><span class="line">    </span><br><span class="line">    BOOL bResult = CreateProcess(<span class="literal">NULL</span>, szCmdLine, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE,</span><br><span class="line">                                 CREATE_SUSPENDED | CREATE_NEW_CONSOLE <span class="comment">/*| CREATE_BREAKAWAY_FROM_JOB8*/</span>,</span><br><span class="line">                                 <span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;si,&amp;pi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将子进程加入到作业对象中</span></span><br><span class="line">    <span class="comment">//     注意：当创建子进程时，子进程会自动加入到父进程所在的作业对象</span></span><br><span class="line">                 </span><br><span class="line">    AssignProcessToJobObject(hjob, pi.hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在可以恢复子进程的主线程,开始执行代码</span></span><br><span class="line">    ResumeThread(pi.hThread);</span><br><span class="line">    CloseHandle(pi.hThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举作业对象中的进程值ID</span></span><br><span class="line">    EnumProcessIdsInJob(hjob);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待子进程结束或作业对象所分配的CPU时间被用完</span></span><br><span class="line">    HANDLE h[<span class="number">2</span>];</span><br><span class="line">    h[<span class="number">0</span>] = pi.hProcess;</span><br><span class="line">    h[<span class="number">01</span>] = hjob;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*WaitForMultipleObjects</span></span><br><span class="line"><span class="comment">    1. nCount，DWORD类型，用于指定句柄数组的数量</span></span><br><span class="line"><span class="comment">    2. lphObjects，Pointer类型，用于指定句柄数组的内存地址</span></span><br><span class="line"><span class="comment">    3. fWaitAll，Boolean类型，True表示函数等待所有指定句柄的Object有信号为止</span></span><br><span class="line"><span class="comment">    4. dwTimeout，DWORD类型，用于指定等待的Timeout时间，单位毫秒，可以是INFINITE</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    返回值：</span></span><br><span class="line"><span class="comment">    如果fWaitAll为TRUE，则返回值表明所有指定对象的状态信号</span></span><br><span class="line"><span class="comment">    如果fWaitAll为FALSE，则返回值-WAIT_OBJECT_0 表示lphObjects数组相应的对象变成有信号</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    DWORD dw = WaitForMultipleObjects(<span class="number">2</span>, h, FALSE, INFINITE);</span><br><span class="line">    <span class="keyword">switch</span> (dw - WAIT_OBJECT_0)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The process has terminated...\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"All of the job's allotted CPU time was used...\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILETIME  CreationTime;</span><br><span class="line">    FILETIME  EXitTime;</span><br><span class="line">    FILETIME  KernelTime;</span><br><span class="line">    FILETIME  UserTime;</span><br><span class="line">    TCHAR szInfo[MAX_PATH];</span><br><span class="line"></span><br><span class="line">    GetProcessTimes(pi.hProcess, &amp;CreationTime, &amp;EXitTime,</span><br><span class="line">                    &amp;KernelTime, &amp;UserTime);</span><br><span class="line"></span><br><span class="line">    StringCchPrintf(szInfo, _countof(szInfo), </span><br><span class="line">                    TEXT(<span class="string">"Kernel = %u | User = %u\n"</span>),</span><br><span class="line">                     KernelTime.dwLowDateTime/<span class="number">10000</span>,</span><br><span class="line">                     UserTime.dwLowDateTime / <span class="number">10000</span>);</span><br><span class="line">    CloseHandle(pi.hProcess);</span><br><span class="line">    CloseHandle(hjob);</span><br><span class="line"></span><br><span class="line">    _tprintf(szInfo);</span><br><span class="line"></span><br><span class="line">    _tsystem(_T(<span class="string">"PAUSE"</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _tsetlocale(LC_ALL, TEXT(<span class="string">"chs"</span>));</span><br><span class="line">    StartRestrictedProcess();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="作业对象事件和完成端口"><a href="#作业对象事件和完成端口" class="headerlink" title="作业对象事件和完成端口"></a>作业对象事件和完成端口</h3><p>（1）将作业对象与完成端口对象关联起来</p>
<p>   JOBOBJECT_ASSOCIATE_COMPLETION_PORT joacp;</p>
<p>   joacp.<strong>CompletionKey</strong> = hJob1; //可用来标识<strong>作业对象</strong>任意唯一值，这里取其<strong>句柄</strong></p>
<p>   joacp.<strong>CompletionPort</strong> = hIOCP; //<strong>完成端口的句柄</strong></p>
<p>   SetInformationJobObject(hJob,JobObjectAssociateCompletionPortInformation,</p>
<p>​           &amp;joacp,sizeof(joacp));</p>
<p> （2）创建线程，将完成端口对象作为参数传入线程函数。并GetQueuedCompletionStatus来等待作业对象的通知事件。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hIOCP</td>
<td>要获取事件的完成端口对象的句柄</td>
</tr>
<tr>
<td>pNumBytesTransferred</td>
<td>等待的事件ID<strong>【与作业对象有关的事件】</strong>①JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT：作业对象中活动进程数达到上限时通知②JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO：作业对象中当前没有活动进程时通知③JOB_OBJECT_MSG_END_OF_JOB_TIME：作业对象耗尽指定的时间片时通知。但其中的进程不会自动终止。可以设置一个新的时间限额以允许继续，或调用TerminateJobObject来终止进程。④JOB_OBJECT_MSG_JOB_MEMORY_LIMIT：作业对象耗尽指定的内存时通知，同时给出进程ID<strong>【与进程有关的事件】</strong>①JOB_OBJECT_MSG_NEW_PROCESS：新进程加入作业对象时通知，并给出进程ID。②JOB_OBJECT_MSG_EXIT_PROCESS：进程正常退出时通知，并给出进程ID。③JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS：进程异常退出时通知，并给出进程ID④JOB_OBJECT_MSG_END_OF_PROCESS_TIME：进程耗尽时间片时通知，进程将终止，并给出进程ID⑤JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT：进程消耗内存数量达到上限时通知，同时给出进程ID。</td>
</tr>
<tr>
<td>pCompletionKey</td>
<td><strong>指定触发这个事件的作业对象的句柄</strong>(可以将一个完成端口对象与多个作业对象进行绑定)</td>
</tr>
<tr>
<td>pOverlapped</td>
<td>在作业事件中，该值表示哪个<strong>进程ID</strong>发生的事件。</td>
</tr>
<tr>
<td>dwMilliseconds</td>
<td>用于指定调用者等待完成端口的时间</td>
</tr>
</tbody>
</table>
<p>   注意：</p>
<p>①作业对象的状态变为己触发是在分配作业的时间到期时，而不是所有进程都结束时。</p>
<p>②默认下，当作业时间到期时，它的所有进程都会自动终止，所以也就不会投递JOB_OBJECT_MSG_END_OF_JOB_TIME。如果只想发送该通知给应用程序，而让应用程序自行来杀死进程，可以做如下设置：</p>
<p>  //创建结构体，并将JOb结束时要采取的措施填入该结构体</p>
<p>  <strong>JOBOBJECT_END_OF_JOB_TIME_INFORMATION joeojti;</strong></p>
<p>  <strong>joeojti.EndOfJobTimeAction = JOB_OBJECT_POST_AT_END_OF_JOB;</strong> //投递通知，而不是“杀死”进程。创建作业时，默认值为JOB_OBJECT_TERMINATE_AT_END_OF_JOB;</p>
<p> //告诉作业对象当作业时间到期时，要采取的措施</p>
<p> <strong>SetInformationJobObject(hJob,JobObjectEndOfJobTimeInformation,</strong></p>
<p><strong>&amp;joeojti,sizeof(joeojti));</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE g_hJob = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE g_hIOCP = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">IOCPThread</span><span class="params">(LPVOID lpParam)</span></span>;</span><br><span class="line"></span><br><span class="line">__<span class="function"><span class="keyword">inline</span> VOID <span class="title">GetAppPath</span><span class="params">(LPTSTR pszBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwLen = <span class="number">0</span>;  <span class="comment">//pszbuffer中接收到的字符个数</span></span><br><span class="line">    <span class="comment">//获取当前应用程序全路径（含文件名）</span></span><br><span class="line">    dwLen = GetModuleFileName(<span class="literal">NULL</span>, pszBuffer, MAX_PATH);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == dwLen) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//去件文件及扩展名，只保留路径（路径的最后面含"\"字符）</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = dwLen; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">'\\'</span>==pszBuffer[i])&#123;</span><br><span class="line">            pszBuffer[i + <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line">    _tsetlocale(LC_ALL, _T(<span class="string">"chs"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个默认的安全属性结构（不继承）</span></span><br><span class="line">    SECURITY_ATTRIBUTES  sa = &#123; <span class="keyword">sizeof</span>(SECURITY_ATTRIBUTES) &#125;;</span><br><span class="line">    sa.bInheritHandle = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建匿名的Job对象</span></span><br><span class="line">    g_hJob = CreateJobObject(&amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定不显示异常关闭对话框，即静默方式运行本程序</span></span><br><span class="line">    JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = &#123;&#125;;</span><br><span class="line">    <span class="comment">//jeli.BasicLimitInformation.PerProcessUserTimeLimit.QuadPart = 100 * 10000i64;</span></span><br><span class="line">    jeli.BasicLimitInformation.LimitFlags =JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION;</span><br><span class="line">    SetInformationJobObject(g_hJob, JobObjectExtendedLimitInformation,</span><br><span class="line">                            &amp;jeli, <span class="keyword">sizeof</span>(JOBOBJECT_EXTENDED_LIMIT_INFORMATION));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为作业对象设置一些限制(经测试，以下的基本限制要在扩展限制设置完以后或，才能设置//也可以直接在扩展限制里面直接设置！)</span></span><br><span class="line">    JOBOBJECT_BASIC_LIMIT_INFORMATION jbli = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//限制进程的用户时间最大值，单位是100纳秒，本例中设置为100ms</span></span><br><span class="line">    jbli.PerProcessUserTimeLimit.QuadPart = <span class="number">100</span> * <span class="number">10000</span>i64; <span class="comment">//该进程能够获得的CPU执行时间最多为100ms</span></span><br><span class="line">    jbli.PerJobUserTimeLimit.QuadPart = <span class="number">350</span> * <span class="number">10000</span>i64;     <span class="comment">//整个作业的时间片为350ms(指CPU执行时间)</span></span><br><span class="line">    <span class="comment">//限制最大工作集为256K</span></span><br><span class="line">    <span class="comment">//jbli.MaximumWorkingSetSize = 256 * 1024;</span></span><br><span class="line">    <span class="comment">//jbli.MinimumWorkingSetSize = 4 * 1024;   //这也是页面的大小（4K）</span></span><br><span class="line"></span><br><span class="line">    jbli.LimitFlags = JOB_OBJECT_LIMIT_PROCESS_TIME | JOB_OBJECT_LIMIT_JOB_TIME; <span class="comment">/*| JOB_OBJECT_LIMIT_WORKINGSET*/</span>;</span><br><span class="line">    SetInformationJobObject(g_hJob, JobObjectBasicLimitInformation,</span><br><span class="line">                            &amp;jbli, <span class="keyword">sizeof</span>(JOBOBJECT_BASIC_LIMIT_INFORMATION));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建完成端口对象</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    HANDLE CreateIoCompletionPort (</span></span><br><span class="line"><span class="comment">    HANDLE FileHandle,              // 有效的文件句柄或INVALID_HANDLE_VALUE</span></span><br><span class="line"><span class="comment">    HANDLE ExistingCompletionPort,  // 已经存在的完成端口。如果为NULL，则为新建一个IOCP</span></span><br><span class="line"><span class="comment">    ULONG_PTR CompletionKey,        // completion key是传送给处理函数的参数</span></span><br><span class="line"><span class="comment">    DWORD NumberOfConcurrentThreads // number of threads to execute concurrently</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    g_hIOCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">1</span>); <span class="comment">//1个线程的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将Job对象与完成端口对象绑定</span></span><br><span class="line">    JOBOBJECT_ASSOCIATE_COMPLETION_PORT jobiocp;</span><br><span class="line">    jobiocp.CompletionKey = g_hJob;</span><br><span class="line">    jobiocp.CompletionPort = g_hIOCP;</span><br><span class="line">    SetInformationJobObject(g_hJob, JobObjectAssociateCompletionPortInformation,</span><br><span class="line">                            &amp;jobiocp, <span class="keyword">sizeof</span>(jobiocp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动监视Job事件的IOCP线程（1个线程）</span></span><br><span class="line">    HANDLE hIOCPThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>,(LPTHREAD_START_ROUTINE)IOCPThread</span><br><span class="line">                                      , (LPVOID)g_hIOCP, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TCHAR pAppPath[MAX_PATH] = &#123;&#125;;</span><br><span class="line">    GetAppPath(pAppPath);</span><br><span class="line">    StringCchCat(pAppPath, MAX_PATH, _T(<span class="string">"ErrorShow.exe"</span>));<span class="comment">//用课本的ErrorShow程序演示</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> iProcessNums = <span class="number">3</span>;</span><br><span class="line">    STARTUPINFO si = &#123; <span class="keyword">sizeof</span>(si) &#125;;</span><br><span class="line">    PROCESS_INFORMATION piArray[iProcessNums] = &#123; &#123; <span class="number">0</span> &#125;, &#123; <span class="number">0</span> &#125;, &#123; <span class="number">0</span> &#125; &#125;;</span><br><span class="line">    HANDLE h[iProcessNums];</span><br><span class="line">    <span class="comment">//以暂停主线程方式创建一个独立的进程（可以改为循环创建多个）</span></span><br><span class="line">    <span class="comment">//注意加上CREATE_BREAKAWAY_FROM_JOB标志</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iProcessNums; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        CreateProcess(pAppPath, <span class="literal">NULL</span>, &amp;sa, &amp;sa, FALSE,</span><br><span class="line">                      CREATE_SUSPENDED | CREATE_BREAKAWAY_FROM_JOB, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;piArray[i]);</span><br><span class="line">        <span class="comment">//将进程与Job对象绑定</span></span><br><span class="line">        AssignProcessToJobObject(g_hJob, piArray[i].hProcess);</span><br><span class="line">        ResumeThread(piArray[i].hThread); <span class="comment">//恢复新进程的主线程</span></span><br><span class="line">        h[i] = piArray[i].hProcess;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询一些作业对象的统计信息，本例中查询基本统计信息和IO统计信息</span></span><br><span class="line">        JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION jobioinfo;</span><br><span class="line">        DWORD dwNeedLen = <span class="number">0</span>;</span><br><span class="line">        QueryInformationJobObject(g_hJob, JobObjectBasicAndIoAccountingInformation,</span><br><span class="line">                                  &amp;jobioinfo, <span class="keyword">sizeof</span>(jobioinfo), &amp;dwNeedLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等进程退出</span></span><br><span class="line">    WaitForMultipleObjects(iProcessNums, h, TRUE, INFINITE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iProcessNums;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(piArray[i].hProcess);</span><br><span class="line">        CloseHandle(piArray[i].hThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向IOCPThread函数发送一个退出的消息，指定dwNumberOfBytesTransferred为0</span></span><br><span class="line">    <span class="comment">//该值直接传递给GetQueuedCompletionStatus函数中对应的参数，用来表示事件ID</span></span><br><span class="line">    PostQueuedCompletionStatus(g_hIOCP,<span class="number">0</span>,(ULONG_PTR)g_hJob,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//等待线程退出</span></span><br><span class="line">    WaitForSingleObject(hIOCPThread,INFINITE);</span><br><span class="line">    CloseHandle(hIOCPThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭作业对象等</span></span><br><span class="line">    CloseHandle(g_hJob);</span><br><span class="line">    CloseHandle(g_hIOCP);</span><br><span class="line">    _tsystem(TEXT(<span class="string">"PAUSE"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD  WINAPI <span class="title">IOCPThread</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG_PTR hJob = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE   hIocp = (HANDLE)lpParam;</span><br><span class="line">    OVERLAPPED* lpOverlapped = <span class="literal">NULL</span>;</span><br><span class="line">    BOOL bLoop = TRUE;</span><br><span class="line">    DWORD dwReasonID = <span class="number">0</span>; <span class="comment">//事件ID，参数lpNumberOfBytes</span></span><br><span class="line">    DWORD dwProcessID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (bLoop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!GetQueuedCompletionStatus(hIocp, &amp;dwReasonID, </span><br><span class="line">                (PULONG_PTR)&amp;hJob, &amp;lpOverlapped, INFINITE))</span><br><span class="line">        &#123;</span><br><span class="line">            _tprintf(_T(<span class="string">"IOCPThread:GetQueueCompletionStatus调用失败，错误代码：0x%08x\n"</span>),</span><br><span class="line">                     GetLastError());</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (dwReasonID)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//作业对象中活动进程数达到上限</span></span><br><span class="line">        <span class="keyword">case</span> JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT:</span><br><span class="line">            _tprintf(_T(<span class="string">"作业对象中活动进程数己达到上限!\n"</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//作业对象中当前没有活动进程</span></span><br><span class="line">        <span class="keyword">case</span> JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO:</span><br><span class="line">            _tprintf(_T(<span class="string">"作业对象中当前没有活动进程!\n"</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//作业对象耗尽指定的时间片</span></span><br><span class="line">        <span class="keyword">case</span> JOB_OBJECT_MSG_END_OF_JOB_TIME:</span><br><span class="line">            _tprintf(_T(<span class="string">"作业对象耗尽指定的时间片!\n"</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//作业对象耗尽指定的内存</span></span><br><span class="line">        <span class="keyword">case</span> JOB_OBJECT_MSG_JOB_MEMORY_LIMIT:</span><br><span class="line">            dwProcessID = (DWORD)lpOverlapped;</span><br><span class="line">            _tprintf(_T(<span class="string">"进程[ID:%u]导致作业对象消耗内存达到上限!\n"</span>),dwProcessID);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//新进程加入作业对象</span></span><br><span class="line">        <span class="keyword">case</span> JOB_OBJECT_MSG_NEW_PROCESS:</span><br><span class="line">            dwProcessID = (DWORD)lpOverlapped;</span><br><span class="line">            _tprintf(_T(<span class="string">"进程[ID:%u]加入作业对象[h:0x%08X]!\n"</span>), dwProcessID,hJob);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//进程正常退出</span></span><br><span class="line">        <span class="keyword">case</span> JOB_OBJECT_MSG_EXIT_PROCESS:</span><br><span class="line">            &#123;</span><br><span class="line">                dwProcessID = (DWORD)lpOverlapped;</span><br><span class="line">                DWORD dwExitCode = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//注意进程退出了，但其内核对象并没释放，还可以从内核对象中获取退出码</span></span><br><span class="line">                HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, dwProcessID);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != hProcess)</span><br><span class="line">                &#123;</span><br><span class="line">                    GetExitCodeProcess(hProcess, &amp;dwExitCode);</span><br><span class="line">                    CloseHandle(hProcess);</span><br><span class="line">                &#125;</span><br><span class="line">                _tprintf(_T(<span class="string">"进程[ID:%u]正常退出，退出码：%u!\n"</span>), dwProcessID, dwExitCode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//进程异常退出</span></span><br><span class="line">        <span class="keyword">case</span> JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS:</span><br><span class="line">            &#123;</span><br><span class="line">                dwProcessID = (DWORD)lpOverlapped;</span><br><span class="line">                DWORD dwExitCode = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//注意进程退出了，但其内核对象并没释放，还可以从内核对象中获取退出码</span></span><br><span class="line">                HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, dwProcessID);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != hProcess)</span><br><span class="line">                &#123;</span><br><span class="line">                    GetExitCodeProcess(hProcess, &amp;dwExitCode);</span><br><span class="line">                    CloseHandle(hProcess);</span><br><span class="line">                &#125;</span><br><span class="line">                _tprintf(_T(<span class="string">"进程[ID:%u]异常退出，退出码：%u!\n"</span>), dwProcessID, dwExitCode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//进程耗尽时间片</span></span><br><span class="line">        <span class="keyword">case</span> JOB_OBJECT_MSG_END_OF_PROCESS_TIME:</span><br><span class="line">            dwProcessID = (DWORD)lpOverlapped;</span><br><span class="line">            _tprintf(_T(<span class="string">"进程[ID:%u]耗尽时间片!\n"</span>), dwProcessID);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//进程消耗内存数量达到上限</span></span><br><span class="line">        <span class="keyword">case</span> JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT:</span><br><span class="line">            dwProcessID = (DWORD)lpOverlapped;</span><br><span class="line">            _tprintf(_T(<span class="string">"进程[ID:%u]消耗内存达到上限!\n"</span>), dwProcessID);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            bLoop = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _tprintf(_T(<span class="string">"ICOP线程（ID:0x%x退出）\n"</span>), GetCurrentThreadId());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><p>（1）线程组成：<strong>线程内核对象+线程栈</strong>（★<strong>进程=进程内核对象+地址空间</strong>）</p>
<p>　　①从内核角度看，<strong>线程是一个内核对象</strong>，系统用它来存储一些关于线程的统计信息（比如运行时间等）</p>
<p>　　②从编程角度看，线程是一堆寄存器状态以及线程栈的一个结构体对象。本质上可以理解为一个函数的调用器（其中的寄存器状态用于控制CPU执行，栈用于存储局部变量和函数参数及函数的返回地址）——<strong>为什么要使用线程栈的？</strong></p>
<table>
<thead>
<tr>
<th>线程1</th>
<th>线程2</th>
<th>备注（使用线程栈的原因分析）</th>
</tr>
</thead>
<tbody>
<tr>
<td>void func1(){  int a;  int b;}</td>
<td>void func2(){  int c;  int d;}</td>
<td><strong>如果不为每个线程分配线程栈</strong>，而使用进程中某一共同的栈，设func3先于func4执行，则变量进栈顺序a、b，如果此时执行线程2，则c、d也会进栈，栈顶指针指向d。假设这时func3执行完，要回收栈则会出现将c、d弹出栈的错误。现实中可能会出现更复杂的情况。当然，如果这两个线程严格串行执行，则不会出现这种错误。</td>
</tr>
</tbody>
</table>
<p>　　③线程还可以带有<strong>消息队列</strong>（GUI线程内部会创建）和APC队列。（但注意<strong>这些队列在线程创建时并不同时创建</strong>，要在调用GUI函数里才会被创建！）</p>
<p>★进程是线程的容器，<strong>线程共享进程的地址空间和资源</strong></p>
<p>（2）什么时候不使用多线程</p>
<p>　　①当一个<strong>算法本身是严格串行化</strong>的时候，即计算的每一步都严重依赖前一个操作步骤的结果时，不适合用多线程）。</p>
<p>　　②当多个功能任务具有比较<strong>严格的先后逻辑关系时</strong>，不宜采用多线程。因为这涉及到线程同步方法的严格控制，从而可能因加了过多的同步而降低了效率。</p>
<p>　　③还有一种特殊情况，比如一个服务器需要处理成千上万个客户端连接，不宜使用多线程，因为过多的线程间的切换也会降低效率，这里可以<strong>考虑用线程池</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_MYMSG  WM_USER</span></span><br><span class="line"></span><br><span class="line">HANDLE hEvent;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(PVOID pvParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MSG msg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//强制系统创建一个消息队列，注释后可看到该线程没有收到任何消息</span></span><br><span class="line">    PeekMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, PM_NOREMOVE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!SetEvent(hEvent))  <span class="comment">//创建好消息队列后，将事件重置为有信号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟一个耗时的初始化过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个简化的消息循环</span></span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>))&#123;</span><br><span class="line">        _tprintf(_T(<span class="string">"线程[ID:0x%X]收到消息-0x%04X \t时间（GetTickCount值）- %u\n"</span>), </span><br><span class="line">                   GetCurrentThreadId(),msg.message,msg.time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行到这里表示收到的是WM_QUIT消息</span></span><br><span class="line">    _tprintf(_T(<span class="string">"线程[ID:0x%X]收到退出消息-0x%04X \t时间（GetTickCount值）- %u\n"</span>),</span><br><span class="line">             GetCurrentThreadId(), msg.message, msg.time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line">    _tsetlocale(LC_ALL, _T(<span class="string">"chs"</span>));</span><br><span class="line">    <span class="comment">//创建同步事件</span></span><br><span class="line">    hEvent = CreateEvent(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hEvent == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    DWORD dwThreadID = <span class="number">0</span>;</span><br><span class="line">    HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwThreadID);</span><br><span class="line">    <span class="comment">//Sleep(100); //注释掉此句，以下两条消息可能会收不到</span></span><br><span class="line">    <span class="comment">//以下两个消息可能收不到，因为新线程默认没有消息队列</span></span><br><span class="line">    PostThreadMessage(dwThreadID, WM_MYMSG + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    PostThreadMessage(dwThreadID, WM_MYMSG + <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hEvent, INFINITE); <span class="comment">//等待子线程创建好消息队列</span></span><br><span class="line">    CloseHandle(hEvent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息队列己经建立，此时发送消息将会成功！</span></span><br><span class="line">    PostThreadMessage(dwThreadID, WM_MYMSG + <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    PostThreadMessage(dwThreadID, WM_MYMSG + <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//强制切换到新线程去执行，其实可以不必这样做，这里演示切换线程</span></span><br><span class="line">    <span class="comment">//以便让消息到达的时间有差异</span></span><br><span class="line">    Sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    PostThreadMessage(dwThreadID, WM_MYMSG + <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    PostThreadMessage(dwThreadID, WM_MYMSG + <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向新线程发送退出消息</span></span><br><span class="line">    PostThreadMessage(dwThreadID, WM_QUIT, (WPARAM)GetCurrentThreadId(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待新线程退出</span></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    _tsystem(_T(<span class="string">"PAUSE"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>（1）进程的入口函数，从本质上看就是主线程的入口函数。在C\C++下是WinMainCRTStartup</p>
<p>（2）主线程是进程内第1个可执行的线程实体，它可以用来创建别的线程。</p>
<p>（3）主线程退出后，进程也会退出（因为<strong>VS嵌入的入口函数会调用ExitProcess终止其它线程的执行。</strong>（当自定义入口时，这个行为就要在自定义的入口函数中自行的维护，即自定义入口函数时，<strong>那么进程将在最后一个线程退出后，才退出</strong>。因此，<strong>主线程也未必是最后一个线程！</strong>）。</p>
<p><br></p>
<h2 id="线程函数-线程入口函数"><a href="#线程函数-线程入口函数" class="headerlink" title="线程函数(线程入口函数)"></a>线程函数(线程入口函数)</h2><p>（1）线程函数的原型：DWORD WINAPI ThreadProc(LPVOID lpParameter);</p>
<p>（2）线程函数是线程执行的起点，可以执行我们希望的任何任务</p>
<p>（3）当线程函数执行完毕，线程将退出，同进线程栈也会被释放，线程内核对象的使用计数递减，如果计数为0，则删除该线程内核对象。（可见<strong>线程内核对象的生命期可能长于线程本身</strong>！）</p>
<p>（4）<strong>线程函数必须有一个返回值</strong>，它会成为该线程的退出代码。其他线程可以用GetExitCodeThread来检查线程是否己终止运行，并进一步判断其退出代码。</p>
<p>（5）线程函数应<strong>尽可能使用函数参数和局部变量</strong>。因为静态变量或全局变量，多线程时可能因同时访问这些变量而要进行额外的同步。由函数参数和局部变量是在线程栈上创建的，不会出现多线程同时访问的问题。</p>
<p><br></p>
<h2 id="CreateThread函数"><a href="#CreateThread函数" class="headerlink" title="CreateThread函数"></a>CreateThread函数</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>psa</td>
<td>指向一个SECURITY_ATTRIBUTES结构体。使用默认安全属性时传入NULL</td>
</tr>
<tr>
<td>cbStackSize</td>
<td>①用于指定线程初始时的栈大小，通常传入0即可，此时系统会使用一个合适的大小。默认是1MB（<strong>保存在PE文件中！</strong>）②线程栈溢出时，产生异常，这可以用来捕获代码中无穷递归bug。若没限制耗尽进程所有的地址空间。</td>
</tr>
<tr>
<td>pfnStartAddr</td>
<td>新线程入口函数的地址（注意：新线程和调用CreateThread函数的线程可以同时被执行，这是windows抢占式的特点）</td>
</tr>
<tr>
<td>pvParam</td>
<td>传给线程入口函数的参数，可以是一个数值或一个结构体</td>
</tr>
<tr>
<td>dwCreateFlags</td>
<td>0——创建后立即执行；CREATE_SUSPENDED——创建后挂起，并不执行</td>
</tr>
<tr>
<td>pdwThreadId</td>
<td>得到新线程ID</td>
</tr>
<tr>
<td>返回值</td>
<td>成功——线程内核对象的句柄；失败——NULL</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_THREADS  10  <span class="comment">//最大线程数</span></span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">MyThreadFunc</span><span class="params">(LPVOID lpParam)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">ErrorHandler</span><span class="params">(LPTSTR lpszFunction)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义线程数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tagMyData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val1;</span><br><span class="line">    <span class="keyword">int</span> val2;</span><br><span class="line">&#125;MYDATA,*PMYDATA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line">    _tsetlocale(LC_ALL, _T(<span class="string">"chs"</span>));</span><br><span class="line"></span><br><span class="line">    PMYDATA pDataArray[MAX_THREADS];</span><br><span class="line">    HANDLE  hThreadArray[MAX_THREADS];</span><br><span class="line"></span><br><span class="line">    _tprintf(_T(<span class="string">"以下10个线程是按顺序创建的，但线程的调度是随机\n"</span>));</span><br><span class="line">    <span class="comment">//循环创建10个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_THREADS;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pDataArray[i] = (PMYDATA)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MYDATA));</span><br><span class="line">        pDataArray[i]-&gt;val1 = i;</span><br><span class="line">        pDataArray[i]-&gt;val2 = i + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        hThreadArray[i] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, MyThreadFunc, pDataArray[i], </span><br><span class="line">                                      <span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (hThreadArray[i] == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ErrorHandler(_T(<span class="string">"CreateThread"</span>));</span><br><span class="line">            ExitProcess(<span class="number">3</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待所有线程退出</span></span><br><span class="line">    WaitForMultipleObjects(MAX_THREADS, hThreadArray, TRUE, INFINITE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; MAX_THREADS;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hThreadArray[i]);</span><br><span class="line">        <span class="keyword">if</span> (pDataArray[i] != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">free</span>(pDataArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _tsystem(_T(<span class="string">"PAUSE"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">MyThreadFunc</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PMYDATA pMyData = (PMYDATA)lpParam;</span><br><span class="line">    _tprintf(_T(<span class="string">"Parameters = %d,%d\n"</span>),pMyData-&gt;val1,pMyData-&gt;val2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrorHandler</span><span class="params">(LPTSTR lpszFunction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LPVOID lpMsgBuf;</span><br><span class="line">    DWORD dwError = GetLastError();</span><br><span class="line">    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |</span><br><span class="line">                  FORMAT_MESSAGE_IGNORE_INSERTS,</span><br><span class="line">                  <span class="literal">NULL</span>,dwError,</span><br><span class="line">                  MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),</span><br><span class="line">                  (LPTSTR)&amp;lpMsgBuf,</span><br><span class="line">                  <span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    _tprintf(_T(<span class="string">"%s failed with error %d:%s"</span>),lpszFunction,dwError,lpMsgBuf);</span><br><span class="line">    LocalFree(lpMsgBuf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=========================================================================================================</span><br><span class="line">=========================================================================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;tchar.h&gt;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI ThreadFunction(LPVOID lpParam)</span><br><span class="line">&#123;</span><br><span class="line">    _tprintf(_T(<span class="string">"Thread(0x%0X) Runing!\n"</span>), GetCurrentThreadId());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建并挂起新线程</span></span><br><span class="line">    HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">                   ThreadFunction, <span class="literal">NULL</span>,</span><br><span class="line">                   CREATE_SUSPENDED,  <span class="comment">//挂机线程</span></span><br><span class="line">                   <span class="literal">NULL</span>);</span><br><span class="line">    _tprintf(_T(<span class="string">"Thread Created!\n"</span>));</span><br><span class="line">    ResumeThread(hThread);</span><br><span class="line">    Sleep(<span class="number">5</span>); <span class="comment">//如果在这里睡眠，将改变ThreadResume与线程函数里输入语句的顺序！</span></span><br><span class="line">    _tprintf(_T(<span class="string">"Thread Resume!\n"</span>));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    _tsystem(_T(<span class="string">"PAUSE"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="终止运行线程"><a href="#终止运行线程" class="headerlink" title="终止运行线程"></a>终止运行线程</h2><p><strong>（1）4种终止线程的方式</strong></p>
<table>
<thead>
<tr>
<th>终止方式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>线程函数返回</td>
<td><strong>强烈推荐 ，</strong>这是保证所有资源被正确清理的唯一方式！可以确保以下工作正确执行。①该函数中的所有C++对象被正确析构。②正确释放线程栈；③把线程退出代码设为函数的返回值；④递减内核对象的计数。</td>
</tr>
<tr>
<td>ExitThread</td>
<td>①“杀死<strong>主调</strong>线程”，操作系统将清理该线程使用的所有操作系统资源（<strong>包括线程堆栈</strong>）②可以指定dwExitCode为线程的退出代码；③C\C++资源不会被销毁</td>
</tr>
<tr>
<td>TerminateThread</td>
<td>①<strong>杀死任何线程</strong>；②线程内核对象减1；③<strong>不销毁线程堆栈</strong>，微软故意这样做，是为了保证其他线程还可以访问被“杀死”线程栈上的值，<strong>该堆栈会等到进程结束时才被释放</strong>。③该函数是<strong>异步</strong>的，函数返回时并不保证另一线程被终止。可用WaitForSingleObject判断线程是否终止。④将<strong>不会通知DLLMain函数某个线程退出</strong>，可能导致资源无法释放。</td>
</tr>
<tr>
<td>进程终止运行时</td>
<td>①ExitProcess或TerminateProcess会终止进程中所有进程，同时释放资源。②这两个函数就好象为每个线程调用TerminateThread，所以C++对象的析构不会被调用，数据不会回写磁盘……</td>
</tr>
</tbody>
</table>
<p><strong>（2）线程终止运行时</strong></p>
<p>　　①线程拥有的所有用户对象句柄被释放（如窗口和钩子句柄）</p>
<p>　　②线程退出代码从<strong>STILL_ACTIVE</strong>变成传给ExitThread或TerminateThread参数的退出代码。</p>
<p>　　③线程内核对象的<strong>状态变为触发状态</strong>，线程内核对象的<strong>使用计数减1</strong>。</p>
<p>　　④如果线程是进程的最后一个活动线程，则进程也被终止。</p>
<p><br>  </p>
<h2 id="线程内幕"><a href="#线程内幕" class="headerlink" title="线程内幕"></a>线程内幕</h2><p><strong>（1）线程内部运行机制</strong>  </p>
<p><img src="/2018/12/10/windows-kernel/image-10.png" width="500px"></p>
<p>​    ①<strong>使用计数</strong>：CreateThread创建内核对象，使用计数初始值为2（注意：这要求对象的销毁须等线程返回并且关闭从CreateThread返回的对象句柄）</p>
<p>　　②<strong>暂停计数</strong>：初始化时设为1。但当线程完成初始化后，系统<strong>检查CREATE_SUSPENDED</strong>标志是否被设置。如果<strong>没被设置，则递减1</strong>，从而变为0。这意味着<strong>线程可以开始执行了</strong>。</p>
<p>　　③<strong>退出代码</strong>为STILL_ACTIVE，<strong>对象状态</strong>为未触发状态。</p>
<p>　　④分配线程栈，将分别将<strong>pvParam</strong>和线程函数的地址<strong>pfnStartAddr</strong>压入栈中。</p>
<p>　　⑤线程上下文（CPU寄存器状态）：保存在线程内核对象中，其中SP指向栈顶（即pfnStartAddr）,IP指向RtlUserThreadStart函数（NTDLL.dll中）</p>
<p>（2）RtlUserThreadStart函数执行的操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*该函数是新线程真正开始执行的地方（而不是线程函数），虽然该函数有两个参数，有但这并不意味该函数是被其他函数调用的（即不要认为新线程开始执行还要再还上层去找），系统在初始化线程时，这两个参数会被操作系统显式写入线程栈中（但有的CPU架构在传这两个参数时是用寄存器的），所以该函数并没有被其他函数调用，是线程真正开始的地方</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">RTLUserThreadStart</span><span class="params">(PTHREAD_START_ROUTINE pfnStartAddr, PVOID pvParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//①调用“线程函数”，并传入CreateThread传过来的pvParam参数。</span></span><br><span class="line">        <span class="comment">//②退出时调用ExitThread，该函数会使线程内核对象计数递减，并设置退出代码为“线程函数”返回值。</span></span><br><span class="line">        <span class="comment">//③因调用的是ExitThread或ExitProcess退出线程的，这意味着线程永远不会退出RtlUserThreadStart函数，它始络在其内部“消亡”，因此该函数</span></span><br><span class="line">        <span class="comment">//的返回值为VOID，表示永远不会返回。</span></span><br><span class="line">        <span class="comment">//④因为该函数不会返回，而且线程栈中也没有其返回地址（因为没有被其他函数调用），如果在没有强行“杀死”线程的前提下尝试返回，</span></span><br><span class="line">        <span class="comment">//RtlUserThreadStart将返回到某个随机的内存位置</span></span><br><span class="line">        ExitThread((pfnStartAddr(pvParam)); <span class="comment">//回调“线程函数”，并传入pvParam参数</span></span><br><span class="line">    &#125;</span><br><span class="line">    __except (UnhandleExceptionFilter(GetExceptionInformation()))</span><br><span class="line">    &#123;</span><br><span class="line">        ExitProcess(GetExceptionCode());<span class="comment">//线程函数调用出错，则直接退出进程！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该函数永远不会返回（因为在ExitThread或ExitProcess中退出了）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="C-C-运行库注意事项"><a href="#C-C-运行库注意事项" class="headerlink" title="C/C++运行库注意事项"></a>C/C++运行库注意事项</h3><h4 id="beginThreadex的内部实现"><a href="#beginThreadex的内部实现" class="headerlink" title="_beginThreadex的内部实现"></a><code>_beginThreadex</code>的内部实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">_CRTIMP <span class="keyword">uintptr_t</span> __cdecl _beginthreadex(</span><br><span class="line">    <span class="keyword">void</span> *security,</span><br><span class="line">    <span class="keyword">unsigned</span> stacksize,</span><br><span class="line">    <span class="keyword">unsigned</span>(__stdcall * initialcode) (<span class="keyword">void</span> *),</span><br><span class="line">    <span class="keyword">void</span> * argument,</span><br><span class="line">    <span class="keyword">unsigned</span> createflag,</span><br><span class="line">    <span class="keyword">unsigned</span> *thrdaddr</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//_tiddata是个结构体，是为每线程独享的数据块，（在mtdll.h定义中）</span></span><br><span class="line">    <span class="comment">//他是从C\C++运行库的堆上分配的，传给_beginthreadex的线程函数和pvParam</span></span><br><span class="line">    <span class="comment">//参数都保存在这个数据块中，同时该结构还保存C\C++运行库中可能导致线程不安全</span></span><br><span class="line">    <span class="comment">//的那些函数中的静态变量（如strok函数使用了依赖于静态变量）</span></span><br><span class="line">    _ptiddata ptd;               <span class="comment">/* 指向每线程数据块指针（使用TLS技术） */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> thdl;              <span class="comment">/* 线程句柄 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> err = <span class="number">0L</span>;      <span class="comment">/* 从GetLastError()返回的错误代码 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> dummyid;            <span class="comment">/* 假的线程ID*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* validation section 检查initialcode（线程函数指针）是否为NULL */</span></span><br><span class="line">    _VALIDATE_RETURN(initialcode != <span class="literal">NULL</span>, EINVAL, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在C\C++运行库的堆上分配一个_tiddata结构的内存，并赋值给ptd指针</span></span><br><span class="line">    <span class="keyword">if</span> ((ptd = (_ptiddata)_calloc_crt(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct _tiddata))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化_tiddata结构体</span></span><br><span class="line">    _initptd(ptd, _getptd()-&gt;ptlocinfo);</span><br><span class="line"></span><br><span class="line">    ptd-&gt;_initaddr = (<span class="keyword">void</span> *)initialcode;  <span class="comment">//线程函数指针</span></span><br><span class="line">    ptd-&gt;_initarg = argument;              <span class="comment">//线程函数的参数</span></span><br><span class="line">    ptd-&gt;_thandle = (<span class="keyword">uintptr_t</span>)(<span class="number">-1</span>);       <span class="comment">//线程句柄（伪句柄）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保传入CreateThread函数的thrdaddr（即用来接收线程ID的指针）不为空</span></span><br><span class="line">    <span class="keyword">if</span> (thrdaddr == <span class="literal">NULL</span>) <span class="comment">//判断是否需要返回线程ID号</span></span><br><span class="line">        thrdaddr = &amp;dummyid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用CreateThread函数来创建新线程</span></span><br><span class="line">    <span class="keyword">if</span> (thdl = (<span class="keyword">uintptr_t</span>)CreateThread((LPSECURITY_ATTRIBUTES)security,</span><br><span class="line">        stacksize,</span><br><span class="line">        _threadstartex,  <span class="comment">//在_beginthreadex内部，线程函数的地址被修改成_threadstartex</span></span><br><span class="line">        (LPVOID)ptd,     <span class="comment">//将_tiddata数据块的指针传给线程函数</span></span><br><span class="line">        createflag,</span><br><span class="line">        (LPDWORD)thrdaddr) <span class="comment">//要返回的线程ID指针</span></span><br><span class="line">        == (<span class="keyword">uintptr_t</span>)<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err = GetLastError();</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建成功，返回线程句柄</span></span><br><span class="line">    <span class="keyword">return</span>(thdl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程错误时的处理</span></span><br><span class="line">error_return:</span><br><span class="line">    <span class="comment">//回收由_calloc_crt()申请的_tiddata块</span></span><br><span class="line">    _free_crt(ptd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校正错误代码（可以使用GetLastError()得到错误代码）</span></span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0L</span>)</span><br><span class="line">        _dosmaperr(err);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>((<span class="keyword">uintptr_t</span>)<span class="number">0</span>); <span class="comment">//返回值为NULL的无效句柄</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//_threadstartex() -新线程开始的地方</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> WINAPI _threadstartex(<span class="keyword">void</span> * ptd)</span><br><span class="line">&#123;</span><br><span class="line">    _ptiddata _ptd;   <span class="comment">/*从CreateThread传入的线程函数参数  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查动态库中的THREAD_ATTACH调用中是否初始化ptd</span></span><br><span class="line">    <span class="keyword">if</span> ((_ptd = (_ptiddata)__crtFlsGetValue(__get_flsindex())) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将tiddata数据库与线程关联起来</span></span><br><span class="line">        <span class="keyword">if</span> (!__crtFlsSetValue(__get_flsindex(), ptd))</span><br><span class="line">            ExitThread(GetLastError());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将线程ID保存在_tiddata数据块中。（父线程在调用了CreateThread</span></span><br><span class="line">        <span class="comment">//以后不能再设置线程ID这个字段了，因为子线程可能己经运行完毕，</span></span><br><span class="line">        <span class="comment">//并释放了_tiddata数据块）</span></span><br><span class="line">        ((_ptiddata)ptd)-&gt;_tid = GetCurrentThreadId(); <span class="comment">//保存父线程ID</span></span><br><span class="line">        _ptd = ptd;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _ptd-&gt;_initaddr = ((_ptiddata)ptd)-&gt;_initaddr;</span><br><span class="line">        _ptd-&gt;_initarg = ((_ptiddata)ptd)-&gt;_initarg;</span><br><span class="line">        _ptd-&gt;_thandle = ((_ptiddata)ptd)-&gt;_thandle;</span><br><span class="line"></span><br><span class="line">        _freefls(ptd); <span class="comment">//如果动态库中己经初始化了ptd，由释放ptd</span></span><br><span class="line">        ptd = _ptd;   <span class="comment">//将ptd赋新的值_ptd</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _ptd-&gt;_initapartment = __crtIsPackagedApp();</span><br><span class="line">    <span class="keyword">if</span> (_ptd-&gt;_initapartment)</span><br><span class="line">    &#123;</span><br><span class="line">        _ptd-&gt;_initapartment = _initMTAoncurrentthread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用Helper函数</span></span><br><span class="line">    _callthreadstartex();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下将永远不会执行，因为线程最终会终止在_callthreadstartex函数内部！</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _callthreadstartex(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _ptiddata ptd;           <span class="comment">/* 指向_tiddata指针 */</span></span><br><span class="line"></span><br><span class="line">    ptd = _getptd(); <span class="comment">//从TLS中获取指向_tiddata的指针</span></span><br><span class="line"></span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="comment">//在这里调用我们的线程函数（函数指针_initaddr字段，参数在_initarg中）</span></span><br><span class="line">        <span class="comment">//线程函数结束后，将返回值并为_endthreadex的参数来调用_endthreadex以</span></span><br><span class="line">        <span class="comment">//便结束线程（注意，很明显，线程会“死”在_callthreadstartex中）</span></span><br><span class="line">        _endthreadex(</span><br><span class="line">            ((<span class="keyword">unsigned</span> (__CLR_OR_STD_CALL *)(<span class="keyword">void</span> *))(((_ptiddata)ptd)-&gt;_initaddr))</span><br><span class="line">            (((_ptiddata)ptd)-&gt;_initarg));</span><br><span class="line">    &#125;</span><br><span class="line">    __except (_XcptFilter(GetExceptionCode(), GetExceptionInformation()))</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//可能永远不会被执行！</span></span><br><span class="line">        _exit(GetExceptionCode());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">/* end of _try - _except */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【关于 _beginthreadex说明的几点】</p>
<p>　　①因为_beginthreadex和_endthreadex是CRT线程函数，所以必须注意<strong>编译选项</strong>runtimelibaray的选择，使用<strong>MT或MTD</strong>（MultiThreaded , Debug MultiThreaded）</p>
<p>　　②每个线程均获得由C/C++运行期库的堆栈分配的自己的<strong>tiddata</strong>内存结构。（tiddata结构位于Mtdll.h文件中的VisualC++源代码中）</p>
<p>　　③传递给_beginthreadex的<strong>线程函数的地址保存在tiddata内存块</strong>中。传递给该<strong>函数的参数也保存在该数据块中</strong></p>
<p>　　④_beginthreadex确实从<strong>内部调用CreateThread</strong>，因为这是操作系统了解如何创建新线程的唯一方法</p>
<p>　　⑤当调用CreatetThread时，它被告知通过<strong>调用_threadstartex而不是pfnStartAddr来启动执行新线程</strong>。还有，传递给<strong>线程函数的参数是tiddata结构而不是pvParam的地址。**</strong>即新线程首先执行RtlUserStartAddr，然后跳转进入_threadstartex。**</p>
<h4 id="endthreadex的内部实现"><a href="#endthreadex的内部实现" class="headerlink" title="_endthreadex的内部实现"></a><code>_endthreadex</code>的内部实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __cdecl _endthreadex(</span><br><span class="line">    <span class="keyword">unsigned</span> retcode</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    _ptiddata ptd;           <span class="comment">/* 指向_tiddata的指针 */</span></span><br><span class="line">    HANDLE handle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ptd = _getptd_noexit(); <span class="comment">//获得指向_tiddata的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除_tiddata块中的floating-point</span></span><br><span class="line">    <span class="keyword">if</span> (ptd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptd-&gt;_initapartment)</span><br><span class="line">            _uninitMTAoncurrentthread();</span><br><span class="line"></span><br><span class="line">        _freeptd(ptd); <span class="comment">//释放tiddata结构体，内存被正确释放！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出线程</span></span><br><span class="line">    ExitThread(retcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【关于 _endthreadex说明的几点】　</p>
<p>　　①C运行期库的_getptd函数内部调用操作系统的TlsGetValue函数，该函数负责检索主调线程的<strong>tiddata</strong>内存块的地址。</p>
<p>　　②然后<strong>该数据块被释放</strong>，而操作系统的ExitThread函数被调用，以便真正撤消该线程。当然，退出代码要正确地设置和传递。</p>
<blockquote>
<p><strong>使用_beginthreadex而不要用CreateThread函数</strong></p>
</blockquote>
<p><strong>（1）如果使用CreateThread而不是_beginthreadex来创建线程会发生什么情况？</strong></p>
<p>　　①当线程调用一个需要_tiddata结构的C\C++运行库函数（如strok）时，这个运行库函数会检查到_tiddata块为NULL，而会<strong>自动创建一个与主调线程关联的_tiddata块</strong>，这样做的目的是保证该库函数能正常运行。（注意，以后调用的任何C\C++运行库都可以使用这个_tiddata块，而无需重复创建！）。</p>
<p>　　②但因CreateThread是API函数，<strong>不会像_endthreadex那样去销毁这个数据块</strong>，因此<strong>可能造成内存泄漏</strong>。</p>
<p>　　③如果线程使用了C\C++运行库的signal函数，则会导致整个进程终止，因为CreateThread函数没有为这个函数准备结构化异常处理帧（SEH）</p>
<p><strong>（2）也不要使用_beginthread/_endthread函数</strong>（注意，<strong>函数名后不带ex</strong>）</p>
<p>　　①_beginthread函数参数少，没有CREATE_SUSPENDED，也不能获取线程ID值</p>
<p>　　②_endthread是无参的，意味着线程的退出代码被硬编码为0</p>
<p>　　③<strong>_endthread内部会调用CloseHandle来关闭新线程</strong>，但这会造成潜在的危险！如：</p>
<p>  DWORD dwExitCode;</p>
<p>  HANDLE hThread  = _beginthread(…);          //该函数会使新线程<strong>立即运行！</strong></p>
<p>  GetExitCodeThread(hThread,&amp;dwExitCode); //但子线程<strong>可能</strong>在该语句之前就<strong>结束</strong>了</p>
<p>​                                                                 //但_endthread<strong>内部调用了CloseHandle</strong>使hThread无效！</p>
<p>  CloseHandle(hThread);  //这里<strong>重复关闭hTread就会出错</strong>。</p>
<p>★<strong>_endthreadex函数内部不会关闭线程句柄</strong>，因此以上代码<strong>不会有bug</strong></p>
<h3 id="了解自己"><a href="#了解自己" class="headerlink" title="了解自己"></a>了解自己</h3><p>（1）伪句柄：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>函数</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取当前进程的句柄值</td>
<td>GetCurrentProcess</td>
<td>永远都是0xFFFFFFFF</td>
</tr>
<tr>
<td>获取当前线程的句柄值</td>
<td>GetCurrentThread</td>
<td>永远都是0xFFFFFFFE</td>
</tr>
</tbody>
</table>
<p>   说明：</p>
<p>　　①伪句柄不会在主调进程句柄表中新建句柄项，故<strong>不会影响相应内核对象的使用计数</strong></p>
<p>　　②如果<strong>调用CloseHandle关闭伪句柄</strong>，<strong>该参数会被忽略</strong>，被返回FALSE。调用GetLastError将返回ERROR_INVALID_HANDLE。</p>
<p>　　③<strong>A线程的伪句柄作为参数传递给B线程时</strong>，该参数不能正确表示A线程，相反，在B线程中，<strong>该句柄其实代表的是B（因为B的伪句柄也是0xFFFFFFFE）</strong>。</p>
<p>（2）将伪句柄转换为真实的句柄：DubplicateHandle函数</p>
<p>（3）获取线程、进程运行的CPU时间</p>
<p>　　①GetThreadTime</p>
<p>　　②GetProcessTime</p>
<p><br><br><br></p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><h3 id="线程的挂起和恢复"><a href="#线程的挂起和恢复" class="headerlink" title="线程的挂起和恢复"></a>线程的挂起和恢复</h3><p><strong>（1）线程挂起</strong></p>
<p>　　①创建时（如CreateProcess、CreateThread），传入CREATE_SUSPENDED标志</p>
<p>　　②用SuspendThread挂起线程。这个函数可以挂起自己，也可以挂起其它线程（只要有线程句柄）</p>
<p>　　③调用SuspendThread时，如果这时<strong>线程执行在用户态，线程会马上被挂起</strong>。如果<strong>调用SuspendThread时线程己经执行在内核态时</strong>，SuspendThread会异步返回，而<strong>线程并不会马上暂停</strong>。但当该线程从内核态又转为用户态时，则会立即被暂停。</p>
<p>　　④当调用SuspendThread挂起线程时，我们并不知道线程在做什么？如果此时A线程正在分配堆中的内存，则它将会锁定堆，这会导致此时也要访问堆的B线程被中止，直到A恢复，而这可能引起其他问题或者死锁。所以<strong>只有在确切目标线程在哪里</strong>（或在做什么时）<strong>调用SuspendThread才是安全</strong>的。</p>
<p>　　⑤线程在挂机计数不为0或没有消息队列没有消息时，是不可调度的（没时间片）</p>
<p><strong>（2）线程恢复：</strong>ResumeThread，<strong>返回前一个挂起计数</strong>，否则返回0xFFFFFFFF。</p>
<p>　　①一个线程可以被多次挂起，最多可以挂起MAXIMUNM_SUSPEND_COUNT（127）次</p>
<p>　　②线程被挂起多次时，只有恢复到挂起计数为0时，才可以重新被调度。</p>
<p>（3）可以调用GetSystemTimeAdjustment来查看线程切换的周期（大约20ms）</p>
<p><br></p>
<h3 id="进程的挂起和恢复"><a href="#进程的挂起和恢复" class="headerlink" title="进程的挂起和恢复"></a>进程的挂起和恢复</h3><p>（1）进程的挂起——挂起进程中所有的线程（注意进程本身是不可调度的）</p>
<p>　　①Windows没有提供挂起进程中所有线程的方法，因为存在竞态条件问题。（如在线程被挂起时，可能创建一个新的线程。系统必须想方设法挂起这个时间段内创建任何新线程。</p>
<p>　　②自定义的SuspendProcess函数（用来挂起所有线程）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//挂起进程中所有的线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SuspendProcess</span><span class="params">(DWORD dwProcessID, BOOL fSuspend)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwThreadID = GetCurrentThreadId(); <span class="comment">//主调线程ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取系统中所有线程列表，第2个参数为0时表示当前进程</span></span><br><span class="line">    HANDLE hSnapshot = CreateToolhelp32Snapshot</span><br><span class="line">                           (TH32CS_SNAPTHREAD, dwProcessID);</span><br><span class="line">    <span class="keyword">if</span> (hSnapshot != INVALID_HANDLE_VALUE)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          以下在枚举线程过程中，可能有新的线程创建，也可能有线程被销毁。但CreateToolhelp32SnapShot只是快照，无法反应这一变化。</span></span><br><span class="line"><span class="comment">          所以新的线程就不会被挂机。同时，被销毁的线程ID可能被另一个进程中的线程给占用，这会造成误挂其他进程中的线程的潜在风险。因此这个函数要慎用。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//遍历线程列表</span></span><br><span class="line">        THREADENTRY32 te = &#123; <span class="keyword">sizeof</span>(te) &#125;;</span><br><span class="line">        BOOL fOk = Thread32First(hSnapshot, &amp;te);</span><br><span class="line">        <span class="keyword">for</span> (; fOk;fOk=Thread32Next(hSnapshot,&amp;te))&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//线程是否在目标进程中</span></span><br><span class="line">            <span class="keyword">if</span> (te.th32OwnerProcessID != dwProcessID)</span><br><span class="line">                <span class="keyword">continue</span>;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//尝试将线程ID转换为线程句柄(可挂机和恢复线程)</span></span><br><span class="line">            HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME,</span><br><span class="line">                                        FALSE, te.th32ThreadID);</span><br><span class="line">            <span class="keyword">if</span> (hThread != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="comment">//挂机或恢复线程</span></span><br><span class="line">                <span class="keyword">if</span> (fSuspend)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//防止主调函数挂起自己，导致循环无法进行而不能挂机其他线程</span></span><br><span class="line">                    <span class="keyword">if</span> (te.th32ThreadID != dwThreadID)</span><br><span class="line">                        SuspendThread(hThread);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    ResumeThread(hThread);</span><br><span class="line">            &#125;</span><br><span class="line">            CloseHandle(hThread);                </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CloseHandle(hSnapshot);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果要挂机进程，最后挂起主调进程</span></span><br><span class="line">        <span class="keyword">if</span> (fSuspend)&#123;</span><br><span class="line">            HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME,</span><br><span class="line">                                        FALSE, dwThreadID);</span><br><span class="line">            <span class="keyword">if</span>(hThread)</span><br><span class="line">                SuspendThread(hThread);</span><br><span class="line">            CloseHandle(hThread);        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(PVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TRUE)&#123;</span><br><span class="line">        _tprintf(_T(<span class="string">"线程（ID:0x%04X)，正在输出... \t时间%d\n"</span>),</span><br><span class="line">                 GetCurrentThreadId(), GetTickCount());</span><br><span class="line">        Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line">    _tsetlocale(LC_ALL, _T(<span class="string">"chs"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建两个线程，线程刚创建时是挂起的——这两个线程用来测试SuspendProcess函数</span></span><br><span class="line">    HANDLE hThread1 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, CREATE_SUSPENDED, <span class="literal">NULL</span>);</span><br><span class="line">    HANDLE hThread2 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, CREATE_SUSPENDED, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread1);</span><br><span class="line">    CloseHandle(hThread2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唤醒所有线程</span></span><br><span class="line">    _tprintf(_T(<span class="string">"正在唤醒线程...\n"</span>));</span><br><span class="line">    SuspendProcess(GetCurrentProcessId(), FALSE);</span><br><span class="line">    </span><br><span class="line">    _tsystem(_T(<span class="string">"PAUSE"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在线程运行过程， 按任意键可以挂起进程</span></span><br><span class="line">    _tprintf(_T(<span class="string">"进程己被挂起！\n"</span>));</span><br><span class="line">    SuspendProcess(GetCurrentProcessId(), TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因所有线程都被挂起，进程中无活动线程，故进程（线）程无法被唤醒</span></span><br><span class="line">    <span class="comment">//所以后面的代码无法执行！</span></span><br><span class="line">    <span class="comment">//再次唤醒所有线程</span></span><br><span class="line">    _tprintf(_T(<span class="string">"正在唤醒线程...\n"</span>));</span><br><span class="line">    SuspendProcess(GetCurrentProcessId(), FALSE);</span><br><span class="line">    _tsystem(_T(<span class="string">"PAUSE"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="睡眠"><a href="#睡眠" class="headerlink" title="睡眠"></a>睡眠</h3><p>（1）调用Sleep函数，将使线程<strong>自愿放弃</strong>属于它的时间片中<strong>剩下的部分</strong></p>
<p>（2）dwMilliseconds只是近似的毫秒数。因为Windows不是实时操作系统，可以过了这个时间段，系统仍在调用其他线程。</p>
<p>（3）dwMilliseconds为<strong>INFINITE</strong>时，<strong>表示永远不要调用这个线程</strong>（但这不好，如果不调用线程，<strong>应该让其退出</strong>！）</p>
<p>（4）dwMilliseconds为0时，<strong>主动放弃剩余时间片</strong>。但如果没有更高优先级线程（优先级≥本线程）可调度时，<strong>这个线程可能被重新调度，即使低优先级线程仍处在饥饿状态</strong>。</p>
<p><br></p>
<h3 id="切换到另一个线程"><a href="#切换到另一个线程" class="headerlink" title="切换到另一个线程"></a>切换到另一个线程</h3><p>（1）调用此函数时，系统会查看是否存在正饥饿线程，如果没有立即返回，调用线程继续执行。如果有，则会调用其他线程（但与Sleep(0)不同，<strong>对另一个线程优先级没有要求，其优先级可以比调用函数的线程低</strong>）</p>
<p>（2）该函数允许一个需要资源的线程强制另一个优先级较低、而目前却拥有该资源的线程放弃该资源。</p>
<p>（3）返回值：如果没有其他线程可以调度，返回FALSE。否则返回非零</p>
<p><br>  </p>
<h3 id="CONTEXT结构"><a href="#CONTEXT结构" class="headerlink" title="CONTEXT结构"></a>CONTEXT结构</h3><p>（1）线程CONTEXT记录线程的状态（如CPU各<strong>寄存器状态</strong>），以供下次调度时从停止处继续。</p>
<p>（2）CONTEXT的结构（要获得或设置时，必须在Context.ContextFlags<strong>设置相应的标志</strong>）</p>
<table>
<thead>
<tr>
<th><strong>标志</strong></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONTEXT_CONTROL</td>
<td>控制寄存器，如EIP、ESP，EBP等</td>
</tr>
<tr>
<td>CONTEXT_INTEGER</td>
<td>整数寄存器，如EDI、ESI、EBX、EDX、ECX、EAX等</td>
</tr>
<tr>
<td>CONTEXT_FLOATING_POINT</td>
<td>浮点寄存器，将寄存器结果返回到FLOATING_SAVE_AREA FloagSave</td>
</tr>
<tr>
<td>CONTEXT_SEGMENTS</td>
<td>段寄存器，如GS、FS、ES、DS</td>
</tr>
<tr>
<td>CONTEXT_DEBUG_REGISTERS</td>
<td>调试寄存器，如DR0、……、DR7</td>
</tr>
<tr>
<td>CONTEXT_EXTENDED_REGISTERS</td>
<td>扩展寄存器，将寄存器的结果返回到BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION]数组中</td>
</tr>
</tbody>
</table>
<p>★<strong>CONTEXT_FULL标志 = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS</strong></p>
<p>（3）获取和设置上下文</p>
<p>①先<strong>挂起线程</strong>和<strong>设置</strong>CONTEXT结构体<strong>相应的标志</strong></p>
<p>②Get\SetThreadContext;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(PVOID pvParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hEvent = (HANDLE)pvParam;</span><br><span class="line">    WaitForSingleObject(hEvent, INFINITE);</span><br><span class="line">    CloseHandle(hEvent);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line">    _tsetlocale(LC_ALL, _T(<span class="string">"chs"</span>));</span><br><span class="line"></span><br><span class="line">    HANDLE hEvent = CreateEvent(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    HANDLE hEventDup = <span class="literal">NULL</span>;</span><br><span class="line">    DuplicateHandle(GetCurrentProcess(), hEvent, </span><br><span class="line">                    GetCurrentProcess(), &amp;hEventDup,</span><br><span class="line">                    DUPLICATE_SAME_ACCESS,FALSE,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, hEventDup,</span><br><span class="line">                                  CREATE_SUSPENDED,<span class="literal">NULL</span>);</span><br><span class="line">    ResumeThread(hThread);</span><br><span class="line"></span><br><span class="line">    SuspendThread(hThread);</span><br><span class="line">    CONTEXT ct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ct.ContextFlags = CONTEXT_ALL;</span><br><span class="line">    GetThreadContext(hThread, &amp;ct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示CONTEXT的内容</span></span><br><span class="line">    _tprintf(_T(<span class="string">"CPU寄存器状态：\n"</span>));</span><br><span class="line">    _tprintf(_T(<span class="string">"\tEAX=0x%08X,EBX=0x%08X\n"</span>),ct.Eax,ct.Ebx);</span><br><span class="line">    _tprintf(_T(<span class="string">"\tECX=0x%08X,EDX=0x%08X\n"</span>), ct.Ecx, ct.Edx);</span><br><span class="line">    _tprintf(_T(<span class="string">"\tESI=0x%08X,EDI=0x%08X\n"</span>), ct.Esi, ct.Edi);</span><br><span class="line">    _tprintf(_T(<span class="string">"\tEIP=0x%08X,ESP=0x%08X\n"</span>), ct.Eip, ct.Esp);</span><br><span class="line">    _tprintf(_T(<span class="string">"\tEBP=0x%08X,EFL=0x%08X\n"</span>), ct.Ebp, ct.EFlags);</span><br><span class="line"></span><br><span class="line">    ResumeThread(hThread);</span><br><span class="line">    SetEvent(hEvent);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hEvent);</span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    _tsystem(_T(<span class="string">"PAUSE"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>（1）线程<strong>优先级被分为0-31级</strong>，其中0级最低、31级最高。但编程时不能直接更改这个数字，要通过“<strong>进程优先级类</strong>”和“<strong>线程相对优先级</strong>”设置。</p>
<p>（2）每次调度时，如果有优先级31级线程可供调度，那系统将CPU分配给该线程。结束后，会查看是否还在在优先级31级的线程可调度，如果存在，它将获得CPU，其他的0-30级是不会分配CPU。这种现象称为<strong>“饥饿”</strong></p>
<p>（3）较高优先高级的线程总是抢占较低优先级的，无论<strong>较低优先级的线程是否正在执行，如果正在运行，则会被立即暂停</strong>，将将CPU分配给较高优先级线程，而且该线程将获得一个完整的时间片</p>
<p>（4）优先级0的线程是个特殊线程，整个系统中只有一个<strong>0等级的线程</strong>，称为<strong>“页面清零线程”</strong>，这个线程负责在没有其他线程需要执行的时候，将系统内存中所有闲置页面清零。</p>
<h3 id="从抽象角度看优先级"><a href="#从抽象角度看优先级" class="headerlink" title="从抽象角度看优先级"></a>从抽象角度看优先级</h3><p>（1）<strong>进程优先级类</strong></p>
<table>
<thead>
<tr>
<th><strong>优先级(及标识符)</strong></th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Time-critical</strong>(REALTIME_PRIORITY_CLASS)</td>
<td>此进程中的线程必须立即响应，执行实时任务。此进程中的线程学会抢占操作系统的组件的CPU时间，使用该优先级类需极为小心。默认下用户进程是不能运行在该优先级类的，除非用户有InCreateSchedulingPriority（提高计划优先级）的特权。</td>
</tr>
<tr>
<td><strong>High(**</strong>高)**(HIGH_PRIORITY_CLASS)</td>
<td>此进程中的线程必须立即响应，执行实时任务。任务管理器运行在这一级。因此用户可通过它来结束失控的进程</td>
</tr>
<tr>
<td><strong>Above normal(**</strong>高于标准)**(ABOVE_NORMAL_PRIOORITY_CLASS)</td>
<td>此进程中的线程运行在Normal和Hight优先级类之间</td>
</tr>
<tr>
<td><strong>Normal**</strong>（标准）**(NORMAL_PRIORITY_CLASS)</td>
<td>此进程中的线程无需特殊调度</td>
</tr>
<tr>
<td><strong>Below normal(**</strong>低于标准)**(BELOW_NORMAL_PRIORITY_CLASS)</td>
<td>此进程中的线程运行在Normal和Idle类之间</td>
</tr>
<tr>
<td>Idle（空闲）(IDLE_PRIORITY_CLASS)</td>
<td>在系统空闲时运行。如屏幕保护程序、后台实用程序和统计数据收集软件通常使用该优先级类</td>
</tr>
</tbody>
</table>
<p>（2）<strong>线程的相对优先级</strong></p>
<table>
<thead>
<tr>
<th><strong>优先级</strong></th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Time0(实时)</td>
<td>对于进程是real-time优先级类，线程运行在31上；所有其他基本优先级类的进程时运行在15</td>
</tr>
<tr>
<td>Highest</td>
<td>线程运行在高于normal之上两个级别</td>
</tr>
<tr>
<td>Above normal(高于标准)</td>
<td>线程运行在高于normal之上一个级别</td>
</tr>
<tr>
<td>Normal（标准）</td>
<td>运行在normal级别</td>
</tr>
<tr>
<td>Below normal(低于标准)</td>
<td>线程运行在低于normal一个级别</td>
</tr>
<tr>
<td>Lowest</td>
<td>线程运行在低于normal两个级别</td>
</tr>
<tr>
<td>Idle（空闲）</td>
<td>对于real-time优先级类时，线程运行在16，其他优先级类运行在1</td>
</tr>
</tbody>
</table>
<p>（3）<strong>线程优先级</strong>=进程优先级类和线程的相对优先级映射到0-31级的某个优先级上</p>
<table>
<thead>
<tr>
<th><strong>线程相对优先级**</strong>（及标识符）**</th>
<th><strong>进程优先级类</strong></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Idle</td>
<td>Belownormal</td>
<td><strong>Normal</strong></td>
<td>Above normal</td>
<td>high</td>
<td>Real-time</td>
<td></td>
</tr>
<tr>
<td><strong>Time-critial</strong>(THREAD_PRIORITY_TIME_CRITICAL)</td>
<td>15</td>
<td>15</td>
<td><strong>15</strong></td>
<td>15</td>
<td>15</td>
<td>31</td>
</tr>
<tr>
<td><strong>Highest</strong>(THREAD_PRIORITY_HIGHEST)</td>
<td>6</td>
<td>8</td>
<td><strong>10</strong></td>
<td>12</td>
<td>15</td>
<td>26</td>
</tr>
<tr>
<td><strong>Above normal</strong>(THREAD_PRIORITY_ABOVE_NORMAL)</td>
<td>5</td>
<td>7</td>
<td><strong>9</strong></td>
<td>11</td>
<td>14</td>
<td>25</td>
</tr>
<tr>
<td><strong>Normal</strong>(THREAD_PRIORITY_NORMAL)</td>
<td><strong>4</strong></td>
<td><strong>6</strong></td>
<td><strong>8</strong></td>
<td><strong>10</strong></td>
<td><strong>13</strong></td>
<td><strong>24</strong></td>
</tr>
<tr>
<td><strong>Below normal</strong>(THREAD_PRIORITY_BELOW_NORMAL)</td>
<td>3</td>
<td>5</td>
<td><strong>7</strong></td>
<td>9</td>
<td>12</td>
<td>23</td>
</tr>
<tr>
<td><strong>Lowest</strong>(THREAD_PRIORITY_LOWEST)</td>
<td>2</td>
<td>4</td>
<td><strong>6</strong></td>
<td>8</td>
<td>11</td>
<td>22</td>
</tr>
<tr>
<td><strong>Idle</strong>(THREAD_PRIORITY_IDLE)</td>
<td>1</td>
<td>1</td>
<td><strong>1</strong></td>
<td>1</td>
<td>1</td>
<td>16</td>
</tr>
</tbody>
</table>
<p>   说明：</p>
<p>　　①<strong>大多数程序线程的优先级为8</strong>，即进程优先级类为Normal、线程相对优先级为Normal</p>
<p>　　②线程优先级是相对于进程优先极的，即改变了进程优先级，级程优先权一般也将变化。</p>
<p>　　③注意：表中线程优先级值没有0，因为0优先级保留给页面清零线程</p>
<p>　　④进程为real-time优先级类中的线程，共优先级不低于16。同理，非real-time的线程优先级值不高能高于15。</p>
<p><br></p>
<h3 id="优先级编程"><a href="#优先级编程" class="headerlink" title="优先级编程"></a>优先级编程</h3><p><strong>（1）获取和设置进程优先级类</strong></p>
<p>　　①在CreateProcess中的fdwCreate参数中传入“进程优先级类”中相应的标志</p>
<p>　　②调用SetPriorityClass函数设置——（可能需要足够的访问权限，因为这函数可以改变系统中任何进程的优先级）</p>
<p>　　③GetPriorityClass获取进程优先级类</p>
<p>　　④可通过命令行（如C:\Start <strong>/low</strong> calc.exe以“低优先级”）来运行就用程序或通过“任务管理器”来改变进程的优先级类</p>
<p><strong>（2）获取和改变线程相对优先级</strong></p>
<p>　　①在CreateThread中传为CREATE_SUSPENDED，然后调用SetThreadPriority。</p>
<p>　　②运行中的线程也可通过SetThreadPriority设置相对优先级，将返回前一个优先级。</p>
<p>　　③GetThreadPriority<strong>获取线程相对优先级</strong>，但Windows并没有返回<strong>线程绝对优先级</strong>（即0-31级）的函数。</p>
<p><strong>（3）动态提升线程优先级：</strong></p>
<p>　　①线程优先级的分类：16～31为实时类型，<strong>1～15为动态类型</strong>，0为系统类型</p>
<p>　　②<strong>线程的基本优先级</strong>=线程相对优先级与进程优先级类映射出来的值（介于0-31）</p>
<p>　　③有时为<strong>及时响应某种事件</strong>，<strong>系统会动态提升线程优先级</strong>，如原来的基本优先级为13，会临时提升级别（如提升2），也就是线程当前优先级达到了15。<strong>也可能是某个低优先级的线程长时间处于饥饿状态</strong>（如3～4秒），系统会临时将优先级提到15。过两个时间片后，优先级将<strong>恢复到原来的基本优先级</strong>。（但注意，线程当前优先级<strong>不会低于</strong>基本优先级）</p>
<p>　　④<strong>系统只提升动类型（即优先级值为1～15）的线程</strong>，这个范围被称为<strong>动态优先级范围</strong></p>
<p>　　⑤可通过SetProcessPriorityBoost或SetThreadPriorityBoost来<strong>允许或禁止系统动态提升优先级</strong>的做法。当然也可以用GetProcess\ThreadPriorityBoost来查看是否启动这种行为。</p>
<p><strong>（4）为前台进程微调调度程序</strong></p>
<p>　　①前台进程：即用户正在使用进程的某个窗口，该进程为前台进程。其余为后台进程。</p>
<p>　　②系统为前台进程的线程微调调度算法，即比后台进程分配更多的时间片。这种微调只在前台进程是Normal优先级类时才进程，其他优先级类时不进行微调。</p>
<p>　　③可在Windows的“<strong>系统属性</strong>”对话框→“高级”→“性能”中单击“设置”，在弹出的“性能选项”对话框的“高级”选项卡中的“调整以优先性能中”选择“程序”，如果选择“后台服务”性能，则不会微调。</p>
<p><strong>（5）调度I/O请求优先级</strong></p>
<p>　　①I/O请求会使得CPU将时间片分配给这种I/O处理，而当一个低优先级的线程获得CPU时，它可以在短时间内产生成千个I/O请求。从而抢得CPU，使高优先级的线程被挂起。</p>
<p>　　②在WindowVista开始，线程也可以对I/O请求设置优先级。</p>
<p>　　③通过将线程相对优先极传入<strong>THREAD_MODE_BACKGROUND_BEGIN</strong>让线程进入后台工作模式此时将只允许发送低优先级的I/O请求，但这同时也降低了线程的CPU调度优先级。要结束后台工作模式里，可以现传入<strong>THREAD_MODE_BACKGROUND_END</strong>。（但注意，使用这两个标志时，<strong>只能传入主调线程的句柄</strong>，即GetCurrentThread（）。系统不允许改变另一个线程的I/O优先级。</p>
<p>　　④要改变所有线程I/O请求优先级，可用SetPriorityClass并传入PROCESS_MODE_BACKGROUND_BEGIN和PROCESS_MODE_BACKGROUND_END标志。类似地，系统不允许改变另一个进程中线程的I/O优先级。</p>
<p>　　⑤为了<strong>避免优先级逆转</strong>，如果某Normal优先级线程频繁请求I/O操作时，<strong>后台优先级线程</strong>可以在获得I/O请求前<strong>延迟几秒</strong>。如果低优先级的线程己经获得了Normal线程要等待的锁，Normal线程可以主动结束等待，但这影响了Normal线程任务的执行。为了防止这类事情发生，甚至应让后台线程不提交I/O请求，以便Normal线程正常执行，但这几乎很不现实。所以应尽量少在Normal线程与台线程之间同步锁。</p>
<p>【Scheduling Lab示例程序】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/* Module:SchdLab.cpp                                                   */</span></span><br><span class="line"><span class="comment">/* Notices:Copyright(c) 2008 Jeffrey Richter &amp; Christophe Nasarre       */</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"..\\..\\CommonFiles\\CmnHdr.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"resource.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFunc</span><span class="params">(PVOID pvParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hThreadPrimary = (HANDLE)pvParam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//挂起主线程</span></span><br><span class="line">    SuspendThread(hThreadPrimary);</span><br><span class="line">    chMB(</span><br><span class="line">        <span class="string">"主线程被挂起，将不再响应输入和产生输出.\n"</span></span><br><span class="line">        <span class="string">"按“确定”按钮恢复主线程，并退出子线程。\n"</span></span><br><span class="line">        );</span><br><span class="line">    ResumeThread(hThreadPrimary);</span><br><span class="line">    CloseHandle(hThreadPrimary);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启用“挂机按钮”</span></span><br><span class="line">    EnableWindow(</span><br><span class="line">         GetDlgItem(FindWindow(<span class="literal">NULL</span>, TEXT(<span class="string">"Scheduling Lab"</span>)), IDC_SUSPEND),</span><br><span class="line">         TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function">BOOL <span class="title">Dlg_OnInitDialog</span><span class="params">(HWND hwnd, HWND hwndFocus, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chSETDLGICONS(hwnd, IDI_SCHEDLAB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化进程优先级类组合框</span></span><br><span class="line">    HWND hWndCtrl = GetDlgItem(hwnd, IDC_PROCESSPRIORITYCLASS);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = ComboBox_AddString(hWndCtrl, TEXT(<span class="string">"高"</span>));</span><br><span class="line">    ComboBox_SetItemData(hWndCtrl, n, HIGH_PRIORITY_CLASS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存当前进程优先级类</span></span><br><span class="line">    DWORD dwpc = GetPriorityClass(GetCurrentProcess());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断系统是否支持“低于标准”优先级类</span></span><br><span class="line">    <span class="keyword">if</span> (SetPriorityClass(GetCurrentProcess(),BELOW_NORMAL_PRIORITY_CLASS))&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//恢复原始的进程优先级类</span></span><br><span class="line">        SetPriorityClass(GetCurrentProcess(), dwpc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增加“高于标准”优先级类</span></span><br><span class="line">        n = ComboBox_AddString(hWndCtrl, TEXT(<span class="string">"高于标准"</span>));</span><br><span class="line">        ComboBox_SetItemData(hWndCtrl, n, ABOVE_NORMAL_PRIORITY_CLASS);</span><br><span class="line">        dwpc = <span class="number">0</span>; <span class="comment">//作为系统是否支持“低于标准”优先级类的标志</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标准优先级类</span></span><br><span class="line">    <span class="keyword">int</span> nNormal= n = ComboBox_AddString(hWndCtrl, TEXT(<span class="string">"标准"</span>));</span><br><span class="line">    ComboBox_SetItemData(hWndCtrl, n, NORMAL_PRIORITY_CLASS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//“低于标准”优先级类</span></span><br><span class="line">    <span class="keyword">if</span> (dwpc == <span class="number">0</span>)&#123;</span><br><span class="line">        n = ComboBox_AddString(hWndCtrl, TEXT(<span class="string">"低于标准"</span>));</span><br><span class="line">        ComboBox_SetItemData(hWndCtrl, n, BELOW_NORMAL_PRIORITY_CLASS);</span><br><span class="line">    &#125;</span><br><span class="line">    n = ComboBox_AddString(hWndCtrl, TEXT(<span class="string">"空闲"</span>));</span><br><span class="line">    ComboBox_SetItemData(hWndCtrl, n, IDLE_PRIORITY_CLASS);</span><br><span class="line">    ComboBox_SetCurSel(hWndCtrl, nNormal); <span class="comment">//选中“标准”优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程相对优先级组合框</span></span><br><span class="line">    hWndCtrl = GetDlgItem(hwnd, IDC_THREADRELATIVEPRIORITY);</span><br><span class="line">    n = ComboBox_AddString(hWndCtrl, TEXT(<span class="string">"最高"</span>));</span><br><span class="line">    ComboBox_SetItemData(hWndCtrl, n, THREAD_PRIORITY_TIME_CRITICAL);</span><br><span class="line"></span><br><span class="line">    n = ComboBox_AddString(hWndCtrl, TEXT(<span class="string">"高"</span>));</span><br><span class="line">    ComboBox_SetItemData(hWndCtrl, n, THREAD_PRIORITY_HIGHEST);</span><br><span class="line"></span><br><span class="line">    n = ComboBox_AddString(hWndCtrl, TEXT(<span class="string">"高于标准"</span>));</span><br><span class="line">    ComboBox_SetItemData(hWndCtrl, n, THREAD_PRIORITY_ABOVE_NORMAL);</span><br><span class="line"></span><br><span class="line">    nNormal= n = ComboBox_AddString(hWndCtrl, TEXT(<span class="string">"标准"</span>));</span><br><span class="line">    ComboBox_SetItemData(hWndCtrl, n, THREAD_PRIORITY_NORMAL);</span><br><span class="line"></span><br><span class="line">    n = ComboBox_AddString(hWndCtrl, TEXT(<span class="string">"低于标准"</span>));</span><br><span class="line">    ComboBox_SetItemData(hWndCtrl, n, THREAD_PRIORITY_BELOW_NORMAL);</span><br><span class="line"></span><br><span class="line">    n = ComboBox_AddString(hWndCtrl, TEXT(<span class="string">"空闲"</span>));</span><br><span class="line">    ComboBox_SetItemData(hWndCtrl, n, THREAD_PRIORITY_IDLE);</span><br><span class="line"></span><br><span class="line">    ComboBox_SetCurSel(hWndCtrl, nNormal);</span><br><span class="line"></span><br><span class="line">    Edit_LimitText(GetDlgItem(hwnd, IDC_SLEEPTIME), <span class="number">4</span>); <span class="comment">//休眼最大值为9999</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dlg_OnCommand</span><span class="params">(HWND hwnd, <span class="keyword">int</span> id, HWND hwndCtrl, UINT codeNotity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (id)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> IDCANCEL:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IDC_PROCESSPRIORITYCLASS:</span><br><span class="line">        <span class="keyword">if</span> (codeNotity == CBN_SELCHANGE)&#123;</span><br><span class="line">            <span class="keyword">int</span> ntp = (<span class="keyword">int</span>)ComboBox_GetItemData(hwndCtrl, ComboBox_GetCurSel(hwnd));</span><br><span class="line">            SetThreadPriority(GetCurrentThread(), ntp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IDC_THREADRELATIVEPRIORITY:</span><br><span class="line">        <span class="keyword">if</span> (codeNotity == CBN_SELCHANGE)&#123;</span><br><span class="line">            <span class="keyword">int</span> ntp =(<span class="keyword">int</span>)ComboBox_GetItemData(hwndCtrl, ComboBox_GetCurSel(hwnd));</span><br><span class="line">            SetThreadPriority(GetCurrentThread(),ntp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IDC_SUSPEND:</span><br><span class="line">        <span class="comment">//为了避免死锁，将“挂起”按钮禁用</span></span><br><span class="line">        EnableWindow(hwndCtrl, FALSE);</span><br><span class="line"></span><br><span class="line">        HANDLE hThreadPrimary; <span class="comment">//主线程</span></span><br><span class="line">        DuplicateHandle(GetCurrentProcess(), GetCurrentThread(), </span><br><span class="line">                        GetCurrentProcess(),&amp;hThreadPrimary,</span><br><span class="line">                        THREAD_SUSPEND_RESUME,FALSE,DUPLICATE_SAME_ACCESS);</span><br><span class="line"></span><br><span class="line">        DWORD dwThreadID;</span><br><span class="line">        CloseHandle(chBEGINTHREADEX(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc,</span><br><span class="line">                        hThreadPrimary, <span class="number">0</span>, &amp;dwThreadID));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function">INT_PTR WINAPI <span class="title">Dlg_Proc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">        chHANDLE_DLGMSG(hwnd, WM_INITDIALOG, Dlg_OnInitDialog);</span><br><span class="line">        chHANDLE_DLGMSG(hwnd, WM_COMMAND, Dlg_OnCommand);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">int</span> WINAPI _tWinMain(HINSTANCE hInstExe, HINSTANCE, PTSTR szCmdLine, <span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    HWND hWnd = CreateDialog(hInstExe, MAKEINTRESOURCE(IDD_SCHEDLAB), <span class="literal">NULL</span>, Dlg_Proc); <span class="comment">//非模态对话框</span></span><br><span class="line">    BOOL fQuit = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!fQuit)&#123;</span><br><span class="line">        MSG msg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PeekMessage(&amp;msg,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,PM_REMOVE))&#123;</span><br><span class="line">            <span class="comment">//用来IsDialogMessage判断是否是键盘导航（如Tab键）</span></span><br><span class="line">            <span class="keyword">if</span> (!IsDialogMessage(hWnd,&amp;msg))&#123;</span><br><span class="line">                <span class="keyword">if</span> (msg.message == WM_QUIT)&#123;</span><br><span class="line">                    fQuit = TRUE;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    TranslateMessage(&amp;msg);</span><br><span class="line">                    DispatchMessage(&amp;msg);</span><br><span class="line">                &#125;        </span><br><span class="line">            &#125; <span class="comment">//End if(!IsDialogMessage())</span></span><br><span class="line">        </span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将数字加入列表框中</span></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> s_n = <span class="number">-1</span>;</span><br><span class="line">            TCHAR sz[<span class="number">20</span>];</span><br><span class="line">            StringCchPrintf(sz, _countof(sz), TEXT(<span class="string">"%u"</span>), ++s_n);</span><br><span class="line">            HWND hWndWork = GetDlgItem(hWnd, IDC_WORK);</span><br><span class="line">            ListBox_SetCurSel(hWndWork, ListBox_AddString(hWndWork,sz));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果列表框中的项目太多时，则删除前100项</span></span><br><span class="line">            <span class="keyword">while</span> (ListBox_GetCount(hWndWork) &gt; <span class="number">100</span>)</span><br><span class="line">                ListBox_DeleteString(hWndWork, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取线程休眠的时间</span></span><br><span class="line">            <span class="keyword">int</span> nSleep = GetDlgItemInt(hWnd, IDC_SLEEPTIME, <span class="literal">NULL</span>, FALSE);</span><br><span class="line">            <span class="keyword">if</span> (chINRANGE(<span class="number">1</span>,nSleep,<span class="number">9999</span>))&#123;</span><br><span class="line">                Sleep(nSleep);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DestroyWindow(hWnd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>  </p>
<h3 id="亲缘性"><a href="#亲缘性" class="headerlink" title="亲缘性"></a>亲缘性</h3><p>（1）<strong>软关联</strong>：默认下，Vista给线程分配CPU时，在其他因素都一样的前提下，系统将使线程在上一次运行的处理上运行，这样有利于重用仍在处理器高速缓存中的数据。</p>
<p>（2）<strong>硬关联</strong>：通过<strong>SetProcessAffinityMask\SetThreadAffinityMask</strong>来指定进（线）程在哪些CPU上运行，获取进（线）程关联性掩码，可通过GetProcessAffinityMask或GetThreadAffinityMask函数。</p>
<p>（3）<strong>子进程继承进程的关联性</strong>。即如果一个进程关联性掩码为0x0000005，它的其所有子进程中的任何线程也将有相同的掩码，并与它共用同一组CPU。</p>
<p>（4）关联性掩码共MAXIMUNM_PROCESSORS位，从0-31/63分别对应CPU 0至CPU 31(63)</p>
<p>（5）<strong>硬关联性有时会影响到CPU的调度程序的调度方案</strong>（见课本194）。如高优先级的A线程被限制在一个CPU 0上，但如果CPU0还有更高优先级线程B，而另一个CPU1上运行的是低优先级线程C。当A被限制在这个CPU0时，就无法抢占另一CPU1上的C线程来执行。为了允许系统将线程移到另一个较空闲的CPU上，可以给线程设置一个理想的CPU。SetThreadIdealProcessor（hThread,dwIdealProcessor），其中dwIdealProcessor为希望将线程设置到的CPU。</p>
<p>（6）Windows任务管理器允许更改进程的CPU关联性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPUINDEXTOMASK(dwCPUIndex)  (1&lt;&lt;(dwCPUIndex))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFunc</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hEvent = (HANDLE)lpParam;</span><br><span class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">float</span> fRandAvg = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> fCnt = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        fCnt += <span class="number">1.0f</span>;</span><br><span class="line">        fRandAvg += (<span class="keyword">float</span>)rand();</span><br><span class="line">        fRandAvg /= fCnt;</span><br><span class="line">        Sleep(<span class="number">1</span>); <span class="comment">//当注释该行时，CPU占用率将几乎达100%，这里可休眠一下</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WAIT_OBJECT_0 == WaitForSingleObject(hEvent, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _tprintf(_T(<span class="string">"%d个随机数的平均值为%f\n"</span>), (DWORD)fCnt, fRandAvg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (DWORD)fCnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line">    _tsetlocale(LC_ALL, _T(<span class="string">"chs"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建停止事件</span></span><br><span class="line">    HANDLE hStopEvent = CreateEvent(<span class="literal">NULL</span>, TRUE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取CPU个数</span></span><br><span class="line">    SYSTEM_INFO si = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    GetSystemInfo(&amp;si);</span><br><span class="line">    <span class="keyword">const</span> DWORD dwCPUCnt = si.dwNumberOfProcessors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程句柄数组</span></span><br><span class="line">    HANDLE *hThread =(HANDLE*)<span class="built_in">malloc</span>(dwCPUCnt*<span class="keyword">sizeof</span>(HANDLE));</span><br><span class="line">    DWORD dwThreadID = <span class="number">0</span>;</span><br><span class="line">    DWORD dwCPUIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环创建线程</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; dwCPUCnt;i++)&#123;</span><br><span class="line">        hThread[i] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc,</span><br><span class="line">                                  hStopEvent, CREATE_SUSPENDED, &amp;dwThreadID);</span><br><span class="line">        <span class="comment">//设置子线程的亲缘性（将子线程分配在不同的CPU上）</span></span><br><span class="line">        SetThreadAffinityMask(hThread[i], CPUINDEXTOMASK(i));</span><br><span class="line"></span><br><span class="line">        _tprintf(_T(<span class="string">"线程[ID:%d]运行在CPU(%d)上\n"</span>), dwThreadID, i);</span><br><span class="line">        ResumeThread(hThread[i]);</span><br><span class="line"></span><br><span class="line">        _tsystem(_T(<span class="string">"PAUSE"</span>)); <span class="comment">//暂停</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将第2个子线程的设为“高优先级”</span></span><br><span class="line">    <span class="keyword">if</span> (dwCPUCnt&gt;<span class="number">1</span>) SetThreadPriority(hThread[<span class="number">1</span>], THREAD_PRIORITY_HIGHEST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果每个CPU都安排了一个线程的话，此时可应看到所有CPU占用率几乎都是100%</span></span><br><span class="line">    _tprintf(_T(<span class="string">"线程全部创建完毕，请查看任务管理器中CPU使用率！\n"</span>));</span><br><span class="line">    _tsystem(_T(<span class="string">"PAUSE"</span>)); <span class="comment">//暂停</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知所有线程停止</span></span><br><span class="line">    SetEvent(hStopEvent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待所有线程退出</span></span><br><span class="line">    WaitForMultipleObjects(dwCPUCnt, hThread,TRUE, INFINITE);</span><br><span class="line"></span><br><span class="line">    DWORD dwExitCode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//取得线程的退出代码，此例中是循环次数，并关闭所有线程句柄</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; dwCPUCnt;i++)&#123;</span><br><span class="line">        GetExitCodeThread(hThread[i], &amp;dwExitCode);</span><br><span class="line">        _tprintf(_T(<span class="string">"线程[ID:%d]退出，退出码为：%u!\n"</span>),</span><br><span class="line">                   GetThreadId(hThread[i]),dwExitCode);</span><br><span class="line">        CloseHandle(hThread[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放线程句柄数组</span></span><br><span class="line">    <span class="built_in">free</span>(hThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭停止事件句柄</span></span><br><span class="line">    CloseHandle(hStopEvent);</span><br><span class="line">    _tsystem(_T(<span class="string">"PAUSE"</span>)); <span class="comment">//暂停</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="原子访问：Interlocked系列函数"><a href="#原子访问：Interlocked系列函数" class="headerlink" title="原子访问：Interlocked系列函数"></a>原子访问：Interlocked系列函数</h3><p>（1）原子访问的原理</p>
<p>　　①<strong>原子访问</strong>：指的是一线程在访问某个资源的同时，能够保证没有其他线程会在同一时刻访问该资源。</p>
<p>　　②从汇编的角度看，哪怕很简单的一条高级语言都可以被编译成多条的机器指令。在多线程环境下，这条语句的执行就可能被打断。而在打断期间，其中间结果可能己经被其他线程更改过，从而导致错误的结果。</p>
<p>　　③在Intelx86指令体系中，有些<strong>运算指令加上lock前缀</strong>就可以保证该指令操作的原子性。其原理是CPU执行该指令时发现其前面加lock前缀，就会在<strong>总线维持一个硬件信号</strong>以阻止其他CPU（或线程）访问与该指令相同的目标内存地址。（注意是指令<strong>目标操作数的内存地址而且这些地址是经过内存对齐过的</strong>！）</p>
<p>　　④以InterlockedIncrement函数为例分析原子访问的原理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">InterlockedIncrement</span><span class="params">(LPLONG <span class="keyword">volatile</span> lpAddend)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   _asm&#123;                    　　<span class="comment">//xadd指令两个功能：①交换(opd)→(ops);②(opd)←(opd)+(ops)</span></span><br><span class="line">      　　 mov  eax,<span class="number">1</span>           <span class="comment">//前缀lock表示线程在执行该指令时，会将[ecx]内存锁</span></span><br><span class="line">       　　mov cx,Addend        <span class="comment">//定（实际上是在CPU总线上放一个信号）以标志该内存正在被使用，</span></span><br><span class="line">       　　lock xadd [ecx],eax  <span class="comment">//从而阻止其他线程同时访问该内存。即其他线程要么在该指令之前，</span></span><br><span class="line">       　　inc eax              <span class="comment">//要么在指令之后才能访问[ecx]指向的这块内存</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）Windows内核支持的<strong>整数原子操作</strong>——Interlocked***互锁函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>InterlockedIncrementInterlockedDecrement</td>
<td>对LONG变量加（减）1，如：InterlockedIncrement(&amp;g_iX)（内部使用lock xadd指令）</td>
</tr>
<tr>
<td>InterlockedExchangeAdd</td>
<td>将一个值加到一个LONG变量，返回变量原值，使用lock xadd指令,如:int g_iX = 0;   //InterlockedExchangeAdd(&amp;g_iX,-2); //g_iX -= 2;</td>
</tr>
<tr>
<td>InterlockedCompareExchange</td>
<td>InterlockedCompareExchange( plDest,lExchange,lComperand)。比如<em>plDestination==lComperand，如果相等将</em>plDest修改为lExchange,如果不等，则<em>plDest不变。返回值为</em>plDest原来的值。 (使用lock cmpxchag指令)</td>
</tr>
<tr>
<td>InterlockedExchangeInterlockedExchangePointer</td>
<td>将第1个参数所指的内存里的当前值，以原子方式替换为第2个参数指定的值。函数返回值为原始值。后面那个函数是改变一个指针本身的值。(如果xchg指令，虽不加lock。但默认为原子操作)</td>
</tr>
<tr>
<td>InterlockedOr</td>
<td>对一个LONG变量做逻辑或运算，使用lock or指令</td>
</tr>
<tr>
<td>InterlockedAnd</td>
<td>对一个LONG变量做逻辑与运算，使用lock and指令</td>
</tr>
<tr>
<td>InterlockedXor</td>
<td>对一个LONG变量做逻辑异或运算，使用lock xor指令</td>
</tr>
</tbody>
</table>
<p>（3）Interlocked<strong>单向链表函数</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>InitializeSListHead</td>
<td>创建一个空栈</td>
</tr>
<tr>
<td>InterlockedPushEntrySList</td>
<td>在栈顶添加一个元素</td>
</tr>
<tr>
<td>InterlockedPopentrySList</td>
<td>移除位于栈顶的元素并将它返回</td>
</tr>
<tr>
<td>InterlockedFlushSlist</td>
<td>清空栈</td>
</tr>
<tr>
<td>QueryDepthSlist</td>
<td>返回栈中元素的数量</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_PROGRAM_ITEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SLIST_ENTRY  ItemEntry;</span><br><span class="line">    ULONG Signature;</span><br><span class="line">&#125;PROGRAM_ITEM,*PPROGRAM_ITEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line">    ULONG Count;</span><br><span class="line">    PSLIST_ENTRY pFirstEntry, pListEntry;</span><br><span class="line">    PSLIST_HEADER  pListHead;</span><br><span class="line">    PPROGRAM_ITEM pProgramItem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化链表头部</span></span><br><span class="line">    <span class="comment">//C库函数_aigned_malloc用来分配一个块对齐过的内存，其中第1个参数表示要分配</span></span><br><span class="line">    <span class="comment">//的字节数，第2个参数表示要对齐到的字节边界（必须是2的整数幂次方）</span></span><br><span class="line">    pListHead = (PSLIST_HEADER)_aligned_malloc(<span class="keyword">sizeof</span>(SLIST_HEADER),</span><br><span class="line">                                               MEMORY_ALLOCATION_ALIGNMENT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pListHead)&#123;</span><br><span class="line">        _tprintf(_T(<span class="string">"内存分配失败！"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化链表头，创建一个空栈</span></span><br><span class="line">    InitializeSListHead(pListHead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入10个元素</span></span><br><span class="line">    <span class="keyword">for</span> (Count = <span class="number">1</span>; Count &lt;= <span class="number">10</span>;Count++)&#123;</span><br><span class="line">        pProgramItem = (PPROGRAM_ITEM)_aligned_malloc(<span class="keyword">sizeof</span>(PROGRAM_ITEM), </span><br><span class="line">                                              MEMORY_ALLOCATION_ALIGNMENT);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == pProgramItem)&#123;</span><br><span class="line">            _tprintf(_T(<span class="string">"内存分配失败！"</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pProgramItem-&gt;Signature = Count;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回值为链表中以上的第1个元素，如果以前是空链表，则这里返回NULL</span></span><br><span class="line">        pFirstEntry = InterlockedPushEntrySList(pListHead, </span><br><span class="line">                                    &amp;(pProgramItem-&gt;ItemEntry)); <span class="comment">//也可以pProgramItem</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除10个元素，并显示其signature字段</span></span><br><span class="line">    <span class="keyword">for</span> (Count = <span class="number">10</span>; Count &gt;= <span class="number">1</span>;Count-=<span class="number">1</span>)&#123;</span><br><span class="line">        pListEntry = InterlockedPopEntrySList(pListHead);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == pListEntry)&#123;</span><br><span class="line">            _tprintf(_T(<span class="string">"链表是空的！"</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pProgramItem = (PPROGRAM_ITEM)pListEntry;</span><br><span class="line">        _tprintf(_T(<span class="string">"Signature = %d\n"</span>), pProgramItem-&gt;Signature);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放该元素的内存</span></span><br><span class="line">        _aligned_free(pListEntry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空链表，并验证是否所有元素都己释放</span></span><br><span class="line">    pListEntry = InterlockedFlushSList(pListHead);</span><br><span class="line">    pFirstEntry = InterlockedPopEntrySList(pListHead);</span><br><span class="line">    <span class="keyword">if</span> (pFirstEntry != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        _tprintf(_T(<span class="string">"错误：链表非空！\n"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _aligned_free(pListHead);</span><br><span class="line"></span><br><span class="line">    _tsystem(_T(<span class="string">"PAUSE"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）利用InterlockedExchange实现自旋锁（spinlock）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//全局变量用来表明“共享资源”是否正在被使用</span></span><br><span class="line"> BOOl g_fResourceInUse = FALSE;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="comment">//等待资源的访问权——注意InterlockedExchange返回旧的值</span></span><br><span class="line">      <span class="keyword">while</span>(InterlockedExchange(&amp;g_fResourceInUse,TRUE)==TRUE)</span><br><span class="line">         Sleep(<span class="number">0</span>); <span class="comment">//如果等不到锁，就休眼一下，以防止循环，浪费CPU。</span></span><br><span class="line">     </span><br><span class="line">      <span class="comment">//访问资源</span></span><br><span class="line">      ……</span><br><span class="line"></span><br><span class="line">      <span class="comment">//不再使用资源时</span></span><br><span class="line">      InterlockedExchange(&amp;g_fResource,FALSE); <span class="comment">//交出锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　①使用这项技术要极其小心，因为<strong>旋转锁是通过循环实现的，较耗费CPU时间</strong>，所以在while中加Sleep，可以改善这种状况，以避免浪费CPU。当然也可以用SwitchToThread代替，以便让低优先级的线程也有被调度的机会。</p>
<p>　　②特别要注意的是，<strong>在单CPU的机器上要避免使用旋转锁</strong>，因为如果这个线程一直在不停循环，对CPU浪费大，也影响了其他线程改变锁的值，造成恶性循环。</p>
<p>　　③<strong>使用旋转锁的线程优先级要相同</strong>，否则如果等待锁的线程优先级高，则使用资源的线程可能会因分配不到CPU时间而无法释放锁。所以使用这种锁的线程要通过SetProcessPrirityBoost(或SetThreadPriortyBoost)来禁用系统动态提升线程优先级</p>
<p>　　④<strong>要确保锁变量和锁所保护的数据位于不同的高速缓存行</strong>(cache line),如果在同一高速缓存行，当使用资源的CPU更改了被保护的数据，会也会其他CPU相应的高速缓存行失效，这里等待锁的CPU还要从<strong>内存</strong>中（<strong>注意：不是CPU高速缓存行</strong>）读入锁的状态，这浪费了CPU时间。</p>
<p>　　⑤旋转锁是假定被保护资源始终只会占用一小段时间。<strong>与切换到内核模式的等待相比，这种通过循环方式的等待效率更高</strong>。</p>
<p><br></p>
<h3 id="高速缓存行"><a href="#高速缓存行" class="headerlink" title="高速缓存行"></a>高速缓存行</h3><p>CPU、CPU高速缓存、内存的关系——见《深入理解计算机系统(第2版)P408》  </p>
<p><img src="/2018/12/10/windows-kernel/image-11.png" width="600px"></p>
<p>1）CPU是基于程序代码和数据在时间和空间上的<strong>局部性原理</strong>预测接下来将要用来的数据，并把这个数据（含指令）装载到高速缓存。</p>
<p>（2）<strong>每个CPU都有自己的高速缓存</strong>，包括指令Cache和数据Cache（其中的数据Cache一般包含多级）</p>
<p>（3）CPU不直接访问主存，而是通过Cache间接的访问内存。</p>
<p>（4）每次都从内存中读取的数据不是1个字节，而是一个Cache Line（<strong>高速缓存行，可能是32字节、64字节或128字节，取决于CPU</strong>）</p>
<p><br> </p>
<h4 id="多处理器下的读写问题"><a href="#多处理器下的读写问题" class="headerlink" title="多处理器下的读写问题"></a>多处理器下的读写问题</h4><p>（1）举例分析</p>
<p>　　①CPU1读取一个字节，这使得该字节及其相邻的若干字节被读到CPU1的高速缓存行</p>
<p>　　②CPU2读取同一个字节，同①一样，将那串字节的数据读到CPU2的高速缓存行</p>
<p>　　③设CPU1对内存的这个字节修改，被写进CPU1的高速缓存行，但未真正写回主存</p>
<p>　　④CPU2再次读取这个字节，由于该字节己经在CPU2的高速缓存行中，因些CPU2不需再访问内存。但CPU2将无法知道这个值已经在CPU1中得到更新的值。</p>
<p>（2）解决方案：</p>
<p>　　①当一个CPU修改了高速缓存行中的1个字节，其他CPU会收到通知，并使自己的缓存行作废。<strong>如CPU1修改了自己的缓存行数据，CPU2中如果相关的缓存行就作废。</strong></p>
<p>　　②CPU2读取自己缓存行的该字时，<strong>发现己经作废，则系统会调度CPU1把新值写入主存，然后CPU2重新访问内存来填充它的高速缓存行</strong>。可见高速缓存行提高了性能，但在多CPU的机器上同样会损失性能。</p>
<p>（3）编程启示</p>
<p>　　①应根据数据缓存行的大小来组织应用程序的数据，<strong>使数据与缓存行边界对齐</strong>。目的是<strong>确保不同的CPU能够各自访问不同的内存地址</strong>，而这些内存地址<strong>不在同一高速缓存行中</strong>。（★获取缓存行大小：通过GetLogicalProcessInformation，传入SYSTEM_LOGICAL_PROCESSOR_INFORMATION结构体，从这个结构体的CACHE_DESCRIPTOR字段中的LineSize获得。）　</p>
<p>　　②利用LineSize，通过<strong>__declspec(align(XXX))来对字段对齐加以控制</strong>。</p>
<table>
<thead>
<tr>
<th>糟糕的数据结构设计</th>
<th>改进后的版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>Struct CUSTINFO{  DWORD dwCustomerID;//只读，经常访问  int  nBalanceDue;  //读写  wchar_t szName[100]; //只读，经常访问  FILETIME ftLstOrderDate; //读写}【说明】<strong>避免高速缓存行可能出现问题的方法</strong>①使用局部变量或函数参数时，因为他们只让一个线程访问数据，就不会受其他线程影响②设置线程亲缘性，始终只让一个CPU访问数据。</td>
<td>#define CACHE_ALIGN 64 //64是从LineSize中获取//强迫<strong>每个结构体</strong>放在不同的缓存行中struct <strong>__declspec(align(CACHE_ALIGN))</strong>CUSTINFO{  DWORD dwCustomerID;  //只读，经常访问  wchar_t szName[100]; //只读，经常访问  <strong>//**</strong>将以下两个字段放在不同的缓存行中<strong>  </strong>__declspec(align(CACHE_ALIGN))**  int  nBalanceDue;  //读写  FILETIME ftLstOrderDate; //读写}</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="高级线程同步"><a href="#高级线程同步" class="headerlink" title="高级线程同步"></a>高级线程同步</h3><p>（1）Interlocked是以原子方式修改一个值，但如果要以原子方式修改“复杂数据结构时”，需要用其他同步手段，如Critical Section、互斥锁等。</p>
<p>（2）旋转锁的使用应谨慎，原因是浪费CPU时间比较严重，特别是在单CPU的机器上不应使用它。</p>
<p>（3）当线程无法取得对资源的访问权或特殊事件尚未发生时，线程应进入不可调度的等待状态，从而避免了浪费CPU的现象。</p>
<p>（4）<strong>volatile限定符</strong>会告诉编译器不要对变量进行优化，而是<strong>每次读取该变量时都从内存中获取</strong>（有时为了提高效率，编译器会变量放到某个寄存器，以便快速访问。这在单线程可能没有问题，但多线程中，这个内存中的变量可能被修改，而出现寄存器的那个变量与内存变量值的不一致，volatile会强迫总是从内存中读取而不优化）。但注意以下区别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> g_iX = <span class="number">0</span>;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(…)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//g_iX可能被其他线程修改，</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//这里强迫每次从内存读取</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> xOrg = g_iX; <span class="comment">//以值的形式访问g_iX</span></span><br><span class="line"></span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二 </span></span><br><span class="line"><span class="keyword">int</span> g_iX = <span class="number">0</span>;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(…)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//以下函数是以地址方式访</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//问g_iX，自然就要从内存中</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//中取，所以无须加volatile</span></span><br><span class="line"></span><br><span class="line">   InterlockedIncrement(&amp;g_iX);</span><br><span class="line"></span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（5）volatile修饰结构体时，等于结构体中所有成员都加volatile限定符。</p>
<p><br></p>
<h3 id="关键段-临界区"><a href="#关键段-临界区" class="headerlink" title="关键段(临界区)"></a>关键段(临界区)</h3><p>（1）CRITICAL_SECTION的使用方法</p>
<p>　　①CRITICAL_SECTION cs;            //声明为全局变量（也可是成员变量，甚至局部变量）</p>
<p>　　②InitializeCriticalSection(&amp;cs);     //初始化临界区，注意cs是临界区对象，不能被移动和复制</p>
<p>　　③EnterCriticalSection(&amp;cs);        //进入或等待临界区（任何要访问共享资源的代码都须包含应在</p>
<p>​                                                    //Enter和Leave之间，如果忘了哪怕一个地方，都可能破坏资源）</p>
<p>　　④LeaveCriticalSection(&amp;cs);       //离开临界区</p>
<p>　　⑤DeleteCriticalSection(&amp;cs);      //不再需要临界区对象。</p>
<p><img src="/2018/12/10/windows-kernel/image-12.png" width="200px"></p>
<p>（2）CRITICAL_SECTION数据结构</p>
<p><img src="/2018/12/10/windows-kernel/image-13.png" width="600px"></p>
<p>　　①LockCount字段：最重要的字段，初始化为-1。该字段在XP和Vista以后版本含义有所不同，在Vista以后版本中。</p>
<p>　　　　A、最低位——0表示临界区被锁，1表示没被锁。–&gt;0x1 &amp; LockCount</p>
<p>　　　　B、第2位（低位数起）：1表示没有线程被唤醒。0表示一个线程被唤醒 –&gt;(0x2 &amp; lockCount)&gt;&gt;1;</p>
<p> 　　　  C、其余各位表示等待锁的线程数量(-1-lockCount)&gt;&gt;2</p>
<p>　　②RecursionCount:<strong>表示拥有者线程己经获得该临界区的次数</strong>，初始值为0。当拥有者线程每调用EnterCriticalSection时会递增1。也就是说只有拥有者调用EnterCriticalSection时RecursionCount才递增。但为了防止拥有者线程一直霸占临界区，<strong>系统允许其他线程调用LeaveCriticalSection使该值递减</strong>。但不管是拥有者线程还是其他线程，调用Leave的总次数应该等于Enter的次数，才能被解开锁，当RecursionCount&lt;=0时，锁就解开，OwningThread被设为0。</p>
<p>　　③OwningThread：此字段表示当前占用该临界区的线程ID</p>
<p>　　④LockSemaphore：此字段命名不恰当，它实际上是一个事件对象，用于通知操作系统该临界区已被释放，等待该临界区的线程之一现在可以获得该临界区并继续执行。因为<strong>系统是在临界区阻止另一个线程时才自动分配事件句柄</strong>，所以如果在不再需要临界区时要将其删除，以防止LockSemaphore 字段可能会导致内存泄漏。</p>
<p><strong>（3）EnterCriticalSection函数的执行过程</strong></p>
<p>　　①如果没有线程正在访问资源，那么EnterCritical会更新临界区成员变量，以表示调用线程己经获得临界区锁，并立即返回，如此调用线程继续执行。</p>
<p>　　②当调用线程获得临界区锁后，如果此时调用线程再次Enter，则会更新RecursionCount，以表示调用线程被获准访问的次数。并立即返回。</p>
<p>　　③当调用线程获得临界区锁后，如果此时是其他线程要进入临界区，则<strong>EnterCriticalSection会使用一个事件内核对象（lockSemaphore）将这个线程切换到等待状态</strong>。（注意，这些等待的线程会事件内核对象记录下来，以表示正在等待该内核对象的都有哪些线程，当然线程本身也会记录，他在等哪些内核对象）（注意：<strong>临界区本身不是内核对象！</strong>）</p>
<p><strong>（4）LeaveCriticalSection函数</strong>：会更新CRITICAL_SECTION的成员变量，如果此时仍有线程处于等待状态，那么<strong>该函数会将其中之一的等待线程换回可调度状态</strong>。</p>
<p>（5）TryEnterCriticalSection函数</p>
<p>　　①该函数不会让调用线程进入等待状态，它通过返回值来表示是否获准访问资源。TRUE表示获准，FALSE表示其他线程正在使用资源，申请被拒绝。</p>
<p>　　②如果返回TRUE时，说明该调用线程己经正在访问资源，CRITICAL_SECTION 成员变量被更新过。<strong>所以每个返回TRUE的TryEnterCriticalSection都须调用LeaveCriticalSection</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADNUM   3</span></span><br><span class="line"></span><br><span class="line">CRITICAL_SECTION g_cs;</span><br><span class="line">HANDLE* hThread = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">临界区中LockCount和RecursionCount字段的含义</span></span><br><span class="line"><span class="comment">1、XP和Windows2000下</span></span><br><span class="line"><span class="comment">（1）LockCount:</span></span><br><span class="line"><span class="comment">    ①初始为-1，每调用EnterCriticalSection时LockCount加1，调用LeaveCriticalSection减1</span></span><br><span class="line"><span class="comment">    ②如LockCount = 5 表示某一线程正在使用临界区，此外还有5个线程正在等待锁</span></span><br><span class="line"><span class="comment">（2）RecursionCount：调用线程多次调用EnterCriticalSection的次数</span></span><br><span class="line"><span class="comment">（3）EntryCount：除了调用线程以外的其他线程调用EnterCriticalSection的次数。</span></span><br><span class="line"><span class="comment">（4）当第1次调用EnterCriticalSection后，LockCount、RecursionCount、EntryCount、ContentionCount各加1，</span></span><br><span class="line"><span class="comment">     OwningThread设为调用线程的ID。</span></span><br><span class="line"><span class="comment">    A、当拥有者再次调用EnterCriticalSection：LockCount++,Recursion++、EntryCount不变</span></span><br><span class="line"><span class="comment">    B、当其他线程调用EnterCriticalSection：LockCount++、EntryCount++、Recursion不变</span></span><br><span class="line"><span class="comment">    C、当拥有者调用LeaveCriticalSection：LockCount减1（到-1）、Recursion减到0，OwningThread设为0.</span></span><br><span class="line"><span class="comment">    D、其他线程调用LeaveCriticalSection，与拥有者调用LeaveCriticalSection变化一样。</span></span><br><span class="line"><span class="comment">2、Windows2003sp1及以后</span></span><br><span class="line"><span class="comment">（1）LockCount：</span></span><br><span class="line"><span class="comment">    A、最低位——0表示临界区被锁，1表示没被锁。--&gt;0x1 &amp; LockCount</span></span><br><span class="line"><span class="comment">    B、第2位（低位数起）：1表示没有线程被唤醒。0表示一个线程被唤醒 --&gt;(0x2 &amp; lockCount)&gt;&gt;1;</span></span><br><span class="line"><span class="comment">    C、其余各位表示等待锁的线程数量(-1-lockCount)&gt;&gt;2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowCriticalSectionInfo</span><span class="params">(PCRITICAL_SECTION pcs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _tprintf(_T(<span class="string">"Thread[%d],CriticalSection Information：\n"</span>),GetCurrentThreadId());</span><br><span class="line">    _tprintf(_T(<span class="string">"---------------------------\n"</span>));</span><br><span class="line">    _tprintf(_T(<span class="string">"LockCount:%d(临界区被锁:%s；是否有线程唤醒:%s；等待锁的线程数量:%d)\n"</span>),</span><br><span class="line">                          pcs-&gt;LockCount,</span><br><span class="line">                          (<span class="number">0x1</span> &amp; pcs-&gt;LockCount) ? _T(<span class="string">"否"</span>) : _T(<span class="string">"是"</span>), </span><br><span class="line">                          ((<span class="number">0x2</span> &amp; pcs-&gt;LockCount)) &gt;&gt; <span class="number">1</span> ? _T(<span class="string">"否"</span>) : _T(<span class="string">"是"</span>),</span><br><span class="line">                          ((<span class="number">-1</span> - pcs-&gt;LockCount) &gt;&gt; <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    _tprintf(_T(<span class="string">"RecursionCount:%d\n"</span>), pcs-&gt;RecursionCount);</span><br><span class="line">    _tprintf(_T(<span class="string">"OwningThread:%d\n"</span>), pcs-&gt;OwningThread);</span><br><span class="line">    _tprintf(_T(<span class="string">"LockSemephore:0x%08X\n"</span>), pcs-&gt;LockSemaphore);</span><br><span class="line">    <span class="comment">//_tprintf(_T("SpinCount:0x%08X\n"), pcs-&gt;SpinCount);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//线程函数1</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc1</span><span class="params">(PVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、演示First进程两次进入临界区。</span></span><br><span class="line">    _tprintf(_T(<span class="string">"第1个子线程[%d]两次进入临界区\n"</span>),GetCurrentThreadId());</span><br><span class="line">    EnterCriticalSection(&amp;g_cs);</span><br><span class="line">    EnterCriticalSection(&amp;g_cs);</span><br><span class="line">    ShowCriticalSectionInfo(&amp;g_cs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程函数2</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc2</span><span class="params">(PVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nIndex = (<span class="keyword">int</span>)pParam;</span><br><span class="line">    <span class="comment">//第nIndex个子程线进入临界区，并拿到锁</span></span><br><span class="line">    _tprintf(_T(<span class="string">"\n第%d个子线程[%d]尝试进入临界区\n"</span>), nIndex,GetCurrentThreadId());</span><br><span class="line">    EnterCriticalSection(&amp;g_cs);</span><br><span class="line">    ShowCriticalSectionInfo(&amp;g_cs);</span><br><span class="line"></span><br><span class="line">    _tprintf(_T(<span class="string">"\n第%d个子线程己经进入临界区......\n"</span>), nIndex, GetCurrentThreadId());</span><br><span class="line"></span><br><span class="line">    _tprintf(_T(<span class="string">"\n第%d个子线程线程[%d]离开临界区\n"</span>), nIndex, GetCurrentThreadId());</span><br><span class="line">    LeaveCriticalSection(&amp;g_cs);</span><br><span class="line">    ShowCriticalSectionInfo(&amp;g_cs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line">    _tsetlocale(LC_ALL, _T(<span class="string">"chs"</span>));</span><br><span class="line"></span><br><span class="line">    InitializeCriticalSection(&amp;g_cs);<span class="comment">//初始化临界区时的状态：</span></span><br><span class="line">    </span><br><span class="line">    hThread = (HANDLE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HANDLE)*THREADNUM);</span><br><span class="line">    hThread[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc1, <span class="literal">NULL</span>, CREATE_SUSPENDED, <span class="literal">NULL</span>);</span><br><span class="line">    hThread[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc2, (LPVOID)<span class="number">2</span>, CREATE_SUSPENDED, <span class="literal">NULL</span>);</span><br><span class="line">    hThread[<span class="number">2</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc2, (LPVOID)<span class="number">3</span>, CREATE_SUSPENDED, <span class="literal">NULL</span>);</span><br><span class="line">    ResumeThread(hThread[<span class="number">0</span>]);</span><br><span class="line">    WaitForSingleObject(hThread[<span class="number">0</span>], INFINITE);</span><br><span class="line">    _tsystem(_T(<span class="string">"PAUSE"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//演示在子线程拥有临界区，但在其他线程（主线程）释放（因子线程两次Enter，主线程要两次Leave）</span></span><br><span class="line">    _tprintf(_T(<span class="string">"\n主线程[%d]解开临界区锁\n"</span>), GetCurrentThreadId());</span><br><span class="line">    LeaveCriticalSection(&amp;g_cs);</span><br><span class="line">    LeaveCriticalSection(&amp;g_cs);</span><br><span class="line">    ShowCriticalSectionInfo(&amp;g_cs);</span><br><span class="line">    _tsystem(_T(<span class="string">"PAUSE"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第2个子线程启动，进入尝试进入临界区（应该可行，因为锁被主线程释放）</span></span><br><span class="line">    ResumeThread(hThread[<span class="number">1</span>]);</span><br><span class="line">    WaitForSingleObject(hThread[<span class="number">1</span>], INFINITE);</span><br><span class="line">    _tsystem(_T(<span class="string">"PAUSE"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程锁一下临界区，并启动第3个线程</span></span><br><span class="line">    _tprintf(_T(<span class="string">"\n主线程[%d]锁定临界区\n"</span>), GetCurrentThreadId());</span><br><span class="line">    EnterCriticalSection(&amp;g_cs);</span><br><span class="line">    ResumeThread(hThread[<span class="number">2</span>]); <span class="comment">//此时第3个线程进入等待状态</span></span><br><span class="line">    Sleep(<span class="number">1000</span>);</span><br><span class="line">    ShowCriticalSectionInfo(&amp;g_cs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程解开临界区锁，并恢复第3个线程</span></span><br><span class="line">    _tprintf(_T(<span class="string">"\n主线程[%d]解开临界区锁\n"</span>), GetCurrentThreadId());</span><br><span class="line">    LeaveCriticalSection(&amp;g_cs);</span><br><span class="line">    Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    _tsystem(_T(<span class="string">"PAUSE"</span>));</span><br><span class="line"></span><br><span class="line">    WaitForMultipleObjects(THREADNUM, hThread, TRUE, INFINITE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADNUM;i++)&#123;</span><br><span class="line">        CloseHandle(hThread[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(hThread);</span><br><span class="line">    DeleteCriticalSection(&amp;g_cs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="关键段和旋转锁"><a href="#关键段和旋转锁" class="headerlink" title="关键段和旋转锁"></a>关键段和旋转锁</h4><p>（1）当一个线程试图进入关键段，但这个关键段正被另一个线程占用时，函数会立即把调用线程切换到等待状态。这意味着线程必须从用户模式切换到内核模式，CPU开销比较大。</p>
<p>（2）但往往当前占用资源的线程可能很快就结束对资源的访问，事实上，在需要等待的线程完成切换到内核模式之前，占用资源的线程可以己经释放了资源，这无法浪费大量CPU时间。</p>
<p>（3）为了提高关键段的性能，可加入合并旋转锁到关键段中。当调用EnterCriticalSection时，先尝试旋转方式的访问资源。只有尝试一个后仍失败。才切换到内核模式并进入等待状态。</p>
<p>（4）<strong>要使用具有旋转方式的关键段</strong>，必须调用以下函数来初始化关键段 <strong>InitializeCriticalSectionAndSpinCount</strong>(pcs,dwSpinCount);其中 dwSpinCount为旋转次数(如4000)。如果在单CPU机器上，系统会忽图dwSpinCount参数。</p>
<p>（5）改变关键段的旋转次数<strong>SetCriticalSectionSpinCount(pcs,dwSpinCount)</strong>;</p>
<p><br></p>
<p><br></p>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>windows的io操作步骤如下   </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.应用程序调用ReadFile函数 </span><br><span class="line">2.ntdll.dll将用户请求陷入内核空间继续处理，由io管理器接管 </span><br><span class="line">3.io管理器创建一个irp，然后根据用户请求填充其字段，接着将其交给最上层驱动程序 </span><br><span class="line">4.驱动程序一层一层将irp传给硬件设备后一层层返回。</span><br><span class="line">注意，每往下传递一层都要注册io完成回调。 </span><br><span class="line">到这里,如果是异步调用，那么就可以返回用户空间处理了</span><br><span class="line">如果是同步的则在io管理器那里被阻塞,io操作还没有完,接着往下看：</span><br><span class="line"></span><br><span class="line">5.硬件操作完成，产生中断，中断排队一个dpc后返回 </span><br><span class="line">6.dpc运行，调用驱动的完成例程 </span><br><span class="line">7.每层的完成例程相继被调用，控制流一层层的返回给io管理器 </span><br><span class="line">8.将ReadFileEx中的用户apc排队（异步情况下），这个apc将在不长的时间内被调用，因为它的优先级高于用户线程。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>1.apc 异步过程调用。<br>异步过程调用类似于linux下的信号，只不过信号处理函数的执行需要两步：设置和触发，而apc则只有一步，只需要将apc回调函数排入线程的apc对 列，它就总会被执行的。apc对列对于每个线程有两个，一个是用户空间的apc对列，一个是内核空间的apc对列，apc函数运行在apc优先级上，它一 般高于用户线程的优先级。</p>
</li>
<li><p>2.dpc 延迟过程调用。<br>延迟过程调用一般用于中断的后期处理。中断可在任何进程（线程）的上下文里面运行，而且一般情况下中断处理 函数要关闭相应中断，以防重入，为了使这种不确定的情况时间最小化，windows只会在中断处理函数里面呆一小会，然后排队一个dpc，从而退出中 断，dpc在低于isr的优先级运行，因此它可被硬件中断中断。</p>
</li>
<li><p>3.irp io请求包<br>这在windows里是一个异常重要的概念，它直接导致 windows的设计理念和类unix以及unix的设计理念的不同。一个irp封装了一个io操作过程，它的内部是一个栈结构，每个栈帧代表一个驱动程 序模块，其中封装了此驱动的回调函数，irp就是一级一级往下层驱动传递从而完成一个io操作。</p>
</li>
</ul>
<ul>
<li>4.基于优先级的抢占式调度。<br>这个是 windows下的调度策略，它完全基于优先级（还有时间片，但不影响什么，时间片对所有进程的策略一样），而不是其它。如果有更高优先级线程就绪，那么 它将马上抢占当前线程。就连中断都有自己优先级，呵呵，当然它是最高的…windows的响应性依赖于动态优先级提升，但是这就牵扯到别的方面了，和 这篇文章的主题不对，因此不讨论。<br>明白了上面的概念以后，我们就可以继续了。</li>
</ul>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2018/12/10/windows-kernel/';
        this.page.title = 'Windows系统解析';
        this.page.identifier = '2018/12/10/windows-kernel/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
