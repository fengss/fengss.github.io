<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Linux系统笔记 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="Linux编程笔记知识详解笔记
历史UNIX发展时间表
基本概念
操作系统实现类型   


微内核:最基本的功能由中央内核实现,所有其他功能交给其他独立进程(文件系统,内存管理等)  
宏内核:内核的全部代码,包括所有子系统(内存管理,文件系统,设备驱动等)都打包到一个文件中,内核每个函数都可以访问内核其他部分(Linux就是一直这种类型)     


用户态和内核态区分为当若干个程序在同一系统并发运行,可以将内核视为资源管理程序,内核负责将可用共享资源(CPU时间,磁盘空间,网络连接)等分">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Golang</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">System</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">BigData</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/ai">Math/AI</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/book">计划</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mesos/">Mesos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scikit/">Scikit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SofaMesh/">SofaMesh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TroubleShoot/">TroubleShoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows内核/">Windows内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows内核驱动/">Windows内核驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内网穿透/">内网穿透</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#历史"><span class="toc-number">1.</span> <span class="toc-text">历史</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UNIX发展时间表"><span class="toc-number">1.1.</span> <span class="toc-text">UNIX发展时间表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基本概念"><span class="toc-number">2.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内核的组成"><span class="toc-number">2.1.</span> <span class="toc-text">内核的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程-切换、调度"><span class="toc-number">2.1.1.</span> <span class="toc-text">进程:切换、调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#地址空间"><span class="toc-number">2.1.2.</span> <span class="toc-text">地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户态-内核态"><span class="toc-number">2.1.3.</span> <span class="toc-text">用户态/内核态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟和物理地址空间"><span class="toc-number">2.1.4.</span> <span class="toc-text">虚拟和物理地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页表"><span class="toc-number">2.1.5.</span> <span class="toc-text">页表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核"><span class="toc-number">2.2.</span> <span class="toc-text">内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内核态和用户态"><span class="toc-number">2.2.1.</span> <span class="toc-text">内核态和用户态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检视系统"><span class="toc-number">2.2.2.</span> <span class="toc-text">检视系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shell"><span class="toc-number">2.3.</span> <span class="toc-text">shell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用户与组"><span class="toc-number">2.4.</span> <span class="toc-text">用户与组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用户"><span class="toc-number">2.4.1.</span> <span class="toc-text">用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组"><span class="toc-number">2.4.2.</span> <span class="toc-text">组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#超级用户"><span class="toc-number">2.4.3.</span> <span class="toc-text">超级用户</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#目录层级"><span class="toc-number">2.5.</span> <span class="toc-text">目录层级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件IO"><span class="toc-number">2.6.</span> <span class="toc-text">文件IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件描述符"><span class="toc-number">2.6.1.</span> <span class="toc-text">文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stdio函数库"><span class="toc-number">2.6.2.</span> <span class="toc-text">stdio函数库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序"><span class="toc-number">2.7.</span> <span class="toc-text">程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#过滤器"><span class="toc-number">2.7.1.</span> <span class="toc-text">过滤器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程"><span class="toc-number">2.8.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程优先级"><span class="toc-number">2.8.1.</span> <span class="toc-text">进程优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生命周期"><span class="toc-number">2.9.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程表示"><span class="toc-number">2.10.</span> <span class="toc-text">进程表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#轻量级进程-线程"><span class="toc-number">2.11.</span> <span class="toc-text">轻量级进程(线程)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程内存布局"><span class="toc-number">2.11.1.</span> <span class="toc-text">进程内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建进程和执行程序"><span class="toc-number">2.11.2.</span> <span class="toc-text">创建进程和执行程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程ID和父进程ID"><span class="toc-number">2.11.3.</span> <span class="toc-text">进程ID和父进程ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程终止和终止状态"><span class="toc-number">2.11.4.</span> <span class="toc-text">进程终止和终止状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程用户和组标识"><span class="toc-number">2.11.5.</span> <span class="toc-text">进程用户和组标识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特权进程"><span class="toc-number">2.11.6.</span> <span class="toc-text">特权进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#守护进程"><span class="toc-number">2.11.7.</span> <span class="toc-text">守护进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#环境列表"><span class="toc-number">2.11.8.</span> <span class="toc-text">环境列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存映射"><span class="toc-number">2.12.</span> <span class="toc-text">内存映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态库和共享库"><span class="toc-number">2.13.</span> <span class="toc-text">静态库和共享库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#静态库"><span class="toc-number">2.13.1.</span> <span class="toc-text">静态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#共享库"><span class="toc-number">2.13.2.</span> <span class="toc-text">共享库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程间通信IPC及同步"><span class="toc-number">2.14.</span> <span class="toc-text">进程间通信IPC及同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号"><span class="toc-number">2.15.</span> <span class="toc-text">信号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程"><span class="toc-number">2.16.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程组和shell任务控制"><span class="toc-number">2.17.</span> <span class="toc-text">进程组和shell任务控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#会话、控制终端、控制进程"><span class="toc-number">2.18.</span> <span class="toc-text">会话、控制终端、控制进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#伪终端"><span class="toc-number">2.19.</span> <span class="toc-text">伪终端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#时间和日期"><span class="toc-number">2.20.</span> <span class="toc-text">时间和日期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#proc文件系统"><span class="toc-number">2.21.</span> <span class="toc-text">/proc文件系统</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#文件I-O"><span class="toc-number">3.</span> <span class="toc-text">文件I/O</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#open事项"><span class="toc-number">3.2.</span> <span class="toc-text">open事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read事项"><span class="toc-number">3.3.</span> <span class="toc-text">read事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#write事项"><span class="toc-number">3.4.</span> <span class="toc-text">write事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#close-amp-lseek事项"><span class="toc-number">3.5.</span> <span class="toc-text">close&amp;lseek事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深入IO"><span class="toc-number">3.6.</span> <span class="toc-text">深入IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原子操作和竞争"><span class="toc-number">3.6.1.</span> <span class="toc-text">原子操作和竞争</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件描述符与打开文件之间的关系"><span class="toc-number">3.6.2.</span> <span class="toc-text">文件描述符与打开文件之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复制文件描述符"><span class="toc-number">3.6.3.</span> <span class="toc-text">复制文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分散输入和集中输出"><span class="toc-number">3.6.4.</span> <span class="toc-text">分散输入和集中输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非阻塞IO"><span class="toc-number">3.6.5.</span> <span class="toc-text">非阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dev-fd目录"><span class="toc-number">3.6.6.</span> <span class="toc-text">/dev/fd目录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程-1"><span class="toc-number">4.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程号和父进程号"><span class="toc-number">4.1.</span> <span class="toc-text">进程号和父进程号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程内存布局-1"><span class="toc-number">4.2.</span> <span class="toc-text">进程内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#命名空间"><span class="toc-number">4.3.</span> <span class="toc-text">命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#uts命名空间"><span class="toc-number">4.3.1.</span> <span class="toc-text">uts命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户命名空间"><span class="toc-number">4.3.2.</span> <span class="toc-text">用户命名空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程PID"><span class="toc-number">4.4.</span> <span class="toc-text">进程PID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核线程"><span class="toc-number">4.5.</span> <span class="toc-text">内核线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调度器"><span class="toc-number">4.6.</span> <span class="toc-text">调度器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟内存管理"><span class="toc-number">4.7.</span> <span class="toc-text">虚拟内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈和栈帧"><span class="toc-number">4.8.</span> <span class="toc-text">栈和栈帧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#环境列表-1"><span class="toc-number">4.9.</span> <span class="toc-text">环境列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从程序中访问环境"><span class="toc-number">4.9.1.</span> <span class="toc-text">从程序中访问环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改环境变量"><span class="toc-number">4.9.2.</span> <span class="toc-text">修改环境变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非局部跳转-setjmp和longjmp"><span class="toc-number">4.10.</span> <span class="toc-text">非局部跳转,setjmp和longjmp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程的创建"><span class="toc-number">4.11.</span> <span class="toc-text">进程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork-、exit-、wait-、execve"><span class="toc-number">4.11.1.</span> <span class="toc-text">fork()、exit()、wait()、execve()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建新进程-fork"><span class="toc-number">4.11.2.</span> <span class="toc-text">创建新进程:fork()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#父、子进程间的文件共享"><span class="toc-number">4.11.2.1.</span> <span class="toc-text">父、子进程间的文件共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fork内存语义"><span class="toc-number">4.11.2.2.</span> <span class="toc-text">fork内存语义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统调用vfork"><span class="toc-number">4.11.3.</span> <span class="toc-text">系统调用vfork()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork-之后的竞争条件-Race-Condition"><span class="toc-number">4.11.4.</span> <span class="toc-text">fork()之后的竞争条件(Race Condition)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#同步信号以规避竞争条件"><span class="toc-number">4.11.4.1.</span> <span class="toc-text">同步信号以规避竞争条件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程的终止"><span class="toc-number">4.12.</span> <span class="toc-text">进程的终止</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的终止-exit-和exit"><span class="toc-number">4.12.1.</span> <span class="toc-text">进程的终止:_exit()和exit()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程终止的细节"><span class="toc-number">4.12.2.</span> <span class="toc-text">进程终止的细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#退出处理程序"><span class="toc-number">4.12.3.</span> <span class="toc-text">退出处理程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程间通信IPC"><span class="toc-number">4.13.</span> <span class="toc-text">进程间通信IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通信工具"><span class="toc-number">4.13.1.</span> <span class="toc-text">通信工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步工具"><span class="toc-number">4.13.2.</span> <span class="toc-text">同步工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存分配"><span class="toc-number">5.</span> <span class="toc-text">内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#堆上分配内存"><span class="toc-number">5.1.</span> <span class="toc-text">堆上分配内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调整program-break-brk-和sbrk"><span class="toc-number">5.1.1.</span> <span class="toc-text">调整program break:brk()和sbrk()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆上分配内存-malloc-和free"><span class="toc-number">5.1.2.</span> <span class="toc-text">堆上分配内存:malloc()和free()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-和free-的实现"><span class="toc-number">5.1.3.</span> <span class="toc-text">malloc()和free()的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc调试的工具和库"><span class="toc-number">5.1.4.</span> <span class="toc-text">malloc调试的工具和库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆上分配内存的其他方法"><span class="toc-number">5.1.5.</span> <span class="toc-text">堆上分配内存的其他方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈上分配内存"><span class="toc-number">5.2.</span> <span class="toc-text">栈上分配内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#alloca调整栈大小"><span class="toc-number">5.2.1.</span> <span class="toc-text">alloca调整栈大小</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#系统和进程信息"><span class="toc-number">6.</span> <span class="toc-text">系统和进程信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#proc文件系统-1"><span class="toc-number">6.1.</span> <span class="toc-text">/proc文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#获取进程相关信息-proc-PID"><span class="toc-number">6.1.1.</span> <span class="toc-text">获取进程相关信息:/proc/PID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问-proc文件"><span class="toc-number">6.1.2.</span> <span class="toc-text">访问/proc文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程-1"><span class="toc-number">7.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述-1"><span class="toc-number">7.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pthreads-API的详细背景"><span class="toc-number">7.2.</span> <span class="toc-text">Pthreads API的详细背景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建线程"><span class="toc-number">7.2.1.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#终止线程"><span class="toc-number">7.2.2.</span> <span class="toc-text">终止线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程ID-Thread-ID"><span class="toc-number">7.2.3.</span> <span class="toc-text">线程ID(Thread ID)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连接-joining-已终止的线程"><span class="toc-number">7.2.4.</span> <span class="toc-text">连接(joining)已终止的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的分离"><span class="toc-number">7.2.5.</span> <span class="toc-text">线程的分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程属性"><span class="toc-number">7.2.6.</span> <span class="toc-text">线程属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程VS进程"><span class="toc-number">7.2.7.</span> <span class="toc-text">线程VS进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程同步"><span class="toc-number">7.3.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥量"><span class="toc-number">7.3.1.</span> <span class="toc-text">互斥量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#加锁解锁互斥量"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">加锁解锁互斥量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态初始化互斥量"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">动态初始化互斥量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件变量"><span class="toc-number">7.3.2.</span> <span class="toc-text">条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#静态分配的条件变量"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">静态分配的条件变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通知和等待条件变量"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">通知和等待条件变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态分配的条件变量"><span class="toc-number">7.3.3.</span> <span class="toc-text">动态分配的条件变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程细节"><span class="toc-number">7.4.</span> <span class="toc-text">线程细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程实现模型"><span class="toc-number">7.4.1.</span> <span class="toc-text">线程实现模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程存储"><span class="toc-number">7.4.2.</span> <span class="toc-text">线程存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程持有数据"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">线程持有数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程特有数据API"><span class="toc-number">7.4.2.2.</span> <span class="toc-text">线程特有数据API</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#文件I-O缓冲"><span class="toc-number">8.</span> <span class="toc-text">文件I/O缓冲</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#文件IO的内核缓冲"><span class="toc-number">8.1.</span> <span class="toc-text">文件IO的内核缓冲</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Read读过程"><span class="toc-number">8.1.1.</span> <span class="toc-text">Read读过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Write写过程"><span class="toc-number">8.1.2.</span> <span class="toc-text">Write写过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap技术"><span class="toc-number">8.1.3.</span> <span class="toc-text">mmap技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓冲区大小对IO系统调用性能影响"><span class="toc-number">8.1.4.</span> <span class="toc-text">缓冲区大小对IO系统调用性能影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stdio库的缓冲"><span class="toc-number">8.2.</span> <span class="toc-text">stdio库的缓冲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件缓存"><span class="toc-number">8.3.</span> <span class="toc-text">文件缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ext2-ext3-ntfs"><span class="toc-number">8.3.1.</span> <span class="toc-text">ext2/ext3,ntfs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VFS"><span class="toc-number">8.3.2.</span> <span class="toc-text">VFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VMM"><span class="toc-number">8.3.3.</span> <span class="toc-text">VMM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FS-Cache-文件缓存"><span class="toc-number">8.3.4.</span> <span class="toc-text">FS Cache(文件缓存)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#存在地位"><span class="toc-number">8.3.4.1.</span> <span class="toc-text">存在地位?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总体结构"><span class="toc-number">8.3.4.2.</span> <span class="toc-text">总体结构?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据块结构"><span class="toc-number">8.3.4.3.</span> <span class="toc-text">数据块结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#访问方式"><span class="toc-number">8.3.4.4.</span> <span class="toc-text">访问方式</span></a></li></ol></li></ol></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            Linux系统笔记
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2018/12/04/linux-programming/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-04T01:23:06.000Z" itemprop="datePublished">2018-12-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Linux/">Linux</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>Linux编程笔记知识详解笔记<br><a id="more"></a></p>
<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><h2 id="UNIX发展时间表"><a href="#UNIX发展时间表" class="headerlink" title="UNIX发展时间表"></a>UNIX发展时间表</h2><p><img src="/2018/12/04/linux-programming/image-01.png" width="500px"></p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><blockquote>
<p>操作系统实现类型   </p>
</blockquote>
<ul>
<li>微内核:最基本的功能由中央内核实现,所有其他功能交给其他独立进程(文件系统,内存管理等)  </li>
<li>宏内核:内核的全部代码,包括所有子系统(内存管理,文件系统,设备驱动等)都打包到一个文件中,内核每个函数都可以访问内核其他部分(Linux就是一直这种类型)     </li>
</ul>
<blockquote>
<p>用户态和内核态区分为当若干个程序在同一系统并发运行,可以将内核视为资源管理程序,内核负责将可用共享资源(CPU时间,磁盘空间,网络连接)等分配到各个系统进程     </p>
</blockquote>
<h2 id="内核的组成"><a href="#内核的组成" class="headerlink" title="内核的组成"></a>内核的组成</h2><p><img src="/2018/12/04/linux-programming/image-101.png" width="500px"></p>
<ul>
<li>进程:进程切换、调度</li>
<li>内存</li>
<li>文件系统</li>
<li>页表</li>
<li>计时</li>
<li>系统调用</li>
<li>……</li>
</ul>
<h3 id="进程-切换、调度"><a href="#进程-切换、调度" class="headerlink" title="进程:切换、调度"></a>进程:切换、调度</h3><p>由于Linux是多任务系统,它支持(看上去)并发执行的若干进程。系统中同时真正在运行的进 程数目最多不超过CPU数目,因此内核会按照短的时间间隔在不同的进程之间切换(用户是注意不到 的),这样就造成了同时处理多进程的假象。这里有两个问题。</p>
<ul>
<li>(1):内核借助于CPU的 助,负责进程切换的技术细节。必须给各个进程造成一种错 ,即CPU 总是可用的。通过在撤销进程的CPU资源之前保存进程所有与状态相关的要素,并将进程置于空闲状 态,即可达到这一目的。在重新激活进程时,则将保存的状态原样 复。进程之间的切换称之为进程 切换。</li>
<li>(2):内核还必须确定如何在现存进程之间共享CPU时间。重要进程得到的CPU时间多一点,次要 进程得到的少一点。确定哪个进程运行多长时间的过程称为调度。</li>
</ul>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>系统中每个用户进程都有自身的虚拟地址范围,从0到TASK_SIZE。用户空间之上的区域(从 TASK_SIZE到232或264)保留给内核专用,用户进程不能访问。</p>
<p>TASK_SIZE是一个特定于计算机体系结 构的常数,把地址空间按给定比例划分为两部分。例如在IA-32系统中,地址空间在3 GiB处划分,因此每个进程的虚拟地址空间是3 GiB。</p>
<p>由于虚拟地址空间的总长度是<code>4 GiB</code>,所以内核空间有<code>1 GiB</code>可用。 尽管实际的数字依不同的计算机体系结构而不同,但一般概念都是相同的。</p>
<p>这种划分与可用的内存数量无关。由于地址空间虚拟化的结果,每个用户进程都认为自身有3 GiB 内存。</p>
<p>各个系统进程的用户空间是完全 此分离的。而虚拟地址空间顶部的内核空间总是同样的,无论当前执行的是哪个进程。  </p>
<p>内存地址是通过指针寻址,因此CPU的字长决定了所能管理的地址空间的最大长度,<br>地址空间最大长度与实际可用内存数无关,因此称为虚拟地址空间,<br>每个用户进程都有自身的虚拟地址范围,一般虚拟地址划分两部分:内核空间和用户空间    </p>
<p><img src="/2018/12/04/linux-programming/image-102.png" width="200px"></p>
<p>系统中每个用户进程都有自身虚拟地址范围,0~TASK_SIZE,用户空间之上的TASK_SIZE~2的32次或者64次留给内核专用,用户进程不能访问    </p>
<h3 id="用户态-内核态"><a href="#用户态-内核态" class="headerlink" title="用户态/内核态"></a>用户态/内核态</h3><p><img src="/2018/12/04/linux-programming/image-103.png" width="500px"></p>
<p>CPU英特尔IA-32分了四种级别,而Linux只是用了两种不同的状态:核心态和用户态       </p>
<p>在用户态禁止访问内核空间,用户进程不能操作或读取内核空间中的数据,也无法执行内核空间的代码        </p>
<p>用户态到和心态的切换通过系统调用的特定转换完成,如果普通进程想要影响系统级操作(例如操作输入/输出装置),<br>则只能借助于系统调用向内核发出请求,内核首先检查进程是否允许执行想要的操作,<br>然后代表进程执行所需的操作,接下来再返回到用户态</p>
<p><img src="/2018/12/04/linux-programming/image-104.png" width="500px"></p>
<p>在核心态和用户态执行,CPU大多时间都在执行用户空间中的代码,<br>当应用程序执行系统调用,则切换核心态,在这个时候内核可以访问虚拟地址空间的用户部分,<br>在系统调用完成之后,CPU再切换成用户态,这就会涉及到上下文的切换    </p>
<p><br></p>
<blockquote>
<p>当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文    </p>
</blockquote>
<p>一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。   </p>
<ul>
<li>1:用户级上下文: 正文、数据、用户堆栈以及共享存储区;</li>
<li>2:寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP);</li>
<li>3:系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在LINUX中,当前进程上下文均保存在进程的任务数据结构中。</span><br><span class="line">在发生中断时,内核就在被中断进程的上下文中,在内核态下执行中断服务例程。</span><br><span class="line">但同时会保留所有需要用到的资源,以便中继服务结束时能恢复被中断进程的执行。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ps命令如果是方括号则是内核线程</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps fax</span><br><span class="line">PID TTY      STAT   TIME COMMAND</span><br><span class="line">2 ?        S      0:00 [kthreadd]</span><br><span class="line">3 ?        S      0:03  \_ [ksoftirqd/0]</span><br><span class="line">5 ?        S&lt;     0:00  \_ [kworker/0:0H]</span><br><span class="line">6 ?        S      0:20  \_ [kworker/u4:0]</span><br><span class="line">7 ?        S      0:00  \_ [migration/0]</span><br><span class="line">8 ?        S      0:00  \_ [rcu_bh]</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="虚拟和物理地址空间"><a href="#虚拟和物理地址空间" class="headerlink" title="虚拟和物理地址空间"></a>虚拟和物理地址空间</h3><p><img src="/2018/12/04/linux-programming/image-105.png" width="500px"></p>
<blockquote>
<p>每个进程都有自己的虚拟地址空间,如何将可用的物理内存映射到虚拟地址空间的区域?     </p>
</blockquote>
<p>可采取物理地址分配虚拟地址,虚拟地址关系到进程的用户空间和内核空间,而物理地址用来寻址实际可用的内存     </p>
<blockquote>
<p>页:两个进程的虚拟地址空间,被内核划分为很多等长的部分称之为页<br>物理内存也划分同样大小的页       </p>
</blockquote>
<p><br></p>
<p>例如如上图,进程A的页5和进程B的页1都指向物理页5<br>物理内存页经常被称作<code>页帧</code>,相比之下,页则专指虚拟地址空间中的页        </p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p><img src="/2018/12/04/linux-programming/image-106.png" width="500px"></p>
<p>将虚拟地址空间映射到物理地址空间的数据结构称为页表</p>
<blockquote>
<p>内核是用页表来为物理地址分配虚拟地址。<br>虚拟地址关系到进程的用户空间和内核空间, 而物理地址则用来寻址实际可用的内存   </p>
<p>实现两个地址空间的关联最容易的方法就是使用<code>数组</code>,<br>对虚拟地址空间中的每一页,都分配一个数组项,该数组项指向与之关联的页帧          </p>
</blockquote>
<p>CPU试图用下面两种方法加速该过程。</p>
<ul>
<li>(1) CPU中有一个专门的部分称为MMU(Memory Management Unit，内存管理单元)，该单元优化了内存访问操作。</li>
<li>(2) 地址转换中出现最频繁的那些地址，保存到称为地址转换后备缓冲 (Translation Lookaside Buffer，TLB)的CPU高速缓存中。无需访问内存中的页表即可从高速缓存直接获得地址数据，因而 大大加速了地址转换。</li>
</ul>
<p><br><br><br></p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><ul>
<li>进程调度,调度cpu执行程序指令</li>
<li>内存管理,Linux也采用了虚拟内存管理机制</li>
<li>文件系统,磁盘之上提供文件系统</li>
<li>创建和终止进程</li>
<li>对设备的访问,键盘、鼠标等</li>
<li>联网,内核以用户进程名义收发网络数据包</li>
<li>提供系统调用的API</li>
</ul>
<h3 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h3><p>CPU在两种不同状态下允许</p>
<p>在用户态下CPU无法访问内核空间</p>
<p>在内核态CPU可以访问内核和用户空间内存</p>
<h3 id="检视系统"><a href="#检视系统" class="headerlink" title="检视系统"></a>检视系统</h3><blockquote>
<p>内核</p>
</blockquote>
<p>内核无所不知、无所不能,哪个进程对cpu使用,使用多久由内核说了算</p>
<p>程序使用的文件名转换磁盘物理位置</p>
<p>每个进程的虚拟内存与计算机物理内存和交换空间的映射关系</p>
<p>内核可以创建新进程和销毁进程,也可以输入输出设备直接通信</p>
<blockquote>
<p>用户进程</p>
</blockquote>
<p>则不知道CPU的使用情况,也不知道自己在内存还是交换空间</p>
<p>也不知道所访问的文件位于磁盘驱动器何处,进程无法创建新进程,自行了断也不行</p>
<p>也不能和计算机外接输入输出设备直接通信</p>
<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>几种重要shell</p>
<ul>
<li>Bourne Shell</li>
<li>C Shell</li>
<li>Korn Shell</li>
<li>Bourne again Shell</li>
</ul>
<h2 id="用户与组"><a href="#用户与组" class="headerlink" title="用户与组"></a>用户与组</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>每个用户定义的一行记录:<code>/etc/passwd</code></p>
<ul>
<li>组ID:用户所属第一个组的整数型组ID</li>
<li>主目录:用户登录后所居于的初始化目录</li>
<li>登录shell,执行解释用户命令的程序名称</li>
</ul>
<h3 id="组"><a href="#组" class="headerlink" title="组"></a>组</h3><p>多个用户分组,记录于<code>etc/group</code></p>
<ul>
<li>组名:组名称</li>
<li>组ID:与组相关的整数型ID</li>
<li>用户列表:登录名列表</li>
</ul>
<h3 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h3><p>ID为0,登录名root</p>
<h2 id="目录层级"><a href="#目录层级" class="headerlink" title="目录层级"></a>目录层级</h2><p><img src="/2018/12/04/linux-programming/image-02.png" width="500px"></p>
<ul>
<li>文件类型</li>
<li>路径和链接</li>
<li>符号链接</li>
<li>文件名</li>
<li>路径名</li>
<li>当前工作目录</li>
<li>文件的所有权和权限</li>
</ul>
<h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><p>open read write close等所执行的io操作</p>
<p>应用程序发起的IO请求,内核会将其转换为响应的文件系统操作或者是设备驱动程序操作</p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>open参数为路径,启动进程会继承3个已打开的文件描述符</p>
<p>0标准输入 1 标准输出 2 标准错误</p>
<h3 id="stdio函数库"><a href="#stdio函数库" class="headerlink" title="stdio函数库"></a>stdio函数库</h3><p>C编程执行文件IO操作,会有stdio函数库</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fopen();</span><br><span class="line">fclose();</span><br><span class="line"><span class="built_in">scanf</span>();</span><br><span class="line"><span class="built_in">printf</span>();</span><br><span class="line">fgets();</span><br><span class="line"><span class="built_in">fputs</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//stdio函数库位于IO系统调用层(open(), close(), read(), write())之上</span></span><br></pre></td></tr></table></figure>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>stdin读取输入,加以转换,转换后数据输出到stdout</p>
<p>上述行为的程序称为过滤器</p>
<p>cat、grep、tr、sort、wc、sed、awk均在列</p>
<p><br></p>
<p><br></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>进程有不同关键度优先级,分实时进程和非实时进程</p>
<ul>
<li><p><code>硬实时进程</code></p>
<blockquote>
<p>严格时间限制,确保在一段时间内完成,例如飞机着陆计算机几秒内必须完成</p>
<p>Linux在主流内核不支持硬实时处理,但修订版本RTLinux,Xenomai,RATI提供该特性</p>
<p>这些修订方案Linux内核作为独立的进程运行次重要软件,实时工作在内核外部完成,只有当没有实时关键才做内核才会运行</p>
</blockquote>
</li>
<li><p><code>软实时进程</code></p>
<blockquote>
<p>硬实时的弱化,可以稍微晚一点不会造成世界末日,比如写入流操作,优先于普通进程,单系统符合过高可能会暂时中断</p>
</blockquote>
</li>
</ul>
<p><img src="/2018/12/04/linux-programming/image-115.png" width="500px"></p>
<p>抢占式多任务处理,各个进程都分配一定时间段执行,时间段过后内核回收执行权,让一个不同的进程运行</p>
<p>时间片长度根据进程优先级的不同而变化</p>
<p>被抢占进程运行环境CPU寄存器的内容和页表都保存,因此执行结果不会丢失,该进程恢复环境也可以完全恢复</p>
<p>完全公平调度器:内核2.6.23版本开发和并进来,调度器分配可用时间首先在不同用户之间分配,又在各个用户的进程之间分配</p>
<p><br></p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><blockquote>
<p>进程可能有以下几种状态</p>
</blockquote>
<ul>
<li>运行:该进程此刻正在执行       </li>
<li>等待:进程能够执行,但没有获得CPU的执行,调度器可以在下一次任务切换时选择该进程     </li>
<li>睡眠:进程正在睡眠无法执行,在等待一个外部事件,调度器无法在下一次任务切换时选择该进程    </li>
</ul>
<p><img src="/2018/12/04/linux-programming/image-108.png" width="500px"></p>
<p><br></p>
<blockquote>
<p>抢占式多任务处理  </p>
</blockquote>
<p>Linux进程管理的结构中还需要另外两种进程状态:<code>用户态</code>和<code>核心态</code><br>反映所有现代CPU至少有两种不同执行状态,其中一种<code>各种限制</code>,另一种<code>无限权利</code></p>
<p>大多数进程属于<code>用户态</code>,只能访问自身数据无法干扰系统其它应用</p>
<p>如果进程想访问系统数据必须切换<code>核心态</code>,这类<code>系统调用</code>切换是受控的</p>
<p>还有第二种通过<code>中断</code>,此发生或多或少不可预测,处理<code>中断</code>操作,通常与执行进程无关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如外部块设备向内存传输数据完毕引发中断</span><br></pre></td></tr></table></figure>
<p>内核的抢占调度建立一个层次结构,用于判断哪些进程状态可以由其他状态抢占</p>
<ul>
<li>普通进程可被抢占,例如收到键盘输入,调度器直接抢占掉普通进程</li>
<li>如系统处于核心态处理系统调用,那么系统中的其他进程无法争夺CPU时间,必须等待或者中断可以终止系统调用</li>
<li>中断可以暂停处于<code>核心态</code>和<code>用户态</code>进程,中断具有最高优先级</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内核2.5 内核抢占选项添加内核, 允许紧急情况下核心态执行系统调用切换另一进程</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="进程表示"><a href="#进程表示" class="headerlink" title="进程表示"></a>进程表示</h2><p>由<code>task_struct</code>来包括终端成员并非简单类型变量,而是指向其他数据结构的指针</p>
<p>进程结构信息如下</p>
<ul>
<li>状态和执行信息(进程pid,父进程和相关进程指针,优先级,执行CPU时间信息)</li>
<li>有关已经分配的虚拟内存信息</li>
<li>进程身份凭据(用户ID,组ID以及权限)</li>
<li>使用的文件包含程序代码二进制文件,以及进程处理的文件系统信息  </li>
<li>该进程所用的信号处理程序  </li>
<li>struct nsproxy用于汇集指向特定于子系统的命名空间包装器的指针:</li>
</ul>
<p><code>state</code>指定了进程的当前状态,可使用下列值  </p>
<ul>
<li>TASK_RUNNING意味着进程处于可运行状态</li>
<li>TASK_INTERRUPTIBLE针对等待某事件或其他资源的睡眠进程设置</li>
<li>TASK_UNINTERRUPTIBLE因内核指示而停用的睡眠进程,不能由外部信号唤醒,只能由内核亲自唤醒</li>
<li>TASK_STOPPED表示进程特意停止运行,例如调试器暂停</li>
<li>TASK_TRACED本不是进程状态,用于从调试停止的进程与常规进程区分</li>
</ul>
<p><br></p>
<h2 id="轻量级进程-线程"><a href="#轻量级进程-线程" class="headerlink" title="轻量级进程(线程)"></a>轻量级进程(线程)</h2><blockquote>
<p>一个进程可能由若干线程组成,这些线程共享同样的数据和资源,但程序执行代码逻辑不一致。  </p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-107.png" width="500px"></p>
<p>由于多线程共享地址空间,所以需要增加互斥机制  </p>
<p>Linux采用clone方式创建线程,类似fork,但启用了检查(哪些与父进程共享,哪些资源线程独有)   </p>
<h3 id="进程内存布局"><a href="#进程内存布局" class="headerlink" title="进程内存布局"></a>进程内存布局</h3><ul>
<li>文本:程序指令</li>
<li>数据:程序使用的静态变量</li>
<li>堆:程序从该区域动态分配额外内存</li>
<li>栈:随函数调用、返回而增减的一片内存,用于为局部变量和函数调用链接信息分配存储空间</li>
</ul>
<h3 id="创建进程和执行程序"><a href="#创建进程和执行程序" class="headerlink" title="创建进程和执行程序"></a>创建进程和执行程序</h3><p>fork创建新进程,调用fork为父进程,新建进程为子进程</p>
<p>子进程从父进程继承数据段,栈段以及堆段副本后,可以修改内容不影响父进程”原版”内容</p>
<p>之后子进程要么执行与父进程共享代码段另外的函数</p>
<p>execve去加载并执行一个全新程序</p>
<p>execve会销毁现有的文本段、数据段、栈段以及堆段</p>
<p>并根据新程序代码创建新段来替换它们</p>
<h3 id="进程ID和父进程ID"><a href="#进程ID和父进程ID" class="headerlink" title="进程ID和父进程ID"></a>进程ID和父进程ID</h3><p>每个进程有PID进程id,PPID父进程id</p>
<h3 id="进程终止和终止状态"><a href="#进程终止和终止状态" class="headerlink" title="进程终止和终止状态"></a>进程终止和终止状态</h3><ul>
<li><p>进程_exit()系统调用请求退出</p>
</li>
<li><p>kill 传递信号进程杀死</p>
</li>
</ul>
<p>父进程wait()调用检测是否终止</p>
<h3 id="进程用户和组标识"><a href="#进程用户和组标识" class="headerlink" title="进程用户和组标识"></a>进程用户和组标识</h3><p>每个进程都有一组与之相关的UID,GID</p>
<ul>
<li><p>真实用户ID和组ID:用来标识进程所属的用户和组</p>
</li>
<li><p>有效用户ID和组ID:进程访问权限,大多数情况有效和真实相同</p>
<p>改变进程有效ID,可使进程具有相关权限</p>
</li>
</ul>
<h3 id="特权进程"><a href="#特权进程" class="headerlink" title="特权进程"></a>特权进程</h3><p>特权进程指有效用户ID为0的进程</p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><ul>
<li><p>守护进程在系统引导启动,直到系统关闭都健在</p>
</li>
<li><p>守护进程在后台运行,且无控制终端供其读写</p>
</li>
</ul>
<h3 id="环境列表"><a href="#环境列表" class="headerlink" title="环境列表"></a>环境列表</h3><p>每个进程都有环境列表,即在进程用户空间内存维护一组环境变量</p>
<p>fork创建新进程会继承父进程环境副本</p>
<p>exec会指定新环境加以接收</p>
<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>调用系统函数mmap()的进程,会在其虚拟地址空间创建一个新的内存映射</p>
<p>映射分类两类</p>
<ul>
<li><p>文件映射:将文件的部分区域映射入调用进程的虚拟内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一旦映射完成</span><br><span class="line">对文件映射的内容访问转换成了响应内存区域的字节操作</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名映射,其映射二面的内容会被初始化为0</p>
</li>
</ul>
<h2 id="静态库和共享库"><a href="#静态库和共享库" class="headerlink" title="静态库和共享库"></a>静态库和共享库</h2><p>将一组函数代码编并置于一个文件中,供其他应用程序调用</p>
<p>此做法有利于程序的开发和维护</p>
<h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>早期Unix系统中唯一的一种目标库</p>
<p>要使用静态库函数,需要创建程序的链接命令中指定相应的库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主程序会对静态库中隶属于各模块不同函数加以引用</span><br><span class="line">链接器解析了引用情况后,会从库中抽取所需目标模块的副本</span><br><span class="line">将其复制到最终可执行的文件中</span><br><span class="line">这就所谓的静态链接</span><br></pre></td></tr></table></figure>
<blockquote>
<p>缺点</p>
</blockquote>
<p>所需库内的各目标模块,采用静态链接方式生成的程序都存有一份副本</p>
<p>在不同的可执行文件都存有相同目标代码的副本造成磁盘空间的浪费</p>
<p>调用同一函数库的程序若均以静态链接方式生成,且又同时加以执行造成内存浪费</p>
<p>对库函数进行修改，需要重新编译，重新生成新的静态库</p>
<p>而所有需要调用该函数“升级版”应用,都需要重新与静态库链接生成</p>
<h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><p>设计共享库解决静态库存在的问题</p>
<p>如何将程序链接到共享库,那么连接器不会把库中目标模块复制到可执行文件中</p>
<p>而是在可执行文件中写入一条记录,表名可执行文件在运行时需要使用该共享库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一旦在运行时将可执行文件载入内存</span><br><span class="line">动态连接器确保将可执行文件所需要的动态库找到</span><br><span class="line">并载入内存,随后实施运行时链接,解析可执行文件中的函数调用</span><br><span class="line">将其与共享库中相应的函数定义关联起来</span><br></pre></td></tr></table></figure>
<p>在运行时共享库内存中中需要保留一份<br>从而节省磁盘空间</p>
<p>还确保了使用到函数的最新版</p>
<h2 id="进程间通信IPC及同步"><a href="#进程间通信IPC及同步" class="headerlink" title="进程间通信IPC及同步"></a>进程间通信IPC及同步</h2><ul>
<li>信号:表事件发生</li>
<li>管道:亦如shell的”|”操作符和FIFO</li>
<li>套接字:不同主机所允许进程之间传递</li>
<li>消息队列,进程间交换消息</li>
<li>文件锁定:防止其他进程读取或更新文件内容</li>
<li>信号量:同步进程动作</li>
<li>共享内存:允许两个及两个以上进程共享一块内存</li>
</ul>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>往往信号称软中断,进程收到信号,意味某一事件或异常情况发生</p>
<ul>
<li>用户键入中断字符(Control - C)</li>
<li>进程的子进程之一终止</li>
<li>进程设定的定时器到期</li>
<li>进程访问无效的内存地址</li>
</ul>
<p>shell中的kill和系统调用kill差不多功能</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>每个进程执行多个线程,线程模想成共享同一虚拟内存及一干其他属性的进程</p>
<p>线程之间共享全局变量进行通信,借助线程API所提供的条件遍历和互斥机制</p>
<p>得到了同步行为</p>
<h2 id="进程组和shell任务控制"><a href="#进程组和shell任务控制" class="headerlink" title="进程组和shell任务控制"></a>进程组和shell任务控制</h2><p>shell执行的每个程序都会在新进程内发起</p>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l | grep a | wc -l</span><br></pre></td></tr></table></figure>
<p>以上管道命令创建并使用了3个进程执行</p>
<p>shell会将管道内的所有进程置于一个进程组或任务中</p>
<p>每个进程都有相同的进程组标识符</p>
<h2 id="会话、控制终端、控制进程"><a href="#会话、控制终端、控制进程" class="headerlink" title="会话、控制终端、控制进程"></a>会话、控制终端、控制进程</h2><p>会话指一组进程组,会话中所有进程都相同的会话标识符</p>
<p>会话做多是支持任务控制的shell</p>
<p>shell创建的所有进程组和shell自身隶属于同一会话</p>
<p>一个会话可以用“&amp;”行命令创建任务数量的后台进程组</p>
<h2 id="伪终端"><a href="#伪终端" class="headerlink" title="伪终端"></a>伪终端</h2><p>伪终端最知名的为telnet何ssh之类的网络登录服务应用</p>
<p>一对相互连接的虚拟设备,也称主从设备</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从设备提供的接口,其行为方式与终端相类似</span><br><span class="line">可以将某一个终端便携的程序与从设备连接</span><br><span class="line">利用连接到主设备的另一程序来驱动着&quot;面向终端&quot;的程序</span><br><span class="line">这是伪终端的关键用途</span><br></pre></td></tr></table></figure>
<h2 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h2><ul>
<li>真实时间:进程的生命周期以某个标准时间点为起点测量出的时间简称UTC</li>
<li>进程时间,进程自启动所占用CPU时间总量,细分系统CPU和用户CPU时间</li>
</ul>
<p>time命令显示真实时间</p>
<h2 id="proc文件系统"><a href="#proc文件系统" class="headerlink" title="/proc文件系统"></a>/proc文件系统</h2><p>类似其他几种UNIX实现,linux也提供了/proc文件系统</p>
<p>/proc为虚拟文件系统,以文件系统目录和文件形式,提供一个指向内核数据结构的接口</p>
<p>这为查看和改变各系统属性开启方便之门</p>
<p>/proc/pID 查看系统中运行各进程的相关信息</p>
<h1 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>大多程序能够使用3种标准的文件描述符</p>
<p><img src="/2018/12/04/linux-programming/image-03.png" width="500px"></p>
<blockquote>
<p>IO操作的4个主要系统调用</p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-04.png" width="400px"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************\</span></span><br><span class="line"><span class="comment">*                  Copyright (C) Michael Kerrisk, 2016.                   *</span></span><br><span class="line"><span class="comment">*                                                                         *</span></span><br><span class="line"><span class="comment">* This program is free software. You may use, modify, and redistribute it *</span></span><br><span class="line"><span class="comment">* under the terms of the GNU General Public License as published by the   *</span></span><br><span class="line"><span class="comment">* Free Software Foundation, either version 3 or (at your option) any      *</span></span><br><span class="line"><span class="comment">* later version. This program is distributed without any warranty.  See   *</span></span><br><span class="line"><span class="comment">* the file COPYING.gpl-v3 for details.                                    *</span></span><br><span class="line"><span class="comment">\*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Listing 4-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BUF_SIZE        <span class="comment">/* Allow "cc -D" to override definition */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> inputFd, outputFd, openFlags;</span><br><span class="line">    <span class="keyword">mode_t</span> filePerms;</span><br><span class="line">    <span class="keyword">ssize_t</span> numRead;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span>)</span><br><span class="line">        usageErr(<span class="string">"%s old-file new-file\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open input and output files */</span></span><br><span class="line"></span><br><span class="line">    inputFd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (inputFd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"opening file %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    openFlags = O_CREAT | O_WRONLY | O_TRUNC;</span><br><span class="line">    filePerms = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP |</span><br><span class="line">                S_IROTH | S_IWOTH;      <span class="comment">/* rw-rw-rw- */</span></span><br><span class="line">    outputFd = open(argv[<span class="number">2</span>], openFlags, filePerms);</span><br><span class="line">    <span class="keyword">if</span> (outputFd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"opening file %s"</span>, argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Transfer data until we encounter end of input or an error */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((numRead = read(inputFd, buf, BUF_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (write(outputFd, buf, numRead) != numRead)</span><br><span class="line">            fatal(<span class="string">"couldn't write whole buffer"</span>);</span><br><span class="line">    <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"read"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (close(inputFd) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"close input"</span>);</span><br><span class="line">    <span class="keyword">if</span> (close(outputFd) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"close output"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码展示了主要用法</p>
<h2 id="open事项"><a href="#open事项" class="headerlink" title="open事项"></a>open事项</h2><blockquote>
<p> 进行open系统调用的flags参数值介绍</p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-05.png" width="500px"></p>
<p><img src="/2018/12/04/linux-programming/image-06.png" width="500px"></p>
<blockquote>
<p>open函数引发的错误</p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-07.png" width="500px"></p>
<p><img src="/2018/12/04/linux-programming/image-08.png" width="500px"></p>
<p>早期UNIX实现,open只有两个参数,无法创建新文件</p>
<p>而使用create系统调用来创建并打开一个新文件</p>
<p>尽管create在老旧程序代码有时可见,但由于open的flags参数对文件打开方式提供更多控制（O_RDWR）</p>
<h2 id="read事项"><a href="#read事项" class="headerlink" title="read事项"></a>read事项</h2><p>read系统调用从文件描述符fd打开文件中读取多少数据</p>
<p>count参数指定多少字节数,buffer提供存放输入数据内存缓冲区地址</p>
<p>缓冲区至少应用count个字节</p>
<p><img src="/2018/12/04/linux-programming/image-09.png" width="400px"></p>
<h2 id="write事项"><a href="#write事项" class="headerlink" title="write事项"></a>write事项</h2><p>将输入写入一个已打开的文件中</p>
<p><img src="/2018/12/04/linux-programming/image-10.png" width="400px"></p>
<h2 id="close-amp-lseek事项"><a href="#close-amp-lseek事项" class="headerlink" title="close&amp;lseek事项"></a>close&amp;lseek事项</h2><p><img src="/2018/12/04/linux-programming/image-12.png" width="400px"></p>
<p>close系统调用关闭一个打开的文件描述符</p>
<blockquote>
<p>lseek </p>
</blockquote>
<p>文件打开时,会将文件偏移量设置为指向文件内容开始</p>
<p>每次read,write将自动对其调整</p>
<p><img src="/2018/12/04/linux-programming/image-11.png" width="400px"></p>
<p>SEEK_SET</p>
<p>将文件偏移量设置从文件头部起始点开始的offset个字节</p>
<p>SEET_CUR</p>
<p>相当于当前文件的偏移量,将文件偏移量调整offset个字节</p>
<p>SEEK_END</p>
<p>将文件偏移量设置为起始于文件尾部的offset各字节</p>
<p><img src="/2018/12/04/linux-programming/image-13.png" width="400px"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************\</span></span><br><span class="line"><span class="comment">*                  Copyright (C) Michael Kerrisk, 2016.                   *</span></span><br><span class="line"><span class="comment">*                                                                         *</span></span><br><span class="line"><span class="comment">* This program is free software. You may use, modify, and redistribute it *</span></span><br><span class="line"><span class="comment">* under the terms of the GNU General Public License as published by the   *</span></span><br><span class="line"><span class="comment">* Free Software Foundation, either version 3 or (at your option) any      *</span></span><br><span class="line"><span class="comment">* later version. This program is distributed without any warranty.  See   *</span></span><br><span class="line"><span class="comment">* the file COPYING.gpl-v3 for details.                                    *</span></span><br><span class="line"><span class="comment">\*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Listing 4-3 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">off_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> fd, ap, j;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">ssize_t</span> numRead, numWritten;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span>)</span><br><span class="line">        usageErr(<span class="string">"%s file &#123;r&lt;length&gt;|R&lt;length&gt;|w&lt;string&gt;|s&lt;offset&gt;&#125;...\n"</span>,</span><br><span class="line">                 argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR | O_CREAT,</span><br><span class="line">                S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP |</span><br><span class="line">                S_IROTH | S_IWOTH);                     <span class="comment">/* rw-rw-rw- */</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ap = <span class="number">2</span>; ap &lt; argc; ap++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (argv[ap][<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'r'</span>:   <span class="comment">/* Display bytes at current offset, as text */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'R'</span>:   <span class="comment">/* Display bytes at current offset, in hex */</span></span><br><span class="line">            len = getLong(&amp;argv[ap][<span class="number">1</span>], GN_ANY_BASE, argv[ap]);</span><br><span class="line"></span><br><span class="line">            buf = <span class="built_in">malloc</span>(len);</span><br><span class="line">            <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">                errExit(<span class="string">"malloc"</span>);</span><br><span class="line"></span><br><span class="line">            numRead = read(fd, buf, len);</span><br><span class="line">            <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">                errExit(<span class="string">"read"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (numRead == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s: end-of-file\n"</span>, argv[ap]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s: "</span>, argv[ap]);</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numRead; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (argv[ap][<span class="number">0</span>] == <span class="string">'r'</span>)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%c"</span>, <span class="built_in">isprint</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>) buf[j]) ?</span><br><span class="line">                                                buf[j] : <span class="string">'?'</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%02x "</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) buf[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">free</span>(buf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'w'</span>:   <span class="comment">/* Write string at current offset */</span></span><br><span class="line">            numWritten = write(fd, &amp;argv[ap][<span class="number">1</span>], <span class="built_in">strlen</span>(&amp;argv[ap][<span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">if</span> (numWritten == <span class="number">-1</span>)</span><br><span class="line">                errExit(<span class="string">"write"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s: wrote %ld bytes\n"</span>, argv[ap], (<span class="keyword">long</span>) numWritten);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'s'</span>:   <span class="comment">/* Change file offset */</span></span><br><span class="line">            offset = getLong(&amp;argv[ap][<span class="number">1</span>], GN_ANY_BASE, argv[ap]);</span><br><span class="line">            <span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">                errExit(<span class="string">"lseek"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s: seek succeeded\n"</span>, argv[ap]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cmdLineErr(<span class="string">"Argument must start with [rRws]: %s\n"</span>, argv[ap]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (close(fd) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"close"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上seek的使用</p>
<h2 id="深入IO"><a href="#深入IO" class="headerlink" title="深入IO"></a>深入IO</h2><h3 id="原子操作和竞争"><a href="#原子操作和竞争" class="headerlink" title="原子操作和竞争"></a>原子操作和竞争</h3><p>以独占方式创建一个文件</p>
<p>当同时指定O_EXCL与O_CREAT作为open的标志位</p>
<p>如果打开文件已然存在,则open会返回一个错误</p>
<p>这种机制保证了进程是打开文件创建者</p>
<p>对文件是否存在检查和创建属于同一原子操作(即不可中断的操作)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************\</span></span><br><span class="line"><span class="comment">*                  Copyright (C) Michael Kerrisk, 2016.                   *</span></span><br><span class="line"><span class="comment">*                                                                         *</span></span><br><span class="line"><span class="comment">* This program is free software. You may use, modify, and redistribute it *</span></span><br><span class="line"><span class="comment">* under the terms of the GNU General Public License as published by the   *</span></span><br><span class="line"><span class="comment">* Free Software Foundation, either version 3 or (at your option) any      *</span></span><br><span class="line"><span class="comment">* later version. This program is distributed without any warranty.  See   *</span></span><br><span class="line"><span class="comment">* the file COPYING.gpl-v3 for details.                                    *</span></span><br><span class="line"><span class="comment">\*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Listing 5-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span>)</span><br><span class="line">        usageErr(<span class="string">"%s file\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_WRONLY);       <span class="comment">/* Open 1: check if file exists */</span></span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;                     <span class="comment">/* Open succeeded */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[PID %ld] File \"%s\" already exists\n"</span>,</span><br><span class="line">                (<span class="keyword">long</span>) getpid(), argv[<span class="number">1</span>]);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != ENOENT) &#123;          <span class="comment">/* Failed for unexpected reason */</span></span><br><span class="line">            errExit(<span class="string">"open"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[PID %ld] File \"%s\" doesn't exist yet\n"</span>,</span><br><span class="line">                    (<span class="keyword">long</span>) getpid(), argv[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;             <span class="comment">/* Delay between check and create */</span></span><br><span class="line">                sleep(<span class="number">5</span>);               <span class="comment">/* Suspend execution for 5 seconds */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"[PID %ld] Done sleeping\n"</span>, (<span class="keyword">long</span>) getpid());</span><br><span class="line">            &#125;</span><br><span class="line">            fd = open(argv[<span class="number">1</span>], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);</span><br><span class="line">            <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">                errExit(<span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[PID %ld] Created file \"%s\" exclusively\n"</span>,</span><br><span class="line">                    (<span class="keyword">long</span>) getpid(), argv[<span class="number">1</span>]);          <span class="comment">/* MAY NOT BE TRUE! */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/04/linux-programming/image-14.png" width="400px"></p>
<p>以上代码会有潜伏一个Bug,第一次调用open,希望打开的文件还不存在,而第二次open其他进程已经创建了文件,进程会得出错误的结论,认为目标文件是自己创建的,所以第二次open无论如何都会调用成功</p>
<h3 id="文件描述符与打开文件之间的关系"><a href="#文件描述符与打开文件之间的关系" class="headerlink" title="文件描述符与打开文件之间的关系"></a>文件描述符与打开文件之间的关系</h3><p>目前为止,文件描述符和打开的文件呈现一一对应的关系</p>
<p>然后事实可以多个文件描述符指向同一个打开文件</p>
<p>这些文件描述符在相同或不同的进程中打开</p>
<blockquote>
<p>内核维护了3个数据结构</p>
</blockquote>
<ul>
<li>进程级的文件描述符表</li>
<li>系统级的打开文件表</li>
<li>文件系统的i-node表</li>
</ul>
<p>针对每个进程,内核为其维护打开文件的描述符表</p>
<p>该表的每一条都记录了单个文件描述符的相关信息</p>
<ul>
<li>控制文件描述符操作的一组标志</li>
<li>对打开文件句柄的引用</li>
</ul>
<p>内核对所有打开文件维护有一个系统级的描述表格</p>
<p>有时称为打开表,表中各条目称为打开文件句柄</p>
<blockquote>
<p>文件打开句柄</p>
</blockquote>
<p>一个打开文件句柄存储了与一个打开文件相关的全部信息如下</p>
<ul>
<li>当前文件偏移量(read, write时更新,或使用lseek直接修改)</li>
<li>打开文件时所使用的状态标志(即open的flags参数)</li>
<li>文件访问模式(如调用open时所设置的只读模式,只写模式或读写模式)</li>
<li>与信号驱动I/O相关的设置</li>
<li>对该文件i-node对象的引用</li>
</ul>
<blockquote>
<p>每个文件系统都会为驻留其上的所有文件建立一个i-node表</p>
</blockquote>
<p>每个文件i-node信息</p>
<ul>
<li>文件类型(常规文件、套接字或FIFO)和访问权限</li>
<li>一个指针，指向该文件所持有的锁的列表</li>
<li>文件的各种属性,包括文件大小以及与不同类型操作相关的时间戳</li>
</ul>
<p><img src="/2018/12/04/linux-programming/image-15.png" width="500px"></p>
<blockquote>
<p>多个文件描述符的协调</p>
</blockquote>
<p>每个进程各自对同一个文件发起了open调用,同一个进程两次打开同一文件</p>
<ul>
<li>两个不同的文件描述符,若指向同一个打开文件句柄,将共享同一文件偏移量,因此如果一个文件描述符修改文件偏移量,另一个文件描述符也察觉到这一变化,无论这两个描述符归属不同进程还是同属一个进程</li>
<li>文件描述符标志（close-on-exec标志）为进程和文件描述符所私有对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符</li>
</ul>
<p><img src="/2018/12/04/linux-programming/image-16.png" width="500px"></p>
<h3 id="复制文件描述符"><a href="#复制文件描述符" class="headerlink" title="复制文件描述符"></a>复制文件描述符</h3><p>shell的I/O重定向语法 2&gt;&1;意在通知shell把标准错误2重定向到标准输出1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./myscript &gt; result.log 2&gt;&amp;1</span><br><span class="line">//标准输出和标准错误写入result.log文件</span><br></pre></td></tr></table></figure>
<p>shell通过复制文件描述符2实现了标准错误的重定向操作</p>
<p>因此文件描述符2与文件描述符1指向同一个打开文件句柄</p>
<p>代码中都是以<code>dup()</code>调用复制一个打开的文件描述符oldfd</p>
<p>并返回一个新的描述符</p>
<p>二者都指向同一打开的文件句柄,系统会保证新描述符一定是编号值最低的未用文件描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"></span><br><span class="line">newfd = dup(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//正常情况,假定shell已经代表程序打开了文件描述符0,1,2且没有其他描述符在用,dup()调用会创建文件描述符1的副本,返回文件描述符编号值为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想获取2的文件描述符则close掉2</span></span><br><span class="line">close(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//新出来的就是2</span></span><br><span class="line">newfd = dup(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果想获得期望文件描述符</p>
</blockquote>
<p>可以用<code>dup2</code>,oldfd指定的文件描述符创建副本,newfd决定编号</p>
<p><img src="/2018/12/04/linux-programming/image-17.png" width="400px"></p>
<h3 id="分散输入和集中输出"><a href="#分散输入和集中输出" class="headerlink" title="分散输入和集中输出"></a>分散输入和集中输出</h3><p><img src="/2018/12/04/linux-programming/image-18.png" width="400px"></p>
<p>系统调用并非只对单个缓冲区进行读写操作</p>
<p>而是一次即可传输多个缓冲区的数据,数组iov定义了一组用来传输数据的缓冲区,整型数iovcnt指定了iov的成员个数</p>
<p><img src="/2018/12/04/linux-programming/image-19.png" width="400px"></p>
<blockquote>
<p>分散输入</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************\</span></span><br><span class="line"><span class="comment">*                  Copyright (C) Michael Kerrisk, 2016.                   *</span></span><br><span class="line"><span class="comment">*                                                                         *</span></span><br><span class="line"><span class="comment">* This program is free software. You may use, modify, and redistribute it *</span></span><br><span class="line"><span class="comment">* under the terms of the GNU General Public License as published by the   *</span></span><br><span class="line"><span class="comment">* Free Software Foundation, either version 3 or (at your option) any      *</span></span><br><span class="line"><span class="comment">* later version. This program is distributed without any warranty.  See   *</span></span><br><span class="line"><span class="comment">* the file COPYING.gpl-v3 for details.                                    *</span></span><br><span class="line"><span class="comment">\*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Listing 5-2 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[3];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">myStruct</span>;</span>       <span class="comment">/* First buffer */</span></span><br><span class="line">    <span class="keyword">int</span> x;                      <span class="comment">/* Second buffer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR_SIZE 100</span></span><br><span class="line">    <span class="keyword">char</span> str[STR_SIZE];         <span class="comment">/* Third buffer */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> numRead, totRequired;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span>)</span><br><span class="line">        usageErr(<span class="string">"%s file\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line">    totRequired = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = &amp;myStruct;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(struct stat);</span><br><span class="line">    totRequired += iov[<span class="number">0</span>].iov_len;</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">1</span>].iov_base = &amp;x;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span>(x);</span><br><span class="line">    totRequired += iov[<span class="number">1</span>].iov_len;</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">2</span>].iov_base = str;</span><br><span class="line">    iov[<span class="number">2</span>].iov_len = STR_SIZE;</span><br><span class="line">    totRequired += iov[<span class="number">2</span>].iov_len;</span><br><span class="line"></span><br><span class="line">    numRead = readv(fd, iov, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"readv"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numRead &lt; totRequired)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Read fewer bytes than requested\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total bytes requested: %ld; bytes read: %ld\n"</span>,</span><br><span class="line">            (<span class="keyword">long</span>) totRequired, (<span class="keyword">long</span>) numRead);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>readv</code>实现了分散输入的功能,从文件描述符fd所指代的文件中读取一片连续的字节,然后将其散置iov指定的缓冲区</p>
<blockquote>
<p>集中输出</p>
</blockquote>
<p><code>writev()</code>系统调用实现了集中输出,将iov所指定的所有缓冲区中的数据拼接起来,然后以连续的字节序列写入文件描述符fd指代的文件中</p>
<p><img src="/2018/12/04/linux-programming/image-20.png" width="400px"></p>
<h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p>打开文件时指定<code>O_NONBLOCK</code>标志,目的两个</p>
<ul>
<li>若open调用未能理解打开文件,则返回错误,而非陷入阻塞,当然如果open操作FIFO可能会陷入阻塞</li>
<li>调用open成功,后续的IO操作也是非阻塞,若IO系统调用未能立即完成,则可能会只传输部分数据,或者系统调用失败,并返回EAGEIN或EWOULDBLOCK错误</li>
</ul>
<p>管道、FIFO、套接字、设备都支持非阻塞</p>
<p>(因为无法通过open获取管道和套接字的文件描述符,所以要启用非阻塞标志,必须使用<code>fcntl()</code>的F_SETFL命令)</p>
<h3 id="dev-fd目录"><a href="#dev-fd目录" class="headerlink" title="/dev/fd目录"></a>/dev/fd目录</h3><p>内核提供有一个特殊的虚拟目录,”/dev/fd/n”，n是与进程中打开文件描述符相对应的编号</p>
<p><code>/dev/fd/0</code>对应进程的标准输入</p>
<h1 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h1><p>进程,一个可执行程序的实例包含内容如下</p>
<ul>
<li>二进制格式标识</li>
<li>机器语言指令</li>
<li>程序入口地址</li>
<li>数据</li>
<li>符号表和重定位表</li>
<li>共享库和动态链接信息</li>
<li>其他信息</li>
</ul>
<h2 id="进程号和父进程号"><a href="#进程号和父进程号" class="headerlink" title="进程号和父进程号"></a>进程号和父进程号</h2><p><img src="/2018/12/04/linux-programming/image-21.png" width="400px"></p>
<p>每个进程都有进程号,进程号为正数,唯一标识系统中的某个进程</p>
<p>Linux内核限制进程号小于等于<code>32767</code>,新进程创建时,内核会按顺序将下一个可用的进程号分配给其使用</p>
<p>每当进程达到<code>32767</code>限制时,重置进程号计数器,以便从小整数开始分配</p>
<p><img src="/2018/12/04/linux-programming/image-22.png" width="500px"></p>
<h2 id="进程内存布局-1"><a href="#进程内存布局-1" class="headerlink" title="进程内存布局"></a>进程内存布局</h2><p>每个进程所分配的内存由很多部分组成,通常称之为“段(segment)“</p>
<ul>
<li><p>文本段</p>
<p>进程允许的程序机器语言指令,文本段具有只读属性</p>
<p>防止进程通过错误指针意外修改自身指令,因多个进程可同时运行同一程序,所以又将文本段设为可共享,这样一份程序代码的拷贝可以映射到所有这样进程的虚拟地址空间中</p>
</li>
<li><p>初始化数据段</p>
<p>显式初始化的全局变量和静态变量</p>
</li>
<li><p>未初始化数据段  </p>
<p>包含未进行显式初始化的全局变量和静态变量,程序启动之前,系统将本段内所有初始化为0,此段通常称为BSS段</p>
<p>源于老版本的汇编语言助记符”block started by symbol“</p>
</li>
<li><p>栈,由栈帧组成,系统为每个当前调用的函数分配栈帧,栈帧存储函数的局部变量,实参,返回值</p>
</li>
<li><p>堆,可在运行时动态进行内存分配的一块区域</p>
</li>
</ul>
<p>程序变量在进程内存各段的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************\</span></span><br><span class="line"><span class="comment">*                  Copyright (C) Michael Kerrisk, 2016.                   *</span></span><br><span class="line"><span class="comment">*                                                                         *</span></span><br><span class="line"><span class="comment">* This program is free software. You may use, modify, and redistribute it *</span></span><br><span class="line"><span class="comment">* under the terms of the GNU General Public License as published by the   *</span></span><br><span class="line"><span class="comment">* Free Software Foundation, either version 3 or (at your option) any      *</span></span><br><span class="line"><span class="comment">* later version. This program is distributed without any warranty.  See   *</span></span><br><span class="line"><span class="comment">* the file COPYING.gpl-v3 for details.                                    *</span></span><br><span class="line"><span class="comment">\*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Listing 6-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> globBuf[<span class="number">65536</span>];            <span class="comment">/* Uninitialized data segment */</span></span><br><span class="line"><span class="keyword">int</span> primes[] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span> &#125;;  <span class="comment">/* Initialized data segment */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">square(<span class="keyword">int</span> x)                   <span class="comment">/* Allocated in frame for square() */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result;                 <span class="comment">/* Allocated in frame for square() */</span></span><br><span class="line"></span><br><span class="line">    result = x * x;</span><br><span class="line">    <span class="keyword">return</span> result;              <span class="comment">/* Return value passed via register */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">doCalc(<span class="keyword">int</span> val)                 <span class="comment">/* Allocated in frame for doCalc() */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The square of %d is %d\n"</span>, val, square(val));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (val &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;                  <span class="comment">/* Allocated in frame for doCalc() */</span></span><br><span class="line"></span><br><span class="line">        t = val * val * val;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The cube of %d is %d\n"</span>, val, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])    <span class="comment">/* Allocated in frame for main() */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> key = <span class="number">9973</span>;      <span class="comment">/* Initialized data segment */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> mbuf[<span class="number">10240000</span>]; <span class="comment">/* Uninitialized data segment */</span></span><br><span class="line">    <span class="keyword">char</span> *p;                    <span class="comment">/* Allocated in frame for main() */</span></span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">malloc</span>(<span class="number">1024</span>);           <span class="comment">/* Points to memory in heap segment */</span></span><br><span class="line"></span><br><span class="line">    doCalc(key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/04/linux-programming/image-23.png" width="400px"></p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>提供虚拟化的轻量级形式,不同方面看运行系统的全局属性  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UID:0的root用户允许做任何事情,其他用户ID会受到限制,例如UID为N的用户不允许啥杀死用户M的进程</span><br><span class="line"></span><br><span class="line">但有些情况下Web主机供应商打算向用户提供Linux所有访问权限,包括root权限</span><br><span class="line"></span><br><span class="line">有kvm和VMware提供虚拟化环境是一种解决方法,单资源分配做的不是肥朝,每个用户都需要独立的内核</span><br><span class="line"></span><br><span class="line">命名空间提供不同的解决方案,所需资源较少</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虚拟化系统,物理计算机运行多个内核,并行的多个不同操作系统</p>
<p>而命名空间只是用一个内核在一台物理计算机上运作,所有全局资源通过命名空间抽象起来</p>
</blockquote>
<p>这样使得一组进程放置到容器中,各个容器彼此隔离,隔离可以使容器成员与其他容器毫无关系</p>
<p><img src="/2018/12/04/linux-programming/image-116.png" width="500px"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">命名空间可组织为层次,一个命名空间是父命名空间,衍生两个子命名空间</span><br><span class="line">每个都有自身的init进程,pid为0</span><br><span class="line">其他进程的pid以递增次序分配</span><br><span class="line">由于相同pid在系统出现多次,所以pid不是全局唯一</span><br><span class="line"></span><br><span class="line">父容器知道子命名空间的存在,也可以看到其中执行的所有进程</span><br><span class="line">子容器123映射到父容器456,789</span><br><span class="line"></span><br><span class="line">还有一种命名空间为UTS和用户命名空间,不存在父子层次</span><br></pre></td></tr></table></figure>
<blockquote>
<p>新的命名空间进程用以下方式创建</p>
</blockquote>
<ul>
<li>fork或clone系统调用创建新进程,有特定的选项控制是与父进程共享命名空间还是建立新的命名空间</li>
<li>unshare系统调用将进程的某些部分从父进程分离,其中也包括命名空间</li>
</ul>
<p><br></p>
<blockquote>
<p> 进程与命名空间关系如下</p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-117.png" width="500px"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> &#123;</span></span><br><span class="line">            <span class="keyword">atomic_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">uts_ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ipc_ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net_ns</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>UTS为<code>Unix Timesharing System</code>简称</li>
<li><code>struct nsproxy</code>用于汇集指向特定于子系统的命名空间包装器的指针<ul>
<li>已经装载的文件系统的视图在<code>struct mnt_namespaces</code>给出</li>
<li>有关进程ID由<code>struct pid_namespaces</code>提供</li>
<li>保存限制每个用户资源使用由<code>struct user_namespace</code>提供</li>
<li>网络相关的命名空间由<code>struct net_ns</code></li>
</ul>
</li>
</ul>
<h3 id="uts命名空间"><a href="#uts命名空间" class="headerlink" title="uts命名空间"></a>uts命名空间</h3><p>没有层次组织,所有汇集到以下结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;utsname.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">new_utsname</span> <span class="title">name</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;utsname.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">new_utsname</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> sysname[<span class="number">65</span>];</span><br><span class="line">    <span class="keyword">char</span> nodename[<span class="number">65</span>];</span><br><span class="line">    <span class="keyword">char</span> release[<span class="number">65</span>];</span><br><span class="line">    <span class="keyword">char</span> version[<span class="number">65</span>];</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上字符串分别存储系统名称,内核发布版本等</p>
<p><code>uname</code>可取这些当前值</p>
<p>进程调用fork通过clone_newuts创建新的UTS命名空间</p>
<h3 id="用户命名空间"><a href="#用户命名空间" class="headerlink" title="用户命名空间"></a>用户命名空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">uidhash_table</span>[<span class="title">UIDHASH_SZ</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">root_user</span>;</span></span><br></pre></td></tr></table></figure>
<p>每个用户命名空间对其用户资源使用的统 计,与其他命名空间完全无关,对root用户的统计也是如此。这是因为在克隆一个用户命名空间时, 为当前用户和root都创建了新的user_struct实例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct user_namespace *<span class="title">clone_user_ns</span><span class="params">(struct user_namespace *old_ns)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">new_user</span>;</span></span><br><span class="line">    ns = kmalloc(<span class="keyword">sizeof</span>(struct user_namespace), GFP_KERNEL);</span><br><span class="line">    ns-&gt;root_user = alloc_uid(ns, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 将current-&gt;user替换为新的 */</span></span><br><span class="line">    new_user = alloc_uid(ns, current-&gt;uid);</span><br><span class="line">    switch_uid(new_user);</span><br><span class="line">    <span class="keyword">return</span> ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>alloc_uid是一个辅助函数,对当前命名空间中给定UID的一个用户,如果该用户没有对应的user_struct实例,则分配一个新的实例。在为root和当前用户分别设置了user_struct实例后, switch_uid确保从现在开始将新的user_struct实例用于资源统计。实质上就是将struct task_struct的user成员指向新的user_struct实例。 </p>
<h2 id="进程PID"><a href="#进程PID" class="headerlink" title="进程PID"></a>进程PID</h2><p>每个进程除了pid还有其他ID</p>
<ul>
<li>处于某个线程组(以CLONE_THREAD来调用clone建立的该进程的不同执行上下文),所有进程都有统一的线程组ID(TGID),如果进程没有使用线程则PID=TGID</li>
<li>独立进程可以合并进程组,进程组成员的<code>task_struct</code>的pgrp即进程组组长的PID</li>
<li>几个进程组可以合并成一个会话,会话中所有进场都有同样的会话ID,保存在<code>task_struct</code>的<code>session</code>成员SID可以使用setsid系统调用设置</li>
</ul>
<p><img src="/2018/12/04/linux-programming/image-118.png" width="500px"></p>
<p>命名空间中的所有PID对父命名空间都是可见的,但子命名空间无法看到父命名空间的PID。 但这意味着某些进程具有多个PID,凡可以看到该进程的命名空间,都会为其分配一个PID。 这必须 反映在数据结构中。我们必须区分局部ID和全局ID。</p>
<ul>
<li>全局ID是在内核本身和初始命名空间中的唯一ID号,在系统启动期间开始的init进程即属于 初始命名空间。对每个ID类型,都有一个给定的全局ID,保证在整个系统中是唯一的。 </li>
<li>局部ID属于某个特定的命名空间,不具备全局有效性。对每个ID类型,它们在所属的命名空 间内部有效,但类型相同、值也相同的ID可能出现在不同的命名空间中。 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">pid_t</span> tgid;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局PID和TGID直接保存在task_struct中,分别是task_struct的pid和tgid成员 </p>
<h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2><p>由内核本身启动的进程,内核线程实际将内核函数委托给独立的进程,与系统其他进程并行执行</p>
<p>它执行的任务如下</p>
<ul>
<li>周期性地修改内存页与页来源块设备同步(例如使用mmap的文件映射)</li>
<li>如果内存页很少使用,则写入交换区</li>
<li>管理延时动作(deferred action)</li>
<li>实现文件系统的事务日志</li>
</ul>
<p>实际两类内核线程</p>
<ul>
<li>类型一:线程启动后一直等待,直至内核请求线程执行某一特定操作</li>
<li>类型二:线程启动后按周期性间隔运行,检测特定资源使用,用量超出或低于阈值采取行动内核使用这类线程用于连续监测任务</li>
</ul>
<p>内核线程会出现在系统进程列表中,但在ps的输出中由方括号包围,以便与普通进程区分。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; ps fax </span><br><span class="line">PID TTY STAT TIME COMMAND </span><br><span class="line">0:00 _ [kblockd/3]</span><br><span class="line">0:00 _ [kacpid]</span><br><span class="line">0:00 _ [kacpi_notify]</span><br></pre></td></tr></table></figure>
<h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>七任务在程序之间共享CPU时间,创造并行执行的错觉,该任务分两个不同的部分</p>
<ul>
<li>涉及调度策略</li>
<li>涉及上下文切换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果通过轮流运行各个进程来模拟多任务,那么当前运行的进程,</span><br><span class="line">其待遇显然好于哪些等待调度 器选择的进程,即等待的进程受到了不公平的对待。</span><br><span class="line">不公平的程度正比于等待时间。</span><br><span class="line"></span><br><span class="line">每次调用调度器时,它会挑选具有最高等待时间的进程,把CPU提供给该进程。</span><br><span class="line">如果经常发生这种情况,那么进程的不公平待遇不会累积,不公平会均匀分布到系统中的所有进程。</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/04/linux-programming/image-119.png" width="500px"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">所有的可运行进程都按时间在一个红黑树中排序,所谓时间即其等待时间。</span><br><span class="line">等待CPU时间最长的 进程是最左侧的项,调度器下一次会考虑该进程。</span><br><span class="line">等待时间稍短的进程在该树上从左至右排序。</span><br><span class="line"></span><br><span class="line">除了红黑树外,就绪队列还装备了虚拟时钟。</span><br><span class="line">该时钟的时间流逝速度慢于实际的时钟,精确的 速度依赖于当前等待调度器挑选的进程的数目。</span><br><span class="line">假定该队列上有4个进程,那么虚拟时钟将以实际时钟四分之一的速度运行。</span><br><span class="line">如果以完全公平的方式分享计算能力,那么该时钟是判断等待进程将获得多少CPU时间的基准。</span><br><span class="line">在就绪队列等待实际的20秒,相当于虚拟时间5秒。</span><br><span class="line">4个进程分别执行5秒,即可使CPU被实际占用20秒。</span><br></pre></td></tr></table></figure>
<p>遗憾的是,该策略受若干现实问题的影响,已经变得复杂了。 </p>
<ul>
<li><p>进程的不同优先级(即,nice值)必须考虑,更重要的进程必须比次要进程更多的CPU时间 </p>
<p>份额。 </p>
</li>
<li><p>进程不能切换得太频繁,因为上下文切换,即从一个进程改变到另一个,是有一定开销的。在切换发生得太频繁时,过多时间花费在进程切换的过程中,而不是用于实际的工作。 另一方面,两次相邻的任务切换之间,时间也不能太长,否则会累积比较大的不公平值。对 多媒体系统来说,进程运行太长时间也会导致延迟增大。 </p>
</li>
</ul>
<blockquote>
<p> 优先级的内核表示 </p>
</blockquote>
<p>在用户空间可以通过nice命令设置进程的静态优先级</p>
<p>这在内部会调用nice系统调用。</p>
<p>进程的 nice值在-20和+19之间(包含)。</p>
<p>值越低,表明优先级越高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setpriority是另一个用于设置进程优先级的系统调用。</span><br><span class="line">它不仅能够修改单个线程的优先级,还能修改线程组中所有线程的优先级</span><br><span class="line">或者通过指定UID来修改特定用户的所有进程的优先级。</span><br></pre></td></tr></table></figure>
<p>内核使用一个简单些的数值范围,从0到139(包含),用来表示内部优先级。同样是值越低,优 先级越高。从0到99的范围专供实时进程使用。nice值[-20, +19]映射到范围100到139,如图2-14所示。 实时进程的优先级总是比普通进程更高。 </p>
<p><img src="/2018/12/04/linux-programming/image-120.png" width="500px"></p>
<blockquote>
<p>核心调度器</p>
</blockquote>
<p>调度器实现基于两个函数:周期性调度函数和主调度器函数,这些函数根据现有进程优先级分配CPU时间</p>
<ul>
<li><p>周期性调度器</p>
<p>周期性调度器在scheduler_tick中实现。如果系统正在活动中,内核会按照频率HZ自动调用该函数。如果没有进程在等待调度,那么在计算机电力供应不足的情况下,也可以关闭该调度器以减少电能消耗 </p>
</li>
<li><p>主调度器</p>
<p>CPU分配给当前活动进程不同的另一个进程,都会直接调用主调度器函数(schedule)</p>
<p>内核会调用 schedule。该函数假定当前活动进程一定会被另一个进程取代 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主调度器确定当前就绪队列,并在prev中保存一个指向活动进程的task_struct的指针</span><br><span class="line">类似周期性调度器,内核利用该时机来更新就绪队列的时钟</span><br><span class="line"></span><br><span class="line">调度器当前运行的进程将要被另一个进程代替,不等价于把进程从就绪队列移除</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>上下文切换</p>
</blockquote>
<p>内核选择新进程之后,必须处理与多任务相关的技术细节,总称上下文切换</p>
<p><img src="/2018/12/04/linux-programming/image-123.png" width="500px"></p>
<h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><p>虚拟内存的使用考虑到了以下几点</p>
<ul>
<li>空间局部性:程序倾向于访问最近访问过的内存地址附近的内存(指令是顺序执行的,且有时会按顺序处理数据结构)</li>
<li>时间局部性:程序倾向于不久的将来再次访问最近刚访问过的内存地址(由于循环)</li>
</ul>
<p>虚拟内存将每个程序使用的内存切割成小型的、固定大小的页单元</p>
<p>任一时刻,每个程序仅有部分页需要驻留在物理内存页帧中,这些页构成了所谓的驻留集,程序未使用的页拷贝保存在交换区-(磁盘空间中的保留区域)</p>
<p>若进程访问的页尚未驻留在物理内存中,将会发生页面错误(内核即可挂起进程的执行,同时从磁盘交换空间中将该页面载入内存)</p>
<p>为了实现这一组织方式, <code>需要内核为每个进程维护一张页表为所有进程共享,每个进程都有自己的进程页表</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“内核页表”由内核自己维护并更新</span><br><span class="line"></span><br><span class="line">在vmalloc区发生page fault时,将“内核页表”同步到“进程页表”中。</span><br></pre></td></tr></table></figure>
<p>页表描述了每个虚拟页面在内存的位置,要么表明驻留在磁盘上</p>
<p><img src="/2018/12/04/linux-programming/image-24.png" width="400px"></p>
<p>虚拟内存的管理使得进程与RAM物理地址空间隔开,从而带来了许多优点  </p>
<ul>
<li><p>进程与进程、进程与内核的隔离,不能读取修改另一进程或内核的内存,这是因为每个进程的内存页表指向截然不同的RAM(或交换空间)物理页面集合   </p>
</li>
<li><p>适当情况下,两个或更多进程能够共享内存,由于内核可以使不同进程的内存页表条目执行相同的RAM页,内存共享的场景</p>
<ul>
<li>执行同一程序的多个进程,共享一份程序代码副本    </li>
<li>进程使用shmget()和mmap()系统调用显式请求与其他进程共享内存区  </li>
</ul>
</li>
<li><p>便于实现内存保护机制,对页表条目标记,表示相关页内容是可读,可写,可执行  </p>
</li>
<li><p>因驻留在内存中仅是程序的一部分,所以程序的加载和运行都很快,而且占用的内存超出RAM容量  </p>
</li>
</ul>
<h2 id="栈和栈帧"><a href="#栈和栈帧" class="headerlink" title="栈和栈帧"></a>栈和栈帧</h2><p>栈驻留在内存的高端并向下递增(朝堆的低方向)  </p>
<p>专用寄存器-SP(stack pointer),用于跟踪当前的栈顶,每次调用函数,会在栈上新分配一帧,每当函数返回时,再从栈上将此栈移去  </p>
<p><img src="/2018/12/04/linux-programming/image-25.png" width="400px">  </p>
<blockquote>
<p>栈又细分内核栈和用户栈  </p>
</blockquote>
<p>内核栈是每个进程保留在内核内存中的内存区域,在执行调用的过程内核的内部函数调用使用  </p>
<p>用户栈的信息如下:  </p>
<ul>
<li><p>函数实参和局部变量:在调用函数自动创建这些变量,函数返回时又将自动销毁这些变量  </p>
</li>
<li><p>函数调用的链接信息:每个函数都会用到一些cpu寄存器,比如程序计数器,其向下一条将要执行的机器语言指令,会在栈的栈帧保存这些寄存器的副本,以便函数返回时能够为函数调用者恢复寄存器的原状   </p>
</li>
</ul>
<h2 id="环境列表-1"><a href="#环境列表-1" class="headerlink" title="环境列表"></a>环境列表</h2><p>每个进程都有与之相关的环境列表的字符串数组,简称环境    </p>
<p>每个字符串都以<code>名称=值</code>形式定义,因此环境是<code>&quot;名称-值&quot;</code>的成对集合,可存储任何信息  </p>
<p>新进程创建会继承父进程的环境副本  </p>
<p>常见用途实在在shell中可确保把这些值传递给所创建的进程   </p>
<blockquote>
<p>shell </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export SHELL=/bin/bash</span><br><span class="line"></span><br><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>
<blockquote>
<p>c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv SHELL /bin/bash</span><br></pre></td></tr></table></figure>
<h3 id="从程序中访问环境"><a href="#从程序中访问环境" class="headerlink" title="从程序中访问环境"></a>从程序中访问环境</h3><p>C中可以通过全局变量<code>char **environ</code>访问环境列表  </p>
<p><img src="/2018/12/04/linux-programming/image-26.png" width="400px"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> **ep;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ep = environ; *ep != <span class="literal">NULL</span>; ep++)</span><br><span class="line">        <span class="built_in">puts</span>(*ep);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h3><ul>
<li><p>putenv 向进程添加一个新的变量,或者修改一个已经存在的变量  </p>
</li>
<li><p>setenv 代替putenv,向环境添加一个变量    </p>
</li>
<li><p>unsetenv 移除env,由name参数标识的变量  </p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE     <span class="comment">/* Get various declarations from &lt;stdlib.h&gt; */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">char</span> **ep;</span><br><span class="line"></span><br><span class="line">    clearenv();         <span class="comment">/* Erase entire environment */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">        <span class="keyword">if</span> (putenv(argv[j]) != <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">"putenv: %s"</span>, argv[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setenv(<span class="string">"GREET"</span>, <span class="string">"Hello world"</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"setenv"</span>);</span><br><span class="line"></span><br><span class="line">    unsetenv(<span class="string">"BYE"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ep = environ; *ep != <span class="literal">NULL</span>; ep++)</span><br><span class="line">        <span class="built_in">puts</span>(*ep);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非局部跳转-setjmp和longjmp"><a href="#非局部跳转-setjmp和longjmp" class="headerlink" title="非局部跳转,setjmp和longjmp"></a>非局部跳转,setjmp和longjmp</h2><p>C语言也包含了goto,但goto存在一个不能从当前函数调到另一函数的限制,以下两个解决了这样的限制   </p>
<p>setjmp的调用为后续由longjmp调用执行的跳转确立了跳转目标,该目标正是程序发起setjmp调用的位置</p>
<p><img src="/2018/12/04/linux-programming/image-28.png" width="350px"></p>
<p>调用setjmp()时,env除了存储当前进程的其他信息外,还保存了程序技术寄存器(指向当前正在执行的机器语言指令)和栈指针寄存器(标记栈顶)的副本,这些信息能够使得后续的longjmp()调用完成两个关键步骤的操作  </p>
<ul>
<li><p>将发起longjmp()调用的函数与之前setjmp()的函数之间的函数栈帧从栈上剥离   </p>
</li>
<li><p>重置程序计数寄存器,使程序得以从初始的setjmp()调用位置继续执行  </p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">doJump(<span class="keyword">int</span> nvar, <span class="keyword">int</span> rvar, <span class="keyword">int</span> vvar)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Inside doJump(): nvar=%d rvar=%d vvar=%d\n"</span>, nvar, rvar, vvar);</span><br><span class="line">    longjmp(env, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> nvar;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> rvar;          <span class="comment">/* Allocated in register if possible */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> vvar;          <span class="comment">/* See text */</span></span><br><span class="line"></span><br><span class="line">    nvar = <span class="number">111</span>;</span><br><span class="line">    rvar = <span class="number">222</span>;</span><br><span class="line">    vvar = <span class="number">333</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setjmp(env) == <span class="number">0</span>) &#123;     <span class="comment">/* Code executed after setjmp() */</span></span><br><span class="line">        nvar = <span class="number">777</span>;</span><br><span class="line">        rvar = <span class="number">888</span>;</span><br><span class="line">        vvar = <span class="number">999</span>;</span><br><span class="line">        doJump(nvar, rvar, vvar);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                    <span class="comment">/* Code executed after longjmp() */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"After longjmp(): nvar=%d rvar=%d vvar=%d\n"</span>, nvar, rvar, vvar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><h3 id="fork-、exit-、wait-、execve"><a href="#fork-、exit-、wait-、execve" class="headerlink" title="fork()、exit()、wait()、execve()"></a>fork()、exit()、wait()、execve()</h3><ul>
<li><p>系统调用fork()允许一父进程创建一个新的子进程,子进程获得父进程的栈,数据段,堆和执行文件段的拷贝  </p>
</li>
<li><p>库函数exit()终止一进程,将进程占用的所有资源(内存,文件描述符等)归还内核,交其进行再次分配,参数status整型变量,表示进程的退出状态,父进程可使用系统调用wait()获取该状态  </p>
</li>
<li><p>系统调用wait(&amp;status)的目的有其二,如果子进程尚未调用exit()终止,那么wait()会挂起父进程直至子进程终止,其二,子进程的终止状态通过wait()的status参数返回  </p>
</li>
<li><p>系统调用execve(pathname, argv ,envp)加载一个新程序(路径名为pathname,参数列表为argv,环境列表为envp)到当前进程的内存,浙江丢弃现存的程序文本段,并未新程序重新创建栈,数据段,以及堆,通常这一动作称为执行一个新程序  </p>
</li>
</ul>
<p>其他一些操作系统将fork()和exec()的功能合二为一形成spawn操作-创建一个新进程并执行指定程序  </p>
<blockquote>
<p>fork,exit,wait以及exece之间的相互协作图  </p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-56.png" width="400px"></p>
<h3 id="创建新进程-fork"><a href="#创建新进程-fork" class="headerlink" title="创建新进程:fork()"></a>创建新进程:fork()</h3><p>创建多进程是任务分解有效办法,例如网络服务器进行listen,为处理每一个请求而创建新的子进程  </p>
<p>以此类手法简化应用程序设计,同时提高系统并发性   </p>
<p><img src="/2018/12/04/linux-programming/image-57.png" width="400px"></p>
<p>系统调用fork()创建一新进程,几乎对调用进程的翻版  </p>
<p>fork()的返回值来区分父,子进程,在父进程中fork()将返回新创建的子进程的进程ID,而fork()在子进程中则返回0,如有必要可调用getpid()以获取自身的进程ID,调用getppid()以获取父进程ID  </p>
<p><img src="/2018/12/04/linux-programming/image-58.png" width="400px">  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> idata = <span class="number">111</span>;             <span class="comment">/* Allocated in data segment */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> istack = <span class="number">222</span>;               <span class="comment">/* Allocated in stack segment */</span></span><br><span class="line">    <span class="keyword">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (childPid = fork()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">"fork"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        idata *= <span class="number">3</span>;</span><br><span class="line">        istack *= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        sleep(<span class="number">3</span>);                   <span class="comment">/* Give child a chance to execute */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Both parent and child come here */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PID=%ld %s idata=%d istack=%d\n"</span>, (<span class="keyword">long</span>) getpid(),</span><br><span class="line">            (childPid == <span class="number">0</span>) ? <span class="string">"(child) "</span> : <span class="string">"(parent)"</span>, idata, istack);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="父、子进程间的文件共享"><a href="#父、子进程间的文件共享" class="headerlink" title="父、子进程间的文件共享"></a>父、子进程间的文件共享</h4><p>执行fork(),子进程会获得父进程所有文件描述符的副本,这些副本的创建方式类似于dup(),意味着父、子进程中对应的描述符均指向相同的打开文件句柄  </p>
<p>打开文件句柄包含当前文件的偏移量(由read()、write()、lseek()修改)以及文件状态标志(由open()设置,通过fcntl()的F_SETFL操作改变)  </p>
<p>一个打开文件的这些属性因之而在父子进程间实现了共享,举例如果子进程更新文件偏移量,那么这种改变会影响到父进程中相应的描述符  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, flags;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">template</span>[] = <span class="string">"/tmp/testXXXXXX"</span>;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);                   <span class="comment">/* Disable buffering of stdout */</span></span><br><span class="line"></span><br><span class="line">    fd = mkstemp(<span class="keyword">template</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"mkstemp"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"File offset before fork(): %lld\n"</span>,</span><br><span class="line">            (<span class="keyword">long</span> <span class="keyword">long</span>) lseek(fd, <span class="number">0</span>, SEEK_CUR));</span><br><span class="line"></span><br><span class="line">    flags = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"fcntl - F_GETFL"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"O_APPEND flag before fork() is: %s\n"</span>,</span><br><span class="line">            (flags &amp; O_APPEND) ? <span class="string">"on"</span> : <span class="string">"off"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">"fork"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:     <span class="comment">/* Child: change file offset and status flags */</span></span><br><span class="line">        <span class="keyword">if</span> (lseek(fd, <span class="number">1000</span>, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"lseek"</span>);</span><br><span class="line"></span><br><span class="line">        flags = fcntl(fd, F_GETFL);         <span class="comment">/* Fetch current flags */</span></span><br><span class="line">        <span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"fcntl - F_GETFL"</span>);</span><br><span class="line">        flags |= O_APPEND;                  <span class="comment">/* Turn O_APPEND on */</span></span><br><span class="line">        <span class="keyword">if</span> (fcntl(fd, F_SETFL, flags) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"fcntl - F_SETFL"</span>);</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:    <span class="comment">/* Parent: can see file changes made by child */</span></span><br><span class="line">        <span class="keyword">if</span> (wait(<span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"wait"</span>);                <span class="comment">/* Wait for child exit */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Child has exited\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"File offset in parent: %lld\n"</span>,</span><br><span class="line">                (<span class="keyword">long</span> <span class="keyword">long</span>) lseek(fd, <span class="number">0</span>, SEEK_CUR));</span><br><span class="line"></span><br><span class="line">        flags = fcntl(fd, F_GETFL);</span><br><span class="line">        <span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"fcntl - F_GETFL"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"O_APPEND flag in parent is: %s\n"</span>,</span><br><span class="line">                (flags &amp; O_APPEND) ? <span class="string">"on"</span> : <span class="string">"off"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设父子进程同时写入一文件,共享文件偏移量会确保二者不会覆盖彼此的输出内容,不过并不能阻止父子进程的输出随意混杂在一起,要想规避这一点就得进程间同步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">比如父进程可以使用系统调用wait来暂停运行并等待子进程退出,shell就是如此</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">要么设计应用程序,应于fork()调用注意两点</span><br><span class="line">- 其一,令父子进程使用不同的文件描述符  </span><br><span class="line"></span><br><span class="line">- 其二,各自立即关闭不再使用的描述符(那些经常由其他进程使用的描述符)</span><br></pre></td></tr></table></figure>
<h4 id="fork内存语义"><a href="#fork内存语义" class="headerlink" title="fork内存语义"></a>fork内存语义</h4><p>从概念上将,fork将对父进程程序段,数据段,堆段，以及栈段创建拷贝  </p>
<p>将父进程内存拷贝至交换空间,以此创建新进场映像,而父进程保持自身内存的同时,将换出映像置为子进程  </p>
<ul>
<li>内核将每一进程的代码段标记只读,从而进程无法修改自身代码,从而父子进程可共享同一代码段,调用fork()在为子进程创建代码时,所构建的一系列进程级页表项珺指向与父进程相同的物理内存也  </li>
</ul>
<ul>
<li><p>对于父进程数据段、栈段、栈段中的各种页,内核采用写时赋值</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最初内核令这些段的页表项指向了父进程相同的物理内存页,并将这些页面自身标记为只读  </span><br><span class="line">调用fork之后,内核捕获所有父进程或子进程针对这些页面修改时创建拷贝</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2018/12/04/linux-programming/image-59.png" width="350px"></p>
<p><img src="/2018/12/04/linux-programming/image-60.png" width="350px"></p>
<blockquote>
<p>控制进程的内存需求  </p>
</blockquote>
<p>通过fork与wait组合使用,可以控制一个进程的内存需求,进程的内存需求量(进程所使用的虚拟内存页范围)受到多种因素影响,例如调用函数,或从函数返回栈的变化,对malloc和free而对堆所做的修改  </p>
<p>调用函数而不改变内存需求量 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#define _BSD_SOURCE     /* To get sbrk() declaration from &lt;unistd.h&gt; in case</span><br><span class="line">                           _XOPEN_SOURCE &gt;= 600; defining _SVID_SOURCE or</span><br><span class="line">                           _GNU_SOURCE also suffices */</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &quot;tlpi_hdr.h&quot;</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">func(int arg)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line"></span><br><span class="line">    for (j = 0; j &lt; 0x100; j++)</span><br><span class="line">        if (malloc(0x8000) == NULL)</span><br><span class="line">            errExit(&quot;malloc&quot;);</span><br><span class="line">    printf(&quot;Program break in child:  %10p\n&quot;, sbrk(0));</span><br><span class="line"></span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int arg = (argc &gt; 1) ? getInt(argv[1], 0, &quot;arg&quot;) : 0;</span><br><span class="line">    pid_t childPid;</span><br><span class="line">    int status;</span><br><span class="line"></span><br><span class="line">    setbuf(stdout, NULL);           /* Disable buffering of stdout */</span><br><span class="line"></span><br><span class="line">    printf(&quot;Program break in parent: %10p\n&quot;, sbrk(0));</span><br><span class="line"></span><br><span class="line">    childPid = fork();</span><br><span class="line">    if (childPid == -1)</span><br><span class="line">        errExit(&quot;fork&quot;);</span><br><span class="line"></span><br><span class="line">    if (childPid == 0)              /* Child calls func() and */</span><br><span class="line">        exit(func(arg));            /* uses return value as exit status */</span><br><span class="line"></span><br><span class="line">    /* Parent waits for child to terminate. It can determine the</span><br><span class="line">       result of func() by inspecting &apos;status&apos; */</span><br><span class="line"></span><br><span class="line">    if (wait(&amp;status) == -1)</span><br><span class="line">        errExit(&quot;wait&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Program break in parent: %10p\n&quot;, sbrk(0));</span><br><span class="line"></span><br><span class="line">    printf(&quot;Status = %d %d\n&quot;, status, WEXITSTATUS(status));</span><br><span class="line"></span><br><span class="line">    exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="系统调用vfork"><a href="#系统调用vfork" class="headerlink" title="系统调用vfork()"></a>系统调用vfork()</h3><p>早期BSD实现,fork()会对父进程的数据段、栈和堆实施严格的复制  </p>
<p>如前所述这是一种浪费,尤其是在调用fork()后立即执行exec()的情况下,出于这一原因BSD后期加入了vfork()的调用,效率远高于fork()的实现,现在Unix采用写时复制技术实现fork(),效率也高出许多早期的fork()实现,进而将对vfork()的需求剔除殆尽  </p>
<p><img src="/2018/12/04/linux-programming/image-61.png" width="300px"></p>
<p>vfork如下两个特效而具有效率,这也是与fork()区别所在  </p>
<ul>
<li><p>无需为子进程复制虚拟内存页或页表,相反,子进程共享父进程内存,直至成功执行了exec()或调用了_exit()退出  </p>
</li>
<li><p>在子进程调用exec()或_exit()之前,将暂停执行父进程  </p>
</li>
</ul>
<p>这缺点就是严重影响到了父进程,在不影响父进程的前提,子进程能在vfork与exec之间所做的操作屈指可数,其中包括对打开文件描述符进行操作,因为vfork调用期间会复制该表,所以子进程操作不影响父进程  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> istack = <span class="number">222</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (vfork()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">"vfork"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:             <span class="comment">/* Child executes first, in parent's memory space */</span></span><br><span class="line">        sleep(<span class="number">3</span>);                   <span class="comment">/* Even if we sleep for a while,</span></span><br><span class="line"><span class="comment">                                       parent still is not scheduled */</span></span><br><span class="line">        write(STDOUT_FILENO, <span class="string">"Child executing\n"</span>, <span class="number">16</span>);</span><br><span class="line">        istack *= <span class="number">3</span>;                <span class="comment">/* This change will be seen by parent */</span></span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:            <span class="comment">/* Parent is blocked until child exits */</span></span><br><span class="line">        write(STDOUT_FILENO, <span class="string">"Parent executing\n"</span>, <span class="number">17</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"istack=%d\n"</span>, istack);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fork-之后的竞争条件-Race-Condition"><a href="#fork-之后的竞争条件-Race-Condition" class="headerlink" title="fork()之后的竞争条件(Race Condition)"></a>fork()之后的竞争条件(Race Condition)</h3><p>调用fork()后,无法确定父、子进程间谁将率先访问CPU(多处理系统,他们可能同时各自方为一个cpu)  </p>
<p>为了产生正确的结果而依赖于特定的执行序列,那么将发生竞争条件而导致失败  </p>
<blockquote>
<p>父子进程竞争输出信息  </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> numChildren, j;</span><br><span class="line">    <span class="keyword">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span>)</span><br><span class="line">        usageErr(<span class="string">"%s [num-children]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    numChildren = (argc &gt; <span class="number">1</span>) ? getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">"num-children"</span>) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);               <span class="comment">/* Make stdout unbuffered */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numChildren; j++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (childPid = fork()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            errExit(<span class="string">"fork"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d child\n"</span>, j);</span><br><span class="line">            _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d parent\n"</span>, j);</span><br><span class="line">            wait(<span class="literal">NULL</span>);                 <span class="comment">/* Wait for child to terminate */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="同步信号以规避竞争条件"><a href="#同步信号以规避竞争条件" class="headerlink" title="同步信号以规避竞争条件"></a>同步信号以规避竞争条件</h4><p>父子进程多次互发信号以协调彼此行为,尽管实际上更有可能采用信号量、文件所获消息传递等技术进行此类协调  </p>
<blockquote>
<p>利用信号同步进程间动作 </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"curr_time.h"</span>                  <span class="comment">/* Declaration of currTime() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYNC_SIG SIGUSR1                <span class="comment">/* Synchronization signal */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>             <span class="comment">/* Signal handler - does nothing but return */</span></span><br><span class="line">handler(<span class="keyword">int</span> sig)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> childPid;</span><br><span class="line">    <span class="keyword">sigset_t</span> blockMask, origMask, emptyMask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);               <span class="comment">/* Disable buffering of stdout */</span></span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;blockMask);</span><br><span class="line">    sigaddset(&amp;blockMask, SYNC_SIG);    <span class="comment">/* Block signal */</span></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;blockMask, &amp;origMask) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"sigprocmask"</span>);</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_RESTART;</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SYNC_SIG, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"sigaction"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (childPid = fork()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">"fork"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* Child */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child does some required action here... */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%s %ld] Child started - doing some work\n"</span>,</span><br><span class="line">                currTime(<span class="string">"%T"</span>), (<span class="keyword">long</span>) getpid());</span><br><span class="line">        sleep(<span class="number">2</span>);               <span class="comment">/* Simulate time spent doing some work */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* And then signals parent that it's done */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%s %ld] Child about to signal parent\n"</span>,</span><br><span class="line">                currTime(<span class="string">"%T"</span>), (<span class="keyword">long</span>) getpid());</span><br><span class="line">        <span class="keyword">if</span> (kill(getppid(), SYNC_SIG) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"kill"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Now child can do other things... */</span></span><br><span class="line"></span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* Parent */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent may do some work here, and then waits for child to</span></span><br><span class="line"><span class="comment">           complete the required action */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%s %ld] Parent about to wait for signal\n"</span>,</span><br><span class="line">                currTime(<span class="string">"%T"</span>), (<span class="keyword">long</span>) getpid());</span><br><span class="line">        sigemptyset(&amp;emptyMask);</span><br><span class="line">        <span class="keyword">if</span> (sigsuspend(&amp;emptyMask) == <span class="number">-1</span> &amp;&amp; errno != EINTR)</span><br><span class="line">            errExit(<span class="string">"sigsuspend"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%s %ld] Parent got signal\n"</span>, currTime(<span class="string">"%T"</span>), (<span class="keyword">long</span>) getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If required, return signal mask to its original state */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;origMask, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"sigprocmask"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent carries on to do other things... */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><h3 id="进程的终止-exit-和exit"><a href="#进程的终止-exit-和exit" class="headerlink" title="进程的终止:_exit()和exit()"></a>进程的终止:<code>_exit()</code>和<code>exit()</code></h3><p>进程的三种终止方式,一位异常终止,而使用_exit系统调用正常终止,还有main函数return回来    </p>
<p><img src="/2018/12/04/linux-programming/image-62.png" width="350px"></p>
<p><code>status</code>参数定义了进程的终止状态,父进程可调用wait以获取该状态,0表示正常退出,非0为异常  </p>
<p>exit()会执行的动作如下   </p>
<ul>
<li><p>调用退出处理程序(通过atexit()和on_exit()注册的函数),其执行顺序和注册顺序相反  </p>
</li>
<li><p>刷新stdio流缓冲区  </p>
</li>
<li><p>使用由status提供的值执行_exit()系统调用  </p>
</li>
</ul>
<p><img src="/2018/12/04/linux-programming/image-63.png" width="400px">  </p>
<h3 id="进程终止的细节"><a href="#进程终止的细节" class="headerlink" title="进程终止的细节"></a>进程终止的细节</h3><p>无论进程是否正常终止,都会执行以下动作  </p>
<ul>
<li><p>关闭所有打开文件描述符,目录流,信息目录描述符,以及(字符集)转换描述符  </p>
</li>
<li><p>作为文件描述符关闭的后果之一,将释放该进程所持有的任何文件锁   </p>
</li>
<li><p>分离任何已连接的System V共享内存段,且对应于各段的shm_nattch计数器值将减一  </p>
</li>
<li><p>进程为每个System V信号量所设置的semadj值将会被加到信号量值中  </p>
</li>
<li><p>如果进程是个管理终端的管理进程,系统会向该终端前台进程组中的每个进程发送SIGHUP信号,接着终端会与会话脱离  </p>
</li>
<li><p>将关闭该进程打开的任何POSIX的消息队列,类似调用mq_close()  </p>
</li>
<li><p>作为进程退出的后果之一,如果某进程组成孤儿,该组存在任何已停止的进程,则组中所有进场收到SIGHUP信号,随之为SIGCONT信号  </p>
</li>
<li><p>移除该进程通过mlock或mlockall锁建立的任何内存锁  </p>
</li>
<li><p>取消该进程调用mmap()锁创建的任何内存映射  </p>
</li>
</ul>
<h3 id="退出处理程序"><a href="#退出处理程序" class="headerlink" title="退出处理程序"></a>退出处理程序</h3><p>有时应用程序需要在进程终止时,执行一些操作,退出处理程序可于进程生命周期的任意时刻点注册,并在该进程调用exit()正常终止时自动执行，但如果程序直接调用_exit()或因信号而异常终止,则不会调用退出处理程序  </p>
<p><img src="/2018/12/04/linux-programming/image-64.png" width="400px"></p>
<p>C语言函数库提供两种方式注册退出处理程序  </p>
<p><img src="/2018/12/04/linux-programming/image-65.png" width="300px">  </p>
<p>函数atexit()将func加到一个函数列表,进程终止时会调用该函数列表的所有函数,应将函数定义不接受任何参数也无返回值  </p>
<p>这些函数的执行顺序与注册顺序相反,如果调用了_exit()或进程因收到信号而终止的就不会再调用剩余的处理程序  </p>
<p><img src="/2018/12/04/linux-programming/image-66.png" width="300px">  </p>
<p>一个进程至少32个退出处理程序  </p>
<p>系统调用sysconf(_SC_ATEXIT_MAX)应用程序即可确定由实现所定义的可注册退出处理程序的数量上限   </p>
<p>on_exit突破了atexit的两种限制  </p>
<ul>
<li><p>退出处理程序执行时无法获知传递给exit()的状态  </p>
</li>
<li><p>无法给退出程序指定参数</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BSD_SOURCE     <span class="comment">/* Get on_exit() declaration from &lt;stdlib.h&gt; */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">atexitFunc1(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"atexit function 1 called\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">atexitFunc2(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"atexit function 2 called\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">onexitFunc(<span class="keyword">int</span> exitStatus, <span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"on_exit function called: status=%d, arg=%ld\n"</span>,</span><br><span class="line">                exitStatus, (<span class="keyword">long</span>) arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (on_exit(onexitFunc, (<span class="keyword">void</span> *) <span class="number">10</span>) != <span class="number">0</span>)</span><br><span class="line">        fatal(<span class="string">"on_exit 1"</span>);</span><br><span class="line">    <span class="keyword">if</span> (atexit(atexitFunc1) != <span class="number">0</span>)</span><br><span class="line">        fatal(<span class="string">"atexit 1"</span>);</span><br><span class="line">    <span class="keyword">if</span> (atexit(atexitFunc2) != <span class="number">0</span>)</span><br><span class="line">        fatal(<span class="string">"atexit 2"</span>);</span><br><span class="line">    <span class="keyword">if</span> (on_exit(onexitFunc, (<span class="keyword">void</span> *) <span class="number">20</span>) != <span class="number">0</span>)</span><br><span class="line">        fatal(<span class="string">"on_exit 2"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h2><blockquote>
<p>IPC工具分类  </p>
</blockquote>
<ul>
<li>通信:关注进程的数据交换   </li>
<li>同步:关注进程和线程操作之间的同步  </li>
<li>信号:沟通  </li>
</ul>
<p><img src="/2018/12/04/linux-programming/image-89.png" width="500px"></p>
<h3 id="通信工具"><a href="#通信工具" class="headerlink" title="通信工具"></a>通信工具</h3><ul>
<li>数据传输工具,区分工具关键因素是写入和读取的概念,为了进行通信,一个进程将数据写入IPC工具,另一个读取数据,这些工具要求用户内存和内核内存之间进行两次数据传输,一次是写入用户内存到内核内存,另一次是读取内核内存到用户内存  </li>
</ul>
<p><img src="/2018/12/04/linux-programming/image-90.png" width="200px"></p>
<ul>
<li>共享内存,允许进程通过将数据放到由进程间共享的一块内存中以完成信息的交换(内核通过将每个进程中的页表条目指向同一个RAM分页来实现这一功)</li>
</ul>
<p><img src="/2018/12/04/linux-programming/image-91.png" width="400px"></p>
<h3 id="同步工具"><a href="#同步工具" class="headerlink" title="同步工具"></a>同步工具</h3><ul>
<li><p>信号量:一个信号量是由一个内核维护的整数,其值永远不会小于0  </p>
</li>
<li><p>文件锁,文件锁分:读(共享)锁和写(互斥)锁  </p>
</li>
</ul>
<ul>
<li>互斥体和条件变量,这些工具通常用于POSIX线程  </li>
</ul>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><h2 id="堆上分配内存"><a href="#堆上分配内存" class="headerlink" title="堆上分配内存"></a>堆上分配内存</h2><p>堆是一段长度可变的连续虚拟内存,始于进程的未初始化数据段末尾,随着内存的分配和释放而增减,堆的当前内存边界是”program break”;  </p>
<p>C语言分配内存惯用malloc函数, 但首先从malloc函数族所基于的brk()和sbrk()开始谈起  </p>
<h3 id="调整program-break-brk-和sbrk"><a href="#调整program-break-brk-和sbrk" class="headerlink" title="调整program break:brk()和sbrk()"></a>调整program break:brk()和sbrk()</h3><p>改变堆的大小(即分配或释放内存),就想命令内核改变进程的<code>program break</code>位置一样简单  </p>
<p><img src="/2018/12/04/linux-programming/image-23.png" width="400px">  </p>
<p>最开始<code>program break</code>正好位于未初始化数据段末尾之后,向上递增      </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在program break位置抬升,程序可访问新分配的内存区域任何内存地址  </span><br><span class="line">而物理内存也尚未分配,内核会首次试图访问这些虚拟内存地址时自动分配新的物理内存页</span><br></pre></td></tr></table></figure>
<p>UNIX系统提供了操作program break的系统调用:brk()和sbrk(),在Linux依然是这样  </p>
<p><img src="/2018/12/04/linux-programming/image-29.png" width="350px">  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brk()会将program break设置为参数end_data_segment所指定的位置</span><br><span class="line"></span><br><span class="line">由于虚拟内存以页为单位,所以end_data_segment实际会四舍五入到下一个内存页的边界处</span><br></pre></td></tr></table></figure>
<p>end_data_segment设定精确上限取决以下因素  </p>
<ul>
<li>进程中对数据段大小资源限制(RLIMIT_DATA)  </li>
<li>内存映射  </li>
<li>共享内存段  </li>
<li>共享库   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sbrk()将program break在原有地址上增加从参数increment传入的大小,返回前一个program break地址  </span><br><span class="line"></span><br><span class="line">也就是说program break增加,返回值是指向这块新分配内存起始位置的指针</span><br></pre></td></tr></table></figure>
<h3 id="堆上分配内存-malloc-和free"><a href="#堆上分配内存-malloc-和free" class="headerlink" title="堆上分配内存:malloc()和free()"></a>堆上分配内存:malloc()和free()</h3><p>一般C语言都使用malloc在堆上分配和free释放内存  </p>
<p><img src="/2018/12/04/linux-programming/image-30.png" width="350px"></p>
<p>malloc返回的内存块所采用的字节对齐方式,意味着malloc是基于8字节或16字节便捷来分配内存的   </p>
<p>malloc在堆上分配参数size字节大小的内存,并返回指定新分配内存起始位置处的指针,其所分配的内存未经初始化<br>free 函数释放ptr参数所指向的内存块,该参数由malloc生成  </p>
<p><img src="/2018/12/04/linux-programming/image-31.png" width="350px"></p>
<p>一般情况下,free并不降低program break的位置,而是将这块内存添加到空闲内存列表中,供后续的malloc函数循环使用<br>操作原因如下:</p>
<ul>
<li><p>被释放的内存块通常会位于堆的中间,而非堆的顶部,因而降低program break是不太可能  </p>
</li>
<li><p>最大限度的减少程序员必须执行sbrk调用  </p>
</li>
<li><p>大多数情况,降低program break的位置不会对那些分配大量内存的程序有多少帮助,因为它们通常倾向于持有已分配的内存或反复释放和重新分配,而非释放所有内存后再持续运行一段时间   </p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ALLOCS 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr[MAX_ALLOCS];</span><br><span class="line">    <span class="keyword">int</span> freeStep, freeMin, freeMax, blockSize, numAllocs, j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span>)</span><br><span class="line">        usageErr(<span class="string">"%s num-allocs block-size [step [min [max]]]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    numAllocs = getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">"num-allocs"</span>);</span><br><span class="line">    <span class="keyword">if</span> (numAllocs &gt; MAX_ALLOCS)</span><br><span class="line">        cmdLineErr(<span class="string">"num-allocs &gt; %d\n"</span>, MAX_ALLOCS);</span><br><span class="line"></span><br><span class="line">    blockSize = getInt(argv[<span class="number">2</span>], GN_GT_0 | GN_ANY_BASE, <span class="string">"block-size"</span>);</span><br><span class="line"></span><br><span class="line">    freeStep = (argc &gt; <span class="number">3</span>) ? getInt(argv[<span class="number">3</span>], GN_GT_0, <span class="string">"step"</span>) : <span class="number">1</span>;</span><br><span class="line">    freeMin =  (argc &gt; <span class="number">4</span>) ? getInt(argv[<span class="number">4</span>], GN_GT_0, <span class="string">"min"</span>) : <span class="number">1</span>;</span><br><span class="line">    freeMax =  (argc &gt; <span class="number">5</span>) ? getInt(argv[<span class="number">5</span>], GN_GT_0, <span class="string">"max"</span>) : numAllocs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (freeMax &gt; numAllocs)</span><br><span class="line">        cmdLineErr(<span class="string">"free-max &gt; num-allocs\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Initial program break:          %10p\n"</span>, sbrk(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Allocating %d*%d bytes\n"</span>, numAllocs, blockSize);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numAllocs; j++) &#123;</span><br><span class="line">        ptr[j] = <span class="built_in">malloc</span>(blockSize);</span><br><span class="line">        <span class="keyword">if</span> (ptr[j] == <span class="literal">NULL</span>)</span><br><span class="line">            errExit(<span class="string">"malloc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Program break is now:           %10p\n"</span>, sbrk(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Freeing blocks from %d to %d in steps of %d\n"</span>,</span><br><span class="line">                freeMin, freeMax, freeStep);</span><br><span class="line">    <span class="keyword">for</span> (j = freeMin - <span class="number">1</span>; j &lt; freeMax; j += freeStep)</span><br><span class="line">        <span class="built_in">free</span>(ptr[j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After free(), program break is: %10p\n"</span>, sbrk(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="malloc-和free-的实现"><a href="#malloc-和free-的实现" class="headerlink" title="malloc()和free()的实现"></a>malloc()和free()的实现</h3><blockquote>
<p>malloc的实现   </p>
</blockquote>
<p>首先扫描之前由free()所释放的空隙内存块列表,以求找到尺寸大于或等于要求的一块空闲内存,如果这块尺寸正好与要求相当,就返回给调用者   </p>
<p>如果在空闲内存列表中根本找不到足够大的空闲内存块,那maoolc()会调用sbrk()以分配更多的内存,为减少对sbrk()的调用,malloc()并未只是严格按照所需字节数分配内存,而是以更大幅度(虚拟内存页大小的倍数)来增加program break,并将超出部分置于空闲内存列表 </p>
<blockquote>
<p>free的实现   </p>
</blockquote>
<p>free()将内存块直接置于空闲内存列表(双向链表)之上,那如何知道内存块大小?当malloc分配内存块的时候,会额外分配几个字节来存放记录这块内存大小的整数值  </p>
<p><img src="/2018/12/04/linux-programming/image-32.png" width="300px"></p>
<p>内存块置于空闲内存列表(双向链表)时,free()会使用内存块本身空间来存放链表指针,将自身添加到列表中  </p>
<p><img src="/2018/12/04/linux-programming/image-33.png" width="350px"></p>
<p>随着分配和释放的步骤越来越多,将会形成这样的双向链表  </p>
<p><img src="/2018/12/04/linux-programming/image-34.png" width="350px"></p>
<h3 id="malloc调试的工具和库"><a href="#malloc调试的工具和库" class="headerlink" title="malloc调试的工具和库"></a>malloc调试的工具和库</h3><ul>
<li><p>mtrace和muntrace函数,分别在程序中打开和关闭对内存分配调用进行跟踪的功能   </p>
</li>
<li><p>mcheck和mprobe函数允许程序对一分配内存块进行一致性检查,如果程序对已分配内存之外进行写操作将捕获这个错误  </p>
</li>
</ul>
<h3 id="堆上分配内存的其他方法"><a href="#堆上分配内存的其他方法" class="headerlink" title="堆上分配内存的其他方法"></a>堆上分配内存的其他方法</h3><p>calloc和realloc分配内存  </p>
<blockquote>
<p>calloc用于给一组相同对象分配内存  </p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-35.png" width="350px">  </p>
<p>参数mumitems指定分配对象的数量,size每个对象的代销  </p>
<blockquote>
<p>realloc调整(大多数是加,没有削减)一块内存的大小,而此块内存是之前malloc分配的  </p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-36.png" width="350px"></p>
<p>ptr是指针,参数size调整大小的期望值  </p>
<h2 id="栈上分配内存"><a href="#栈上分配内存" class="headerlink" title="栈上分配内存"></a>栈上分配内存</h2><h3 id="alloca调整栈大小"><a href="#alloca调整栈大小" class="headerlink" title="alloca调整栈大小"></a>alloca调整栈大小</h3><p>alloca()可动态分配内存,通过增加栈帧的大小从栈上分配,该变量离开其作用域之后被自动释放,无需手动调用释放函数。</p>
<p><img src="/2018/12/04/linux-programming/image-37.png" width="350px"></p>
<p>参数size指定栈上分配的字节数,alloc将指向已分配的内存块指针作为返回值  </p>
<p>用alloca()来分配内存相对于malloc的优势如下  </p>
<ul>
<li>分配内存的速度快于malloc,因为编译器将alloc作为内联代码处理,并通过直接调整栈指针来实现,也不需要维护空闲内存快列表  </li>
</ul>
<ul>
<li>alloc分配的内存随着栈帧的移除而自动释放,因为函数返回时锁指向的代码会重置栈指针寄存器,使其指向前一帧末尾  </li>
</ul>
<h1 id="系统和进程信息"><a href="#系统和进程信息" class="headerlink" title="系统和进程信息"></a>系统和进程信息</h1><p>系统和进程信息的访问方法,重点论<code>/proc</code>文件系统  </p>
<h2 id="proc文件系统-1"><a href="#proc文件系统-1" class="headerlink" title="/proc文件系统"></a>/proc文件系统</h2><p>较老的UNIX实现中,并无简单方法来获取(或修改)内核属性并没法知道以下  </p>
<ul>
<li>系统多少进程运行,属主哪个  </li>
<li>一个进程打开了什么文件  </li>
<li>目前锁定了什么文件,那些进程持有这些锁  </li>
<li>系统正使用什么套接字  </li>
</ul>
<p>老版UNIX为解决这问题,允许特权级程序深入内核内存中的数据结构,然后带来很多问题,特别是内核数据结构需要专业知识  </p>
<p>现代的UNIX实现提供了一个/proc的虚拟文件系统,该文件系统驻留在/proc目录,包含了各种用于展示内核信息的文件,并允许进程通过常规文件I/O调用来方便取,有时还可以修改这些信息  </p>
<p>之所以称之虚拟,因为文件和子目录并未存储在磁盘上,而是由内核在进程访问此类信息时动态创建而成  </p>
<h3 id="获取进程相关信息-proc-PID"><a href="#获取进程相关信息-proc-PID" class="headerlink" title="获取进程相关信息:/proc/PID"></a>获取进程相关信息:/proc/PID</h3><p>对于系统中每个进程,内核提供了相应的目录,命名为/proc/PID  </p>
<p>每个/proc/PID目录中都存在一个命名为status的文件,提供了以下信息 </p>
<p><img src="/2018/12/04/linux-programming/image-38.png" width="300px"></p>
<p>以下列举了/proc/PID的子目录  </p>
<p><img src="/2018/12/04/linux-programming/image-39.png" width="350px">  </p>
<blockquote>
<p>/proc/PID/fd目录  </p>
</blockquote>
<p>进程打开的每个文件描述符都包含了一个符号链接,每个符号链接的名称与描述符的数值相匹配  </p>
<p>例如: /proc/1968/1 是ID为1968的进程中向标准输出的符号链接  </p>
<blockquote>
<p>/proc/PID/task目录  </p>
</blockquote>
<p>针对进程的每个线程,提供了<code>proc/PID/task/TID</code>命名的子目录  </p>
<p>status文件中内容都有可能不同的字段:State,Pid,SigPnd,SigBlk,CapInh,CapPrm,CapEff和CapBnd就在此列  </p>
<p><img src="/2018/12/04/linux-programming/image-40.png" width="400px">  </p>
<h3 id="访问-proc文件"><a href="#访问-proc文件" class="headerlink" title="访问/proc文件"></a>访问/proc文件</h3><p>通常都是shell,也可以从程序使用常规的IO系统调用来访问/proc目录下的文件,但在访问文件时,会有一些限制  </p>
<ul>
<li><p>/proc目录下的一些文件是只读的,即仅用于显示内核信息,无法修改  </p>
</li>
<li><p>/proc目录下的一些文件仅能由文件拥有者读取,例如/proc/PID目录下所有的文件都属于拥有相应进程的用户  </p>
</li>
<li><p>除了/proc/PID子目录的文件,/proc目录的其他文件大多数属于root用户,并且也仅有root用户能够修改那些可修改文件  </p>
</li>
</ul>
<p>/proc/PID目录中的文件内容变化不定,每个目录随进程ID创建而生,又随进程终止而灭  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> line[MAX_LINE];</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">"/proc/sys/kernel/pid_max"</span>, (argc &gt; <span class="number">1</span>) ? O_RDWR : O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line">    n = read(fd, line, MAX_LINE);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"read"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Old value: "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.*s"</span>, (<span class="keyword">int</span>) n, line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lseek(fd, <span class="number">0</span>, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"lseek"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(fd, argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>])) != <span class="built_in">strlen</span>(argv[<span class="number">1</span>]))</span><br><span class="line">            fatal(<span class="string">"write() failed"</span>);</span><br><span class="line"></span><br><span class="line">        system(<span class="string">"echo /proc/sys/kernel/pid_max now contains "</span></span><br><span class="line">               <span class="string">"`cat /proc/sys/kernel/pid_max`"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程-1"><a href="#线程-1" class="headerlink" title="线程"></a>线程</h1><p>POSIX线程,即Pthreads线程  </p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>与进程(process)类似,线程(thread)是允许应用程序兵法执行多个任务的一种机制,一个进程包含多个线程,同一程序中所有线程均独立执行相同的程序,且共享同一份全局内存区域,包括初始化数据段,为初始化数据段,以及堆内存段  </p>
<p>同一进程中的多个线程可以并发执行,在多处理器环境下,多个线程可以同时并发  </p>
<p><img src="/2018/12/04/linux-programming/image-67.png" width="400px">  </p>
<blockquote>
<p>多进程与多线程对比  </p>
</blockquote>
<ul>
<li><p>进程间的信息难以共享,由于除去只读代码段,父子进程并未共享内存,因此采用一些进程通信(IPC)的方式,处理交换信息  </p>
</li>
<li><p>调用fork()来创建进程的代价相对较高,即便利用了写时复制技术,仍然需要赋值诸如内存页表和文件描述符表之类的多种进程属性  </p>
</li>
</ul>
<p>线程的优势如下  </p>
<ul>
<li><p>线程之间方便快速共享信息,只需将数据复制到共享(全局或堆)变量中即可  </p>
</li>
<li><p>创建线程比创建进程快10倍甚至更多,线程的创建之所以快，因为不需要fork赋值诸多熟悉,本身共享的,</p>
</li>
</ul>
<p>除了全局内存之外,线程还共享一些其他属性  </p>
<p><img src="/2018/12/04/linux-programming/image-68.png" width="350px"></p>
<h2 id="Pthreads-API的详细背景"><a href="#Pthreads-API的详细背景" class="headerlink" title="Pthreads API的详细背景"></a>Pthreads API的详细背景</h2><blockquote>
<p>线程数据结构  </p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-69.png" width="450px"></p>
<blockquote>
<p>Pthreads函数返回值  </p>
</blockquote>
<p>从系统调用和库函数中一般做法是返回状态,0表示成功,-1返回表示失败,并设置errno一标识错误原因  </p>
<p>而Pthreads函数均已0表示成功,返回一正值表示失败,这一失败的返回值和errno中值含义相同  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> *thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">s = pthread_create(&amp;thread, <span class="literal">NULL</span>, func, &amp;arg);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span> )&#123;</span><br><span class="line">    errExitEN(s, <span class="string">"pthread_create"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>pthread_create</p>
<p><img src="/2018/12/04/linux-programming/image-70.png" width="400px"></p>
<ul>
<li>参数thread指向pthread_t类型的缓冲区,在pthread_crreate()返回前,会保存一个该线程的唯一标识,后续的pthreads函数将使用该标识来引用此线程  </li>
</ul>
<ul>
<li><p>参数attr指向pthread_attr_t对象的指针,该对象指定了新线程各种属性,如果NULL则各种默认属性  </p>
</li>
<li><p>调用pthread_create()后,应用程序无法从确定系统接着会调度哪个线程来使用CPU资源  </p>
</li>
</ul>
<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>如下方式终止线程运行  </p>
<ul>
<li><p>线程start函数指向return语句并返回指定值  </p>
</li>
<li><p>线程调用pthread_exit()  </p>
</li>
<li><p>调用pthread_cancel()取消线程  </p>
</li>
<li><p>任意线程调用了exit(),或主线程执行了return语句,都会导致进程中的所有线程立即停止  </p>
</li>
</ul>
<p><img src="/2018/12/04/linux-programming/image-71.png" width="400px"></p>
<p>pthread_exit()相当于线程的start函数中执行return,不同之处在于,可在显示start函数锁调用的任意函数中调用pthread_exit()  </p>
<p>如果主线程调用了pthread_exit(),而非调用了exit()或执行了return语句,那么其他线程将继续运行  </p>
<h3 id="线程ID-Thread-ID"><a href="#线程ID-Thread-ID" class="headerlink" title="线程ID(Thread ID)"></a>线程ID(Thread ID)</h3><p>进程内部的每个线程都有一个唯一标识,称为线程ID, 线程ID会返回给pthread_create()的调用者,一个线程可以通过pthread_self()来获取自己的线程ID  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>线程ID在应用程序中非常有用   </p>
<ul>
<li><p>不同的Pthreads函数利用线程ID来标识要操作的目标线程,这些函数包括pthread_join(),pthread_detach(),pthread_cancel()和pthread_kill()等  </p>
</li>
<li><p>在一些应用程序中,以特定的线程ID作为动态数据结构的标签,既可以用来识别某个数据结构的创建者或属主线程,又可以确定随后对该数据结构执行操作的具体线程  </p>
</li>
</ul>
<p><img src="/2018/12/04/linux-programming/image-72.png" width="400px">  </p>
<p>pthread_t实现了一个结构类型,线程ID在所有进程中是唯一的  </p>
<p><img src="/2018/12/04/linux-programming/image-73.png" width="400px"></p>
<h3 id="连接-joining-已终止的线程"><a href="#连接-joining-已终止的线程" class="headerlink" title="连接(joining)已终止的线程"></a>连接(joining)已终止的线程</h3><p>函数pthread_join()等待由thread标识的线程终止(如果线程已经终止,pthread_join()会立即返回),这类操作叫连接  </p>
<p><img src="/2018/12/04/linux-programming/image-74.png" width="400px">  </p>
<p>如果retval为非空指针,将会保存线程终止时返回值的拷贝,该返回值也是线程调用return或pthread_exit()所指定的值 </p>
<p>若线程未分离(detached),则必须使用pthread_join()来进行连接,如果未能连接,那么线程终止时产生僵尸线程,僵尸线程如果过多浪费系统资源,而且无法创建新的线程  </p>
<p>pthread_join()类似进程的waitpid()不过差别如下 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程之间的关系是对等的,任意线程均可以调用pthread_join()与该进程的任何线程连接起来</span><br><span class="line">而进程只能等待fork()创建出来的子进程</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">threadFunc(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *s = (<span class="keyword">char</span> *) arg;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) <span class="built_in">strlen</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t1;</span><br><span class="line">    <span class="keyword">void</span> *res;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="string">"Hello world\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_create"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message from main()\n"</span>);</span><br><span class="line">    s = pthread_join(t1, &amp;res);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_join"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread returned %ld\n"</span>, (<span class="keyword">long</span>) res);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程的分离"><a href="#线程的分离" class="headerlink" title="线程的分离"></a>线程的分离</h3><p>有时候程序员并不关心线程的返回状态,只是希望系统在线程终止时能够自动清理并移除之  </p>
<p>这类情况可调用pthread_deatch()并传入pthread_t的线程标识符,标记该线程处理分离状态   </p>
<p><img src="/2018/12/04/linux-programming/image-75.png" width="400px"></p>
<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>创建线程的时候pthread_create()放入类型为pthread_attr_t的attr参数,可利用创建线程时指定新线程的属性  </p>
<p>相关属性如下 </p>
<ul>
<li>线程栈的位置和大小  </li>
<li>线程调度策略  </li>
<li>线程优先级  </li>
<li>线程是否处于可连接或分离状态   </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">threadFunc(<span class="keyword">void</span> *x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thr;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    s = pthread_attr_init(&amp;attr);       <span class="comment">/* Assigns default values */</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_attr_init"</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_attr_setdetachstate"</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;thr, &amp;attr, threadFunc, (<span class="keyword">void</span> *) <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_create"</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_attr_destroy(&amp;attr);    <span class="comment">/* No longer needed */</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_attr_destroy"</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_join(thr, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_join failed as expected"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程VS进程"><a href="#线程VS进程" class="headerlink" title="线程VS进程"></a>线程VS进程</h3><p>多线程优点  </p>
<ul>
<li>线程间数据共享很简单,而进程数据共享就得创建共享内存段或使用管道pipe等  </li>
<li>创建线程快于创建进程,线程间的上下文切换消耗时间比进程短   </li>
</ul>
<p>多线程缺点 </p>
<ul>
<li>多线程编程,需要线程安全函数,或以线程安全的方式来调用函数  </li>
<li>某个线程中的bug,危及该进程所有线程  </li>
<li>每个线程都争用宿主进程中的有限虚拟地址空间,特别是一旦每个线程栈以及线程特有的数据(线程本地存储)消耗掉进程虚拟空间的一部分,让后续线程无缘使用这些区域  </li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>线程同步彼此行为的两个工具:互斥量和条件变量  </p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>线程优势通过全局共享信息,代价是必须确保多线程不会同时修改同一变量,或某一线程不会读取正由其他线程修改的变量  </p>
<p>术语<code>临界区</code>:指某一共享资源的代码片段,并且这段代码的执行应为院子操作,同时访问同一共享资源的其他线程不应中断该片段执行  </p>
<blockquote>
<p>两线程以错误的方式递增全局变量的值   </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> glob = <span class="number">0</span>;   <span class="comment">/* "volatile" prevents compiler optimizations</span></span><br><span class="line"><span class="comment">                                   of arithmetic operations on 'glob' */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *                   <span class="comment">/* Loop 'arg' times incrementing 'glob' */</span></span><br><span class="line">threadFunc(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> loops = *((<span class="keyword">int</span> *) arg);</span><br><span class="line">    <span class="keyword">int</span> loc, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; loops; j++) &#123;</span><br><span class="line">        loc = glob;</span><br><span class="line">        loc++;</span><br><span class="line">        glob = loc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t1, t2;</span><br><span class="line">    <span class="keyword">int</span> loops, s;</span><br><span class="line"></span><br><span class="line">    loops = (argc &gt; <span class="number">1</span>) ? getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">"num-loops"</span>) : <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, &amp;loops);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_create"</span>);</span><br><span class="line">    s = pthread_create(&amp;t2, <span class="literal">NULL</span>, threadFunc, &amp;loops);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_create"</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_join"</span>);</span><br><span class="line">    s = pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_join"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"glob = %d\n"</span>, glob);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/04/linux-programming/image-76.png" width="400px"></p>
<p>为避免线程更新共享变量时所出现问题,必须使用互斥量来确保同时仅有一个县城可以访问某项共享资源   </p>
<p>互斥量有两种状态:已锁定和未锁定,任何时候最多只有一个线程可以锁定该互斥量,视图对已经锁定的某一互斥量再次加锁,将可能阻塞线程或失败  </p>
<p>获取(acquire)和释放(release)来替代加锁和解锁  </p>
<p>对每个共享资源使用不同互斥量,每个线程在访问同一资源将如此操作  </p>
<ul>
<li>针对共享资源锁定互斥量  </li>
<li>访问共享资源  </li>
<li>对互斥量解锁  </li>
</ul>
<p><img src="/2018/12/04/linux-programming/image-77.png" width="300px"></p>
<h4 id="加锁解锁互斥量"><a href="#加锁解锁互斥量" class="headerlink" title="加锁解锁互斥量"></a>加锁解锁互斥量</h4><p>pthread_mutex_lock()可以锁定某一互斥量     </p>
<pre><code>- 如果自身已锁定,线程将会发生死锁
</code></pre><p>pthread_mutex_unlock()可以将一个互斥量解锁  </p>
<pre><code>- 解锁未锁定发送错误  
- 解锁其他线程锁定的互斥量  
</code></pre><p><img src="/2018/12/04/linux-programming/image-79.png" width="400px"></p>
<blockquote>
<p>使用互斥量对全局变量的访问  </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> glob = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mtx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *                   <span class="comment">/* Loop 'arg' times incrementing 'glob' */</span></span><br><span class="line">threadFunc(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> loops = *((<span class="keyword">int</span> *) arg);</span><br><span class="line">    <span class="keyword">int</span> loc, j, s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; loops; j++) &#123;</span><br><span class="line">        s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            errExitEN(s, <span class="string">"pthread_mutex_lock"</span>);</span><br><span class="line"></span><br><span class="line">        loc = glob;</span><br><span class="line">        loc++;</span><br><span class="line">        glob = loc;</span><br><span class="line"></span><br><span class="line">        s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            errExitEN(s, <span class="string">"pthread_mutex_unlock"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t1, t2;</span><br><span class="line">    <span class="keyword">int</span> loops, s;</span><br><span class="line"></span><br><span class="line">    loops = (argc &gt; <span class="number">1</span>) ? getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">"num-loops"</span>) : <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, &amp;loops);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_create"</span>);</span><br><span class="line">    s = pthread_create(&amp;t2, <span class="literal">NULL</span>, threadFunc, &amp;loops);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_create"</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_join"</span>);</span><br><span class="line">    s = pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_join"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"glob = %d\n"</span>, glob);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态初始化互斥量"><a href="#动态初始化互斥量" class="headerlink" title="动态初始化互斥量"></a>动态初始化互斥量</h4><p>静态初始值<code>PTHREAD_MUTEX_INITIALIZER</code>,只能静态分配且携带默认属性  </p>
<p>其他情况必须调用pthread_mutex_init()对互斥量进行动态初始化  </p>
<p><img src="/2018/12/04/linux-programming/image-80.png" width="400px"></p>
<p>mutex指定函数执行初始化操作的目标互斥量  </p>
<p>attr代表了参数  </p>
<p>如下情况就得用动态互斥量 </p>
<ul>
<li><p>动态分配于堆中的互斥量,例如链表每个结构都包含一个pthread_mutex_t类型的字段存放互斥量,借以保护对该结构的访问 </p>
</li>
<li><p>互斥量是在栈中分配的自动变量  </p>
</li>
<li><p>初始化经由静态分配,且不使用默认属性的互斥量  </p>
</li>
</ul>
<p>当不在需要动态分配的互斥量则销毁 </p>
<p><img src="/2018/12/04/linux-programming/image-81.png" width="400px"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mtx;</span><br><span class="line"><span class="keyword">pthread_mutexattr_t</span> mtxAttr;</span><br><span class="line"><span class="keyword">int</span> s,type;</span><br><span class="line"></span><br><span class="line">s = pthread_mutexattr_init(&amp;mtxAttr);</span><br><span class="line"></span><br><span class="line">s = pthread_mutexattr_settype(&amp;mtxAttr, PTHREAD_MUTEX_ERRORCHECK);</span><br><span class="line"></span><br><span class="line">s = pthread_mutex_init(mtx, &amp;mtxAttr);</span><br><span class="line"></span><br><span class="line">s = pthread_mutexattr_destroy(&amp;mtxAttr);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>互斥量的类型  </p>
</blockquote>
<ul>
<li>PTHREAD_MUTEX_NORMAL  </li>
</ul>
<p>该类型的互斥量不具有死锁检测,如果线程对自己锁定的互斥量加锁,则发生死锁   </p>
<ul>
<li>PTHREAD_MUTEX_ERRORCHECK  </li>
</ul>
<p>对此类的互斥量的所有操作都会执行错误检查,这类互斥量运行比一般类型慢  </p>
<ul>
<li>PTHREAD_MUTEX_RECURSIVE  </li>
</ul>
<p>递归互斥量维护一个锁计数器,第一次取得计数器置1，后续同一线程加锁叠加,而解锁也得递减计数器降至0,才会释放  </p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>互斥量防止多个线程同时访问同一共享变量,条件变量允许一个线程就某个共享变量(或其他共享资源)的状态变化通知其他线程,并让其他线程等待(阻塞)这一通知  </p>
<h4 id="静态分配的条件变量"><a href="#静态分配的条件变量" class="headerlink" title="静态分配的条件变量"></a>静态分配的条件变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure>
<h4 id="通知和等待条件变量"><a href="#通知和等待条件变量" class="headerlink" title="通知和等待条件变量"></a>通知和等待条件变量</h4><p>条件变量的主要作用是发送信号和等待,发送信号操作即通知一个或多个处于等待状态的线程,某个共享变量的状态已经发生改变,等待操作是指收到一个同之前一直处于阻塞的状态  </p>
<p>函数<code>pthread_cond_signal()</code>和<code>pthread_cond_broadcast()</code>均可针对由参数cond所指定的条件变量而发送信号,<code>pthread_cond_wait()</code>函数将阻塞一线程,直至收到条件变量cond的通知   </p>
<p><code>pthread_cond_signal()</code>和<code>pthread_cond_broadcast()</code>可避免发生如下情况:  </p>
<ul>
<li>同时唤醒所有等待线程  </li>
<li>某一线程首先获得调度  </li>
<li>剩余每个线程轮流锁定互斥量并检测共享变量的状态,不过由于第一个线程所做的工作,余下的线程发现无事可做,随即解锁互斥量转而休眠  </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mtx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> avail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">threadFunc(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = atoi((<span class="keyword">char</span> *) arg);</span><br><span class="line">    <span class="keyword">int</span> s, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Code to produce a unit omitted */</span></span><br><span class="line"></span><br><span class="line">        s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            errExitEN(s, <span class="string">"pthread_mutex_lock"</span>);</span><br><span class="line"></span><br><span class="line">        avail++;        <span class="comment">/* Let consumer know another unit is available */</span></span><br><span class="line"></span><br><span class="line">        s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            errExitEN(s, <span class="string">"pthread_mutex_unlock"</span>);</span><br><span class="line"></span><br><span class="line">        s = pthread_cond_signal(&amp;cond);         <span class="comment">/* Wake sleeping consumer */</span></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            errExitEN(s, <span class="string">"pthread_cond_signal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> s, j;</span><br><span class="line">    <span class="keyword">int</span> totRequired;            <span class="comment">/* Total number of units that all threads</span></span><br><span class="line"><span class="comment">                                   will produce */</span></span><br><span class="line">    <span class="keyword">int</span> numConsumed;            <span class="comment">/* Total units so far consumed */</span></span><br><span class="line">    Boolean done;</span><br><span class="line">    <span class="keyword">time_t</span> t;</span><br><span class="line"></span><br><span class="line">    t = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create all threads */</span></span><br><span class="line"></span><br><span class="line">    totRequired = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        totRequired += atoi(argv[j]);</span><br><span class="line"></span><br><span class="line">        s = pthread_create(&amp;tid, <span class="literal">NULL</span>, threadFunc, argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            errExitEN(s, <span class="string">"pthread_create"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop to consume available units */</span></span><br><span class="line"></span><br><span class="line">    numConsumed = <span class="number">0</span>;</span><br><span class="line">    done = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            errExitEN(s, <span class="string">"pthread_mutex_lock"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (avail == <span class="number">0</span>) &#123;            <span class="comment">/* Wait for something to consume */</span></span><br><span class="line">            s = pthread_cond_wait(&amp;cond, &amp;mtx);</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">                errExitEN(s, <span class="string">"pthread_cond_wait"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* At this point, 'mtx' is locked... */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (avail &gt; <span class="number">0</span>) &#123;             <span class="comment">/* Consume all available units */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Do something with produced unit */</span></span><br><span class="line"></span><br><span class="line">            numConsumed ++;</span><br><span class="line">            avail--;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T=%ld: numConsumed=%d\n"</span>, (<span class="keyword">long</span>) (time(<span class="literal">NULL</span>) - t),</span><br><span class="line">                    numConsumed);</span><br><span class="line"></span><br><span class="line">            done = numConsumed &gt;= totRequired;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            errExitEN(s, <span class="string">"pthread_mutex_unlock"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (done)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Perhaps do other work here that does not require mutex lock */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态分配的条件变量"><a href="#动态分配的条件变量" class="headerlink" title="动态分配的条件变量"></a>动态分配的条件变量</h3><p>使用函数pthread_cond_init()对条件变量进行动态初始化,需要使用pthread_cond_init()的情形类似于pthread_mutex_init()来动态初始化互斥量的情况</p>
<p><img src="/2018/12/04/linux-programming/image-82.png" width="400px"></p>
<p>同理当不再需要一个自动或动态分配的条件变量时,请调用<code>pthread_cond_destory()</code>函数予以销毁  </p>
<p><img src="/2018/12/04/linux-programming/image-83.png" width="400px"></p>
<h2 id="线程细节"><a href="#线程细节" class="headerlink" title="线程细节"></a>线程细节</h2><h3 id="线程实现模型"><a href="#线程实现模型" class="headerlink" title="线程实现模型"></a>线程实现模型</h3><p>阐述实现线程API的3中不同模型,3种实现模型差异主要集中在线程如何与内核调度实体(KSE,Kernel Scheduling Entity)相映射,KSE是内核分配CPU以及其他系统资源的对象单位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">早于线程而出现的传统UNIX中,kse等同于进程</span><br></pre></td></tr></table></figure>
<p>我们现在用的Linux线程就是NPTL。</p>
<p>线程的实现曾有3种模型：</p>
<ul>
<li><p>1.多对一(M:1)的用户级线程模型</p>
</li>
<li><p>2.一对一(1:1)的内核级线程模型</p>
</li>
<li><p>3.多对多(M:N)的两级线程模型</p>
</li>
</ul>
<p>上面的x对y(x:y)即x个用户线程对应y个内核调度实体(Kernel Scheduling Entity，这个是内核分配CPU的对象单位)。</p>
<p>LinuxThreads和NPTL都是采用一对一的线程模型，NGPT采用的是多对多的线程模型  </p>
<blockquote>
<p>多对一(M:1)实现(用户级线程)  </p>
</blockquote>
<p>在M:1线程实现中,关乎线程创建、调度以及同步(互斥量的锁定,条件变量的等待等)所有细节全部由进程内用户空间(user-space)的线程库来处理,对于进程中存在的多个线程,内核一无所知  </p>
<p>M:1实现的优势不多,其中最大的优点在于:许多线程操作(例如线程创建和终止,线程上下文间切换,互斥量以及条件变量操作)速度都很快,因为无需切换到内核模式,此外由于线程库无需内核支持,所以M:!实现系统间的移植较容易  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当然线程的一些其他操作还是要经过内核,如IO读写。</span><br><span class="line">这样导致了一个问题:当多线程并发执行时,如果其中一个线程执行IO操作时,内核接管这个操作</span><br><span class="line">如果IO阻塞,用户态的其他线程都会被阻塞,因为这些线程都对应同一个内核调度实体。</span><br><span class="line">在多处理器机器上内核不知道用户态有这些线程,无法把它们调度到其他处理器,也无法通过优先级来调度。</span><br><span class="line">这对线程的使用是没有意义的！</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一对一(1:1)实现(内核级线程)  </p>
</blockquote>
<p>在1:1线程实现中,每个线程映射一个单独的KSE,内核分别对每个线程做调度处理,线程同步操作通过内核系统调用实现<br>1:1实现消除了M:1实现的种种弊端,遭阻塞的系统调用不会导致进程的所有线程被阻塞,在多处理器硬件平台,内核还可以将进程中多个线程调度到不同的CPU上  </p>
<p>不过因为需要切换到内核模式,所以线程创建、上下文切换以及同步操作就慢一些,另外每个线程分别维护一个KSE也需要开销,如果应用程序包含大量线程,则可能对内核调度器造成严重的负担,降低系统性能  </p>
<p>尽管有这些缺点,1:1实现通常更胜于M:1实现, Linux Threads和NPTL都采用1:1模型  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每个用户线程都对应各自的内核调度实体</span><br><span class="line">内核会对每个线程进行调度,可以调度到其他处理器上面。</span><br><span class="line">当然由内核来调度的结果就是:线程的每次操作会在用户态和内核态切换。</span><br><span class="line">另外内核为每个线程都映射调度实体,如果系统出现大量线程,会对系统性能有影响。</span><br><span class="line">但该模型的实用性还是高于多对一的线程模型。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多对多(M:N)实现两级模型  </p>
</blockquote>
<p>结合1:1和M:1模型的优点,避免二者的缺点  </p>
<p>在M:N模型中,每个进程都拥有多个与之相关的KSE,并且也可以把多个线程映射到一个KSE,这种设计允许内核将同一应用的线程调度到不同的CPU商允许,同时解决了随线程数量而放大的性能问题  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每个线程可以拥有多个调度实体，也可以多个线程对应一个调度实体。</span><br><span class="line">听起来好像非常完美，但线程的调度需要由内核态和用户态一起来实现。</span><br><span class="line">可想而知，多个对象操作一个东西时，肯定要一些其他的同步机制。</span><br><span class="line">用户态和内核态的分工合作导致实现该模型非常复杂。</span><br><span class="line">NPTL曾经也想使用该模型但它太复杂,要对内核进行大范围改动,所以还是采用了一对一的模型！！！</span><br></pre></td></tr></table></figure>
<h3 id="线程存储"><a href="#线程存储" class="headerlink" title="线程存储"></a>线程存储</h3><h4 id="线程持有数据"><a href="#线程持有数据" class="headerlink" title="线程持有数据"></a>线程持有数据</h4><p>实现函数线程安全最为有效的方式就是使其重入,应以这种方式来实现所有新的函数库  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可重入函数无需使用互斥量即可实现线程安全</span><br><span class="line"></span><br><span class="line">其要诀在于避免对安全和静态变量的使用,需要返回给调用者的任何信息</span><br><span class="line"></span><br><span class="line">亦或是需要在对函数的历次调用期间加以维护的信息,都存储在调用者分配的缓冲区内</span><br></pre></td></tr></table></figure>
<p>对已有的不可重入函数库,使用线程特有的数据技术,可以无需修改函数接口而实现已有函数的线程安全  </p>
<p>较之于可重入函数,采用线程特有数据的函数效率可能要略低一点   </p>
<p><img src="/2018/12/04/linux-programming/image-84.png" width="300px"></p>
<blockquote>
<p>库函数视角下线程特有数据  </p>
</blockquote>
<ul>
<li><p>该函数必须为每个调用者线程分配单独的存储,且只需在线程初次调用此函数时分配一次即可 </p>
</li>
<li><p>在同一线程对此函数的后续所有调用中,该函数都需要获取初次调用时线程分配的存储块地址,由于函数调用结束时会自动释放变量,故而函数不应利用自动变量存放存储块指针,也不能将指针存放于静态变量中,因为静态变量在进程中只有一个实例  </p>
</li>
<li><p>不同函数各自可能都需要使用线程持有数据,每个函数都需要方法来标识其自身的线程特有数据(键),以便与其他函数所使用的线程特有数据有所区分  </p>
</li>
<li><p>当线程退出时,函数无法控制将要发生的情况,这时候线程可能都会执行该函数之外的代码,不过一定存在某种机制(解构器),在线程退出时自动释放为该线程所分配的存储。如非如此随着持续不断地创建线程、调用函数和终止线程,将会引发内存泄漏  </p>
</li>
</ul>
<h4 id="线程特有数据API"><a href="#线程特有数据API" class="headerlink" title="线程特有数据API"></a>线程特有数据API</h4><ul>
<li><p>函数<code>pthread_key_create()</code>可创建此键,且只需在首个调用该函数的线程中创建一次,<code>pthread_once()</code>使用的正出于这一目的  </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">调用`pthread_key_create()`还有另外目的</span><br><span class="line">允许调用者制定一个自定义解构函数,用于释放为该键所分配的各个存储块</span><br><span class="line">当使用线程特有数据的线程终止时,PthreadsApi会自动调用此解构函数  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key一旦被创建所有线程都可以访问它,但各线程可根据自己的需要往key中填入不同的值</span><br><span class="line">这就相当于提供了一个同名而不同值的全局变量一键多值。</span><br><span class="line"></span><br><span class="line">一键多值靠的是一个关键数据结构数组即TSD池</span><br><span class="line">创建一个TSD就相当于将结构数组中的某一项设置为“in_use”,并将其索引返回给*key,然后设置清理函数。</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数为会每个调用者线程创建线程特有数据块,这一分配通过调用malloc()完成,每个线程只分配一次，且只会在线程初次调用此函数时分配  </p>
</li>
<li><p>为了保持上一步所分配存储块的地址,函数会使用<code>pthrea_setspecific()</code>和<code>pthread_getspecific()</code>  </p>
</li>
</ul>
<p><code>pthread_key_create()</code>函数为线程持有数据创建一个新键,并通过key所指向的缓冲区返回给调用者  </p>
<p><img src="/2018/12/04/linux-programming/image-85.png" width="400px"></p>
<p>参数destructor指向一个自定义函数 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dest</span><span class="params">(<span class="keyword">void</span> *value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要线程终止时与key的关联值部位NULL,PthreadApi就自动执行解构函数,并将与key的关联值作为参数传入解构函数</p>
<p>线程特有数据,典型的NPTL实现会包含以下数组  </p>
<ul>
<li><p>一个全局(进程范围)数组,存放线程特有数据的键信息  </p>
</li>
<li><p>每个线程包含一个数组,存有为每个线程分配的线程特有数据块指针  </p>
</li>
</ul>
<p><img src="/2018/12/04/linux-programming/image-86.png" width="200px"></p>
<ul>
<li><p>函数pthread_setspecific()要求PthreadsApi将value与调用现场以及key相关联(key是pthread_key_create()的调用返回)</p>
</li>
<li><p>函数pthread_getspecific()的函数执行的操作与之相反,返回之前与本线程以及给定key相关的值(value)</p>
</li>
</ul>
<p><img src="/2018/12/04/linux-programming/image-87.png" width="400px"></p>
<blockquote>
<p>线程 key 以及TSD的关系图  </p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-88.png" width="400px"></p>
<p>当线程刚创建,所有线程特有数据的指针都初始化NULL,线程初次调用函数,必须使用pthread_getspecific()函数来检查该线程是否已有key对应的关联值,如果没有则函数会分配一块内存通过pthread_setspecific()保存指向该内存块的指针  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE                 <span class="comment">/* Get '_sys_nerr' and '_sys_errlist'</span></span></span><br><span class="line"><span class="meta"><span class="comment">                                       declarations from &lt;stdio.h&gt; */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;                 /* Get declaration of strerror() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ERROR_LEN 256           <span class="comment">/* Maximum length of string</span></span></span><br><span class="line"><span class="meta"><span class="comment">                                       returned by strerror() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buf[MAX_ERROR_LEN];     <span class="comment">/* Statically allocated return buffer */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *</span><br><span class="line">strerror(<span class="keyword">int</span> err)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span> || err &gt;= _sys_nerr || _sys_errlist[err] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, MAX_ERROR_LEN, <span class="string">"Unknown error %d"</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(buf, _sys_errlist[err], MAX_ERROR_LEN - <span class="number">1</span>);</span><br><span class="line">        buf[MAX_ERROR_LEN - <span class="number">1</span>] = <span class="string">'\0'</span>;          <span class="comment">/* Ensure null termination */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="文件I-O缓冲"><a href="#文件I-O缓冲" class="headerlink" title="文件I/O缓冲"></a>文件I/O缓冲</h1><p>出于速度和效率考虑,系统IO调用(即内核)和标注C语言库IO函数再操作磁盘文件时会对数据进行缓冲   </p>
<blockquote>
<p>页缓存、文件和进程之间关系的清晰思路图   </p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-51.png" width="700px"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">每个进程的地址空间使用mm_struct结构体标识</span><br><span class="line"></span><br><span class="line">该结构体中包含一系列的由vm_area_struct结构体组成的连续地址空间链表。</span><br><span class="line"></span><br><span class="line">每个vm_area_struct中存在struct file* vm_file用于指向该连续地址空间中所打开的文件</span><br><span class="line"></span><br><span class="line">而vm_file通过struct file中的struct path与struct dentry相关联。  </span><br><span class="line"></span><br><span class="line">struct dentry中通过inode指针指向inode  </span><br><span class="line"></span><br><span class="line">inode与address_space一一对应至此形成了页缓存与文件系统之间的关联</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">为了便于查找与某个文件相关联的所有进程</span><br><span class="line"></span><br><span class="line">address_space中的prio_tree_root指向了所有与该页缓存相关联的进程所形成的优先查找树的根节点。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>页缓存、文件系统、进程地址空间简化关系图  </p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-53.png" width="600px"></p>
<h2 id="文件IO的内核缓冲"><a href="#文件IO的内核缓冲" class="headerlink" title="文件IO的内核缓冲"></a>文件IO的内核缓冲</h2><blockquote>
<p>内核空间与用户空间之间以及磁盘的IO交互   </p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-52.png" width="600px"></p>
<p>read()和write()系统调用在操作磁盘文件时不会直接发起磁盘访问,而是仅仅在用户空间内存缓冲区与内核缓冲区高速缓存(kernel buffer cache)之间复制数据  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(fd, <span class="string">"abc"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>write()函数随记立刻返回,在某个时刻,内核会将其缓冲区中的数据写入(刷新至)磁盘,(因此可以说系统调用和磁盘操作并不同步),如果另一进程视图读取该文件的这几个字节,那么内核将自动从缓冲区高速缓存(kernel buffer cache)中提供这些数据,而不是从文件中(读取过期的内容)  </p>
<p>同理针对读取而言,内核从磁盘中读取数据并存储到内核缓冲区中,read()调用将从该缓冲区中读取数据,直至把缓冲区中的数据取完,这时候,内核会将文件的下一段内容读入缓冲区高速缓存(对于序列化文件,内核通常尝试执行预读,以确保在需要之前就将文件的下一数据块读入缓冲区高速缓存中)</p>
<p>采用这一设计,意在是read和write调用的操作更为快速,因为不需要等待(缓慢)的磁盘操作  </p>
<p><img src="/2018/12/04/linux-programming/image-47.png" width="400px"></p>
<p><img src="/2018/12/04/linux-programming/image-48.png" width="400px"></p>
<p>Linux对内核缓冲区高速缓存的大小没有固定上限,内核会分配尽可能多的缓冲区高速缓存页   </p>
<p>仅受如下因素:可用的物理内存总量以及出于其他目的对物理内存的需求  </p>
<p>如果内存不足,则内核会将一些修改过的缓冲区高速缓存页内容刷新到磁盘,并释放其供系统重用  </p>
<p><img src="/2018/12/04/linux-programming/image-41.png" width="400px">  </p>
<h3 id="Read读过程"><a href="#Read读过程" class="headerlink" title="Read读过程"></a>Read读过程</h3><p>进程发起读请求的过程如下：</p>
<ul>
<li><p>1.进程调用库函数read()向内核发起读文件的请求；</p>
</li>
<li><p>2.内核通过检查进程的文件描述符定位到虚拟文件系统已经打开的文件列表项，调用该文件系统对VFS的read()调用提供的接口；</p>
</li>
<li><p>3.通过文件表项链接到目录项模块，根据传入的文件路径在目录项中检索，找到该文件的inode；</p>
</li>
<li><p>4.inode中，通过文件内容偏移量计算出要读取的页；</p>
</li>
<li><p>5.通过该inode的i_mapping指针找到对应的address_space页缓存树—基数树，查找对应的页缓存节点；</p>
<ul>
<li><p>(1)如果页缓存节点命中，那么直接返回文件内容；</p>
</li>
<li><p>(2)如果页缓存缺失，那么产生一个缺页异常，首先创建一个新的空的物理页框，通过该inode找到文件中该页的磁盘地址，读取相应的页填充该页缓存（DMA的方式将数据读取到页缓存），更新页表项；重新进行第5步的查找页缓存的过程；</p>
</li>
</ul>
</li>
<li><p>6.文件内容读取成功；</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">也就是说,所有的文件内容的读取（无论一开始是命中页缓存还是没有命中页缓存）最终都是直接来源于页缓存。</span><br><span class="line"></span><br><span class="line">当将数据从磁盘复制到页缓存之后,还要将页缓存的数据通过CPU复制到read调用提供的缓冲区中</span><br><span class="line"></span><br><span class="line">这就是普通文件IO需要的两次复制数据复制过程。</span><br><span class="line"></span><br><span class="line">其中第一次是通过DMA的方式将数据从磁盘复制到页缓存中,本次过程只需要CPU在一开始的时候让出总线、</span><br><span class="line"></span><br><span class="line">结束之后处理DMA中断即可,中间不需要CPU的直接干预,CPU可以去做别的事情;</span><br><span class="line"></span><br><span class="line">第二次是将数据从页缓存复制到进程自己的的地址空间对应的物理内存中</span><br><span class="line"></span><br><span class="line">这个过程中需要CPU的全程干预,浪费CPU的时间和额外的物理内存空间。</span><br></pre></td></tr></table></figure>
<h3 id="Write写过程"><a href="#Write写过程" class="headerlink" title="Write写过程"></a>Write写过程</h3><p>由于页缓存的架构,当一个进程调用write系统调用的时候，对于文件的更新仅仅是被写到了文件的页缓存中</p>
<p>相应的页被标记为dirty。具体过程如下：</p>
<ul>
<li><p>1.进程调用库函数read()向内核发起读文件的请求；</p>
</li>
<li><p>2.内核通过检查进程的文件描述符定位到虚拟文件系统已经打开的文件列表项，调用该文件系统对VFS的read()调用提供的接口；</p>
</li>
<li><p>3.通过文件表项链接到目录项模块，根据传入的文件路径在目录项中检索，找到该文件的inode；</p>
</li>
<li><p>4.inode中，通过文件内容偏移量计算出要读取的页；</p>
</li>
<li><p>5.通过该inode的i_mapping指针找到对应的address_space页缓存树—基数树，查找对应的页缓存节点；</p>
<ul>
<li><p>(1)如果页缓存节点命中，直接把文件内容修改写在页缓存的页中。写文件就结束了。这时候文件修改位于页缓存，并没有写回到磁盘文件中去。</p>
</li>
<li><p>(2)如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到该文件页的磁盘地址,读取相应的页填充新的页缓存。此时缓存页命中,进行第5#1步。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">由于写操作只是写到了页缓存中,因此进程并没有被阻塞到磁盘IO发生</span><br><span class="line"></span><br><span class="line">因此当计算机崩溃的时候,写操作所引起的改变可能并没有发生在磁盘上。</span><br><span class="line"></span><br><span class="line">所以对于一些要求严格的写操作,比如数据库系统</span><br><span class="line"></span><br><span class="line">就需要调用fsync等操作及时将数据同步到磁盘上(虽然这中间也可能存在磁盘的驱动程序崩溃的情况)。</span><br><span class="line"></span><br><span class="line">读操作与写不同,一般会阻塞到进程读取到数据</span><br><span class="line">(除非调用非阻塞IO,即使使用IO多路复用技术也是将进程阻塞在多个监听描述符上,本质上还是阻塞的)。</span><br><span class="line"></span><br><span class="line">为了减轻读操作的这种延迟linux操作系统的内核使用了&quot;预读&quot;技术</span><br><span class="line"></span><br><span class="line">也就是当从磁盘中读取你所需要的数据的时候,内核将会多读取一些页到页缓存中。</span><br></pre></td></tr></table></figure>
<h3 id="mmap技术"><a href="#mmap技术" class="headerlink" title="mmap技术"></a>mmap技术</h3><p><img src="/2018/12/04/linux-programming/image-54.png" width="500px"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">使用了常规的read()系统调用读取了12KB的数据,现在scene.dat中三个大小为4KB的页也存在于页缓存中  </span><br><span class="line"></span><br><span class="line">就像先前所说的所有的文件IO都是通过页缓存进行的</span><br><span class="line"></span><br><span class="line">在X86架构的linux体系中,内核以4KB大小的页为单位组织文件中的数据</span><br><span class="line"></span><br><span class="line">所以即使你从一个文件中仅仅读取几个字节的数据,那么包含这些字节的整个页的数据都会从硬盘读入页缓存中。</span><br><span class="line"></span><br><span class="line">这对于提高硬盘的吞吐量很有帮助,并且用户通常每次读取的数据不仅仅是只有几个字节而已。</span><br><span class="line"></span><br><span class="line">页缓存记录了每个4KB中的页在文件中的位置，如图中的#0， #1等。</span><br><span class="line"></span><br><span class="line">然而，在一次文件读取的过程中，必须将文件的内容从页缓存拷贝到用户的空间。</span><br><span class="line"></span><br><span class="line">这个过程和缺页异常(通过DMA调入需要的页)不一样，这个拷贝过程需要通过CPU进行,因此浪费了CPU的时间。</span><br><span class="line"></span><br><span class="line">另一个弊端就是浪费了物理内存,因为需要为同样的数据在内存中维护两个副本</span><br><span class="line"></span><br><span class="line">render进程的heap所对应的堆中的数据和页缓存中的数据存在重复</span><br><span class="line"></span><br><span class="line">并且如果系统中有多个这样的进程的话</span><br><span class="line"></span><br><span class="line">那么需要为每个进程维护同样的一份数据副本,严重浪费了CPU的时间和物理内存空间。</span><br></pre></td></tr></table></figure>
<p>好在，通过内存映射IO—mmap,进程不但可以直接操作文件对应的物理内存,减少从内核空间到用户空间的数据复制过程,同时可以和别的进程共享页缓存中的数据,达到节约内存的作用</p>
<p><img src="/2018/12/04/linux-programming/image-55.png" width="500px"></p>
<h3 id="缓冲区大小对IO系统调用性能影响"><a href="#缓冲区大小对IO系统调用性能影响" class="headerlink" title="缓冲区大小对IO系统调用性能影响"></a>缓冲区大小对IO系统调用性能影响</h3><p>无论写1000次,每次1个字节,还是一次性写入1000个字节,内核访问磁盘的字节数都是相同的,我们更细化后者,因为它只需要一次系统调用,而前者则要调用1000次,虽然比磁盘操作快许多,但系统调用的耗费时间总量也相当可观,内核必须捕获调用,在用户空间与内核空间之间传输数据    </p>
<p>BUF_SIZE指定了每次调用read和write时传输的字节数,复制大小100MB的文件,设定不同的大小得到以下的时间表  </p>
<p>可以观察到不同大小的缓冲区对执行文件IO所产生的影响</p>
<p><img src="/2018/12/04/linux-programming/image-42.png" width="400px">  </p>
<p><img src="/2018/12/04/linux-programming/image-43.png" width="400px">  </p>
<p>此表显示了不同大小缓冲区调用write()从用户空间向内核缓冲区高速缓存传输数据所花费的成本,缓冲区越大,数据差异就越明显</p>
<p>缓冲区大小为1个字节时,需要调用read和write大概1亿次,缓冲区大小为4096个字节时,需要调用read和write 24000此左右,几乎达到了最优性能,设置再超过这个值意义不大,这是因为内核空间和用户空间之间复制数据以及执行实际磁盘IO所花费的时间相比,read和write系统调用的成本就显得微不足道  </p>
<p>总之,如果与文件发送大量的文件传输,通过采用大块空间缓冲数据,以及执行更少的系统调用,可以极大地提高IO性能  </p>
<h2 id="stdio库的缓冲"><a href="#stdio库的缓冲" class="headerlink" title="stdio库的缓冲"></a>stdio库的缓冲</h2><p>当操作磁盘文件,缓冲大块数据以减少系统调用,C语言函数库的IO函数,比如fprintf,fscanf,fgets,fputs,fputc,fgetc正是这么做的  </p>
<p>因此stdio库可以是程序员免于自行处理对数据的缓冲,无论是write还是read  </p>
<blockquote>
<p>设置stdio流的缓冲模式  </p>
</blockquote>
<p>调用<code>setvbuf()</code>函数,可以控制stdio库使用缓冲的形式  </p>
<p><img src="/2018/12/04/linux-programming/image-44.png" width="400px"></p>
<p>stream标识要修改哪个文件流的缓冲   </p>
<p>参数buf和size则针对参数stream要使用的缓冲区,制定这些参数有如下两种方式  </p>
<ul>
<li><p>参数buf不为NULL,那么其指向size大小的内存块以作为stream的缓冲区,因为stdio库将要使用buf指向的缓冲区,所以应该以动态或静态在堆中为该缓冲区分配一块空间(使用malloc类似)  </p>
</li>
<li><p>若buf为NULL,stdio库会为stream自动分配一个缓冲区,但不强制使用size来确定其缓冲区的大小,glibc实现会在该场景下忽略size参数  </p>
</li>
</ul>
<p>mode参数解析  </p>
<ul>
<li><p><code>_IONBF</code><br>  不对IO进行缓冲，每个stdio库函数立即调用write系统调用或read系统调用,并且忽略buf和size参数</p>
</li>
<li><p><code>_IOLBF</code><br>  采用行缓冲IO,指代终端设备的流,对于输出流,在输出一个换行符(除非缓冲区已经填满)前将缓冲数据,对于输入流,每次读取一行数据  </p>
</li>
</ul>
<ul>
<li><code>_IOFBF</code><br>  采用全缓冲IO,单次读、写数据(通过read()或write()系统调用)的大小与缓冲区相同,默认此模式  </li>
</ul>
<blockquote>
<p>setbuf()函数构建于setvbuf()之上</p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-45.png" width="400px"></p>
<p>setbuf(fp,buf)调用除了不反悔函数结果外,就相当于setvbuf()</p>
<blockquote>
<p>setbuffer()函数类似setbuf()函数,但允许调用者指定buf缓冲区大小  </p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-46.png" width="400px"></p>
<blockquote>
<p>刷新stdio缓冲区  </p>
</blockquote>
<p>无论当前采用何种缓冲模式,在任何时候,都可以使用fflush()库函数强制将stdio输出流的中的数据(即通过write())刷新到内核缓冲区中  </p>
<h2 id="文件缓存"><a href="#文件缓存" class="headerlink" title="文件缓存"></a>文件缓存</h2><p><img src="/2018/12/04/linux-programming/image-109.png" width="500px"></p>
<blockquote>
<p>存储设备上的数据,操作系统向应用程序提供的逻辑概念就是”文件”。<br>应用程序要存储或访问数据时,只需读或者写”文件”的一维地址空间即可     </p>
</blockquote>
<ul>
<li>应用程序需要读取文件中的数据时,系统先分配内存,将数据从存储设备读入到这些内存中,然后再将数据分发给应用程序  </li>
<li>当需要往文件中写数据时,操作系统先分配内存接收用户数据,然后再将数据从内存写到磁盘上     </li>
</ul>
<h3 id="ext2-ext3-ntfs"><a href="#ext2-ext3-ntfs" class="headerlink" title="ext2/ext3,ntfs"></a>ext2/ext3,ntfs</h3><blockquote>
<p>具体文件系统,如 ext2/ext3、jfs、ntfs等,负责在文件 Cache和存储设备之间交换数据  </p>
</blockquote>
<ul>
<li>具体文件系统则一般只与 Buffer Cache 交互,它们负责在外围存储设备和 Buffer Cache 之间交换数据。  </li>
</ul>
<h3 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h3><blockquote>
<p>位于具体文件系统之上的虚拟文件系统VFS负责在应用程序和文件 Cache 之间通过 read/write 等接口交换数据    </p>
</blockquote>
<ul>
<li>VFS 负责 Page Cache 与用户空间的数据交换。   </li>
</ul>
<h3 id="VMM"><a href="#VMM" class="headerlink" title="VMM"></a>VMM</h3><blockquote>
<p>虚拟内存管理系统,则允许应用程序和文件 Cache 之间通过 memory map的方式交换数据</p>
</blockquote>
<h3 id="FS-Cache-文件缓存"><a href="#FS-Cache-文件缓存" class="headerlink" title="FS Cache(文件缓存)"></a>FS Cache(文件缓存)</h3><p>文件 Cache 管理指的就是对这些由操作系统分配,并用来存储文件数据的内存的管理。<br>Cache 管理的优劣通过两个指标衡量：</p>
<p>一是 Cache 命中率,Cache 命中时数据可以直接从内存中获取,不再需要访问低速外设,因而可以显著提高性能；</p>
<p>二是有效 Cache 的比率,有效 Cache 是指真正会被访问到的 Cache 项,如果有效 Cache 的比率偏低,则相当部分磁盘带宽会被浪费到读取无用 Cache 上,而且无用 Cache 会间接导致系统内存紧张,最后可能会严重影响性能。   </p>
<blockquote>
<p>内存管理系统负责文件 Cache 的分配和回收      </p>
</blockquote>
<h4 id="存在地位"><a href="#存在地位" class="headerlink" title="存在地位?"></a>存在地位?</h4><p>文件 Cache 是文件数据在内存中的副本,因此文件 Cache 管理与内存管理系统和文件系统都相关</p>
<ul>
<li>文件 Cache 作为物理内存的一部分,需要参与物理内存的分配回收过程</li>
<li>文件 Cache 中的数据来源于存储设备上的文件,需要通过文件系统与存储设备进行读写交互。文件 Cache 可以看做是内存管理系统与文件系统之间的联系纽带。</li>
</ul>
<h4 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构?"></a>总体结构?</h4><p><img src="/2018/12/04/linux-programming/image-110.png" width="500px"></p>
<p><img src="/2018/12/04/linux-programming/image-111.png" width="500px"></p>
<blockquote>
<p>一是 Page Cache,另一个 Buffer Cache,每一个 Page Cache 包含若干 Buffer Cache        </p>
</blockquote>
<ul>
<li><p>内存管理系统和 VFS 只与 Page Cache 交互,内存管理系统负责维护每项 Page Cache 的分配和回收  </p>
<blockquote>
<p>同时还可使用 memory map 方式访问时负责建立映射   </p>
</blockquote>
</li>
<li><p>磁盘那边中VFS也负责Page Cache 与用户空间的数据交换  </p>
</li>
<li>Ext2/3只与Buffer Cache交互,负责外围存储设备数据交互    </li>
</ul>
<h4 id="数据块结构"><a href="#数据块结构" class="headerlink" title="数据块结构"></a>数据块结构</h4><p>文件的每个数据块最多只能对应一个 Page Cache 项,它通过两个数据结构来管理这些 Cache 项,一个是 radix tree,另一个是双向链表  </p>
<ul>
<li><p>Radix tree 是一种搜索树,Linux 内核利用这个数据结构来通过文件内偏移快速定位Cache项,radix tree 中的每一个叶子节点指向文件内相应偏移所对应的Cache项。  </p>
</li>
<li><p>双向链表,Linux内核为每一片物理内存区域(zone)维护active_list和inactive_list两个双向链表,这两个list主要用来实现物理内存的回收。</p>
</li>
</ul>
<blockquote>
<p>这两个链表上除了文件Cache之外,还包括其它匿名(Anonymous)内存,如进程堆栈等。</p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-112.png" width="500px"></p>
<h4 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h4><p>Linux内核中与文件Cache操作相关的API有很多,按其使用方式可以分成两类;</p>
<ul>
<li>一类是以拷贝方式操作的相关接口,如read/write/sendfile等,其中sendfile在2.6系列的内核中已经不再支持;</li>
</ul>
<p><img src="/2018/12/04/linux-programming/image-113.png" width="500px"></p>
<ul>
<li>另一类是以地址映射方式操作的相关接口,如mmap等。  </li>
</ul>
<blockquote>
<p>将Cache项映射到用户空间,使得应用程序可以像使用内存指针一样访问文件,Memory map访问Cache的方式在内核中是采用请求页面机制实现的</p>
</blockquote>
<p><img src="/2018/12/04/linux-programming/image-114.png" width="500px"></p>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2018/12/04/linux-programming/';
        this.page.title = 'Linux系统笔记';
        this.page.identifier = '2018/12/04/linux-programming/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
