<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>X86_32汇编语言解析 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="X86汇编语言编程相关详解笔记   
转载此文  
本文描述基本的32位X86汇编语言的一个子集，其中涉及汇编语言的最核心部分，包括寄存器结构，数据表示，基本的操作指令（包括数据传送指令、逻辑计算指令、算数运算指令），以及函数的调用规则。  
个人认为：在理解了本文后，基本可以无障碍地阅读绝大部分标准X86汇编程序。当然，更复杂的指令请参阅Intel相关文档。  
X86指令集123456789101112131415161718192021222324252627282930313233343">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Golang</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">System</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">Reverse</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">BigData</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/ai">Math/AI</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/physical">Physical</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/life">生活规划</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mesos/">Mesos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scikit/">Scikit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SofaMesh/">SofaMesh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TroubleShoot/">TroubleShoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x64-Windows系统总结/">x64 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内网穿透/">内网穿透</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#X86指令集"><span class="toc-number">1.</span> <span class="toc-text">X86指令集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Intel-X86-CPU系列的寄存器"><span class="toc-number">2.</span> <span class="toc-text">Intel X86 CPU系列的寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#32位CPU系统级寄存器和数据结构"><span class="toc-number">2.1.</span> <span class="toc-text">32位CPU系统级寄存器和数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寄存器分类介绍"><span class="toc-number">2.2.</span> <span class="toc-text">寄存器分类介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寄存器详解"><span class="toc-number">2.3.</span> <span class="toc-text">寄存器详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通用寄存器"><span class="toc-number">2.3.1.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标志寄存器"><span class="toc-number">2.3.2.</span> <span class="toc-text">标志寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制寄存器"><span class="toc-number">2.3.3.</span> <span class="toc-text">控制寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试寄存器"><span class="toc-number">2.3.4.</span> <span class="toc-text">调试寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统地址寄存器"><span class="toc-number">2.3.5.</span> <span class="toc-text">系统地址寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16位段寄存器：CS-DS-ES-FS-GS-SS"><span class="toc-number">2.3.6.</span> <span class="toc-text">16位段寄存器：CS,DS,ES,FS,GS,SS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他寄存器"><span class="toc-number">2.3.7.</span> <span class="toc-text">其他寄存器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#寄存器"><span class="toc-number">3.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存和寻址模式"><span class="toc-number">4.</span> <span class="toc-text">内存和寻址模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#声明静态数据区"><span class="toc-number">4.1.</span> <span class="toc-text">声明静态数据区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寻址模式"><span class="toc-number">4.2.</span> <span class="toc-text">寻址模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#长度规定"><span class="toc-number">4.3.</span> <span class="toc-text">长度规定</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#汇编指令"><span class="toc-number">5.</span> <span class="toc-text">汇编指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据传送指令"><span class="toc-number">5.1.</span> <span class="toc-text">数据传送指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算术和逻辑指令"><span class="toc-number">5.2.</span> <span class="toc-text">算术和逻辑指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#控制转移指令"><span class="toc-number">5.3.</span> <span class="toc-text">控制转移指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#调用规则"><span class="toc-number">6.</span> <span class="toc-text">调用规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#调用者规则"><span class="toc-number">6.1.</span> <span class="toc-text">调用者规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#被调用者规则"><span class="toc-number">6.2.</span> <span class="toc-text">被调用者规则</span></a></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            X86_32汇编语言解析
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2018/12/09/x86-assembly/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-09T09:39:37.000Z" itemprop="datePublished">2018-12-09</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/assembly/">assembly</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>X86汇编语言编程相关详解笔记<br><a id="more"></a>   </p>
<p><a href="http://www.cnblogs.com/YukiJohnson/archive/2012/10/27/2741836.html" target="_blank" rel="noopener">转载此文</a>  </p>
<p>本文描述基本的32位X86汇编语言的一个子集，其中涉及汇编语言的最核心部分，包括寄存器结构，数据表示，基本的操作指令（包括数据传送指令、逻辑计算指令、算数运算指令），以及函数的调用规则。  </p>
<p>个人认为：在理解了本文后，基本可以无障碍地阅读绝大部分标准X86汇编程序。当然，更复杂的指令请参阅Intel相关文档。  </p>
<h1 id="X86指令集"><a href="#X86指令集" class="headerlink" title="X86指令集"></a>X86指令集</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br></pre></td><td class="code"><pre><span class="line">X86和X87汇编指令大全（有注释）  </span><br><span class="line">---------- 一、数据传输指令 ----------------------------------------------------  </span><br><span class="line">它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据.  </span><br><span class="line">1. 通用数据传送指令.  </span><br><span class="line">    MOV     传送字或字节.  </span><br><span class="line">    MOVSX   先符号扩展,再传送.  </span><br><span class="line">    MOVZX   先零扩展,再传送.  </span><br><span class="line">    PUSH    把字压入堆栈.  </span><br><span class="line">    POP     把字弹出堆栈.  </span><br><span class="line">    PUSHA   把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈.  </span><br><span class="line">    POPA    把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈.  </span><br><span class="line">    PUSHAD  把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈.  </span><br><span class="line">    POPAD   把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈.  </span><br><span class="line">    BSWAP   交换32位寄存器里字节的顺序  </span><br><span class="line">    XCHG    交换字或字节.(至少有一个操作数为寄存器,段寄存器不可作为操作数)  </span><br><span class="line">    CMPXCHG 比较并交换操作数.(第二个操作数必须为累加器AL/AX/EAX)  </span><br><span class="line">    XADD    先交换再累加.(结果在第一个操作数里)  </span><br><span class="line">    XLAT    字节查表转换.----BX指向一张256字节的表的起点,AL为表的索引值(0-255,即0-FFH);返回AL为查表结果.([BX+AL]-&gt;AL)  </span><br><span class="line">2. 输入输出端口传送指令.  </span><br><span class="line">    IN      I/O端口输入. ( 语法: IN   累加器,    &#123;端口号│DX&#125; )  </span><br><span class="line">    OUT     I/O端口输出. ( 语法: OUT &#123;端口号│DX&#125;,累加器 )输入输出端口由立即方式指定时,</span><br><span class="line">                        其范围是 0-255; 由寄存器 DX 指定时,其范围是    0-65535.  </span><br><span class="line">3. 目的地址传送指令.  </span><br><span class="line">    LEA     装入有效地址.例: LEA DX,string ;把偏移地址存到DX.  </span><br><span class="line">    LDS     传送目标指针,把指针内容装入DS.例: LDS SI,string   ;把段地址:偏移地址存到DS:SI.  </span><br><span class="line">    LES     传送目标指针,把指针内容装入ES.例: LES DI,string   ;把段地址:偏移地址存到ES:DI.  </span><br><span class="line">    LFS     传送目标指针,把指针内容装入FS.例: LFS DI,string   ;把段地址:偏移地址存到FS:DI.  </span><br><span class="line">    LGS     传送目标指针,把指针内容装入GS.例: LGS DI,string   ;把段地址:偏移地址存到GS:DI.  </span><br><span class="line">    LSS     传送目标指针,把指针内容装入SS.例: LSS DI,string   ;把段地址:偏移地址存到SS:DI.  </span><br><span class="line">4. 标志传送指令.  </span><br><span class="line">    LAHF    标志寄存器传送,把标志装入AH.  </span><br><span class="line">    SAHF    标志寄存器传送,把AH内容装入标志寄存器.  </span><br><span class="line">    PUSHF   标志入栈.  </span><br><span class="line">    POPF    标志出栈.  </span><br><span class="line">    PUSHD   32位标志入栈.  </span><br><span class="line">    POPD    32位标志出栈.  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------- 二、算术运算指令 ----------------------------------------------------  </span><br><span class="line">    ADD     加法.  </span><br><span class="line">    ADC     带进位加法.  </span><br><span class="line">    INC     加 1.  </span><br><span class="line">    AAA     加法的ASCII码调整.  </span><br><span class="line">    DAA     加法的十进制调整.  </span><br><span class="line">    SUB     减法.  </span><br><span class="line">    SBB     带借位减法.  </span><br><span class="line">    DEC     减 1.  </span><br><span class="line">    NEG     求反(以    0 减之).  </span><br><span class="line">    CMP     比较.(两操作数作减法,仅修改标志位,不回送结果).  </span><br><span class="line">    AAS     减法的ASCII码调整.  </span><br><span class="line">    DAS     减法的十进制调整.  </span><br><span class="line">    MUL     无符号乘法.结果回送AH和AL(字节运算),或DX和AX(字运算),  </span><br><span class="line">    IMUL    整数乘法.结果回送AH和AL(字节运算),或DX和AX(字运算),  </span><br><span class="line">    AAM     乘法的ASCII码调整.  </span><br><span class="line">    DIV     无符号除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算).  </span><br><span class="line">    IDIV    整数除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算).  </span><br><span class="line">    AAD     除法的ASCII码调整.  </span><br><span class="line">    CBW     字节转换为字. (把AL中字节的符号扩展到AH中去)  </span><br><span class="line">    CWD     字转换为双字. (把AX中的字的符号扩展到DX中去)  </span><br><span class="line">    CWDE    字转换为双字. (把AX中的字符号扩展到EAX中去)  </span><br><span class="line">    CDQ     双字扩展. (把EAX中的字的符号扩展到EDX中去)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------- 三、逻辑运算指令 ----------------------------------------------------  </span><br><span class="line">    AND     与运算.  </span><br><span class="line">    OR      或运算.  </span><br><span class="line">    XOR     异或运算.  </span><br><span class="line">    NOT     取反.  </span><br><span class="line">    TEST    测试.(两操作数作与运算,仅修改标志位,不回送结果).  </span><br><span class="line">    SHL     逻辑左移.  </span><br><span class="line">    SAL     算术左移.(=SHL)  </span><br><span class="line">    SHR     逻辑右移.  </span><br><span class="line">    SAR     算术右移.(=SHR)  </span><br><span class="line">    ROL     循环左移.  </span><br><span class="line">    ROR     循环右移.  </span><br><span class="line">    RCL     通过进位的循环左移.  </span><br><span class="line">    RCR     通过进位的循环右移.  </span><br><span class="line">              以上八种移位指令,其移位次数可达255次.  </span><br><span class="line">              移位一次时, 可直接用操作码. 如 SHL AX,1.  </span><br><span class="line">              移位&gt;1次时, 则由寄存器CL给出移位次数.  </span><br><span class="line">              如 MOV CL,04   SHL AX,CL  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------- 四、串指令 ----------------------------------------------------------  </span><br><span class="line">              DS:SI 源串段寄存器 :源串变址.  </span><br><span class="line">              ES:DI 目标串段寄存器:目标串变址.  </span><br><span class="line">              CX 重复次数计数器.  </span><br><span class="line">              AL/AX 扫描值.  </span><br><span class="line">              D标志   0表示重复操作中SI和DI应自动增量; 1表示应自动减量.  </span><br><span class="line">              Z标志   用来控制扫描或比较操作的结束.  </span><br><span class="line">    MOVS    串传送.( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )  </span><br><span class="line">    CMPS    串比较.( CMPSB 比较字符. CMPSW 比较字. )  </span><br><span class="line">    SCAS    串扫描.把AL或AX的内容与目标串作比较,比较结果反映在标志位.  </span><br><span class="line">    LODS    装入串.把源串中的元素(字或字节)逐一装入AL或AX中.( LODSB 传送字符. LODSW 传送字.LODSD 传送双字. )  </span><br><span class="line">    STOS    保存串.是LODS的逆过程.  </span><br><span class="line">    REP         当CX/ECX&lt;&gt;0时重复.  </span><br><span class="line">    REPE/REPZ   当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复.  </span><br><span class="line">    REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复.  </span><br><span class="line">    REPC        当CF=1且CX/ECX&lt;&gt;0时重复.  </span><br><span class="line">    REPNC       当CF=0且CX/ECX&lt;&gt;0时重复.  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------- 五、程序转移指令 ----------------------------------------------------  </span><br><span class="line">1. 无条件转移指令 (长转移)  </span><br><span class="line">    JMP         无条件转移指令  </span><br><span class="line">    CALL        过程调用  </span><br><span class="line">    RET/RETF    过程返回.  </span><br><span class="line">2. 条件转移指令   (短转移,-128到+127的距离内)( 当且仅当(SF XOR OF)=1时,OP1&lt;OP2 )  </span><br><span class="line">    JA/JNBE     不小于或不等于时转移.  </span><br><span class="line">    JAE/JNB     大于或等于转移.  </span><br><span class="line">    JB/JNAE     小于转移.  </span><br><span class="line">    JBE/JNA     小于或等于转移.  </span><br><span class="line">        以上四条,测试无符号整数运算的结果(标志C和Z).  </span><br><span class="line">    JG/JNLE     大于转移.  </span><br><span class="line">    JGE/JNL     大于或等于转移.  </span><br><span class="line">    JL/JNGE     小于转移.  </span><br><span class="line">    JLE/JNG     小于或等于转移.  </span><br><span class="line">        以上四条,测试带符号整数运算的结果(标志S,O和Z).  </span><br><span class="line">    JE/JZ       等于转移.  </span><br><span class="line">    JNE/JNZ     不等于时转移.  </span><br><span class="line">    JC          有进位时转移.  </span><br><span class="line">    JNC         无进位时转移.  </span><br><span class="line">    JNO         不溢出时转移.  </span><br><span class="line">    JNP/JPO     奇偶性为奇数时转移.  </span><br><span class="line">    JNS         符号位为 &quot;0&quot; 时转移.  </span><br><span class="line">    JO          溢出转移.  </span><br><span class="line">    JP/JPE      奇偶性为偶数时转移.  </span><br><span class="line">    JS          符号位为 &quot;1&quot; 时转移.  </span><br><span class="line">3. 循环控制指令(短转移)  </span><br><span class="line">    LOOP            CX不为零时循环.  </span><br><span class="line">    LOOPE/LOOPZ     CX不为零且标志Z=1时循环.  </span><br><span class="line">    LOOPNE/LOOPNZ   CX不为零且标志Z=0时循环.  </span><br><span class="line">    JCXZ            CX为零时转移.  </span><br><span class="line">    JECXZ           ECX为零时转移.  </span><br><span class="line">4. 中断指令  </span><br><span class="line">    INT         中断指令  </span><br><span class="line">    INTO        溢出中断  </span><br><span class="line">    IRET        中断返回  </span><br><span class="line">5. 处理器控制指令  </span><br><span class="line">    HLT         处理器暂停,  直到出现中断或复位信号才继续.  </span><br><span class="line">    WAIT        当芯片引线TEST为高电平时使CPU进入等待状态.  </span><br><span class="line">    ESC         转换到外处理器.  </span><br><span class="line">    LOCK        封锁总线.  </span><br><span class="line">    NOP         空操作.  </span><br><span class="line">    STC         置进位标志位.  </span><br><span class="line">    CLC         清进位标志位.  </span><br><span class="line">    CMC         进位标志取反.  </span><br><span class="line">    STD         置方向标志位.  </span><br><span class="line">    CLD         清方向标志位.  </span><br><span class="line">    STI         置中断允许位.  </span><br><span class="line">    CLI         清中断允许位.  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------- 六、伪指令 ----------------------------------------------------------  </span><br><span class="line">    DW          定义字(2字节).  </span><br><span class="line">    PROC        定义过程.  </span><br><span class="line">    ENDP        过程结束.  </span><br><span class="line">    SEGMENT     定义段.  </span><br><span class="line">    ASSUME      建立段寄存器寻址.  </span><br><span class="line">    ENDS        段结束.  </span><br><span class="line">    END         程序结束.  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------- 七、处理机控制指令：标志处理指令 ------------------------------------  </span><br><span class="line">    CLC     进位位置0指令  </span><br><span class="line">    CMC     进位位求反指令  </span><br><span class="line">    STC     进位位置为1指令  </span><br><span class="line">    CLD     方向标志置1指令  </span><br><span class="line">    STD     方向标志位置1指令  </span><br><span class="line">    CLI     中断标志置0指令  </span><br><span class="line">    STI     中断标志置1指令  </span><br><span class="line">    NOP     无操作  </span><br><span class="line">    HLT     停机  </span><br><span class="line">    WAIT    等待  </span><br><span class="line">    ESC     换码  </span><br><span class="line">    LOCK    封锁  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">========== 浮点运算指令集 ======================================================  </span><br><span class="line">---------- 一、控制指令(带9B的控制指令前缀F变为FN时浮点不检查，机器码去掉9B)----  </span><br><span class="line">FINIT                 初始化浮点部件                  机器码  9B DB E3  </span><br><span class="line">FCLEX                 清除异常                         机器码  9B DB E2  </span><br><span class="line">FDISI                 浮点检查禁止中断                 机器码  9B DB E1  </span><br><span class="line">FENI                  浮点检查禁止中断二            机器码  9B DB E0  </span><br><span class="line">WAIT                  同步CPU和FPU                    机器码  9B  </span><br><span class="line">FWAIT                 同步CPU和FPU                    机器码  D9 D0  </span><br><span class="line">FNOP                  无操作                          机器码  DA E9  </span><br><span class="line">FXCH                  交换ST(0)和ST(1)                机器码  D9 C9  </span><br><span class="line">FXCH ST(i)            交换ST(0)和ST(i)                机器码  D9 C1iii  </span><br><span class="line">FSTSW ax              状态字到ax                       机器码  9B DF E0  </span><br><span class="line">FSTSW   word ptr mem  状态字到mem                      机器码  9B DD mm111mmm  </span><br><span class="line">FLDCW   word ptr mem  mem到状态字                      机器码  D9 mm101mmm  </span><br><span class="line">FSTCW   word ptr mem  控制字到mem                      机器码  9B D9 mm111mmm  </span><br><span class="line">  </span><br><span class="line">FLDENV  word ptr mem  mem到全环境                      机器码  D9 mm100mmm  </span><br><span class="line">FSTENV  word ptr mem  全环境到mem                      机器码  9B D9 mm110mmm  </span><br><span class="line">FRSTOR  word ptr mem  mem到FPU状态                    机器码  DD mm100mmm  </span><br><span class="line">FSAVE   word ptr mem  FPU状态到mem                    机器码  9B DD mm110mmm  </span><br><span class="line">  </span><br><span class="line">FFREE ST(i)           标志ST(i)未使用                   机器码  DD C0iii  </span><br><span class="line">FDECSTP               减少栈指针1-&gt;0 2-&gt;1             机器码  D9 F6  </span><br><span class="line">FINCSTP               增加栈指针0-&gt;1 1-&gt;2             机器码  D9 F7  </span><br><span class="line">FSETPM                浮点设置保护                       机器码  DB E4  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------- 二、数据传送指令 ----------------------------------------------------  </span><br><span class="line">FLDZ                  将0.0装入ST(0)                  机器码  D9 EE  </span><br><span class="line">FLD1                  将1.0装入ST(0)                  机器码  D9 E8  </span><br><span class="line">FLDPI                 将π装入ST(0)                    机器码  D9 EB  </span><br><span class="line">FLDL2T                将ln10/ln2装入ST(0)             机器码  D9 E9  </span><br><span class="line">FLDL2E                将1/ln2装入ST(0)                机器码  D9 EA  </span><br><span class="line">FLDLG2                将ln2/ln10装入ST(0)             机器码  D9 EC  </span><br><span class="line">FLDLN2                将ln2装入ST(0)                  机器码  D9 ED  </span><br><span class="line">  </span><br><span class="line">FLD    real4 ptr mem  装入mem的单精度浮点数             机器码  D9 mm000mmm  </span><br><span class="line">FLD    real8 ptr mem  装入mem的双精度浮点数             机器码  DD mm000mmm  </span><br><span class="line">FLD   real10 ptr mem  装入mem的十字节浮点数             机器码  DB mm101mmm  </span><br><span class="line">  </span><br><span class="line">FILD    word ptr mem  装入mem的二字节整数              机器码  DF mm000mmm  </span><br><span class="line">FILD   dword ptr mem  装入mem的四字节整数              机器码  DB mm000mmm  </span><br><span class="line">FILD   qword ptr mem  装入mem的八字节整数              机器码  DF mm101mmm  </span><br><span class="line">  </span><br><span class="line">FBLD   tbyte ptr mem  装入mem的十字节BCD数            机器码  DF mm100mmm  </span><br><span class="line">  </span><br><span class="line">FST    real4 ptr mem  保存单精度浮点数到mem             机器码  D9 mm010mmm  </span><br><span class="line">FST    real8 ptr mem  保存双精度浮点数到mem             机器码  DD mm010mmm  </span><br><span class="line">  </span><br><span class="line">FIST    word ptr mem  保存二字节整数到mem              机器码  DF mm010mmm  </span><br><span class="line">FIST   dword ptr mem  保存四字节整数到mem              机器码  DB mm010mmm  </span><br><span class="line">  </span><br><span class="line">FSTP   real4 ptr mem  保存单精度浮点数到mem并出栈      机器码  D9 mm011mmm  </span><br><span class="line">FSTP   real8 ptr mem  保存双精度浮点数到mem并出栈      机器码  DD mm011mmm  </span><br><span class="line">FSTP  real10 ptr mem  保存十字节浮点数到mem并出栈      机器码  DB mm111mmm  </span><br><span class="line">  </span><br><span class="line">FISTP   word ptr mem  保存二字节整数到mem并出栈           机器码  DF mm011mmm  </span><br><span class="line">FISTP  dword ptr mem  保存四字节整数到mem并出栈           机器码  DB mm011mmm  </span><br><span class="line">FISTP  qword ptr mem  保存八字节整数到mem并出栈           机器码  DF mm111mmm  </span><br><span class="line">  </span><br><span class="line">FBSTP  tbyte ptr mem  保存十字节BCD数到mem并出栈     机器码  DF mm110mmm  </span><br><span class="line">  </span><br><span class="line">FCMOVB                ST(0),ST(i) &lt;时传送              机器码  DA C0iii  </span><br><span class="line">FCMOVBE               ST(0),ST(i) &lt;=时传送             机器码  DA D0iii  </span><br><span class="line">FCMOVE                ST(0),ST(i) =时传送             机器码  DA C1iii  </span><br><span class="line">FCMOVNB               ST(0),ST(i) &gt;=时传送             机器码  DB C0iii  </span><br><span class="line">FCMOVNBE              ST(0),ST(i) &gt;时传送              机器码  DB D0iii  </span><br><span class="line">FCMOVNE               ST(0),ST(i) !=时传送            机器码  DB C1iii  </span><br><span class="line">FCMOVNU               ST(0),ST(i) 有序时传送        机器码  DB D1iii  </span><br><span class="line">FCMOVU                ST(0),ST(i) 无序时传送        机器码  DA D1iii  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------- 三、比较指令   --------------------------------------------------------  </span><br><span class="line">FCOM                  ST(0)-ST(1)                      机器码  D8 D1  </span><br><span class="line">FCOMI                 ST(0),ST(i)  ST(0)-ST(1)         机器码  DB F0iii  </span><br><span class="line">FCOMIP                ST(0),ST(i)  ST(0)-ST(1)并出栈   机器码  DF F0iii  </span><br><span class="line">FCOM   real4 ptr mem  ST(0)-实数mem                      机器码  D8 mm010mmm  </span><br><span class="line">FCOM   real8 ptr mem  ST(0)-实数mem                      机器码  DC mm010mmm  </span><br><span class="line">  </span><br><span class="line">FICOM   word ptr mem  ST(0)-整数mem                      机器码  DE mm010mmm  </span><br><span class="line">FICOM  dword ptr mem  ST(0)-整数mem                      机器码  DA mm010mmm  </span><br><span class="line">FICOMP  word ptr mem  ST(0)-整数mem并出栈               机器码  DE mm011mmm  </span><br><span class="line">FICOMP dword ptr mem  ST(0)-整数mem并出栈               机器码  DA mm011mmm  </span><br><span class="line">  </span><br><span class="line">FTST                  ST(0)-0                          机器码  D9 E4  </span><br><span class="line">FUCOM  ST(i)          ST(0)-ST(i)                      机器码  DD E0iii  </span><br><span class="line">FUCOMP ST(i)          ST(0)-ST(i)并出栈                   机器码  DD E1iii  </span><br><span class="line">FUCOMPP               ST(0)-ST(1)并二次出栈             机器码  DA E9  </span><br><span class="line">FXAM                  ST(0)规格类型                    机器码  D9 E5  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------- 四、运算指令   --------------------------------------------------------  </span><br><span class="line">FADD                  把目的操作数 (直接接在指令后的变量或堆栈缓存器) </span><br><span class="line">                      与来源操作数 (接在目的操作数后的变量或堆栈缓存器) 相加，并将结果存入目的操作数  </span><br><span class="line"></span><br><span class="line">FADDP  ST(i),ST       这个指令是使目的操作数加上 ST 缓存器，并弹出 ST 缓存器</span><br><span class="line">                      而目的操作数必须是堆栈缓存器的其中之一，</span><br><span class="line">                      最后不管目的操作数为何，经弹出一次后，目的操作数会变成上一个堆栈缓存器了  </span><br><span class="line"></span><br><span class="line">FIADD                 FIADD 是把 ST 加上来源操作数</span><br><span class="line">                      然后再存入 ST 缓存器，来源操作数必须是字组整数或短整数形态的变数  </span><br><span class="line">  </span><br><span class="line">FSUB                  减  </span><br><span class="line">FSUBP  </span><br><span class="line">FSUBR                 减数与被减数互换  </span><br><span class="line">FSUBRP  </span><br><span class="line">FISUB  </span><br><span class="line">FISUBR  </span><br><span class="line">  </span><br><span class="line">FMUL                  乘  </span><br><span class="line">FMULP  </span><br><span class="line">FIMUL  </span><br><span class="line">  </span><br><span class="line">FDIV                  除  </span><br><span class="line">FDIVP  </span><br><span class="line">FDIVR  </span><br><span class="line">FDIVRP  </span><br><span class="line">FIDIV  </span><br><span class="line">FIDIVR  </span><br><span class="line">  </span><br><span class="line">FCHS                  改变 ST 的正负值  </span><br><span class="line">  </span><br><span class="line">FABS                  把 ST  之值取出，取其绝对值后再存回去。  </span><br><span class="line">  </span><br><span class="line">FSQRT                 将 ST  之值取出，开根号后再存回去。  </span><br><span class="line">  </span><br><span class="line">FSCALE                这个指令是计算 ST*2^ST(1)之值,再把结果存入 ST 里而 ST(1)之值不变。</span><br><span class="line">                      ST(1)  必须是在 -32768 到 32768 (-215 到 215 )之间的整数，</span><br><span class="line">                      如果超过这个范围计算结果无法确定，如果不是整数 ST(1)    </span><br><span class="line">                      会先向零舍入成整数再计算。所以为安全起见，最好是由字组整数载入到 ST(1) 里。  </span><br><span class="line">  </span><br><span class="line">FRNDINT               这个指令是把 ST 的数值舍入成整数，FPU提供四种舍入方式</span><br><span class="line">                      由 FPU 的控制字组(control word)中的 RC 两个位决定  </span><br><span class="line">                          RC    舍入控制  </span><br><span class="line">                          00    四舍五入  </span><br><span class="line">                          01    向负无限大舍入  </span><br><span class="line">                          10    向正无限大舍入  </span><br><span class="line">                          11    向零舍去  </span><br><span class="line">================================================================================</span><br></pre></td></tr></table></figure>
<h1 id="Intel-X86-CPU系列的寄存器"><a href="#Intel-X86-CPU系列的寄存器" class="headerlink" title="Intel X86 CPU系列的寄存器"></a>Intel X86 CPU系列的寄存器</h1><h2 id="32位CPU系统级寄存器和数据结构"><a href="#32位CPU系统级寄存器和数据结构" class="headerlink" title="32位CPU系统级寄存器和数据结构"></a>32位CPU系统级寄存器和数据结构</h2><p><img src="/2018/12/09/x86-assembly/image-67.png" width="400px"></p>
<h2 id="寄存器分类介绍"><a href="#寄存器分类介绍" class="headerlink" title="寄存器分类介绍"></a>寄存器分类介绍</h2><p>通用寄存器：8个，分别为EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI<br>标志寄存器：1个，EFLAGS<br>控制寄存器：5个，分别为CR0-CR4<br>调试寄存器：8个，分别为DR0-DR7<br>系统地址寄存器:4个，GDTR、IDTR、LDTR和TR<br>16位段寄存器：6个，分别为CS,DS,ES,FS,GS,SS<br>其他寄存器：EIP、TSC等</p>
<h2 id="寄存器详解"><a href="#寄存器详解" class="headerlink" title="寄存器详解"></a>寄存器详解</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><blockquote>
<p>通用寄存器:EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI</p>
</blockquote>
<ul>
<li>（1）尽管这8个通用寄存器大多时候是通用的，可以用作任何用途，但是在某些情况下，他们也有隐含的用法。</li>
</ul>
<p>比如ECX、ESI和EDI在串循环操作中分别用作计数器、源和目标。</p>
<p>EBP和ESP主要用来维护栈，ESP通常指向栈的顶部，EBP指向当前栈帧的起始地址。   </p>
<ul>
<li><p>（2）EAX, EBX, ECX, EDX都可以作为32位寄存器、16位寄存器或者8位寄存器使用。</p>
<ul>
<li><p>EAX可作为累加器用于乘法、除法及一些调整指令，对于这些指令，累加器常表现为隐含形式。</p>
</li>
<li><p>EAX寄存器也可以保存被访问存储器单元的偏移地址。</p>
</li>
<li><p>EBX常用于地址指针，保存被访问存储器单元的偏移地址。</p>
</li>
<li><p>ECX经常用作计数器，用于保存指令的 计数值。</p>
</li>
<li><p>ECX寄存器也可以保存访问数据所在存储器单元的偏移地址。用于计数的指令包括重复的串指令、移位指令和循环指令。移位指令用CL计数，重复的串 指令用CX计数，循环指令用CX或ECX计数。</p>
</li>
<li><p>EDX常与EAX配合，用于保存乘法形成的部分结果，或者除法操作前的被除数，它还可以保存寻址存储器数据。   </p>
</li>
</ul>
</li>
<li><p>（3）EBP和ESP是32位寄存器，也可作为16位寄存器BP, SP使用，常用于椎栈操作。  </p>
</li>
<li>（4）EDI和ESI常用于串操作，EDI用于寻址目标数据串，ESI用于寻址源数据串。   </li>
</ul>
<h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><blockquote>
<p>标志寄存器:EFLAGS  </p>
</blockquote>
<p>控制任务状态和模式切换、中断处理、指令追踪和访问权限控制.寄存器中的标志位需要特权指令代码才可以修改(特权指令:运行在内核态下的代码)   </p>
<ul>
<li>(1) EFLAGS寄存器的状态标志(0、2、4、6、7以及11位)指示算术指令（如ADD, SUB, MUL以及DIV指令）的结果，这些状态标志的作用如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CF(bit 0) [Carry flag]   若算术操作产生的结果在最高有效位(most-significant bit)发生进位或借位则将其置1，反之清零。这个标志指示无符号整型运算的溢出状态，这个标志同样在多倍精度运算(multiple-precision arithmetic)中使用。</span><br><span class="line"></span><br><span class="line">PF(bit 2) [Parity flag]   如果结果的最低有效字节(least-significant byte)包含偶数个1位则该位置1，否则清零。</span><br><span class="line"></span><br><span class="line">AF(bit 4) [Adjust flag]   如果算术操作在结果的第3位发生进位或借位则将该标志置1，否则清零。这个标志在BCD(binary-code decimal)算术运算中被使用。</span><br><span class="line"></span><br><span class="line">ZF(bit 6) [Zero flag]   若结果为0则将其置1，反之清零。</span><br><span class="line"></span><br><span class="line">SF(bit 7) [Sign flag]   该标志被设置为有符号整型的最高有效位。(0指示结果为正，反之则为负)</span><br><span class="line"></span><br><span class="line">OF(bit 11) [Overflow flag]   如果整型结果是较大的正数或较小的负数，并且无法匹配目的操作数时将该位置1，反之清零。这个标志为带符号整型运算指示溢出状态。</span><br></pre></td></tr></table></figure>
<ul>
<li>(2) DF(位于EFLAGS寄存器的第10位)控制串指令(MOVS, CMPS, SCAS, LODS以及STOS)。</li>
</ul>
<p>设置DF标志使得串指令自动递减（从高地址向低地址方向处理字符串），清除该标志则使得串指令自动递增。STD以及CLD指令分别用于设置以及清除DF标志。  </p>
<ul>
<li>(3) 系统标志以及IOPL域(System Flags and IOPL Field)<br>EFLAGS寄存器中的这部分标志用于控制操作系统或是执行操作，它们不允许被应用程序所修改。这些标志的作用如下：   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TF(bit 8) [Trap flag]   将该位设置为1以允许单步调试模式，清零则禁用该模式。</span><br><span class="line"></span><br><span class="line">IF(bit 9) [Interrupt enable flag]   该标志用于控制处理器对可屏蔽中断请求(maskable interrupt requests)的响应。置1以响应可屏蔽中断，反之则禁止可屏蔽中断。</span><br><span class="line"></span><br><span class="line">IOPL(bits 12 and 13) [I/O privilege level field]   指示当前运行任务的I/O特权级(I/O privilege level)，正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。</span><br><span class="line"></span><br><span class="line">NT(bit 14) [Nested task flag]   这个标志控制中断链和被调用任务。若当前任务与前一个执行任务相关则置1，反之则清零。</span><br><span class="line"></span><br><span class="line">RF(bit 16) [Resume flag]   控制处理器对调试异常的响应。</span><br><span class="line"></span><br><span class="line">VM(bit 17) [Virtual-8086 mode flag]   置1以允许虚拟8086模式，清除则返回保护模式。</span><br><span class="line"></span><br><span class="line">AC(bit 18) [Alignment check flag]   该标志以及在CR0寄存器中的AM位置1时将允许内存引用的对齐检查，以上两个标志中至少有一个被清零则禁用对齐检查。</span><br><span class="line"></span><br><span class="line">VIF(bit 19) [Virtual interrupt flag]   该标志是IF标志的虚拟镜像(Virtual image)，与VIP标志结合起来使用。使用这个标志以及VIP标志，并设置CR4控制寄存器中的VME标志就可以允许虚拟模式扩展(virtual mode extensions)</span><br><span class="line"></span><br><span class="line">VIP(bit 20) [Virtual interrupt pending flag]   该位置1以指示一个中断正在被挂起，当没有中断挂起时该位清零。【Software sets and clears this flag; the processor only reads it.】与VIF标志结合使用。</span><br><span class="line"></span><br><span class="line">ID(bit 21) [Identification flag]   程序能够设置或清除这个标志指示了处理器对CPUID指令的支持。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><blockquote>
<p>控制寄存器：CR0-CR4  </p>
</blockquote>
<p>作用:控制寄存器决定处理器的操作模式和当前执行任务的一些特征种类:  </p>
<ul>
<li>CR0: 控制系统的工作模式和处理器的状态</li>
<li>CR1: 保留</li>
<li>CR2 :保留出错的线性地址</li>
<li>CR3:页目录基址的物理地址和PCD和PWT标志位(和CACHE有关)</li>
<li>CR4:一些结构的扩展.表明对于特定的处理器和操作系统执行支持. </li>
</ul>
<p><img src="/2018/12/09/x86-assembly/image-68.png" width="400px">  </p>
<ul>
<li><p>CR0<br>PG:分页有效时,置位为1,清空时为0.与PE一同使用.该指令表明是否使用页表将线性地址转换成物理地址<br>CD: cache 缺失设置位<br>NW:直写无效(直写:高速缓存中的数据始终保持与主存储器中数据匹配 )<br>AM: 对齐功能屏蔽(与EFLAGS寄存器中 AC标志位一同使用)<br>WP:写保护<br>NE: 数字错误标志位(与浮点协处理器共同使用)<br>ET: 扩展类型.设置有效位时,支持 ntel 387 DX 数学协处理器指令.<br>TS: 每当任务切换时就设置该位,并且在解释协处理器指令之前测试该位<br>EM;该位表明是否需要仿真协处理器的功能<br>MP:协处理器监视标志位<br>PE: 保护模式使能,当设置有效位,CPU工作在保护模式.反之,实模式.</p>
</li>
<li><p>CR3:<br>PCD:控制当前页目录表的缓冲,当设置清空时,缓冲.置位时,缓冲无效.与CR0中的CD或PG一同使用<br>PWT:控制cache采取直写还是回写的策略.当设置清空时,回写有效.当置位时,直写有效.  </p>
</li>
<li><p>CR4:<br>VME:虚地址模式.当清空时,无效.<br>PVI:保护模式虚中断,当清空时,无效<br>TSD:时间戳允许标志位.当清空时,允许RDTSC指令执行在任务特权级上.当置位时,只允许工作在特权级0.<br>DE:调试扩展.置位,表明DR4与DR5将产生没有定义的异常<br>PSE:当置位,使用4M的页面;清空,使用4K的页面<br>PAE:置位,使用36物理内存的分页机制.清空时,使用32位分页机制<br>MCE:置位,使用机器检查异常机制.<br>PGE:置位,启动全局页面.当写CR3时,也不会被替换.<br>PCE:置位,表明使RDPMC指令工作在任何保护级别.<br>OSFXSR:置位.表明操作系统支持FXSAVE and FXRSTOR指令<br>OSXMMEXCPT:置位.表明操作系统支持不可屏蔽的SIMD浮点异常.</p>
</li>
</ul>
<h3 id="调试寄存器"><a href="#调试寄存器" class="headerlink" title="调试寄存器"></a>调试寄存器</h3><blockquote>
<p>调试寄存器：DR0-DR7 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调试寄存器主要作用是调试应用代码、系统代码、开发多任务操作系统.来监视代码的运行和处理器的性能.</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/09/x86-assembly/image-69.png" width="400px">  </p>
<ul>
<li>DR0-DR3:保留32位断点的线性地址.  </li>
<li>DR6<br>B0—B3:断点状态的监测<br>BD:调试寄存器访问监测.置位,表明在指令流中,下一条指令将访问其中的一个调试寄存器<br>BS:单步执行标志位<br>BT:任务转换标志位</li>
<li>DR7:<br>L0—L3:局部断点使能标志位<br>G0–G3: 全局断点使能标志位<br>LE AND GE:置位,表明处理器可以监测导致数据断点的指令.推荐置位为1.<br>GD:通用监测使能标志位.表明是否开启调试寄存器保护.<br>LEN0 through LEN3 : 用来表明相应断点地址寄存器内存位置的大小.<br>R/W0 through R/W3: 相应断点的状态</li>
</ul>
<h3 id="系统地址寄存器"><a href="#系统地址寄存器" class="headerlink" title="系统地址寄存器"></a>系统地址寄存器</h3><blockquote>
<p>系统地址寄存器:GDTR、IDTR、LDTR和TR  </p>
</blockquote>
<ul>
<li>(1) 全局描述符表寄存器GDTR，是一个48位寄存器，用来存放全局描述符表GDT的32位线性基地址和16位的界限值。在全局描述符表中不仅包括有操作系统使用的描述符，而且还有所有任务使用的公用描述符。  </li>
<li>(2) 中断描述符表寄存器IDTR，是一个48位寄存器，用来存放中断描述符表IDT的32位线性基地址和16位的界限值。  </li>
<li>(3) 局部描述符表寄存器LDTR，是一个16位寄存器，用来存放局部描述符表LDT的16位选择符。另外还有一个隐含的描述符高速缓冲寄存器，用来存放LDT表描述符。   </li>
<li>(4) 任务状态寄存器TR，是一个16位寄存器，用来存放任务状态段TSS的16位选择符。与之相应，也有一个隐含的描述符高速缓冲寄存器，用来存放任务状态段TSS的描述符。   </li>
</ul>
<h3 id="16位段寄存器：CS-DS-ES-FS-GS-SS"><a href="#16位段寄存器：CS-DS-ES-FS-GS-SS" class="headerlink" title="16位段寄存器：CS,DS,ES,FS,GS,SS"></a>16位段寄存器：CS,DS,ES,FS,GS,SS</h3><p>段寄存器有两部分，一部分是编程可见的选择器寄存器，为6个16位寄存器，对应在另一部分有6个64位的描述符寄存器，后一部分是编程不可见的。</p>
<p>在实地址方式或虚拟8086方式，描述符寄存器不起作用,选择器寄存器退化成16位CPU的段寄存器功能,存放内存段的段基址——段首地址的高16位，</p>
<ul>
<li>CS对应于代码段    </li>
<li>SS对应于堆栈段   </li>
<li>DS对应于数据段  </li>
<li>ES对应于附加数据段</li>
</ul>
<p>在串操作时DS和ES分别对应于源数据段和目的数据段。FS和GS没有定义。</p>
<h3 id="其他寄存器"><a href="#其他寄存器" class="headerlink" title="其他寄存器"></a>其他寄存器</h3><blockquote>
<p>其他寄存器：EIP、TSC     </p>
</blockquote>
<ul>
<li>(1）指令指针指示器–EIP</li>
</ul>
<p>它是32位寄存器，低16位称为IP，用与兼容16位CPU</p>
<p>其内容是下一条要取入CPU的指令在内存中的偏移地址。</p>
<p>当一个程序开始运行时，系统把EIP清零<br>每取入一条指令，EPI自动增加取入CPU的字节数目。所以称EIP为指令指针。   </p>
<ul>
<li>(2）时间戳寄存器–TSC</li>
</ul>
<p>每个时钟周期时其值加1，重启时清零。通过RDTSC指令读取TSC寄存器，只有当CR4寄存器的TSD位为0时，才可以在任何优先级下执行该指令，否则只能在特权级下执行该指令。   </p>
<ul>
<li>(3) 浮点寄存器</li>
</ul>
<p>由于在80486微处理器内部设有浮点运算器</p>
<p>因此在其内部有相应的寄存器  </p>
<p>其中包括8个80位通用数据寄存器、1个48位指令指针寄存器、1个48位数据指针寄存器、1个16位控制字寄存器、1个16位状态字寄存器和1个16位标记字寄存器。   </p>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>主要寄存器如下图所示：</p>
<p><img src="/2018/12/09/x86-assembly/image-01.png" width="500px">  </p>
<p>X86处理器中有8个32位的通用寄存器。</p>
<p>由于历史的原因</p>
<ul>
<li>EAX通常用于计算  </li>
<li>ECX通常用于循环变量计数  </li>
<li>ESP和EBP有专门用途，ESP指示栈指针(用于指示栈顶位置)</li>
<li>而EBP则是基址指针（用于指示子程序或函数调用的基址指针）。</li>
</ul>
<p>如图中所示，EAX、EBX、ECX和EDX的前两个高位字节和后两个低位字节可以独立使用</p>
<p>其中两位低字节又被独立分为H和L部分，这样做的原因主要是考虑兼容16位的程序，具体兼容匹配细节请查阅相关文献。</p>
<p>应用寄存器时，其名称大小写是不敏感的，如EAX和eax没有区别。  </p>
<h1 id="内存和寻址模式"><a href="#内存和寻址模式" class="headerlink" title="内存和寻址模式"></a>内存和寻址模式</h1><h2 id="声明静态数据区"><a href="#声明静态数据区" class="headerlink" title="声明静态数据区"></a>声明静态数据区</h2><p>可以在X86汇编语言中用汇编指令.DATA声明静态数据区（类似于全局变量）</p>
<p>数据以单字节、双字节、或双字（4字节）的方式存放，分别用DB,DW, DD指令表示声明内存的长度。</p>
<p>在汇编语言中，相邻定义的标签在内存中是连续存放的。</p>
<table>
<thead>
<tr>
<th>.DATA</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>var</td>
<td>DB 64</td>
<td>;声明一个字节，并将数值64放入此字节中</td>
</tr>
<tr>
<td>var2</td>
<td>DB ?</td>
<td>; 声明一个为初始化的字节.</td>
</tr>
<tr>
<td></td>
<td>DB 10</td>
<td>; 声明一个没有label的字节，其值为10.</td>
</tr>
<tr>
<td>X</td>
<td>DW ?</td>
<td>; <em>声明一个双字节，未初始化</em>.</td>
</tr>
<tr>
<td>Y</td>
<td>DD 30000</td>
<td>; 声明一个4字节，其值为30000.</td>
</tr>
</tbody>
</table>
<p>还可以声明连续的数据和数组，声明数组时使用DUP关键字</p>
<table>
<thead>
<tr>
<th>Z</th>
<th>DD 1, 2, 3</th>
<th>; Declare three 4-byte values, initialized to 1, 2, and 3. The value of location Z + 8 will be 3.</th>
</tr>
</thead>
<tbody>
<tr>
<td>bytes</td>
<td>DB 10 DUP(?)</td>
<td>; Declare 10 uninitialized bytes starting at location <em>bytes</em>.</td>
</tr>
<tr>
<td>arr</td>
<td>DD 100 DUP(0)</td>
<td>; Declare 100 4-byte words starting at location arr, all initialized to 0</td>
</tr>
<tr>
<td>str</td>
<td>DB ‘hello’,0</td>
<td>; Declare 6 bytes starting at the address str, initialized to the ASCII character values for hello and the null (0) byte.</td>
</tr>
</tbody>
</table>
<h2 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h2><p>现代X86处理器具有232字节的寻址空间。</p>
<p>在上面的例子中,我们用标签(label)表示内存区域,这些标签在实际汇编时,均被32位的实际地址代替。</p>
<p>除了支持这种直接的内存区域描述,X86还提供了一种灵活的内存寻址方式,  </p>
<p>即利用最多两个32位的寄存器和一个32位的有符号常数相加计算一个内存地址</p>
<p>其中一个寄存器可以左移1、2或3位以表述更大的空间。</p>
<p>下面例子是汇编程序中常见的方式  </p>
<blockquote>
<table>
<thead>
<tr>
<th>mov eax, [ebx]</th>
<th>; 将ebx值指示的内存地址中的4个字节传送到eax中</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov [var], ebx</td>
<td>; 将ebx的内容传送到var的值指示的内存地址中.</td>
</tr>
<tr>
<td>mov eax, [esi-4]</td>
<td>; 将esi-4值指示的内存地址中的4个字节传送到eax中</td>
</tr>
<tr>
<td>mov [esi+eax], cl</td>
<td>; 将cl的值传送到esi+eax的值指示的内存地址中</td>
</tr>
<tr>
<td>mov edx, [esi+4*ebx]</td>
<td>; 将esi+4*ebx值指示的内存中的4个字节传送到edx</td>
</tr>
</tbody>
</table>
</blockquote>
<p>下面是违反规则的例子:</p>
<table>
<thead>
<tr>
<th>mov eax, [ebx-ecx]</th>
<th>; 只能用加法</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov [eax+esi+edi], ebx</td>
<td>; 最多只能有两个寄存器参与运算</td>
</tr>
</tbody>
</table>
<h2 id="长度规定"><a href="#长度规定" class="headerlink" title="长度规定"></a>长度规定</h2><p>在声明内存大小时，在汇编语言中，一般用DB，DW，DD均可声明的内存空间大小  </p>
<p>这种现实声明能够很好地指导汇编器分配内存空间，但是，对于</p>
<p><code>mov [ebx], 2</code></p>
<p>如果没有特殊的标识，则不确定常数2是单字节、双字节，还是双字。  </p>
<p>对于这种情况，X86提供了三个指示规则标记</p>
<p>分别为<code>BYTE PTR</code>, <code>WORD PTR</code>, <code>and DWORD PTR</code></p>
<p>如上面例子写成：<code>mov BYTE PTR [ebx], 2， mov WORD PTR [ebx], 2， mov DWORD PTR [ebx], 2，</code> 则意思非常清晰。</p>
<h1 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h1><p>汇编指令通常可以分为数据传送指令、逻辑计算指令和控制流指令。本节将讲述其中最重要的指令，以下标记分别表示寄存器、内存和常数。</p>
<table>
<thead>
<tr>
<th><code>&lt;reg32&gt;</code></th>
<th>32位寄存器 (EAX, EBX, ECX, EDX, ESI, EDI, ESP, or EBP)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;reg16&gt;</code></td>
<td>16位寄存器 (AX, BX, CX, or DX)</td>
</tr>
<tr>
<td><code>&lt;reg8&gt;</code></td>
<td>8位寄存器(AH, BH, CH, DH, AL, BL, CL, or DL)</td>
</tr>
<tr>
<td><code>&lt;reg&gt;</code></td>
<td>任何寄存器</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&lt;mem&gt;</code></td>
<td>内存地址 (e.g., [eax], [var + 4], or dword ptr [eax+ebx])</td>
</tr>
<tr>
<td><code>&lt;con32&gt;</code></td>
<td>32为常数</td>
</tr>
<tr>
<td><code>&lt;con16&gt;</code></td>
<td>16位常数</td>
</tr>
<tr>
<td><code>&lt;con8&gt;</code></td>
<td>8位常数</td>
</tr>
<tr>
<td><code>&lt;con&gt;</code></td>
<td>任何8位、16位或32位常数</td>
</tr>
</tbody>
</table>
<h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><p><strong>mov</strong> — Move (Opcodes: 88, 89, 8A, 8B, 8C, 8E, …)</p>
<p>mov指令将第二个操作数（可以是寄存器的内容、内存中的内容或值）复制到第一个操作数（寄存器或内存）。mov不能用于直接从内存复制到内存，其语法如下所示：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">mov</span> &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line"><span class="keyword">mov</span> &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">mov</span> &lt;reg&gt;,&lt;const&gt;</span><br><span class="line"><span class="keyword">mov</span> &lt;mem&gt;,&lt;const&gt;</span><br></pre></td></tr></table></figure>
<p><em>案例</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span> — 将<span class="built_in">ebx</span>的值拷贝到<span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [var], <span class="number">5</span> — 将<span class="number">5</span>保存找var指示内存中的一个字节中</span><br></pre></td></tr></table></figure>
<p><strong>push</strong>— Push stack (Opcodes: FF, 89, 8A, 8B, 8C, 8E, …)</p>
<p>push指令将操作数压入内存的栈中，栈是程序设计中一种非常重要的数据结构，其主要用于函数调用过程中，其中ESP只是栈顶。在压栈前，首先将ESP值减4（X86栈增长方向与内存地址编号增长方向相反），然后将操作数内容压入ESP指示的位置。其语法如下所示：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> &lt;reg32&gt;</span><br><span class="line"><span class="keyword">push</span> &lt;mem&gt;</span><br><span class="line"><span class="keyword">push</span> &lt;con32&gt;</span><br></pre></td></tr></table></figure>
<p><em>案例</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="built_in">eax</span> — 将<span class="built_in">eax</span>内容压栈</span><br><span class="line"><span class="keyword">push</span> [var] — 将var指示的<span class="number">4</span>直接内容压栈</span><br></pre></td></tr></table></figure>
<p><strong>pop</strong>— Pop stack</p>
<p>pop指令与push指令相反，它执行的是出栈的工作。它首先将ESP指示的地址中的内容出栈，然后将ESP值加4. 其语法如下所示：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pop</span> &lt;reg32&gt;</span><br><span class="line"><span class="keyword">pop</span> &lt;mem&gt;</span><br></pre></td></tr></table></figure>
<p><em>案例</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pop</span> <span class="built_in">edi</span> — <span class="keyword">pop</span> the top element of the stack <span class="keyword">into</span> <span class="built_in">EDI</span>.</span><br><span class="line"><span class="keyword">pop</span> [<span class="built_in">ebx</span>] — <span class="keyword">pop</span> the top element of the stack <span class="keyword">into</span> memory <span class="meta">at</span> the four bytes starting <span class="meta">at</span> location <span class="built_in">EBX</span>.</span><br></pre></td></tr></table></figure>
<p><strong>lea</strong>— Load effective address</p>
<p> lea实际上是一个载入有效地址指令，将第二个操作数表示的地址载入到第一个操作数（寄存器）中。其语法如下所示：</p>
<p><em>语法</em><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lea</span> &lt;reg32&gt;,&lt;mem&gt;</span><br></pre></td></tr></table></figure></p>
<p><em>案例</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lea</span> <span class="built_in">eax</span>, [var] — var指示的地址载入<span class="built_in">eax</span>中.</span><br><span class="line"><span class="keyword">lea</span> <span class="built_in">edi</span>, [<span class="built_in">ebx</span>+<span class="number">4</span>*<span class="built_in">esi</span>] —</span><br></pre></td></tr></table></figure>
<p><code>ebx+4*esi</code>表示的地址载入到edi中，这实际是上面所说的寻址模式的一种表示方式</p>
<h2 id="算术和逻辑指令"><a href="#算术和逻辑指令" class="headerlink" title="算术和逻辑指令"></a>算术和逻辑指令</h2><p><strong>add</strong>— Integer Addition</p>
<p>add指令将两个操作数相加，且将相加后的结果保存到第一个操作数中。其语法如下所示：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span> &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">add</span> &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line"><span class="keyword">add</span> &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">add</span> &lt;reg&gt;,&lt;con&gt;</span><br><span class="line"><span class="keyword">add</span> &lt;mem&gt;,&lt;con&gt;</span><br></pre></td></tr></table></figure>
<p><em>案例</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">10</span> — <span class="built_in">EAX</span> ← <span class="built_in">EAX</span> + <span class="number">10</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">BYTE</span> <span class="built_in">PTR</span> [var], <span class="number">10</span> —</span><br></pre></td></tr></table></figure>
<p>10与var指示的内存中的一个byte的值相加，并将结果保存在var指示的内存中</p>
<p><strong>sub</strong>— Integer Subtraction</p>
<p>sub指令指示第一个操作数减去第二个操作数，并将相减后的值保存在第一个操作数，其语法如下所示：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sub</span> &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">sub</span> &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line"><span class="keyword">sub</span> &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">sub</span> &lt;reg&gt;,&lt;con&gt;</span><br><span class="line"><span class="keyword">sub</span> &lt;mem&gt;,&lt;con&gt;</span><br></pre></td></tr></table></figure></p>
<p><em>案例</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sub</span> <span class="built_in">al</span>, <span class="number">ah</span> — <span class="built_in">AL</span> ← <span class="built_in">AL</span> - <span class="number">AH</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">216</span> — <span class="built_in">eax</span>中的值减<span class="number">26</span>，并将计算值保存在<span class="built_in">eax</span>中</span><br></pre></td></tr></table></figure>
<p><strong>inc, dec</strong>— Increment, Decrement</p>
<p>inc,dec分别表示将操作数自加1，自减1，其语法如下所示：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inc</span> &lt;reg&gt;</span><br><span class="line"><span class="keyword">inc</span> &lt;mem&gt;</span><br><span class="line"><span class="keyword">dec</span> &lt;reg&gt;</span><br><span class="line"><span class="keyword">dec</span> &lt;mem&gt;</span><br></pre></td></tr></table></figure>
<p><em>案例</em><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dec</span> <span class="built_in">eax</span> — <span class="built_in">eax</span>中的值自减<span class="number">1</span>.</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [var] — *var指示内存中的一个<span class="number">4</span>-<span class="built_in">byte</span>值自加<span class="number">1</span>*</span><br></pre></td></tr></table></figure></p>
<p><strong>imul</strong>— Integer Multiplication</p>
<p>整数相乘指令，它有两种指令格式，一种为两个操作数，将两个操作数的值相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器；第二种格式为三个操作数，其语义为：将第二个和第三个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器。其语法如下所示：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">imul</span> &lt;reg32&gt;,&lt;reg32&gt;</span><br><span class="line"><span class="keyword">imul</span> &lt;reg32&gt;,&lt;mem&gt;</span><br><span class="line"><span class="keyword">imul</span> &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;</span><br><span class="line"><span class="keyword">imul</span> &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;</span><br></pre></td></tr></table></figure>
<p><em>案例</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">imul</span> <span class="built_in">eax</span>, [var] — <span class="built_in">eax</span>→ <span class="built_in">eax</span> * [var]</span><br><span class="line"></span><br><span class="line"><span class="keyword">imul</span> <span class="built_in">esi</span>, <span class="built_in">edi</span>, <span class="number">25</span> — <span class="built_in">ESI</span> → <span class="built_in">EDI</span> * <span class="number">25</span></span><br></pre></td></tr></table></figure>
<p><strong>idiv</strong>— Integer Division</p>
<p>idiv指令完成整数除法操作，idiv只有一个操作数，此操作数为除数，而被除数则为EDX:EAX中的内容（一个64位的整数），操作的结果有两部分：商和余数，其中商放在eax寄存器中，而余数则放在edx寄存器中。其语法如下所示：</p>
<p><em>语法</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">idiv</span> &lt;reg32&gt;</span><br><span class="line"><span class="keyword">idiv</span> &lt;mem&gt;</span><br></pre></td></tr></table></figure>
<p><em>案例</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">idiv</span> <span class="built_in">ebx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">idiv</span> <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [var]</span><br></pre></td></tr></table></figure>
<p><strong>and, or, xor</strong>— Bitwise logical and, or and exclusive or</p>
<p>逻辑与、逻辑或、逻辑异或操作指令，用于操作数的位操作，操作结果放在第一个操作数中。其语法如下所示：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">and</span> &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line"><span class="keyword">and</span> &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">and</span> &lt;reg&gt;,&lt;con&gt;</span><br><span class="line"><span class="keyword">and</span> &lt;mem&gt;,&lt;con&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span> &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">or</span> &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line"><span class="keyword">or</span> &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">or</span> &lt;reg&gt;,&lt;con&gt;</span><br><span class="line"><span class="keyword">or</span> &lt;mem&gt;,&lt;con&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">xor</span> &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">xor</span> &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line"><span class="keyword">xor</span> &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">xor</span> &lt;reg&gt;,&lt;con&gt;</span><br><span class="line"><span class="keyword">xor</span> &lt;mem&gt;,&lt;con&gt;</span><br></pre></td></tr></table></figure>
<p><em>案例</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="built_in">eax</span>, <span class="number">0fH</span> — 将<span class="built_in">eax</span>中的钱<span class="number">28</span>位全部置为<span class="number">0</span>，最后<span class="number">4</span>位保持不变.</span><br><span class="line"><span class="keyword">xor</span> <span class="built_in">edx</span>, <span class="built_in">edx</span> — 设置<span class="built_in">edx</span>中的内容为<span class="number">0</span>.</span><br></pre></td></tr></table></figure>
<p><strong>not</strong>— Bitwise Logical Not</p>
<p>位翻转指令，将操作数中的每一位翻转，即0-&gt;1, 1-&gt;0。其语法如下所示：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">not</span> &lt;reg&gt;</span><br><span class="line"><span class="keyword">not</span> &lt;mem&gt;</span><br></pre></td></tr></table></figure>
<p><em>案例</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">not</span> <span class="built_in">BYTE</span> <span class="built_in">PTR</span> [var] — *将var指示的一个字节中的所有位翻转*.</span><br></pre></td></tr></table></figure>
<p><strong>neg</strong>— Negate</p>
<p>取负指令。语法为：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">neg</span> &lt;reg&gt;</span><br><span class="line"><span class="keyword">neg</span> &lt;mem&gt;</span><br></pre></td></tr></table></figure>
<p><em>案例</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">neg</span> <span class="built_in">eax</span> — <span class="built_in">EAX</span> → - <span class="built_in">EAX</span></span><br></pre></td></tr></table></figure>
<p><strong>shl, shr</strong>— Shift Left, Shift Right</p>
<p>位移指令，有两个操作数，第一个操作数表示被操作数，第二个操作数指示位移的数量。其语法如下所示：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shl</span> &lt;reg&gt;,&lt;con8&gt;</span><br><span class="line"><span class="keyword">shl</span> &lt;mem&gt;,&lt;con8&gt;</span><br><span class="line"><span class="keyword">shl</span> &lt;reg&gt;,&lt;<span class="built_in">cl</span>&gt;</span><br><span class="line"><span class="keyword">shl</span> &lt;mem&gt;,&lt;<span class="built_in">cl</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">shr</span> &lt;reg&gt;,&lt;con8&gt;</span><br><span class="line"><span class="keyword">shr</span> &lt;mem&gt;,&lt;con8&gt;</span><br><span class="line"><span class="keyword">shr</span> &lt;reg&gt;,&lt;<span class="built_in">cl</span>&gt;</span><br><span class="line"><span class="keyword">shr</span> &lt;mem&gt;,&lt;<span class="built_in">cl</span>&gt;</span><br></pre></td></tr></table></figure>
<p><em>案例</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shl</span> <span class="built_in">eax</span>, <span class="number">1</span> — Multiply the value of <span class="built_in">EAX</span> by <span class="number">2</span> (if the most significant bit is <span class="number">0</span>)，左移<span class="number">1</span>位，相当于乘以<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">shr</span> <span class="built_in">ebx</span>, <span class="built_in">cl</span> — Store <span class="keyword">in</span> <span class="built_in">EBX</span> the floor of result of dividing the value of <span class="built_in">EBX</span> by <span class="number">2</span>*n* where *n* is the value <span class="keyword">in</span> <span class="built_in">CL</span></span><br></pre></td></tr></table></figure>
<h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><p>X86处理器维持着一个指示当前执行指令的指令指针（IP）</p>
<p>当一条指令执行后，此指针自动指向下一条指令。</p>
<p>IP寄存器不能直接操作，但是可以用控制流指令更新。</p>
<p>一般用标签（label）指示程序中的指令地址，在X86汇编代码中，可以在任何指令前加入标签。如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">ebp</span>+<span class="number">8</span>]</span><br><span class="line"><span class="symbol">begin:</span> <span class="keyword">xor</span> <span class="built_in">ecx</span>, <span class="built_in">ecx</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">esi</span>]</span><br></pre></td></tr></table></figure>
<p>如第二条指令用begin指示，这种标签的方法在某种程度上简化了汇编程序设计，控制流指令通过标签实现程序指令跳转。</p>
<p><strong>jmp</strong> — Jump</p>
<p>控制转移到label所指示的地址，（从label中取出执行执行），如下所示：</p>
<p><code>jmp &lt;label&gt;</code></p>
<p><em>案例</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span> begin — Jump to the instruction labeled begin.</span><br></pre></td></tr></table></figure>
<p><strong>jcondition</strong>— 条件条约 </p>
<p>条件转移指令，条件转移指令依据机器状态字中的一些列条件状态转移。</p>
<p>机器状态字中包括指示最后一个算数运算结果是否为0，运算结果是否为负数等。</p>
<p>机器状态字具体解释请见微机原理、计算机组成等课程。语法如下所示：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">je</span> &lt;label&gt; (jump when equal)</span><br><span class="line"><span class="keyword">jne</span> &lt;label&gt; (jump when <span class="keyword">not</span> equal)</span><br><span class="line"><span class="keyword">jz</span> &lt;label&gt; (jump when last result was <span class="meta">zero</span>)</span><br><span class="line"><span class="keyword">jg</span> &lt;label&gt; (jump when greater than)</span><br><span class="line"><span class="keyword">jge</span> &lt;label&gt; (jump when greater than <span class="keyword">or</span> equal to)</span><br><span class="line"><span class="keyword">jl</span> &lt;label&gt; (jump when less than)</span><br><span class="line"><span class="keyword">jle</span> &lt;label&gt;(jump when less than <span class="keyword">or</span> equal to)</span><br></pre></td></tr></table></figure>
<p><em>案例</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line"><span class="keyword">jle</span> done  ,</span><br></pre></td></tr></table></figure>
<p>如果eax中的值小于ebx中的值，跳转到done指示的区域执行，否则，执行下一条指令。</p>
<p><strong>cmp</strong>— Compare</p>
<p>cmp指令比较两个操作数的值，并根据比较结果设置机器状态字中的条件码。  </p>
<p>此指令与sub指令类似，但是cmp不用将计算结果保存在操作数中。其语法如下所示：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp</span> &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">cmp</span> &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">cmp</span> &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">cmp</span> &lt;reg&gt;,&lt;con&gt;</span><br></pre></td></tr></table></figure>
<p><em>案例</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp</span> <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [var], <span class="number">10</span></span><br><span class="line">jeq <span class="keyword">loop</span>,</span><br></pre></td></tr></table></figure>
<p>比较var指示的4字节内容是否为10，如果不是，则继续执行下一条指令，否则，跳转到loop指示的指令开始执行</p>
<p><strong>call</strong>, <strong>ret</strong>— 子程序调用或返回  </p>
<p>这两条指令实现子程序（过程、函数等意思）的调用及返回。</p>
<p>call指令首先将当前执行指令地址入栈，然后无条件转移到由标签指示的指令。</p>
<p>与其它简单的跳转指令不同，call指令保存调用之前的地址信息（当call指令结束后，返回到调用之前的地址）。</p>
<p>ret指令实现子程序的返回机制，ret指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。</p>
<p>call，ret是函数调用中最关键的两条指令。具体细节见下面一部分的讲解。语法为：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> &lt;label&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<h1 id="调用规则"><a href="#调用规则" class="headerlink" title="调用规则"></a>调用规则</h1><p>为了加强程序员之间的协作及简化程序开发进程，设定一个函数调用规则非常必要，函数调用规则规定函数调用及返回的规则</p>
<p>只要遵照这种规则写的程序均可以正确执行，从而程序员不必关心诸如参数如何传递等问题；</p>
<p>另一方面，在汇编语言中可以调用符合这种规则的高级语言所写的函数，从而将汇编语言程序与高级语言程序有机结合在一起。</p>
<p>调用规则分为两个方面，及调用者规则和被调用者规则</p>
<p>如一个函数A调用一个函数B，则A被称为调用者(Caller)，B被称为被调用者(Callee)。</p>
<p>下图显示一个调用过程中的内存中的栈布局：</p>
<p><img src="/2018/12/09/x86-assembly/image-02.png" alt=""></p>
<p>在X86中，栈增长方向与内存编号增长方向相反。</p>
<h2 id="调用者规则"><a href="#调用者规则" class="headerlink" title="调用者规则"></a>调用者规则</h2><p>调用者规则包括一系列操作，描述如下：</p>
<ul>
<li><p>1）在调用子程序之前，调用者应该保存一系列被设计为调用者保存的寄存器的值。调用者保存寄存器有eax，ecx，edx。由于被调用的子程序会修改这些寄存器，所以为了在调用子程序完成之后能正确执行，调用者必须在调用子程序之前将这些寄存器的值入栈。</p>
</li>
<li><p>2）在调用子程序之前，将参数入栈。参数入栈的顺序应该是从最后一个参数开始，如上图中parameter3先入栈。</p>
</li>
<li><p>3）利用call指令调用子程序。这条指令将返回地址放置在参数的上面，并进入子程序的指令执行。（子程序的执行将按照被调用者的规则执行）</p>
</li>
</ul>
<p>当子程序返回时，调用者期望找到子程序保存在eax中的返回地址。为了恢复调用子程序执行之前的状态，调用者应该执行以下操作：</p>
<ul>
<li><p>1）清除栈中的参数；</p>
</li>
<li><p>2）将栈中保存的eax值、ecx值以及edx值出栈，恢复eax、ecx、edx的值（当然，如果其它寄存器在调用之前需要保存，也需要完成类似入栈和出栈操作）</p>
</li>
</ul>
<blockquote>
<p>案例</p>
</blockquote>
<p>如下代码展示了一个调用子程序的调用者应该执行的操作。此汇编程序调用一个具有三个参数的函数_myFunc，其中第一个参数为eax，第二个参数为常数216，第三个参数为var指示的内存中的值。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> [var] <span class="comment">; Push last parameter first</span></span><br><span class="line"><span class="keyword">push</span> <span class="number">216</span>   <span class="comment">; Push the second parameter</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">eax</span>   <span class="comment">; Push first parameter last</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> _myFunc <span class="comment">; Call the function (assume C naming)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">esp</span>, <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>在调用返回时，调用者必须清除栈中的相应内容，在上例中，参数占有12个字节，为了消除这些参数，只需将ESP加12即可。</p>
<p> _myFunc的值保存在eax中，ecx和edx中的值也许已经被改变，调用者还必须在调用之前保存在栈中，并在调用结束之后，出栈恢复ecx和edx的值。</p>
<h2 id="被调用者规则"><a href="#被调用者规则" class="headerlink" title="被调用者规则"></a>被调用者规则</h2><p>被调用者应该遵循如下规则：</p>
<ul>
<li>1）将ebp入栈，并将esp中的值拷贝到ebp中，其汇编代码如下：</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">mov</span>  <span class="built_in">ebp</span>, <span class="built_in">esp</span></span><br></pre></td></tr></table></figure>
<p>上述代码的目的是保存调用子程序之前的基址指针，基址指针用于寻找栈上的参数和局部变量。当一个子程序开始执行时，基址指针保存栈指针指示子程序的执行。为了在子程序完成之后调用者能正确定位调用者的参数和局部变量，ebp的值需要返回。</p>
<ul>
<li><p>2）在栈上为局部变量分配空间。</p>
</li>
<li><p>3）保存callee-saved寄存器的值，callee-saved寄存器包括ebx,edi和esi，将ebx,edi和esi压栈。</p>
</li>
<li><p>4）在上述三个步骤完成之后，子程序开始执行，当子程序返回时，必须完成如下工作：</p>
<ul>
<li><p>4.1）将返回的执行结果保存在eax中</p>
</li>
<li><p>4.2）弹出栈中保存的callee-saved寄存器值，恢复callee-saved寄存器的值（ESI和EDI）</p>
</li>
<li><p>4.3）收回局部变量的内存空间。实际处理时，通过改变EBP的值即可：mov esp, ebp。 </p>
</li>
<li><p>4.4）通过弹出栈中保存的ebp值恢复调用者的基址寄存器值。</p>
</li>
<li><p>4.5）执行ret指令返回到调用者程序。</p>
</li>
</ul>
</li>
</ul>
<p>After these three actions are performed, the body of the subroutine may proceed. When the subroutine is returns, it must follow these steps:</p>
<p>Leave the return value in EAX.</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.486</span></span><br><span class="line"><span class="meta">.MODEL</span> FLAT</span><br><span class="line"><span class="meta">.CODE</span></span><br><span class="line"><span class="meta">PUBLIC</span> _myFunc</span><br><span class="line">_myFunc PROC</span><br><span class="line">  <span class="comment">; Subroutine Prologue</span></span><br><span class="line">  <span class="keyword">push</span> <span class="built_in">ebp</span>     <span class="comment">; Save the old base pointer value.</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ebp</span>, <span class="built_in">esp</span> <span class="comment">; Set the new base pointer value.</span></span><br><span class="line">  <span class="keyword">sub</span> <span class="built_in">esp</span>, <span class="number">4</span>   <span class="comment">; Make room for one 4-byte local variable.</span></span><br><span class="line">  <span class="keyword">push</span> <span class="built_in">edi</span>     <span class="comment">; Save the values of registers that the function</span></span><br><span class="line">  <span class="keyword">push</span> <span class="built_in">esi</span>     <span class="comment">; will modify. This function uses EDI and ESI.</span></span><br><span class="line">  <span class="comment">; (no need to save EBX, EBP, or ESP)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; Subroutine Body</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">8</span>]   <span class="comment">; Move value of parameter 1 into EAX</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">ebp</span>+<span class="number">12</span>]  <span class="comment">; Move value of parameter 2 into ESI</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">edi</span>, [<span class="built_in">ebp</span>+<span class="number">16</span>]  <span class="comment">; Move value of parameter 3 into EDI</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mov</span> [<span class="built_in">ebp</span>-<span class="number">4</span>], <span class="built_in">edi</span>   <span class="comment">; Move EDI into the local variable</span></span><br><span class="line">  <span class="keyword">add</span> [<span class="built_in">ebp</span>-<span class="number">4</span>], <span class="built_in">esi</span>   <span class="comment">; Add ESI into the local variable</span></span><br><span class="line">  <span class="keyword">add</span> <span class="built_in">eax</span>, [<span class="built_in">ebp</span>-<span class="number">4</span>]   <span class="comment">; Add the contents of the local variable</span></span><br><span class="line">                     <span class="comment">; into EAX (final result)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; Subroutine Epilogue </span></span><br><span class="line">  <span class="keyword">pop</span> <span class="built_in">esi</span>      <span class="comment">; Recover register values</span></span><br><span class="line">  <span class="keyword">pop</span>  <span class="built_in">edi</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">esp</span>, <span class="built_in">ebp</span> <span class="comment">; Deallocate local variables</span></span><br><span class="line">  <span class="keyword">pop</span> <span class="built_in">ebp</span> <span class="comment">; Restore the caller's base pointer value</span></span><br><span class="line">  <span class="keyword">ret</span></span><br><span class="line">_myFunc ENDP</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>子程序首先通过入栈的手段保存ebp，分配局部变量，保存寄存器的值。</p>
<p>在子程序体中，参数和局部变量均是通过ebp进行计算。</p>
<p>由于参数传递在子程序被调用之前，所以参数总是在ebp指示的地址的下方（在栈中）</p>
<p>因此，上例中的第一个参数的地址是ebp+8，第二个参数的地址是ebp+12，第三个参数的地址是ebp+16；</p>
<p>而局部变量在ebp指示的地址的上方</p>
<p>所有第一个局部变量的地址是ebp-4，而第二个这是ebp-8.</p>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2018/12/09/x86-assembly/';
        this.page.title = 'X86_32汇编语言解析';
        this.page.identifier = '2018/12/09/x86-assembly/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
