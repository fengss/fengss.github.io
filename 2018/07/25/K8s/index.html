<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Docker&amp;K8s | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="Docker Kubernetes ServiceMesher 云原生
DockerNameSpaces资源隔离
Linux的命名空间机制提供了以下七种不同的命名空间  




Namespace
系统调用参数
隔离内容




UTS
CLONE_NEWUTS
主机名与域名     


IPC
CLONE_NEWIPC
信号量、消息队列和共享内存   


PID
CLONE_NEWPID
进程编号  


Network
CLONE_NEWNET
网络设备、网络栈、端口等等   


M">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Golang</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">System</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">Reverse</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">BigData</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/ai">Math/AI</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/physical">Physical</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/life">生活规划</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mesos/">Mesos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scikit/">Scikit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SofaMesh/">SofaMesh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TroubleShoot/">TroubleShoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x64-Windows系统总结/">x64 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内网穿透/">内网穿透</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker"><span class="toc-number">1.</span> <span class="toc-text">Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NameSpaces资源隔离"><span class="toc-number">1.1.</span> <span class="toc-text">NameSpaces资源隔离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络"><span class="toc-number">1.2.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#libnetwork"><span class="toc-number">1.2.1.</span> <span class="toc-text">libnetwork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络模式"><span class="toc-number">1.2.2.</span> <span class="toc-text">网络模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主机模式"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">主机模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#容器模式"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">容器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#None模式"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">None模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#网桥模式"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">网桥模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VMware三种网络模式"><span class="toc-number">1.2.3.</span> <span class="toc-text">VMware三种网络模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bridged-桥接模式"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">Bridged(桥接模式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NAT-网络地址转换模式"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">NAT(网络地址转换模式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Host-Only模式"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">Host-Only模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CGroups-资源限制"><span class="toc-number">1.3.</span> <span class="toc-text">CGroups 资源限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AUFS-amp-amp-overlay2-文件存储"><span class="toc-number">1.4.</span> <span class="toc-text">AUFS &amp;&amp; overlay2 文件存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dockerfile"><span class="toc-number">2.</span> <span class="toc-text">Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile基本构成"><span class="toc-number">2.1.</span> <span class="toc-text">Dockerfile基本构成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker镜像基本操作命令"><span class="toc-number">2.2.</span> <span class="toc-text">Docker镜像基本操作命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-Compose"><span class="toc-number">3.</span> <span class="toc-text">Docker-Compose</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-Compose基本命令"><span class="toc-number">3.1.</span> <span class="toc-text">Docker-Compose基本命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker容器基本命令"><span class="toc-number">3.2.</span> <span class="toc-text">Docker容器基本命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubernetes"><span class="toc-number">4.</span> <span class="toc-text">Kubernetes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础架构"><span class="toc-number">4.1.</span> <span class="toc-text">基础架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本知识"><span class="toc-number">4.2.</span> <span class="toc-text">基本知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本概念"><span class="toc-number">4.3.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Master节点"><span class="toc-number">4.3.1.</span> <span class="toc-text">Master节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node节点"><span class="toc-number">4.3.2.</span> <span class="toc-text">Node节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Controller-Manager"><span class="toc-number">4.3.3.</span> <span class="toc-text">Controller-Manager</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Istio"><span class="toc-number">5.</span> <span class="toc-text">Istio</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Envoy"><span class="toc-number">5.1.</span> <span class="toc-text">Envoy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础"><span class="toc-number">5.1.1.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定制化"><span class="toc-number">5.1.2.</span> <span class="toc-text">定制化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#嵌入proxy-init作为InitContainer"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">嵌入proxy_init作为InitContainer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#嵌入proxy容器作为sidecar"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">嵌入proxy容器作为sidecar</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pilot"><span class="toc-number">5.2.</span> <span class="toc-text">Pilot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#整个流程"><span class="toc-number">5.2.1.</span> <span class="toc-text">整个流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现意义"><span class="toc-number">5.2.2.</span> <span class="toc-text">实现意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pilot-Agent"><span class="toc-number">5.2.3.</span> <span class="toc-text">Pilot-Agent</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mixer"><span class="toc-number">5.3.</span> <span class="toc-text">Mixer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mixer不足"><span class="toc-number">5.3.1.</span> <span class="toc-text">Mixer不足</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mixer的改进"><span class="toc-number">5.3.2.</span> <span class="toc-text">Mixer的改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mixer-Cache"><span class="toc-number">5.3.3.</span> <span class="toc-text">Mixer Cache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#属性"><span class="toc-number">5.3.3.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mixer-Cache设计之道"><span class="toc-number">5.3.3.2.</span> <span class="toc-text">Mixer Cache设计之道</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码解析"><span class="toc-number">6.</span> <span class="toc-text">源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pilot解析"><span class="toc-number">6.1.</span> <span class="toc-text">Pilot解析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">7.</span> <span class="toc-text">参考</span></a></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            Docker&amp;K8s
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2018/07/25/K8s/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-07-25T08:51:25.000Z" itemprop="datePublished">2018-07-25</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/K8s/">K8s</a>, <a class="article-tag-link" href="/tags/docker/">docker</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>Docker Kubernetes ServiceMesher 云原生<br><a id="more"></a></p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="NameSpaces资源隔离"><a href="#NameSpaces资源隔离" class="headerlink" title="NameSpaces资源隔离"></a>NameSpaces资源隔离</h2><blockquote>
<p><code>Linux</code>的命名空间机制提供了以下七种不同的命名空间  </p>
</blockquote>
<table>
<thead>
<tr>
<th>Namespace</th>
<th>系统调用参数</th>
<th>隔离内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>UTS</td>
<td>CLONE_NEWUTS</td>
<td>主机名与域名     </td>
</tr>
<tr>
<td>IPC</td>
<td>CLONE_NEWIPC</td>
<td>信号量、消息队列和共享内存   </td>
</tr>
<tr>
<td>PID</td>
<td>CLONE_NEWPID</td>
<td>进程编号  </td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>网络设备、网络栈、端口等等   </td>
</tr>
<tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>挂载点（文件系统）  </td>
</tr>
<tr>
<td>User</td>
<td>CLONE_NEWUSER</td>
<td>用户和用户组     </td>
</tr>
</tbody>
</table>
<p>通过这七个选项我们能在创建新的进程时设置新进程,应该在哪些资源上与宿主机器进行隔离。</p>
<p><code>ps</code>命令打印出当前操作系统中正在执行的进程,一个是<code>pid</code>为<code>1</code>的init 进程<br>另一个是<code>pid</code>为<code>2</code>的<code>kthreadd</code>进程<br>这两个进程都是被<code>Linux</code>中的上帝进程<code>idle</code>创建出来的    </p>
<ul>
<li>前者负责执行内核的一部分初始化工作和系统配置  </li>
<li>后者负责管理和调度其他的内核进程  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root         1     0  0 Jun08 ?        00:00:13 /usr/lib/systemd/systemd --system --deserialize 15</span><br><span class="line">root         2     0  0 Jun08 ?        00:00:00 [kthreadd]</span><br><span class="line">root         3     2  0 Jun08 ?        00:00:10 [ksoftirqd/0]</span><br><span class="line">root         5     2  0 Jun08 ?        00:00:00 [kworker/0:0H]</span><br></pre></td></tr></table></figure>
<p>而docker容器中却是如下    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@helloworld-v2-646d4bbdcd-gwdh2:/opt/microservices# ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 Jun09 ?        00:00:00 /bin/sh -c python app.py</span><br><span class="line">root         5     1  0 Jun09 ?        00:00:49 python app.py</span><br><span class="line">root        11     0  0 06:35 ?        00:00:00 /bin/bash</span><br><span class="line">root        16    11  0 06:35 ?        00:00:00 ps -ef</span><br></pre></td></tr></table></figure>
<p>容器是创建新进程时传入<code>CLONE_NEWPID</code>实现的,从而达到了<code>Linux</code>的命名空间实现进程的隔离,<code>Docker</code>容器内部的任意进程都对宿主机器的进程一无所知。</p>
<blockquote>
<p>如下是容器设置命名空间的方式    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">containerRouter.postContainersStart</span><br><span class="line">└── daemon.ContainerStart</span><br><span class="line">    └── daemon.createSpec</span><br><span class="line">        └── setNamespaces</span><br><span class="line">            └── setNamespace</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (daemon *Daemon) createSpec(c *container.Container) (*specs.Spec, error) &#123;</span><br><span class="line">    s := oci.DefaultSpec()</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">    if err := setNamespaces(daemon, &amp;s, c); err != nil &#123;</span><br><span class="line">        return nil, fmt.Errorf(&quot;linux spec namespaces: %v&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &amp;s, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func setNamespaces(daemon *Daemon, s *specs.Spec, c *container.Container) error &#123;</span><br><span class="line">    // user</span><br><span class="line">    // network</span><br><span class="line">    // ipc</span><br><span class="line">    // uts</span><br><span class="line"></span><br><span class="line">    // pid</span><br><span class="line">    if c.HostConfig.PidMode.IsContainer() &#123;</span><br><span class="line">        ns := specs.LinuxNamespace&#123;Type: &quot;pid&quot;&#125;</span><br><span class="line">        pc, err := daemon.getPidContainer(c)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return err</span><br><span class="line">        &#125;</span><br><span class="line">        ns.Path = fmt.Sprintf(&quot;/proc/%d/ns/pid&quot;, pc.State.GetPID())</span><br><span class="line">        setNamespace(s, ns)</span><br><span class="line">    &#125; else if c.HostConfig.PidMode.IsHost() &#123;</span><br><span class="line">        oci.RemoveNamespace(s, specs.LinuxNamespaceType(&quot;pid&quot;))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ns := specs.LinuxNamespace&#123;Type: &quot;pid&quot;&#125;</span><br><span class="line">        setNamespace(s, ns)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>setNamespaces</code>方法中不仅会设置进程相关的命名空间，还会设置与<code>用户</code>、<code>网络</code>、<code>IPC</code> 以及 <code>UTS</code> 相关的命名空间        </p>
<p><br></p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><blockquote>
<p> <code>Docker</code>的容器通过<code>Linux</code>的命名空间完成了与宿主机进程的网络隔离,但是<code>Docker</code>中的服务仍然需要与外界相连才能发挥作用    </p>
</blockquote>
<h3 id="libnetwork"><a href="#libnetwork" class="headerlink" title="libnetwork"></a>libnetwork</h3><p>整个网络部分的功能都是通过<code>Docker</code>拆分出来的<code>libnetwork</code>实现的,它提供了一个连接不同容器的实现,同时也能够为应用给出一个能够提供一致的编程接口和网络层抽象的容器网络模型。    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">libnetwork中最重要的概念,容器网络模型由以下的几个主要组件组成,分别是 Sandbox、Endpoint 和 Network    </span><br><span class="line"></span><br><span class="line">在容器网络模型中,每一个容器内部都包含一个 Sandbox,其中存储着当前容器的网络栈配置,包括容器的接口、路由表和 DNS 设置</span><br><span class="line">Linux 使用网络命名空间实现这个 Sandbox,每一个 Sandbox 中都可能会有一个或多个 Endpoint</span><br><span class="line">在 Linux 上就是一个虚拟的网卡 veth，Sandbox 通过 Endpoint 加入到对应的网络中</span><br><span class="line">这里的网络可能就是我们在上面提到的 Linux 网桥或者 VLAN。</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h3><p><code>Docker</code>为我们提供了四种不同的网络模式:<code>Host</code>、<code>Container</code>、<code>None</code> 和 <code>Bridge</code> 模式    </p>
<h4 id="主机模式"><a href="#主机模式" class="headerlink" title="主机模式"></a>主机模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">众所周知，Docker使用了Linux的Namespaces技术来进行资源隔离，</span><br><span class="line">如PID Namespace隔离进程Mount Namespace隔离文件系统,Network Namespace隔离网络等。</span><br><span class="line">一个Network Namespace提供了一份独立的网络环境，</span><br><span class="line">包括网卡、路由、Iptable规则等都与其他的Network Namespace隔离。</span><br><span class="line">一个Docker容器一般会分配一个独立的Network Namespace。</span><br><span class="line">但如果启动容器的时候使用host模式，</span><br><span class="line">那么这个容器将不会获得一个独立的Network Namespace，</span><br><span class="line">而是和宿主机共用一个Network Namespace。</span><br><span class="line">容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</span><br><span class="line"></span><br><span class="line">例如，我们在10.10.101.105/24的机器上用host模式启动一个含有web应用的Docker容器，监听tcp80端口。</span><br><span class="line">当我们在容器中执行任何类似ifconfig命令查看网络环境时，看到的都是宿主机上的信息。</span><br><span class="line">而外界访问容器中的应用，则直接使用10.10.101.105:80即可</span><br><span class="line">不用任何NAT转换，就如直接跑在宿主机中一样。</span><br><span class="line">但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</span><br></pre></td></tr></table></figure>
<h4 id="容器模式"><a href="#容器模式" class="headerlink" title="容器模式"></a>容器模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在理解了host模式后，这个模式也就好理解了。</span><br><span class="line">这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。</span><br><span class="line">新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。</span><br><span class="line">同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</span><br><span class="line">两个容器的进程可以通过lo网卡设备通信。</span><br></pre></td></tr></table></figure>
<h4 id="None模式"><a href="#None模式" class="headerlink" title="None模式"></a>None模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个模式和前两个不同。在这种模式下，Docker容器拥有自己的Network Namespace，</span><br><span class="line">但是，并不为Docker容器进行任何网络配置。</span><br><span class="line">也就是说，这个Docker容器没有网卡、IP、路由等信息。</span><br><span class="line">需要我们自己为Docker容器添加网卡、配置IP等。</span><br></pre></td></tr></table></figure>
<h4 id="网桥模式"><a href="#网桥模式" class="headerlink" title="网桥模式"></a>网桥模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bridge模式是Docker默认的网络设置，</span><br><span class="line">此模式会为每一个容器分配Network Namespace、设置IP等，</span><br><span class="line">并将一个主机上的Docker容器连接到一个虚拟网桥上。</span><br></pre></td></tr></table></figure>
<h3 id="VMware三种网络模式"><a href="#VMware三种网络模式" class="headerlink" title="VMware三种网络模式"></a>VMware三种网络模式</h3><h4 id="Bridged-桥接模式"><a href="#Bridged-桥接模式" class="headerlink" title="Bridged(桥接模式)"></a>Bridged(桥接模式)</h4><blockquote>
<p>特点</p>
</blockquote>
<p>虚拟机和主机是处于同等地位的机器，所以网络功能也无异于主机。并且和主机处于同一网段。</p>
<p><img src="/2018/07/25/K8s/image-01.png" alt="img"></p>
<blockquote>
<p> 虚拟机配置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=&quot;eth0&quot;</span><br><span class="line">BOOTPROTO=“static&quot; #设置静态ip,动态为dhcp</span><br><span class="line">IPADDR=&quot;192.168.1.3&quot;</span><br><span class="line">GATEWAY=&quot;192.168.1.1&quot;</span><br><span class="line">HWADDR=&quot;08:00:27:C7:1B:22&quot;</span><br><span class="line">DNS1=&quot;8.8.8.8&quot;</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大致原理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在这种模式下，VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机</span><br><span class="line">它可以访问网内任何一台机器，你需要手工为虚拟系统配置IP地址、子网掩码，</span><br><span class="line">而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信，</span><br><span class="line">虚拟系统和宿主机器的关系，就像连接在同一个Hub上的两台电脑。</span><br><span class="line">从网络技术上理解相当于在宿主机前端加设了一个虚拟交换机，然后宿主机和所有虚拟机共享这个交换机。</span><br><span class="line"></span><br><span class="line">如果你想利用VMWare在局域网内新建一个虚拟服务器，为局域网用户提供网络服务，就应该选择桥接模式。</span><br></pre></td></tr></table></figure>
<h4 id="NAT-网络地址转换模式"><a href="#NAT-网络地址转换模式" class="headerlink" title="NAT(网络地址转换模式)"></a>NAT(网络地址转换模式)</h4><blockquote>
<p> 特点</p>
</blockquote>
<ul>
<li>主机ping不通虚拟机(包括宿主)</li>
<li>同一宿主的虚拟机可以相互ping通</li>
<li>宿主能够联网,虚拟机也能联网(其他主机)。宿主没有联网，虚拟机也不能联网</li>
<li>虚拟机能够ping通主机其他主机不能访问虚拟机</li>
</ul>
<p><img src="/2018/07/25/K8s/image-02.png" alt="img"></p>
<blockquote>
<p>虚拟机配置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=&quot;eth0&quot;</span><br><span class="line">BOOTPROTO=“static&quot; #设置静态ip,动态为dhcp</span><br><span class="line">IPADDR=&quot;10.0.2.5&quot;</span><br><span class="line">GATEWAY=&quot;10.0.2.1&quot;</span><br><span class="line">HWADDR=&quot;08:00:27:C7:1B:22&quot;</span><br><span class="line">DNS1=&quot;10.0.2.1&quot;</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 大致原理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用NAT模式,就是让虚拟系统借助NAT的功能,通过宿主机所在的网络来访问公网。</span><br><span class="line">在这种模式下宿主机成为双网卡主机,同时参与现有的宿主局域网和新建的虚拟局域网</span><br><span class="line">但由于加设了一个虚拟的NAT服务器，使得虚拟局域网内的虚拟机在对外访问时</span><br><span class="line">使用的则是宿主机的IP地址，这样从外部网络来看，只能看到宿主机，完全看不到新建的虚拟局域网。</span><br><span class="line"></span><br><span class="line">采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置</span><br><span class="line">只需要宿主机器能访问互联网即可。</span><br><span class="line"></span><br><span class="line">如果你想利用VMWare安装一个新的虚拟系统</span><br><span class="line">在虚拟系统中不用进行任何手工配置就能直接访问互联网，建议你采用NAT模式。</span><br></pre></td></tr></table></figure>
<h4 id="Host-Only模式"><a href="#Host-Only模式" class="headerlink" title="Host-Only模式"></a>Host-Only模式</h4><blockquote>
<p> 特点</p>
</blockquote>
<p>只能和主机相互通信，不能上网，也不能访问其他主机，用于建立与外部隔离的网络环境</p>
<p><img src="/2018/07/25/K8s/image-03.png" alt="img"></p>
<blockquote>
<p> 虚拟机配置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=&quot;eth0&quot;</span><br><span class="line">BOOTPROTO=“static&quot; #设置静态ip,动态为dhcp</span><br><span class="line">IPADDR=&quot;192.168.56.3&quot;</span><br><span class="line">HWADDR=&quot;08:00:27:C7:1B:22&quot;</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大致原理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在Host-Only模式下，虚拟网络是一个全封闭的网络</span><br><span class="line">它唯一能够访问的就是主机,通过过主机上的VMwareNetwork Adepter VMnet1虚拟网卡直接连接到VMnet1虚拟交换机上</span><br><span class="line">与虚拟网卡进行通信，实现主机和虚拟机的通信。</span><br><span class="line">其实Host-Only网络和NAT网络很相似，不同的地方就是 Host-Only网络没有NAT服务，</span><br><span class="line">所以虚拟网络不能连接到Internet。</span><br></pre></td></tr></table></figure>
<h2 id="CGroups-资源限制"><a href="#CGroups-资源限制" class="headerlink" title="CGroups 资源限制"></a>CGroups 资源限制</h2><blockquote>
<p>目前越来越火的轻量级容器<code>Docker</code>就使用了<code>cgroups</code>提供的资源限制能力来完成cpu,内存等部分的资源控制。<br>每一个<code>CGroup</code>都是一组被相同的标准和参数限制的进程,不同的<code>CGroup</code>之间是有层级关系的<br>也就是说它们之间可以从父类继承一些用于限制资源使用的标准和参数。       </p>
</blockquote>
<p>cgroups 的全称是control groups，cgroups为每种可以控制的资源定义了一个子系统。典型的子系统介绍如下：</p>
<p>cpu 子系统,主要限制进程的 cpu 使用率。  </p>
<ul>
<li><code>cpuacct</code> 子系统，可以统计 cgroups 中的进程的 cpu 使用报告。</li>
<li><code>cpuset</code> 子系统，可以为 cgroups 中的进程分配单独的 cpu 节点或者内存节点。</li>
<li><code>memory</code> 子系统，可以限制进程的 memory 使用量。</li>
<li><code>blkio</code> 子系统，可以限制进程的块设备 io。</li>
<li><code>devices</code> 子系统，可以控制进程能够访问某些设备。</li>
<li><code>net_cls</code> 子系统，可以标记 cgroups 中进程的网络数据包，然后可以使用 tc 模块（traffic control）对数据包进行控制。</li>
<li><code>freezer</code> 子系统，可以挂起或者恢复 cgroups 中的进程。</li>
<li><code>ns</code> 子系统，可以使不同 cgroups 下面的进程使用不同的 namespace。</li>
</ul>
<p><br></p>
<h2 id="AUFS-amp-amp-overlay2-文件存储"><a href="#AUFS-amp-amp-overlay2-文件存储" class="headerlink" title="AUFS &amp;&amp; overlay2 文件存储"></a>AUFS &amp;&amp; overlay2 文件存储</h2><p><code>UnionFS</code>其实是一种为<code>Linux</code>操作系统设计的用于把多个文件系统『联合』到同一个挂载点的文件系统服务。而<code>AUFS</code>即 Advanced UnionFS 其实就是 UnionFS 的升级版,它能够提供更优秀的性能和效率。    </p>
<p><code>AUFS</code>作为联合文件系统，它能够将不同文件夹中的层联合<code>Union</code>到了同一个文件夹中,这些文件夹在<code>AUFS</code>中称作分支   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每一个镜像层都是建立在另一个镜像层之上的,同时所有的镜像层都是只读的</span><br><span class="line">只有每个容器最顶层的容器层才可以被用户直接读写</span><br><span class="line">所有的容器都建立在一些底层服务（Kernel）上</span><br><span class="line">包括命名空间、控制组、rootfs 等等</span><br><span class="line">这种容器的组装方式提供了非常大的灵活性,只读的镜像层通过共享也能够减少磁盘的占用。</span><br></pre></td></tr></table></figure>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="Dockerfile基本构成"><a href="#Dockerfile基本构成" class="headerlink" title="Dockerfile基本构成"></a>Dockerfile基本构成</h2><table>
<thead>
<tr>
<th>四部分</th>
<th>指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础镜像信息</td>
<td>FROM</td>
</tr>
<tr>
<td>维护者信息</td>
<td>MAINTAINER</td>
</tr>
<tr>
<td>镜像操作指令</td>
<td>WORKDIR、RUN、COPY、ADD、EXPOSE等</td>
</tr>
<tr>
<td>容器执行命令</td>
<td>CMD、ENTRYPOINT</td>
</tr>
</tbody>
</table>
<p>•ADD</p>
<p>ADD命令有两个参数，源和目标。它的基本作用是从源系统的文件系统上复制文件到目标容器的文件系统。如果源是一个URL，那该URL的内容将被下载并复制到容器中。</p>
<p>•USER</p>
<p>使用哪个用户跑container</p>
<p>•VOLUME</p>
<p>VOLUME [“/data”] 创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p>
<p>•RUN</p>
<p>安装软件用</p>
<p>•CMD</p>
<p>container启动时执行的命令,但是一个Dockerfile中只能有一条CMD命令,多条则只执行最后一条CMD.</p>
<p>和RUN不同的是,这些命令不是在镜像构建的过程中执行的,而是在用镜像构建容器后被调用。</p>
<p>•ENTRYPOINT</p>
<p>container启动时执行的命令，但是一个Dockerfile中只能有一条ENTRYPOINT命令，如果多条，则只执行最后一条</p>
<p>CMD/ENTRYPOINT两个共同点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">都可以指定shell或exec函数调用的方式执行命令;</span><br><span class="line"></span><br><span class="line">当存在多个CMD指令或ENTRYPOINT指令时,只有最后一个生效;</span><br></pre></td></tr></table></figure>
<p>CMD/ENTRYPOINT两个差异点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">差异1：CMD指令指定的容器启动时命令可以被docker run指定的命令覆盖，而ENTRYPOINT指令指定的命令不能被覆盖，而是将docker run指定的参数当做ENTRYPOINT指定命令的参数。</span><br><span class="line"></span><br><span class="line">差异2：CMD指令可以为ENTRYPOINT指令设置默认参数，而且可以被docker run指定的参数覆盖;</span><br></pre></td></tr></table></figure>
<h2 id="Docker镜像基本操作命令"><a href="#Docker镜像基本操作命令" class="headerlink" title="Docker镜像基本操作命令"></a>Docker镜像基本操作命令</h2><ul>
<li>docker tag</li>
</ul>
<p>docker tag : 标记本地镜像，将其归入某一仓库。</p>
<p>docker tag ubuntu:15.10 runoob/ubuntu:v3 </p>
<ul>
<li>docker build</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-m :设置内存最大值;</span><br><span class="line">--ulimit :Ulimit配置。</span><br></pre></td></tr></table></figure>
<p>docker build : 使用Dockerfile创建镜像。</p>
<p>docker build -t runoob/ubuntu:v1 . </p>
<ul>
<li>docker commit</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-a :提交的镜像作者;</span><br><span class="line">-c :使用Dockerfile指令来创建镜像;</span><br><span class="line">-m :提交时的说明文字;</span><br><span class="line">-p :在commit时，将容器暂停。</span><br></pre></td></tr></table></figure>
<p>docker commit :从容器创建一个新的镜像。</p>
<p>docker commit -a “runoob.com” -m “my apache” a404c6c174a2 mymysql:v1 </p>
<ul>
<li>docker push</li>
</ul>
<p>docker push yourdomain.com/myproject/myrepo:mytag</p>
<ul>
<li>docker login</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-u :登陆的用户名</span><br><span class="line">-p :登陆的密码</span><br></pre></td></tr></table></figure>
<p>docker login yourdomain.com -u 用户名 -p 密码 </p>
<ul>
<li>docker pull</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-a :拉取所有 tagged 镜像</span><br><span class="line">--disable-content-trust :忽略镜像的校验,默认开启</span><br></pre></td></tr></table></figure>
<p>docker pull yourdomain.com/myproject/myrepo:mytag</p>
<ul>
<li>docker search </li>
</ul>
<p>docker search -s 10 java </p>
<p>//从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像</p>
<p><br></p>
<p><br></p>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker-Compose"></a>Docker-Compose</h1><p>Docker Compose是一个用来定义和运行复杂应用的Docker工具。</p>
<p>一个使用Docker容器的应用,通常由多个容器组成。</p>
<p>使用Docker Compose不再需要使用shell脚本来启动容器。 </p>
<p><img src="/2018/07/25/K8s/image-04.png" alt="image-20180802101513858"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java-web能够访问同front-net的网络</span><br><span class="line"></span><br><span class="line">Java-backend能够访问同backend-net的网络</span><br><span class="line"></span><br><span class="line">Java-all能够访问front-net和backend-net网络</span><br></pre></td></tr></table></figure>
<h2 id="Docker-Compose基本命令"><a href="#Docker-Compose基本命令" class="headerlink" title="Docker-Compose基本命令"></a>Docker-Compose基本命令</h2><ul>
<li>build</li>
</ul>
<p>构建项目中的服务容器。</p>
<p>Docker-compose文件有相关build&amp;dockerfile参数指定Dockerfile</p>
<p>并在service中直接用image和tag命名</p>
<ul>
<li>down</li>
</ul>
<p>此命令将会停止 up 命令所启动的容器，并移除网络</p>
<ul>
<li>exec</li>
</ul>
<p>进入指定的容器。</p>
<ul>
<li>help</li>
</ul>
<p>获得一个命令的帮助。</p>
<ul>
<li>images</li>
</ul>
<p>列出 Compose 文件中包含的镜像。</p>
<ul>
<li>kill</li>
</ul>
<p>通过发送 SIGKILL 信号来强制停止服务容器。</p>
<p>支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。</p>
<ul>
<li>pause</li>
</ul>
<p>暂停一个服务容器。</p>
<ul>
<li>port</li>
</ul>
<p>打印某个容器端口所映射的公共端口。</p>
<ul>
<li>ps</li>
</ul>
<p>列出项目中目前的所有容器。</p>
<ul>
<li>pull</li>
</ul>
<p>拉取服务依赖的镜像。</p>
<ul>
<li>push</li>
</ul>
<p>推送服务依赖的镜像到 Docker 镜像仓库。</p>
<ul>
<li>start</li>
</ul>
<p>格式为 docker-compose start [SERVICE…]。</p>
<p>启动已经存在的服务容器。</p>
<ul>
<li>stop</li>
</ul>
<p>停止已经处于运行状态的容器,但不删除它。通过 docker-compose start 可以再次启动这些容器。</p>
<ul>
<li>run</li>
</ul>
<p>在指定服务上执行一个命令。</p>
<ul>
<li>restart</li>
</ul>
<p>重启项目中的服务。rm</p>
<p>删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。</p>
<ul>
<li>top</li>
</ul>
<p>查看各个服务容器内运行的进程。</p>
<ul>
<li>unpause</li>
</ul>
<p>恢复处于暂停状态中的服务。</p>
<ul>
<li>up</li>
</ul>
<p>它将尝试自动完成包括构建镜像,(重新)创建服务,启动服务,并关联服务相关容器的一系列操作。</p>
<ul>
<li>scale</li>
</ul>
<p>设置服务的个数.</p>
<h2 id="Docker容器基本命令"><a href="#Docker容器基本命令" class="headerlink" title="Docker容器基本命令"></a>Docker容器基本命令</h2><ul>
<li><p>docker ps</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-a :全部</span><br><span class="line"></span><br><span class="line">-l :显示最近创建的容器。</span><br><span class="line"></span><br><span class="line">-n :列出最近创建的n个容器。</span><br><span class="line"></span><br><span class="line">-a -s :多显示总的文件大小。</span><br><span class="line"></span><br><span class="line">-a -q :静默模式,只显示容器编号。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>docker inspect</li>
</ul>
<p>获取容器/镜像的元数据。</p>
<ul>
<li>docker top</li>
</ul>
<p>docker top :查看容器中运行的进程信息，支持 ps 命令参数。</p>
<ul>
<li>docker attach</li>
</ul>
<p>docker attach :连接到正在运行中的容器。</p>
<p>attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器</p>
<ul>
<li>docker exec</li>
</ul>
<p>•-i: 以交互模式运行容器，通常与 -t 同时使用;</p>
<p>•-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用;</p>
<ul>
<li>docker export</li>
</ul>
<p>docker export &gt; my_container.tar</p>
<p>docker export : 导出容器export</p>
<p>export命令用于持久化容器（不是镜像）。所以，我们就需要通过以下方法得到容器ID：</p>
<p>sudo docker export &gt; /home/export.tar</p>
<p>Save命令用于持久化镜像（不是容器）。所以，我们就需要通过以下方法得到镜像名称： sudo docker save busybox-1 &gt; /home/save.tar</p>
<ul>
<li>docker import</li>
</ul>
<p>docker import my_ubuntu_v3.tar runoob/ubuntu:v4</p>
<p>docker import : 从归档文件中创建镜像。</p>
<ul>
<li>docker run</li>
</ul>
<ul>
<li>docker create</li>
</ul>
<p>参数同docker run但是与docker run不同的是,docker create创建的容器并未实际启动,还需要执行docker start命令</p>
<ul>
<li>docker start</li>
</ul>
<p>docker start CONTAINER</p>
<p>start 启动一个已经被停止的容器</p>
<ul>
<li>docker stop</li>
</ul>
<p>•-t,–time=10:等待十秒后去停止</p>
<ul>
<li>docker kill</li>
</ul>
<p>•-s :向容器发送一个信号docker kill -s KILL mynginx </p>
<ul>
<li>docker rm </li>
</ul>
<p>删除一个或多少容器 </p>
<ul>
<li>docker pause/unpause</li>
</ul>
<p>暂停数据库容器db01提供服务。docker pause db01 </p>
<p>恢复数据库容器db01提供服务。docker unpause db01</p>
<p><br></p>
<p><br></p>
<h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><blockquote>
<p>抽象版      </p>
</blockquote>
<p><img src="/2018/07/25/K8s/image-05.png" alt="Kubernetes"></p>
<blockquote>
<p>完整版    </p>
</blockquote>
<p><img src="/2018/07/25/K8s/image-06.png" alt="Kuberentes"></p>
<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">K8s提供了完备的容器集群管理平台</span><br><span class="line">包括多层次的安全防护,准入机制,多租户应用支撑能力,透明的服务注册和服务发现机制,</span><br><span class="line">强大的故障发现和自我修复能力,服务滚动升级和在线扩容能力,</span><br><span class="line">可扩展的资源自动调度机制以及多粒度的资源配额管理能力</span><br><span class="line"></span><br><span class="line">K8s中Service为核心,一个Service有如下关键特征</span><br><span class="line">1:拥有一个唯一指定的名字</span><br><span class="line">2:拥有一个虚拟IP(ClusterIp,ServiceIp或VIP)和端口号</span><br><span class="line">3:能够提供某种远程服务能力</span><br><span class="line">4:被映射到了提供这种服务能力的一组容器应用上</span><br><span class="line"></span><br><span class="line">虽然一个Service通常由多个相关的服务进程提供服务,</span><br><span class="line">每个服务进程都有一个独立的Endpoint(IP+Port)访问点</span><br><span class="line">K8s可以通过Service链接到指定的服务上,不需要为服务的IP地址变换而头疼</span><br><span class="line"></span><br><span class="line">容器提供强大的隔离功能,所以有必要为Service提供服务的进程组放入容器进行隔离</span><br><span class="line">为此有了Pod对象,每个服务进程包裹到相应的Pod中</span><br><span class="line">为了建立Service和Pod间的关联关系,K8s首先给每个Pod贴上一个标签</span><br><span class="line">例如mysql的pod贴上name=mysql,</span><br><span class="line">结合Service定义标签选择权(Lable Selector)就巧妙解决Service与Pod的关联问题</span><br><span class="line"></span><br><span class="line">每个Pod运行一个Pause容器,其他容器则为业务容器,</span><br><span class="line">业务容器共享Pause容器的网络栈和Volume挂载卷</span><br><span class="line">因此它们之间的通信和数据交换更为高效</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">集群管理上k8s将机器划分一个Master节点和一群工作节点Node</span><br><span class="line">Master上运行一组进程Kube-apiserver,Kube-controller-manager,Kube-schedule</span><br><span class="line">这些进程实现了整个集群的资源管理,Pod调度,弹性伸缩,安全控制,系统监控和纠错等管理功能</span><br><span class="line">Node作为集群的工作节点,运行真正的应用程序,Node上最小运行单元为Pod,</span><br><span class="line">并且还运行着Kubelet,Kube-proxy服务进程</span><br><span class="line">这些服务负责Pod的创建,启动,监控,重启,销毁,以及实现软件模式的均衡负载器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">服务扩容和升级</span><br><span class="line">在k8s集群,你只需要为扩容的Service关联的pod创建一个RC(Replication Controller),</span><br><span class="line">则该Service的扩容和后来的升级都可以解决</span><br><span class="line">在RC定义以下三个信息</span><br><span class="line">1:目标Pod的定义</span><br><span class="line">2:目标Pod需要运行的副本数量</span><br><span class="line">3:监控的目标Pod的标签</span><br><span class="line">创建好RC之后,k8s会通过RC中定义的Lable筛选出对应的Pod实例并实时监控状态和数量,</span><br><span class="line">如果实例数量少于定义的副本数量,则根据RC中定义的Pod模板来创建新的pod,</span><br><span class="line">然后将此pod调度到合适的node上启动运行</span><br><span class="line">直到pod实例的数量达到预定的目标,这个过程纯自动化,无需人工干预</span><br></pre></td></tr></table></figure>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Master节点"><a href="#Master节点" class="headerlink" title="Master节点"></a>Master节点</h3><p><img src="/2018/07/25/K8s/image-07.png" alt="Kubernetes master"></p>
<ul>
<li>API服务器</li>
</ul>
<p>API服务器是一个关键组件 并使用 Kubernetes API 和 JSON over HTTP它提供了Kubernetes的内部和外部接口。API服务器处理和验证 REST请求并更新 API 对象的状态etcd，从而允许客户端在Worker节点之间配置工作负载和容器。</p>
<ul>
<li>调度器</li>
</ul>
<p>调度程序是可插拔组件，其基于资源可用性来选择未调度的pod（由调度程序管理的基本实体）应该运行哪个节点。调度程序跟踪每个节点上的资源利用率，以确保工作负载不会超过可用资源。为此，调度程序必须知道资源需求，资源可用性以及各种其他用户提供的约束和策略指令，例如服务质量，亲和力，数据位置等。实质上，调度程序的作用是将资源“供应”与工作负载“需求”相匹配。 </p>
<ul>
<li>控制器管理</li>
</ul>
<p>控制器管理器是核心的Kubernetes控制器如DaemonSet控制器和复制控制器的进程。控制器与API服务器通信以创建，更新和删除他们管理的资源(pod，服务端点等)Node节点Node也称为Worker是部署容器(工作负载)的单机器(或虚拟机)集群中的每个节点都必须运行容器runtime(如 Docker)以及下面提到的组件,以便与这些容器的网络配置进行通信。</p>
<h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><p><img src="/2018/07/25/K8s/image-08.png" alt="kubernetes node"></p>
<ul>
<li>Kubelet</li>
</ul>
<p>Kubelet负责每个节点的运行状态(即确保节点上的所有容器都正常运行)。它按照控制面板的指示来处理启动,停止和维护应用程序容器(按组织到pod中)并监视pod的状态如果不处于所需状态则pod将被重新部署到同一个节点。节点状态每隔几秒通过心跳消息中继到主机。主控器检测到节点故障后，复制控制器将观察此状态更改，并在其他健康节点上启动pod。</p>
<ul>
<li>Kube代理</li>
</ul>
<p>kube代理是网络代理和负载平衡器的实现，它支持服务抽象以及其他网络操作。它负责根据传入请求的IP和端口号将流量路由到相应的容器。</p>
<h3 id="Controller-Manager"><a href="#Controller-Manager" class="headerlink" title="Controller-Manager"></a>Controller-Manager</h3><p><img src="/2018/07/25/K8s/image-09.png" alt="image-20180802102914786"></p>
<blockquote>
<p> 复制(replication)控制器</p>
</blockquote>
<p>确保指定pod存在指定数目的实例 </p>
<blockquote>
<p> 端点(endpoint)控制器</p>
</blockquote>
<p>负责endpoint对象的创建、更新 </p>
<blockquote>
<p>节点(node)控制器</p>
</blockquote>
<p>负责节点的发现、管理和监控 </p>
<blockquote>
<p>命名空间(namespaces)控制器</p>
</blockquote>
<p>响应对命名空间的操作,并网络隔离</p>
<blockquote>
<p> 服务(service)控制器</p>
</blockquote>
<p>由此控制service,而service是定义一系列Pod以及访问这些Pod的策略的一层抽象。</p>
<p>Service通过Label找到Pod组,在没有selector选择器就会通过对应的endpoint</p>
<p><br><br><br></p>
<h1 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h1><p><img src="/2018/07/25/K8s/image-10.png" alt="img"></p>
<p>大体分两个结构:数据面板(Envoy)和控制面板(Istio)</p>
<ul>
<li>Pilot:提供了服务发现均衡负载以及路由配置还有故障注入,管理Envoy的转发规则</li>
<li>Mixer:Envoy转发请求前的前提条件检查验证服务是否白名单ACL等以及配额上的资源管理,转发请求后的日志和监控信息上报</li>
<li>Istio-Auth:服务间的认证</li>
</ul>
<h2 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h2><p><img src="/2018/07/25/K8s/image-11.png" alt="image-20180802103154353"></p>
<p><img src="/2018/07/25/K8s/image-17.png" alt="image-20180802103154353"></p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>在配置里面往往会配置四个东西。  </p>
<ul>
<li>Listener-&gt;LDS</li>
<li>Routes-&gt;RDS</li>
<li>Clusters-&gt;CDS</li>
<li>Endpoints-&gt;EDS  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">一是listener:也即envoy既然是proxy,专门做转发,就得监听一个端口,接入请求</span><br><span class="line">然后才能够根据策略转发,这个监听的端口称为listener</span><br><span class="line"></span><br><span class="line">二是endpoint:是目标的ip地址和端口,这个是proxy最终将请求转发到的地方。</span><br><span class="line"></span><br><span class="line">三是cluster:一个cluster是具有完全相同行为的多个endpoint,</span><br><span class="line">也即如果有三个容器在运行,就会有三个IP和端口,但是部署的是完全相同的三个服务</span><br><span class="line">他们组成一个Cluster,从cluster到endpoint的过程称为负载均衡,可以轮询等。</span><br><span class="line"></span><br><span class="line">四是route:有时候多个cluster具有类似的功能，但是是不同的版本号,可以通过route规则,选择将请求路由到某一个版本号,也即某一个cluster。</span><br></pre></td></tr></table></figure>
<p><code>Envoy</code>可以通过加装静态配置文件的方式运行,而动态信息需要从<code>Discovery Service</code>去拿。    </p>
<p><code>Discovery Service</code>就是部署在控制面的,在<code>istio</code>中是<code>Pilot</code>。    </p>
<blockquote>
<p>Envoy Mesh </p>
</blockquote>
<p><code>Envoy Mesh</code>指的是由<code>envoy</code>做负载均衡和代理的<code>mesh</code>。该<code>Mesh</code>中会包含两类<code>envoy</code>  </p>
<ul>
<li>Edge envoy:即流量进出 mesh 时候的 envoy,相当于 kubernetes 中的 ingress。</li>
<li>Service envoy:服务 envoy 是跟每个 serivce 实例一起运行的,应用程序无感知的进程外工具,在 kubernetes 中会与应用容器以 sidecar 形式运行在同一个 pod 中。</li>
</ul>
<h3 id="定制化"><a href="#定制化" class="headerlink" title="定制化"></a>定制化</h3><h4 id="嵌入proxy-init作为InitContainer"><a href="#嵌入proxy-init作为InitContainer" class="headerlink" title="嵌入proxy_init作为InitContainer"></a>嵌入proxy_init作为InitContainer</h4><blockquote>
<p>定制化的第一项就是添加了一个initContainer</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在这个InitContainer里面运行了一个shell脚本  </span><br><span class="line">shell脚本在容器里面写入了大量的iptables规则。</span><br><span class="line"></span><br><span class="line">首先定义的一条规则是ISTIO_REDIRECT转发链，这条链不分三七二十一，都将网络包转发给envoy的15000端口。</span><br><span class="line">    </span><br><span class="line">但是一开始这条链没有被挂到iptables默认的几条链中，所以不起作用。</span><br><span class="line">    </span><br><span class="line">接下来就是在PREROUTING规则中，使用这个转发链，从而进入容器的所有流量，都被先转发到envoy的15000端口。</span><br><span class="line">    </span><br><span class="line">envoy作为一个代理，已经被配置好了，将请求转发给productpage程序。</span><br><span class="line">    </span><br><span class="line">productpage程序接受到请求，会转向调用外部的reviews或者ratings，从上面的分析我们知道，productpage只是做普通的域名调用。</span><br><span class="line">    </span><br><span class="line">当productpage往后端进行调用的时候，就碰到了output链，这个链会使用转发链，将所有出容器的请求都转发到envoy的15000端口。</span><br><span class="line">    </span><br><span class="line">这样无论是入口的流量，还是出口的流量，全部用envoy做成了汉堡包。</span><br></pre></td></tr></table></figure>
<h4 id="嵌入proxy容器作为sidecar"><a href="#嵌入proxy容器作为sidecar" class="headerlink" title="嵌入proxy容器作为sidecar"></a>嵌入proxy容器作为sidecar</h4><blockquote>
<p>嵌入proxy容器作为sidecar<br>进入容器我们可以看到,启动了两个进程。     </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一个是我们熟悉的envoy,他有一个配置文件是/etc/istio/proxy/envoy-rev0.json</span><br><span class="line"></span><br><span class="line">有了配置文件,envoy就能够转发了</span><br><span class="line"></span><br><span class="line">在这里面配置了envoy的管理端口,等一下会通过这个端口查看envoy被pilot下发了哪些转发策略。</span><br><span class="line"></span><br><span class="line">然后就是动态资源,也即从各种discovery service去拿转发策略。</span><br><span class="line"></span><br><span class="line">还有就是静态资源,也即静态配置的,需要重启才能加载的。</span><br></pre></td></tr></table></figure>
<h2 id="Pilot"><a href="#Pilot" class="headerlink" title="Pilot"></a>Pilot</h2><p><img src="/2018/07/25/K8s/image-16.png" alt="image-20180802103717953"></p>
<h3 id="整个流程"><a href="#整个流程" class="headerlink" title="整个流程"></a>整个流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pilot另外一个对外的接口是Rules API</span><br><span class="line">这是给管理员的接口,管理员通过这个接口设定一些规则,这些规则往往是应用于Routes, Clusters, Endpoints的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">而都有哪些Clusters和Endpoints,是由Platform Adapter这面通过服务发现得到的。</span><br><span class="line">自动发现的这些Clusters和Endpoints,外加管理员设置的规则,形成了Pilot的数据模型  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其实就是他自己定义的一系列数据结构,然后通过envoy API暴露出去，等待envoy去拉取这些规则。</span><br></pre></td></tr></table></figure>
<h3 id="实现意义"><a href="#实现意义" class="headerlink" title="实现意义"></a>实现意义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Envoy是一个高性能的C++写的proxy转发器,</span><br><span class="line"></span><br><span class="line">Envoy如何转发请求呢？</span><br><span class="line">需要定一些规则,然后按照这些规则进行转发。</span><br><span class="line">规则可以是静态的,放在配置文件中的,启动的时候加载,要想重新加载,一般需要重新启动</span><br><span class="line">但是Envoy支持热加载和热重启,一定程度上缓解了这个问题。</span><br><span class="line"></span><br><span class="line">当然最好的方式是规则设置为动态的,放在统一的地方维护,这个统一的地方在Envoy眼中看来称为Discovery Service,</span><br><span class="line">过一段时间去这里拿一下配置,就修改了转发策略。</span><br></pre></td></tr></table></figure>
<h3 id="Pilot-Agent"><a href="#Pilot-Agent" class="headerlink" title="Pilot-Agent"></a>Pilot-Agent</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pilot-agent的作用,他是envoy的一个简单的管理器,因为有些静态资源;  </span><br><span class="line">如果TLS的证书,envoy还不支持动态下发,因而需要重新静态配置,然后pilot-agent负责将envoy进行热重启加载。</span><br><span class="line"></span><br><span class="line">好在envoy有良好的热重启机制,重启的时候,会先启动一个备用进程</span><br><span class="line">将转发的统计数据通过shared memory在两个进程间共享。</span><br></pre></td></tr></table></figure>
<h2 id="Mixer"><a href="#Mixer" class="headerlink" title="Mixer"></a>Mixer</h2><p>Mixer提供三个核心功能：</p>
<ul>
<li>前置条件检查（Precondition Checking）<blockquote>
<p>某一服务响应外部请求前，通过Envoy向Mixer发送Check请求，检查该请求是否满足一定的前提条件，包括白名单检查、ACL检查等。</p>
</blockquote>
</li>
<li>配额管理（Quota Management）<blockquote>
<p>当多个请求发生资源竞争时，通过配额管理机制可以实现对资源的有效管理。</p>
</blockquote>
</li>
<li>遥测报告上报（Telemetry Reporting）<blockquote>
<p>该服务处理完请求后，通过Envoy向Mixer上报日志、监控等数据。</p>
</blockquote>
</li>
</ul>
<h3 id="Mixer不足"><a href="#Mixer不足" class="headerlink" title="Mixer不足"></a>Mixer不足</h3><p>Istio最大的毛病就是qps始终很低,有大牛统计过如下分析   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netty4.1的HTTP转发的demo，没做任何优化和调教，轻松10万+的QPS</span><br><span class="line">gRPC直连，15万QPS轻松做到</span><br><span class="line">而istio的qps从0.5.1的700，到0.6.0的1000，再到0.7.1的1700</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最开始Service Mesh以Linkerd/Envoy为代表  </p>
</blockquote>
<p>主要是以proxy/sidecar的形式出现<br>功能基本都在sidecar中<br>请求通过sidecar转发,期间发生的各种检查/判断/操作,都是在sidecar中进行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#传统分布式  </span><br><span class="line">client -&gt; registry -&gt; service</span><br><span class="line"></span><br><span class="line">#第一版服务网格</span><br><span class="line">client-&gt;sidecar-&gt;registry -&gt; service</span><br></pre></td></tr></table></figure>
<p>只是多了一层proxy/sidecar的转发,</p>
<blockquote>
<p>接着出现第二代演进,Istio出现  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#第一版服务网格</span><br><span class="line">client-&gt; sidecar-&gt; registry -&gt; service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#第二版服务网格</span><br><span class="line">client-&gt; sidecar-&gt; ControlPlan(Istio)-&gt; service</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/25/K8s/image-13.png" alt="img"></p>
<p>控制平面的三大模块如上图,<br>其中的Pilot和Auth都不直接参与到流量的处理流程<br>因此他们不会对运行时性能产生直接影响</p>
<p>mixer的工作,就需要envoy从每次请求中获取信息,然后发起两次对mixer的请求：</p>
<ul>
<li>在转发请求之前：这时需要做前提条件检查和配额管理，只有满足条件的请求才会做转发</li>
<li>在转发请求之后：这时要上报日志等，术语上称为遥感信息，Telemetry，或者Reporting。</li>
</ul>
<blockquote>
<p>第二代Istio服务网格特性  </p>
</blockquote>
<p>原有的sidecar被归结为data plane,然后在data plane上增加control plane。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data plane 只负责转发,其中部分数据来自Pilot和Auth。</span><br><span class="line">和后端基础设施相关的功能放置在mixer中,通过各种adapter实现</span><br></pre></td></tr></table></figure>
<h3 id="Mixer的改进"><a href="#Mixer的改进" class="headerlink" title="Mixer的改进"></a>Mixer的改进</h3><blockquote>
<p>在Envoy中增加mixer filter。<br>这个Filter和控制面的Mixer组件进行通讯,完成策略控制和遥测数据收集功能。</p>
</blockquote>
<p><img src="/2018/07/25/K8s/image-12.png" alt="img"></p>
<p>关键在于增加了缓存:</p>
<ul>
<li><p>Mixer Filter中保存有策略判断所需的数据缓存,因此大部分策略判断在Envoy中就处理了,不需要发送请求到Mixer。</p>
</li>
<li><p>另外Envoy收集到的遥测数据会先保存在Envoy的缓存中,每隔一段时间再通过批量的方式上报到Mixer。</p>
</li>
</ul>
<p>缓存的工作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sidecar 中包含本地缓存，一大部分的前置检查可以通过缓存来进行。</span><br><span class="line">另外，sidercar 会把待发送的指标数据进行缓冲，这样可能在几千次请求之后才调用一次 Mixer。</span><br><span class="line">前置检查和请求处理是同步的</span><br><span class="line">指标数据上送是使用 fire-and-forget 模式异步完成的。</span><br></pre></td></tr></table></figure>
<p>敖大大针对改进产生的疑问:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">“一大部分的前置检查可以通过缓存来进行”,大部分？</span><br><span class="line">可是只要有一个前置检查不能缓存，就必须去mixer里面请求</span><br><span class="line"></span><br><span class="line">没有看到任何关于quota的说明。到底quato怎么办？</span><br><span class="line">配额按说是没法缓存的，</span><br><span class="line">否则配额就不准确了。而一旦需要执行配额管理，还是必须发起请求到mixer</span><br><span class="line"></span><br><span class="line">envoy中要执行前置检查,不仅仅需要缓存前置检查的各种配置信息，</span><br><span class="line">也必须要求envoy有执行前置检查的能力,</span><br><span class="line">即原来在mixer中实现前置检查的所有逻辑代码必须在envoy里面再实现一次。</span><br></pre></td></tr></table></figure>
<h3 id="Mixer-Cache"><a href="#Mixer-Cache" class="headerlink" title="Mixer Cache"></a>Mixer Cache</h3><blockquote>
<p>为了保证运行时性能,避免每次请求都远程访问Mixer核心逻辑,Istio特意为Mixer增加了缓存     </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">但是Mixer Cache不放在Envoy</span><br><span class="line">而是在Mixer这边</span><br><span class="line">因为当缓存在Mixer一侧时,缓存总数是各个adapter缓存的总数,也就是每个属性数量的简单相加。</span><br><span class="line">而当缓存在Envoy一侧时,缓存总数是每个属性取值数量的笛卡尔乘积。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Envoy请求一些属性到Mixer,Mixer通过Adapter返回Mixer关心的ReferencedAttribute关注属性</span><br><span class="line">Envoy就会将“a=1,b=2,c=3”这个实际被使用的属性值进行签名得到缓存的key</span><br><span class="line">Envoy会先根据保存的被关注属性组合,看请求是否命中,比如这里的”a/b/c”属性组合就可以匹配这三个请求。</span><br><span class="line">然后根据”a/b/c”组合简化请求的属性为“a=1,b=2,c=3”，再进行签名计算</span><br><span class="line">然后再以计算得到的签名为key在缓存中查找。</span><br><span class="line">如果找到，返回缓存结果。如果没有找到,继续发送请求到mixer,然后保存得到的response到缓存中</span><br></pre></td></tr></table></figure>
<p>因为缓存在Mixer而不再Envoy所以造成以下局势尴尬局面  </p>
<ul>
<li>要明确划分数据平面和控制平面的界限,Mixer就必须独立于Envoy</li>
<li>Mixer和Envoy之间就变成了远程访问，存在性能瓶颈</li>
<li>为了解决性能问题，避免远程访问，就需要将cache加在envoy一侧</li>
<li>然后就不得不面对缓存总数呈现笛卡尔乘积的威胁</li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><blockquote>
<p>每次请求中的各个属性   </p>
</blockquote>
<p>来源于<a href="http://istio.doczh.cn/docs/reference/config/mixer/attribute-vocabulary.html" target="_blank" rel="noopener">属性词汇</a>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request.path: xyz/abc</span><br><span class="line">request.size: 234</span><br><span class="line">request.time: 12:34:56.789 04/17/2017</span><br><span class="line">source.ip: 192.168.0.1</span><br><span class="line">target.service: example</span><br></pre></td></tr></table></figure>
<p>Istio中首要的属性生产者是Envoy,然后特定的Mixer适配器和服务也会产生属性。  </p>
<blockquote>
<p>引用属性  </p>
</blockquote>
<p>Envoy会提交所有的Attribute，而在CheckResponse的应答中，PreconditionResult 表示前置条件检查的结果：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td>status</td>
<td>google.rpc.Status</td>
<td>状态码OK表示所有前置条件均满足。<br>任何其它状态码表示不是所有的前置条件都满足<br>并且在detail中描述为什么。</td>
</tr>
<tr>
<td>validDuration</td>
<td>google.protobuf.Duratio</td>
<td>时间量,在此期间这个结果可以认为是有效的</td>
</tr>
<tr>
<td>validUseCount</td>
<td>int32</td>
<td>可使用的次数,在此期间这个结果可以认为是有效的  </td>
</tr>
<tr>
<td>attributes</td>
<td>CompressedAttributes</td>
<td>mixer返回的属性。<br>返回的切确属性集合由mixer配置的adapter决定。<br>这些属性用于传送新属性<br>这些新属性是Mixer根据输入的属性集合和它的配置派生的。</td>
</tr>
<tr>
<td>referencedAttributes</td>
<td>ReferencedAttribute</td>
<td>在匹配条件并生成结果的过程中使用到的全部属性集合。  </td>
</tr>
</tbody>
</table>
<p><img src="/2018/07/25/K8s/image-14.png" alt="img"> </p>
<p>流程如上图  </p>
<p>Envoy请求带一些属性过来a=1,b=2,c=3,e=0,f=0<br>Mixer在CheckResponse返回referencedAttributes内容a,b,c</p>
<blockquote>
<p>Envoy关心这些<code>引用属性</code>,才知道Mixer的Adpater对哪些属性感兴趣<br>Mixer Cache需要缓存Mixer整个CheckResponse的结果,避免每次都让Envoy请求Mixer      </p>
</blockquote>
<h4 id="Mixer-Cache设计之道"><a href="#Mixer-Cache设计之道" class="headerlink" title="Mixer Cache设计之道"></a>Mixer Cache设计之道</h4><p>将返回的ReferencedAttributes的key做简单hash得到的值作为新的key,<br>其他返回结果在value</p>
<p>Mixer Cache分为两个部分</p>
<ul>
<li>check cache  </li>
<li>quota cache  </li>
</ul>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="Pilot解析"><a href="#Pilot解析" class="headerlink" title="Pilot解析"></a>Pilot解析</h2><p><img src="/2018/07/25/K8s/image-15.png" alt="image">  </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="">servicemesher</a></li>
<li><a href="https://jimmysong.io/posts/envoy-archiecture-and-terminology/" target="_blank" rel="noopener">Envoy</a>  </li>
</ul>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2018/07/25/K8s/';
        this.page.title = 'Docker&amp;K8s';
        this.page.identifier = '2018/07/25/K8s/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
