<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>TCP网络编程笔记 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="网络编程相关的语法详解笔记 
TCP分段与UDP/IP分片
(MTU最大传输单元,MSS最大分段大小)   

1234567891011TCP报文段如果很长的话,会在发送时发生分段,在接受时进行重组,同样IP数据报在长度超过一定值时也会发生分片,在接收端再将分片重组。我们先来看两个与TCP报文段分段和IP数据报分片密切相关的概念。MTU(最大传输单元)是链路层中的网络对数据帧的一个限制,依然以以太网为例,MTU为1500个字节。一个IP数据报在以太网中 传输,如果它的长度大于该MTU值,就要进">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Go/Rust</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">系统内核</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">威胁追踪</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">数据库</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP分段与UDP-IP分片"><span class="toc-number">1.</span> <span class="toc-text">TCP分段与UDP/IP分片</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MTU"><span class="toc-number">1.1.</span> <span class="toc-text">MTU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MSS-最大分段大小"><span class="toc-number">1.2.</span> <span class="toc-text">MSS(最大分段大小)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#网络"><span class="toc-number">2.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IP"><span class="toc-number">2.1.</span> <span class="toc-text">IP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP特点"><span class="toc-number">2.1.1.</span> <span class="toc-text">IP特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP"><span class="toc-number">2.2.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何承载在IP上传输"><span class="toc-number">2.2.1.</span> <span class="toc-text">如何承载在IP上传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP首部"><span class="toc-number">2.2.2.</span> <span class="toc-text">TCP首部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP的状态变迁"><span class="toc-number">2.2.3.</span> <span class="toc-text">TCP的状态变迁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11种状态如下"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">11种状态如下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#状态变迁图"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">状态变迁图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三次握手-四次挥手"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">三次握手,四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不常见的异常"><span class="toc-number">2.2.3.4.</span> <span class="toc-text">不常见的异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#握手过程中的其他问题"><span class="toc-number">2.2.3.5.</span> <span class="toc-text">握手过程中的其他问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ISN的同步"><span class="toc-number">2.2.3.6.</span> <span class="toc-text">ISN的同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#挥手过程中的其他问题"><span class="toc-number">2.2.3.7.</span> <span class="toc-text">挥手过程中的其他问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#为什么需要TIME-WAIT"><span class="toc-number">2.2.3.7.1.</span> <span class="toc-text">为什么需要TIME_WAIT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#大规模出现TIME-WAIT"><span class="toc-number">2.2.3.7.2.</span> <span class="toc-text">大规模出现TIME_WAIT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#关于TIME-WAIT的建议"><span class="toc-number">2.2.3.7.3.</span> <span class="toc-text">关于TIME_WAIT的建议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP重传机制"><span class="toc-number">2.2.4.</span> <span class="toc-text">TCP重传机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#超时重传机制"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">超时重传机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#快速重传机制"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">快速重传机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP的流量控制"><span class="toc-number">2.2.5.</span> <span class="toc-text">TCP的流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RTT算法"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">RTT算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP滑动窗口"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">TCP滑动窗口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP的拥塞控制"><span class="toc-number">2.2.6.</span> <span class="toc-text">TCP的拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#慢启动算法"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">慢启动算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#拥塞避免算法"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">拥塞避免算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#拥塞发生时的算法"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">拥塞发生时的算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#快速恢复算法"><span class="toc-number">2.2.6.4.</span> <span class="toc-text">快速恢复算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP数据传输过程"><span class="toc-number">2.2.7.</span> <span class="toc-text">TCP数据传输过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP的定时器"><span class="toc-number">2.2.8.</span> <span class="toc-text">TCP的定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WireShark"><span class="toc-number">2.2.9.</span> <span class="toc-text">WireShark</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp头部为何先放端口信息"><span class="toc-number">2.2.9.1.</span> <span class="toc-text">tcp头部为何先放端口信息?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三次握手会不会被恶意使用"><span class="toc-number">2.2.9.2.</span> <span class="toc-text">三次握手会不会被恶意使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消息确认有没有弱点"><span class="toc-number">2.2.9.3.</span> <span class="toc-text">消息确认有没有弱点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SocketApi"><span class="toc-number">2.2.10.</span> <span class="toc-text">SocketApi</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Api历史"><span class="toc-number">2.2.10.1.</span> <span class="toc-text">Api历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#头文件"><span class="toc-number">2.2.10.2.</span> <span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketApi函数"><span class="toc-number">2.2.10.3.</span> <span class="toc-text">SocketApi函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子"><span class="toc-number">2.2.10.4.</span> <span class="toc-text">例子</span></a></li></ol></li></ol></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            TCP网络编程笔记
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2018/10/22/net-coding/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-10-22T03:45:06.000Z" itemprop="datePublished">2018-10-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/网络编程/">网络编程</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>网络编程相关的语法详解笔记<br><a id="more"></a> </p>
<h1 id="TCP分段与UDP-IP分片"><a href="#TCP分段与UDP-IP分片" class="headerlink" title="TCP分段与UDP/IP分片"></a>TCP分段与UDP/IP分片</h1><blockquote>
<p>(MTU最大传输单元,MSS最大分段大小)   </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TCP报文段如果很长的话,会在发送时发生分段,在接受时进行重组,同样IP数据报在长度超过一定值时也会发生分片,在接收端再将分片重组。</span><br><span class="line">我们先来看两个与TCP报文段分段和IP数据报分片密切相关的概念。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MTU(最大传输单元)是链路层中的网络对数据帧的一个限制,依然以以太网为例,MTU为1500个字节。</span><br><span class="line">一个IP数据报在以太网中 传输,如果它的长度大于该MTU值,就要进行分片传输,使得每片数据报的长度小于MTU。</span><br><span class="line">分片传输的IP数据报不一定按序到达,但IP首部中的信息能让这些数据报片按序组装。</span><br><span class="line">IP数据报的分片与重组是在网络层进完成的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MSS是TCP数据包每次能够传输的最大数据分段,TCP报文段的长度大于MSS时,要进行分段传输。</span><br></pre></td></tr></table></figure>
<p><br> </p>
<h2 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h2><p>计算机沟通必须有标准:tcp/ip v4,还有ipv6,但是没有普遍</p>
<p><img src="/2018/10/22/net-coding/image-01.png" height="250px"></p>
<p>Link链路层-&gt;Internet网络层-&gt;Transport(Tcp层),Link时常与Internet来回主要是因为MTU进行数据包分片</p>
<p><img src="/2018/10/22/net-coding/image-02.png" height="300px"></p>
<p>IP数据包进入协议栈的封装</p>
<p><img src="/2018/10/22/net-coding/image-03.png" height="200px"></p>
<p>Link层有头尾包裹,检测FrameData和FrameHeader标识相关的信息传输过来是否出错</p>
<blockquote>
<p>以太网FrameData最小46个字节,不足填0,最大1500个字节,称为MTU(最大传输单元)  </p>
<p>当我们传输的数据超过最大传输单元MTU,在IP层进行分片数据包分成若干个片</p>
</blockquote>
<p>之前ADSL猫的MTU只有1480字节,还有光纤各不一样,所以经常会在Link与Internet之间来回切数据包</p>
<p><br> </p>
<h2 id="MSS-最大分段大小"><a href="#MSS-最大分段大小" class="headerlink" title="MSS(最大分段大小)"></a>MSS(最大分段大小)</h2><p>MSS是TCP里的一个概念(首部的选项字段中)。  </p>
<p>MSS是TCP数据包每次能够传输的最大数据分段,TCP报文段的长度大于MSS时,要进行分段传输。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TCP协议在建立连接的时候通常要协商双方的MSS值,每一方都有用于通告它期望接收的MSS选项(MSS选项只出现在SYN报文段中,即TCP三次握手的前两次)。</span><br><span class="line"></span><br><span class="line">MSS的值一般为MTU值减去两个首部大小(需要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes)</span><br><span class="line"></span><br><span class="line">所以如果用链路层以太网,MSS的值往往为1460。而Internet上标准的MTU(最小的MTU,链路层网络为x2.5时)为576</span><br><span class="line"></span><br><span class="line">那么如果不设置,则MSS的默认值就为536个字节。很多时候,MSS的值最好取512的倍数。</span><br><span class="line"></span><br><span class="line">TCP报文段的分段与重组是在运输层完成的。</span><br><span class="line"></span><br><span class="line">到了这里有一个问题自然就明了了,TCP分段的原因是MSS,IP分片的原因是MTU</span><br><span class="line"></span><br><span class="line">由于一直有MSS&lt;=MTU,很明显分段后的每一段TCP报文段再加上IP首部后的长度不可能超过MTU</span><br><span class="line"></span><br><span class="line">因此也就不需要在网络层进行IP分片了。</span><br><span class="line"></span><br><span class="line">因此TCP报文段很少会发生IP分片的情况。</span><br><span class="line"></span><br><span class="line">再来看UDP数据报,由于UDP数据报不会自己进行分段,因此当长度超过了MTU时,会在网络层进行IP分片。  </span><br><span class="line"></span><br><span class="line">同样ICMP(在网络层中)同样会出现IP分片情况。</span><br></pre></td></tr></table></figure>
<p><br> </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>UDP不会分段,就由IP来分。TCP会分段,当然就不用IP来分了！</p>
</blockquote>
<p>另外IP数据报分片后,只有第一片带有UDP首部或ICMP首部,其余的分片只有IP头部,到了端点后根据IP头部中的信息再网络层进行重组。  </p>
<p>而TCP报文段的每个分段中都有TCP首部,到了端点后根据TCP首部的信息在传输层进行重组。</p>
<p>IP数据报分片后,只有到达目的地后才进行重组,而不是向其他网络协议,在下一站就要进行重组。   </p>
<p>最后一点对IP分片的数据报来说,即使只丢失一片数据也要重新传整个数据报(既然有重传,说明运输层使用的是具有重传功能的协议,如TCP协议)</p>
<p>这是因为IP层本身没有超时重传机制——由更高层(比如TCP)来负责超时和重传。</p>
<p>当来自TCP报文段的某一段(在IP数据报的某一片中)丢失后</p>
<p>TCP在超时后会重发整个TCP报文段,该报文段对应于一份IP数据报(可能有多个IP分片),没有办法只重传数据报中的一个数据分片。  </p>
<p><br><br><br> </p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="IP特点"><a href="#IP特点" class="headerlink" title="IP特点"></a>IP特点</h3><blockquote>
<p>不可靠,无连接</p>
</blockquote>
<ul>
<li><p>不可靠:ip数据包不保证一定传送到,ip数据如果在中途路由器内存用完,则丢掉整个数据包,到达机器利用icmp传达(ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答,则认为主机可达。)</p>
<p>数据包如果保证一定送到则利用tcp协议</p>
</li>
<li><p>无连接:ip数据包每个处理都相互独立,不是顺序发送,A-&gt;B各个数据包走的线路不一样,B可能先收到后面的数据包</p>
</li>
</ul>
<p>IP数据包如下</p>
<p><img src="/2018/10/22/net-coding/image-04.png" width="400px"></p>
<p>网络传输数据都由BigEndian,windows/linux都LittleEndian,但网络传输是BigEndian</p>
<p>在cpu内存地址,存储方式主流的英特尔都是LittleEndian</p>
<p>由之前IP数据包协议栈的封装</p>
<p>IPheader就是4位版本+4位首部长度+8位服务类型(TOS)+16位数据包总长度</p>
<p>8位生存时间TTL:每经过一个Link中的TTL减1,如果减到0发不到就系统认为发不到就丢弃并报告错误</p>
<p>8位协议:怎样方式传输,tcp还是如何</p>
<p>16位首部检验和:算数据有无差错</p>
<p>32位源IP地址:发送源头</p>
<p>32位目的IP地址:发送目的地</p>
<p>ipv4,32位地址40多亿,当时没有考虑到会人手一台电脑</p>
<p>Ipv6,128位地址足够用,已经使用,但是推广缓慢,只有部分骨干网络学校网络使用</p>
<p>ipv4大部分地址掌握在美国人手中,所以推ipv6不值当,国内的话对长城有影响</p>
<p><br><br><br> </p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul>
<li>TCP如何利用ip到达自己的目的地</li>
<li>TCP首部</li>
<li>TCP的状态变迁</li>
<li>TCP的连接建立</li>
<li>TCP的连接断开</li>
<li>TCP的数据交互</li>
</ul>
<h3 id="如何承载在IP上传输"><a href="#如何承载在IP上传输" class="headerlink" title="如何承载在IP上传输"></a>如何承载在IP上传输</h3><blockquote>
<p> IP特点:无连接,不可靠, TCP如何变成可靠与有链接？</p>
</blockquote>
<p>总结特性如下:</p>
<ul>
<li><p>TCP将数据分割报文段</p>
<p>TCP将数据分为好几段报文段</p>
</li>
<li><p>定时器</p>
<p>每当tcp发出去之后建立一个定时器(a-&gt;b,如果a等定时器还未回复,则再尝试发送一次,尝试次数一定数目告诉应用程序,发送失败),也有一种所谓的粘包现象:发送端发了3次,接收端只收了1次</p>
</li>
<li><p>延迟确认</p>
<p>当tcp收到数据包,进行延迟确认(十次确认的包,用一次确认就行了),在确认的时候会将乱序的数据包重新排序,也会砍重复数据包</p>
</li>
<li><p>检验和</p>
<p>tcp还会检验和,用来检测数据是否出现错误,当tcp检验和正常</p>
</li>
<li><p>流量控制</p>
<p>为了让tcp服务稳定下来,利用了流量控制,防止较快的机器过意压榨了减慢的机器</p>
</li>
</ul>
<p><br> </p>
<h3 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h3><p><img src="/2018/10/22/net-coding/image-05.png" width="800px"></p>
<p>ip首部20个字节,tcp首部也是20个字节,在都没有选项的情况下</p>
<p>假如数据通过以太网传输,最小需要46个字节,ip+tcp=20+20还差六个字节则补0填充</p>
<blockquote>
<p>tcp首部四个字节</p>
</blockquote>
<p>在网络传输都是bigEndian,传输过程中在程序A打开端口号,作<code>sourcePort</code>,接收程序B打开端口号作为<code>DestinationPort</code></p>
<p>源ip+源端口号+目标ip+目标端口号作为一个<code>socket pair</code>四元组,</p>
<blockquote>
<p><code>Sequence Number</code> 4个字节</p>
</blockquote>
<p>包的序号Seq,用于解决网络包乱序(<code>reordering</code>)。</p>
<p><code>Sequence Number</code>tcp分割数据包每个包都有一个<code>Sequence Number</code>,当我确认的时候也会根据<code>Sequence Number</code>来进行确认</p>
<blockquote>
<p><code>Acknowledgement Number</code> 4个字节</p>
</blockquote>
<p>Ack用于确认收到Seq(<code>Ack = Seq + 1</code>,表示收到了Seq及Seq之前的数据包,期待Seq + 1),用于解决丢包。</p>
<blockquote>
<p><code>Data offset</code>  4个位</p>
</blockquote>
<p>数据偏移(即首部长度):占4位,它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。<code>“数据偏移”</code>的单位是32位字,即以4字节为计算单位。 </p>
<blockquote>
<p><code>Reserved</code>(保留字段)占6位</p>
</blockquote>
<p>保留为今后使用,但目前应置为0。</p>
<blockquote>
<p><code>TCPFlag</code>(标志位):占6位</p>
</blockquote>
<p>分别表示6个标志:紧急URG,确认ACK,推送PSH(PuSH),复位RST(ReSeT),同步SYN,终止FIN(FINis)</p>
<ul>
<li>URG—— 当URG= 1 时,表明紧急指针字段有效。它告诉系统此报文段中有紧急数据,应尽快传送(相当于高优先级的数据)。</li>
<li>ACK—— 当ACK= 1 时确认号字段有效,当ACK= 0 时,确认号无效。</li>
<li>PSH(PuSH) ——接收TCP收到PSH= 1 的报文段,就尽快地交付接收应用进程,而不再等到整个缓存都填满了后再向上交付。</li>
<li>RST(ReSeT)—— 当RST= 1 时,表明TCP连接需要释放连接,然后再重新建立运输连接。</li>
<li>SYN—— 同步SYN= 1 表示这是一个连接请求或连接接受报文。</li>
<li>FIN(FINis) ——用来释放一个连接。FIN= 1 表明此报文段的发送端的数据已发送完毕,并要求释放运输连接。</li>
</ul>
<blockquote>
<p><code>Window size</code> 占2字节</p>
</blockquote>
<p><code>Window Size</code>,又叫<code>Advertised Window</code>,可以近似理解为滑动窗口<code>(Sliding Window)</code>的大小,用于流控。</p>
<p>用来让对方设置发送窗口的依据,单位为字节。</p>
<p>表示接收缓冲区的空闲空间,16位,用来告诉TCP连接对端自己能够接收的最大数据长度。</p>
<p>2个字节大小为65535,窗口大小量</p>
<blockquote>
<p> <code>CheckSum</code> </p>
</blockquote>
<p>检验和,<code>windows内部局域网</code>传过来的的东西也可能没做检查,如果出错也不管,不要太信任<code>checksum</code></p>
<blockquote>
<p><code>Urgent point</code></p>
</blockquote>
<p><strong>UrgentPointers（紧急指针字段）</strong>:占16位,指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。</p>
<p><br> </p>
<h3 id="TCP的状态变迁"><a href="#TCP的状态变迁" class="headerlink" title="TCP的状态变迁"></a>TCP的状态变迁</h3><p>tcp是如何利用ip提供了可靠的字节流传输服务,面向连接且有状态还有序</p>
<p>其实是把tcp每台机器做出了状态机</p>
<h4 id="11种状态如下"><a href="#11种状态如下" class="headerlink" title="11种状态如下"></a>11种状态如下</h4><ul>
<li><p>CLOSED：<code>实际上不存在的状态</code></p>
<p>初始状态,表示TCP连接是“关闭着的”或“未打开的”。</p>
</li>
<li><p>LISTEN ：<code>服务器等待客户端来连接</code></p>
<p>表示服务器端的某个SOCKET处于监听状态,可以接受客户端的连接。</p>
</li>
<li><p>SYN_RCVD ：<code>服务器确认首次连接</code></p>
<p>表示服务器接收到了来自客户端请求连接的SYN报文。在正常情况下,这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态,很短暂,基本上用netstat很难看到这种状态,除非故意写一个监测程序,将三次TCP握手过程中最后一个ACK报文不予发送。当TCP连接处于此状态时,再收到客户端的ACK报文,它就会进入到ESTABLISHED 状态。</p>
</li>
<li><p>SYN_SENT ：<code>客户端尝试来连接服务器</code><br>这个状态与SYN_RCVD 状态相呼应,当客户端SOCKET执行connect()进行连接时,它首先发送SYN报文,然后随即进入到SYN_SENT 状态,并等待服务端的发送三次握手中的第2个报文。SYN_SENT 状态表示客户端已发送SYN报文。</p>
</li>
<li><p>ESTABLISHED ：<code>建立了连接,双方可发送数据</code></p>
<p>表示TCP连接已经成功建立。</p>
</li>
<li><p>FIN_WAIT_1 ：<code>等待对方关闭</code></p>
<p>这个状态得好好解释一下,其实FIN_WAIT_1 和FIN_WAIT_2 两种状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时,它想主动关闭连接,向对方发送了FIN报文,此时该SOCKET进入到FIN_WAIT_1 状态。而当对方回应ACK报文后,则进入到FIN_WAIT_2 状态。当然在实际的正常情况下,无论对方处于任何种情况下,都应该马上回应ACK报文,所以FIN_WAIT_1 状态一般是比较难见到的,而FIN_WAIT_2 状态有时仍可以用netstat看到。</p>
</li>
<li><p>FIN_WAIT_2 ：<code>等待对方关闭</code></p>
<p>上面已经解释了这种状态的由来,实际上FIN_WAIT_2状态下的SOCKET表示半连接,即有一方调用close()主动要求关闭连接。<br>注意：FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态）,这种状态下如果对方不关闭（不配合完成4次挥手过程）,那这个 FIN_WAIT_2 状态将一直保持到系统重启,越来越多的FIN_WAIT_2 状态会导致内核crash。</p>
</li>
<li><p>TIME_WAIT ：<code>等待自己应用程序关闭</code></p>
<p>表示收到了对方的FIN报文,并发送出了ACK报文。<br>TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime,最大分段生存期,指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值,RFC 1122建议是2分钟,但BSD传统实现采用了30秒,Linux可以cat /proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值）,然后即可回到CLOSED 可用状态了。如果FIN_WAIT_1状态下,收到了对方同时带FIN标志和ACK标志的报文时,可以直接进入到TIME_WAIT状态,而无须经过FIN_WAIT_2状态。（这种情况应该就是四次挥手变成三次挥手的那种情况）</p>
</li>
<li><p>CLOSING ：<code>等待对方确认自己关闭</code></p>
<p>这种状态在实际情况中应该很少见,属于一种比较罕见的例外状态。正常情况下,当一方发送FIN报文后,按理来说是应该先收到（或同时收到）对方的ACK报文,再收到对方的FIN报文。但是CLOSING 状态表示一方发送FIN报文后,并没有收到对方的ACK报文,反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话,就出现了双方同时发送FIN报文的情况,这是就会出现CLOSING 状态,表示双方都正在关闭SOCKET连接。</p>
</li>
<li><p>CLOSE_WAIT ：<code>等待自己应用程序关闭</code></p>
<p>表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己,你的系统毫无疑问地将会回应一个ACK报文给对方,此时TCP连接则进入到CLOSE_WAIT状态。接下来呢,你需要检查自己是否还有数据要发送给对方,如果没有的话,那你也就可以close()这个SOCKET并发送FIN报文给对方,即关闭自己到对方这个方向的连接。有数据的话则看程序的策略,继续发送或丢弃。简单地说,当你处于CLOSE_WAIT 状态下,需要完成的事情是等待你去关闭连接。</p>
</li>
<li><p>LAST_ACK ：<code>等待最后一次确认消息</code></p>
<p>当被动关闭的一方在发送FIN报文后,等待对方的ACK报文的时候,就处于LAST_ACK 状态。当收到对方的ACK报文后,也就可以进入到CLOSED 可用状态了。</p>
</li>
</ul>
<p><br> </p>
<h4 id="状态变迁图"><a href="#状态变迁图" class="headerlink" title="状态变迁图"></a>状态变迁图</h4><p><img src="/2018/10/22/net-coding/image-06.png" width="600px"></p>
<ul>
<li><p>Server<br>  <code>Closed</code>-&gt;<code>Listen</code>-&gt;<code>SYC_RECEIVED</code>-&gt;<code>ESTABLISHED</code></p>
<p>  -&gt;<code>CLOSE_WAIT</code>-&gt;<code>LAST_ACK</code></p>
<p>  在<code>SYC_RECEIVED</code>-&gt;<code>ESTABLISHED</code>会建立一个<code>socket pair</code>四元组</p>
</li>
</ul>
<ul>
<li><p>Client</p>
<p><code>CLOSED</code>-&gt;<code>SYN_SENT</code>-&gt;<code>ESTABLISHED</code></p>
<p>-&gt;<code>FIN_WAIT_1</code>-&gt;<code>FIN_WAIT_2</code>-&gt;<code>TIME_WAIT</code></p>
<p><code>TIME_WAIT</code>:进入这个阶段<code>socket pair</code>不可用,必须得等待<code>timeout</code></p>
</li>
</ul>
<p><br> </p>
<h4 id="三次握手-四次挥手"><a href="#三次握手-四次挥手" class="headerlink" title="三次握手,四次挥手"></a>三次握手,四次挥手</h4><p><img src="/2018/10/22/net-coding/image-07.png" width="500px"></p>
<blockquote>
<p> 为什么关闭四次,连接是三次?</p>
</blockquote>
<p>断开经过四次,是因为tcp是全双工协议,两边都可以发送并且没有关联</p>
<p>而连接最简单的方式也是两个一来一回四次握手,但此处进行了优化:<code>将server端回复的ACK同server端自己的SYN合并在一个报文中发送给client</code>,所以减少为三次。</p>
<p>但挥手要回收大量资源是耗时操作;因此不能强制<code>将server端回复的ACK同server端自己的FIN合并在一个报文中发送给client”</code>所以通常认为挥手需要四次。</p>
<blockquote>
<p>为什么会有TIME_WAIT状态？</p>
</blockquote>
<p>IP头部有TTL8位生存时间,表示经过设备的数量,TIME_WAIT确保要么送达目的地,要么通过网络一次次流转后让它自亡,一般2分钟,这样为了防止有的无用的包在网络上无限传播下去,浪费网络带宽</p>
<p>一般数据包来回两趟所以2分钟乘以2约等于4分钟</p>
<p><code>从主动关闭这方来看,这段时间不能使用,保证了新建的链接不会与上一次的链接数据混乱</code></p>
<p><br> </p>
<h4 id="不常见的异常"><a href="#不常见的异常" class="headerlink" title="不常见的异常"></a>不常见的异常</h4><blockquote>
<p> RST异常</p>
</blockquote>
<ul>
<li>客户端连接服务器,超时了发送了RST复位</li>
<li>应用程序处理了一部分消息,误认为客户端有问题发送了RST复位</li>
</ul>
<blockquote>
<p>Listen会保持一个队列</p>
</blockquote>
<p>队列保存三次握手OK的socket,但是上层应用程序还没处理socket,对于客户端认为和服务器进入了<code>ESTABLISHED</code>,而服务器还没进入,所以发过来的数据会暂存,等待应用来处理</p>
<p>如果队列满了客户端的新建链接,服务器既不返回错误也不确认,就返回超时……</p>
<p><br> </p>
<h4 id="握手过程中的其他问题"><a href="#握手过程中的其他问题" class="headerlink" title="握手过程中的其他问题"></a>握手过程中的其他问题</h4><blockquote>
<p>建连接时SYN超时</p>
</blockquote>
<p>server收到client发的SYN并回复Ack(SYN)（此处称为Ack1）后,如果client掉线了（或网络超时）,那么server将无法收到client回复的Ack(Ack(SYN))（此处称为Ack2）,连接处于一个中间状态（非成功非失败）。</p>
<p>为了解决中间状态的问题,server如果在一定时间内没有收到Ack2,会重发Ack1（不同于数据传输过程中的重传机制）。Linux下,默认重试5次,加上第一次最多共发送6次；重试间隔从1s开始翻倍增长（一种指数回退策略,Exponential Backoff）,5次的重试时间分别为1s, 2s, 4s, 8s, 16s,第5次发出后还要等待32s才能判断第5次也超时。所以,至多共发送6次,经过1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s,TCP才会认为SYN超时断开这个连接。</p>
<blockquote>
<p>SYN FLOOD攻击  </p>
</blockquote>
<p>可以利用建连接时的SYN超时机制发起SYN Flood攻击——给server发一个SYN就立即下线,于是服务器默认需要占用资源63s才会断开连接。</p>
<p>发SYN的速度是很快的,这样,攻击者很容易将server的SYN队列资源耗尽,使server无法处理正常的新连接。</p>
<p>针对该问题,Linux提供了一个tcp_syncookies参数解决这个问题——当SYN队列满了后,TCP会通过源地址端口、目标地址端口和时间戳构造一个特别的Sequence Number发回去,称为SYN Cookie</p>
<p>如果是攻击者则不会有响应,如果是正常连接,则会把这个SYN Cookie发回来,然后server端可以通过SYN Cookie建连接(即使你不在SYN队列中)。</p>
<p>至于SYN队列中的连接,则不做处理直至超时关闭。请注意,不要用tcp_syncookies参数来处理正常的大负载连接情况,因为SYN Cookie本质上也破坏了建连接的SYN超时机制,是妥协版的TCP协议。</p>
<p>对于正常的连接请求,有另外三个参数可供选择：</p>
<ul>
<li><code>tcp_synack_retries</code>参数设置SYN超时重试次数</li>
<li><code>tcp_max_syn_backlog</code>参数设置最大SYN连接数（SYN队列容量）</li>
<li><code>tcp_abort_on_overflow</code>参数使SYN请求处理不过来的时候拒绝连接</li>
</ul>
<p><br></p>
<h4 id="ISN的同步"><a href="#ISN的同步" class="headerlink" title="ISN的同步"></a>ISN的同步</h4><blockquote>
<p>ISN(初始化序列号,Inital Sequence Number),通信的双方要同步对方ISN——所以叫SYN(全称Synchronize Sequence Numbers)</p>
</blockquote>
<ul>
<li>首先,不能选择静态的ISN。例如,如果连接建好后始终用1来做ISN,如果client发了30个segment（假设一个字节一个segment）过去,但是网络断了,于是 client重连,又用了1做ISN,但是旧连接的那些segment(称为<code>“迷途的重复分组”</code>)到了,由于区分连接的五元组相同(称该新连接为旧连接的<code>“化身”</code>),server会把它们当做新连接中的segment。</li>
<li>然后从上例还能够得知,需要使ISN随时钟动态增长,以保证新连接的ISN大于旧连接。</li>
<li>最后从安全等角度考虑,也不能使ISN的增长呈现规律性(如简单随时钟正比例增长)。这很容易理解,如果增长规律过于简单,则很容伪造ISN对网络两端发起攻击。</li>
</ul>
<p>最终,设计了多种ISN增长算法,普遍使ISN随时钟动态增长,并具有一定的随机性。</p>
<p>RFC793中描述了一种简单的ISN增长算法:ISN会和一个假的时钟绑在一起,这个时钟会在每4微秒对ISN做加一操作,直到超过2^32,又从0开始。</p>
<p>这样一个ISN的周期大约是4.55个小时。定义segment在网络上的最大存活时间为MSL(Maximum Segment Lifetime),网络中存活时间超过MSL的分组将被丢弃。</p>
<p>因此,如果使用RFC793中的ISN增长算法,则MSL的值必须小于4.55小时,以保证不会在相邻的连接中重用ISN(TIME_WAIT也有该作用)。同时,这间接限制了网络的大小(当然4.55小时的MSL已经能构造非常大的网络了)。</p>
<p><br><br><br></p>
<h4 id="挥手过程中的其他问题"><a href="#挥手过程中的其他问题" class="headerlink" title="挥手过程中的其他问题"></a>挥手过程中的其他问题</h4><h5 id="为什么需要TIME-WAIT"><a href="#为什么需要TIME-WAIT" class="headerlink" title="为什么需要TIME_WAIT"></a>为什么需要TIME_WAIT</h5><p>在TCP状态机中,从<code>TIME_WAIT</code>状态到<code>CLOSED</code>状态,有一个超时时间<code>2 MSL</code>。为什么需要TIME_WAIT状态,且超时时间为<code>2 MSL</code>？主要有两个原因：</p>
<ul>
<li><code>2 * MSL</code>确保有足够的时间让被动方收到了ACK或主动方收到了被动方发超时重传的FIN。即如果被动方没有收到Ack,就会触发被动方重传FIN,发送Ack+接收FIN正好2个MSL,<code>TIME_WAIT</code>状态的连接收到重传的FIN后,重传Ack,再等待<code>2 * MSL</code>时间。</li>
<li>确保有足够的时间让<code>“迷途的重复分组”</code>过期丢弃。这只需要<code>1 * MSL</code>即可,超过MSL的分组将被丢弃,否则很容易同新连接的数据混在一起（仅仅依靠ISN是不行的）。</li>
</ul>
<p><br></p>
<h5 id="大规模出现TIME-WAIT"><a href="#大规模出现TIME-WAIT" class="headerlink" title="大规模出现TIME_WAIT"></a>大规模出现TIME_WAIT</h5><p>一个常见问题是大规模出现TIME_WAIT,通常是在高并发短连接的场景中,会消耗很多资源。</p>
<p>网上大部分文章都是教你打开两个参数,<code>tcp_tw_reuse</code>或<code>tcp_tw_recycle</code>。这两个参数默认都是关闭的,<code>tcp_tw_recycle比tcp_tw_reuse</code>更为激进；要想使用二者,还需要打开<code>tcp_timestamps</code>(默认打开),否则无效。不过,打开这两个参数可能会让TCP连接出现诡异的问题：如上所述,如果不等待超时就重用连接的话,新旧连接的数据可能会混在一起,比如新连接握手期间收到了旧连接的FIN,则新连接会被重置。因此,使用这两个参数时应格外小心。</p>
<p>各参数详细如下：</p>
<ul>
<li><code>tcp_tw_reuse</code>：官方文档上说<code>tcp_tw_reuse</code>加上<code>tcp_timestamps</code>可以保证客户端(仅客户端)在协议角度的安全,但是需要在两端都打开tcp_timestamps。</li>
<li><code>tcp_tw_recycle</code>：如果是<code>tcp_tw_recycle</code>被打开了话,会假设对端开启了<code>tcp_timestamps</code>,然后会去比较时间戳,如果时间戳变大了,就可以重用连接(NAT网络有可能建连接失败,出现<code>”connection time out”</code>的错误)。</li>
</ul>
<p>补充一个参数：</p>
<ul>
<li><code>tcp_max_tw_buckets</code>：控制并发的TIME_WAIT的数量(默认180000),如果超限,系统会把多余的TIME_WAIT连接destory掉,然后在日志里打一个警告(如<code>“time wait bucket table overflow”</code>)。官网文档说这个参数是用来对抗DDoS攻击的,需要根据实际情况考虑。</li>
</ul>
<p><br></p>
<h5 id="关于TIME-WAIT的建议"><a href="#关于TIME-WAIT的建议" class="headerlink" title="关于TIME_WAIT的建议"></a>关于TIME_WAIT的建议</h5><p>总之<code>TIME_WAIT</code>出现在主动发起挥手的一方,即谁发起挥手谁就要牺牲资源维护那些等待从TIME_WAIT转换到CLOSED状态的连接。TIME_WAIT的存在是必要的,因此与其通过上述参数破协议来逃避TIME_WAIT,不如好好优化业务(如改用长连接等),针对不同业务优化TIME_WAIT问题。</p>
<p>对于HTTP服务器,可以设置HTTP的KeepAlive参数,在应用层重用TCP连接来处理多个HTTP请求(需要浏览器配合),让client端(即浏览器)发起挥手,这样TIME_WAIT只会出现在client端。</p>
<p><br></p>
<h3 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h3><p>TCP协议通过重传机制保证所有的segment都可以到达对端,通过滑动窗口允许一定程度的乱序和丢包(滑动窗口还具有流量控制等作用,暂不讨论)。注意,此处重传机制特指数据传输阶段,握手、挥手阶段的传输机制与此不同。</p>
<p>TCP是面向字节流的,Seq与Ack的增长均以字节为单位。</p>
<p>在最朴素的实现中,为了减少网络传输,接收端只回复最后一个连续包的Ack,并相应移动窗口。</p>
<p>比如,发送端发送1,2,3,4,5一共五份数据(假设一份数据一个字节),接收端快速收到了<code>Seq 1</code>,<code>Seq 2</code>,于是回<code>Ack 3</code>,并移动窗口;然后收到了<code>Seq 4</code>,由于在此之前未收到过<code>Seq 3</code>(乱序),如果仍在窗口内,则只填充窗口,但不发送<code>Ack 5</code>,否则丢弃<code>Seq 3</code>(与丢包的效果相似);<br>假设在窗口内,则等以后收到<code>Seq 3</code>时,发现<code>Seq 4</code>及以前的数据包都收到了,则回<code>Ack 5</code>,并移动窗口。</p>
<h4 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h4><p>当发送方发现等待<code>Seq 3</code>的<code>Ack</code>(即<code>Ack 4</code>)超时后,会认为<code>Seq 3</code>发送“失败”,重传<code>Seq 3</code>。一旦接收方收到<code>Seq 3</code>,会立即回<code>Ack 4</code>。</p>
<blockquote>
<p>发送方无法区分是<code>Seq 3</code>丢包、接收方故障、还是<code>Ack 4</code>丢包,本文统一表述为Seq发送“失败”。</p>
</blockquote>
<p>这种方式有些问题：假设目前已收到了<code>Seq 4</code>；由于未收到<code>Seq 3</code>,导致发送方重传<code>Seq 3</code>,在收到重传的<code>Seq 3</code>之前,包括新收到的<code>Seq 5</code>和刚才收到的<code>Seq 4</code>都不能回复Ack,很容易引发发送方重传<code>Seq 4</code>、<code>Seq5</code>。接收方之前已经将<code>Seq 4</code>、<code>Seq 5</code>保存到窗口中,此时重传<code>Seq 4</code>、<code>Seq 5</code>明显造成浪费。</p>
<blockquote>
<p>也就是说,超时重传机制面临“重传一个还是重传所有”的问题即：</p>
</blockquote>
<ul>
<li>重传一个：仅重传timeout的包（即Seq 3）,后续包等超时后再重传。节省资源,但效率略低。</li>
<li>重传所有：每次都重传timeout包及之后所有的数据（即Seq 3、4、5）。效率更高（如果带宽未打满）,但浪费资源。</li>
</ul>
<p>可知,两种方法都属于超时重传机制,各有利弊,但二者都需要等待timeout,是基于时间驱动的,性能与timeout的长度密切相关。如果timeout很长（普遍情况）,则两种方法的性能都会受到较大影响。</p>
<h4 id="快速重传机制"><a href="#快速重传机制" class="headerlink" title="快速重传机制"></a>快速重传机制</h4><p>最理想的方案是:在超时之前,通过某种机制要求发送方尽快重传timeout的包（即<code>Seq 3</code>）,如快速重传机制（Fast Retransmit）。</p>
<p>这种方案浪费资源（浪费多少取决于<code>“重传一个还是重传所有”</code>,见下）,但效率非常高（因为不需要等待timeout了）。</p>
<p>快速重传机制不基于时间驱动,而基于数据驱动:如果包没有连续到达,就Ack最后那个可能被丢了的包；如果发送方连续收到3次相同的Ack,就重传对应的Seq。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如：假设发送方仍然发送1,2,3,4,5共5份数据；接收方先收到Seq 1,回Ack 2；</span><br><span class="line">然后Seq 2因网络原因丢失了,正常收到Seq 3,继续回Ack 2；</span><br><span class="line">后面Seq 4和Seq 5都到了,最后一个可能被丢了的包还是Seq 2,继续回Ack 2；</span><br><span class="line">现在发送方已经连续收到4次（大于等于3次）相同的Ack（即Ack 2）,知道最大序号的未收到包是Seq 2,于是重传Seq 2,并清空Ack 2的计数器；</span><br><span class="line">最后,接收方收到了Seq 2,查看窗口发现Seq 3、4、5都收到了,回Ack 6。</span><br></pre></td></tr></table></figure>
<p>示意图如下：</p>
<p><img src="/2018/10/22/net-coding/image-10.png" width="400px"></p>
<p>快速重传解决了timeout的问题,但依然面临“重传一个还是重传所有”的问题。对于上面的示例来说,是只重传Seq 2呢还是重传Seq 2、3、4、5呢？</p>
<p>如果只使用快速重传,则必须重传所有：因为发送方并不清楚上述连续的4次Ack 2是因为哪些Seq传回来的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设发送方发出了Seq 1到Seq 20供20份数据</span><br><span class="line">只有Seq 1、6、10、20到达了接收方,触发重传Ack 2;</span><br><span class="line">然后发送方重传Seq 2,接收方收到,回复Ack 3;</span><br><span class="line">接下来,发送方与接收方都不会再发送任何数据,两端陷入等待。</span><br><span class="line">因此,发送方只能选择“重传所有”,这也是某些TCP协议的实际实现,对于带宽未满时重传效率的提升非常明显。</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><h4 id="RTT算法"><a href="#RTT算法" class="headerlink" title="RTT算法"></a>RTT算法</h4><p>根据前文对TCP超时重传机制的介绍,我们知道<code>Timeout</code>的设置对于重传非常重要：</p>
<ul>
<li>设长了,重发就慢,丢了老半天才重发,没有效率,性能差。</li>
<li>设短了,会导致可能并没有丢就重发。于是重发的就快,会增加网络拥塞,导致更多的超时,更多的超时导致更多的重发。</li>
</ul>
<p>而且这个超时时间在不同的网络环境下不同,必须动态设置。</p>
<p>为此TCP引入了RTT（<code>Round Trip Time</code>,环回时间）:一个数据包从发出去到回来的时间。</p>
<p>这样,发送端就大约知道正常传输需要多少时间,据此计算RTO（<code>Retransmission TimeOut</code>,超时重传时间）。 </p>
<p>算法有以下实现  </p>
<ul>
<li>经典算法  <ul>
<li>首先采样RTT,记下最近几次的RTT值。  </li>
<li>然后使用加权移动平均算法(<code>Weighted Moving Average Method</code>)做平滑,计算SRTT(<code>Smoothed RTT</code>)  </li>
<li>最后计算RTO:<code>RTO = min [ UBOUND, max [ LBOUND, (β * SRTT) ] ]</code>(通常取1.3≤β≤2.0)  </li>
</ul>
</li>
<li>Karn / Partridge 算法    </li>
<li>Jacobson / Karels 算法  </li>
</ul>
<p><br></p>
<h4 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h4><p>TCP使用滑动窗口(<code>Sliding Window</code>)做<code>流量控制</code>与<code>乱序重排</code>  </p>
<p>TCP头里有一个字段叫<code>Window</code>(或<code>Advertised Window</code>),用于接收方通知发送方自己还有多少缓冲区可以接收数据。</p>
<p>发送方根据接收方的处理能力来发送数据,不会导致接收方处理不过来,是谓流量控制。暂且把<code>Advertised Window</code>当做滑动窗口,更容易理解滑动窗口如何完成流量控制,后面介绍拥塞控制时再说明二者的区别。</p>
<p><img src="/2018/10/22/net-coding/image-11.png" width="500px">  </p>
<p>假设位置序号从左向右增长（常见的读、写缓冲区设计）,解释一下：</p>
<ul>
<li>发送方：<code>LastByteAcked</code>指向收到的连续最大Ack的位置;<code>LastByteSent</code>指向已发送的最后一个字节的位置;<code>LastByteWritten</code>指向上层应用已写完的最后一个字节的位置。</li>
<li>接收方：<code>LastByteRead</code>指向上层应用已读完的最后一个字节的位置;<code>NextByteExpected</code>指向收到的连续最大Seq的位置;<code>LastByteRcvd</code>指向已收到的最后一个字节的位置。可以看到<code>NextByteExpected</code>与<code>LastByteRcvd</code>中间有些Seq还没有到达,对应空白区。</li>
</ul>
<blockquote>
<p><code>Advertised Window</code>衡量接收方还能接收的数据量,发送方要根据<code>Advertised Window</code>决定接下来发送的数据量上限,即<code>EffectiveWindow</code>(可能为0）。</p>
</blockquote>
<p>据此在接收方计算<code>Advertised Window</code>,在发送方计算<code>Effective Window</code>:</p>
<ul>
<li>接收方在Ack中记录自己的<code>AdvertisedWindow = MaxRcvBuffer – (LastByteRcvd - LastByteRead)</code>,随Ack回复到发送方。</li>
<li>发送方根据Ack中的<code>Advertised Window</code>值,需保证<code>LastByteSent - LastByteAcked ≤ AdvertisedWindow</code>,则窗口内剩余可发送的数据大小<code>EffectiveWindow = AdvertisedWindow - (LastByteSent - LastByteAcked)</code>,以保证接收方可以处理。  </li>
</ul>
<hr>

<blockquote>
<p>发送缓冲区的滑动窗口</p>
</blockquote>
<p><img src="/2018/10/22/net-coding/image-12.png" width="500px">  </p>
<p>上图分为4个部分：</p>
<ul>
<li><code>#1</code>是已发送已确认的数据,即LastByteAcked之前的区域。</li>
<li><code>#2</code>是已发送未确认的数据,即LastByteAcked与LastByteSent之间的区域,大小不超过AdvertisedWindow。</li>
<li><code>#3</code>是窗口内未发送的数据,即LastByteSent与窗口右界之间的区域,大小等于EffectiveWindow(可能为0)。</li>
<li><code>#4</code>是窗口外未发送的数据,即窗口右界与LastByteWritten之间的区域。</li>
</ul>
<p>其中,<code>#2 + #3</code>组成了滑动窗口,总大小不超过AdvertisedWindow,二者比例受到接收方的处理速度与网络情况的影响（如果丢包严重或处理速度慢于发送速度,则<code>#2</code>:<code>#3</code>会越来越大）。</p>
<blockquote>
<p>以下是一个AdvertisedWindow的调整过程,EffectiveWindow随之变化;</p>
</blockquote>
<p><img src="/2018/10/22/net-coding/image-13.png" width="600px"></p>
<p><br></p>
<h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><blockquote>
<p>为什么要进行拥塞控制？</p>
</blockquote>
<p>假设网络已经出现拥塞,如果不处理拥塞,那么延时增加,出现更多丢包,触发发送方重传数据,加剧拥塞情况,继续恶性循环直至网络瘫痪。可知,拥塞控制与流量控制的适应场景和目的均不同。</p>
<p>拥塞发生前,可避免流量过快增长拖垮网络；拥塞发生时,唯一的选择就是降低流量。</p>
<p>主要使用4种算法完成拥塞控制:</p>
<ul>
<li>1:慢启动</li>
<li>2:拥塞避免</li>
<li>3:拥塞发生</li>
<li>4:快速恢复</li>
</ul>
<p>算法1、2适用于拥塞发生前,算法3适用于拥塞发生时,算法4适用于拥塞解决后(相当于拥塞发生前)。</p>
<p><br></p>
<p><code>rwnd</code>(<code>Receiver Window</code>,接收者窗口)与<code>cwnd</code>(<code>Congestion Window</code>,拥塞窗口)的概念:</p>
<ul>
<li><code>rwnd</code>是用于流量控制的窗口大小,即上述流量控制中的<code>AdvertisedWindow</code>,主要取决于接收方的处理速度,由接收方通知发送方被动调整。</li>
<li><code>cwnd</code>是用于拥塞处理的窗口大小,取决于网络状况,由发送方探查网络主动调整。</li>
</ul>
<p>介绍流量控制时,我们在没有考虑<code>cwnd</code>,认为发送方的滑动窗口最大即为<code>rwnd</code>。</p>
<p>实际上需要同时考虑流量控制与拥塞处理,则发送方窗口的大小不超过<code>min{rwnd, cwnd}</code>。</p>
<p>下述4种拥塞控制算法只涉及对<code>cwnd</code>的调整,同介绍流量控制时一样,暂且不考虑<code>rwnd</code>,假定滑动窗口最大为<code>cwnd</code>;但读者应明确<code>rwnd</code>、<code>cwnd</code>与发送方窗口大小的关系。</p>
<h4 id="慢启动算法"><a href="#慢启动算法" class="headerlink" title="慢启动算法"></a>慢启动算法</h4><p><code>慢启动算法(Slow Start)</code>作用在拥塞产生之前:对于刚刚加入网络的连接,要一点一点的提速,不要妄图一步到位。</p>
<p>如下：</p>
<ul>
<li>连接刚建好,初始化<code>cwnd = 1</code>(当然,通常不会初始化为1,太小),表明可以传一个MSS大小的数据。</li>
<li>每收到一个ACK,<code>cwnd++</code>,线性增长。</li>
<li>每经过一个RTT,<code>cwnd = cwnd * 2</code>,指数增长(主要增长来源)。</li>
<li>还有一个<code>ssthresh(slow start threshold)</code>,当<code>cwnd &gt;= ssthresh</code>时,就会进入拥塞避免算法。</li>
</ul>
<p>因此如果网速很快的话,Ack返回快,RTT短,那么这个慢启动就一点也不慢。下图说明了这个过程：</p>
<p><img src="/2018/10/22/net-coding/image-14.png" width="500px"></p>
<p><br></p>
<h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><p>前面说过,当<code>cwnd &gt;= ssthresh</code>(通常<code>ssthresh = 65535</code>)时,就会进入拥塞避免算法(<code>Congestion Avoidance</code>):缓慢增长,小心翼翼的找到最优值。如下：</p>
<ul>
<li>每收到一个Ack,<code>cwnd = cwnd + 1/cwnd</code>,显然cwnd &gt; 1时无增长。</li>
<li>每经过一个RTT,<code>cwnd++</code>,线性增长(主要增长来源)。</li>
</ul>
<p>慢启动算法主要呈指数增长,粗犷型,速度快(<code>“慢”</code>是相对于一步到位而言的);</p>
<p>而拥塞避免算法主要呈线性增长,精细型,速度慢,但更容易在不导致拥塞的情况下,找到网络环境的cwnd最优值。</p>
<p><br> </p>
<h4 id="拥塞发生时的算法"><a href="#拥塞发生时的算法" class="headerlink" title="拥塞发生时的算法"></a>拥塞发生时的算法</h4><p>慢启动与拥塞避免算法作用在拥塞发生前,采取不同的策略增大<code>cwnd</code>;如果已经发生拥塞,则需要采取策略减小<code>cwnd</code>。</p>
<blockquote>
<p>那么TCP如何判断当前网络拥塞了呢？</p>
</blockquote>
<p>很简单,如果发送方发现有Seq发送失败(表现为“丢包”),就认为网络拥塞了。</p>
<p>丢包后有两种重传方式,对应不同的网络情况,也就对应着两种拥塞发生时的控制算法：</p>
<ul>
<li><p>超时重传。TCP认为这种情况太糟糕,调整力度比较大</p>
<ul>
<li><code>ssthresh =  cwnd /2</code></li>
<li><code>cwnd = 1</code>,重新进入慢启动过程(网络糟糕,要慢慢调整)</li>
</ul>
</li>
<li><p>快速重传。TCP认为这种情况通常比RTO超时好一些,主流实现TCP Reno的调整力度更柔和（TCP Tahoe的实现和RTO超时一样暴躁）：</p>
<ul>
<li><code>ssthresh =  cwnd /2</code></li>
<li><code>cwnd = cwnd /2</code>,进入快速恢复算法(网络没那么糟,可以快速调整,见下)</li>
</ul>
</li>
</ul>
<p>可以看到,不管是哪种重传方式,<code>ssthresh</code>都会变成<code>cwnd</code>的一半,仍然是指数回退,待拥塞消失后再逐渐增长回到新的最优值,总体上在最优值（动态）附近震荡。</p>
<p>回退后根据不同的网络情况,可以选择不同的恢复算法。慢启动已经介绍过了,下面介绍快速恢复算法。</p>
<p><br></p>
<h4 id="快速恢复算法"><a href="#快速恢复算法" class="headerlink" title="快速恢复算法"></a>快速恢复算法</h4><p>如果触发了快速重传,即发送方收到至少3次相同的Ack,那么TCP认为网络情况不那么糟,也就没必要提心吊胆的,可以适当大胆的恢复。</p>
<p>为此设计快速恢复算法（Fast Recovery）,下面介绍TCP Reno中的实现。<br>回顾一下,进入快速恢复之前,cwnd和sshthresh已被更新:</p>
<ul>
<li><code>ssthresh = cwnd /2</code></li>
<li><code>cwnd = cwnd /2</code></li>
</ul>
<p>然后,进入快速恢复算法：</p>
<ul>
<li><code>cwnd = ssthresh  + 3 * MSS</code>(尝试一步到位)</li>
<li>重传重复Ack对应的Seq</li>
<li>如果再收到该重复Ack,则<code>cwnd++</code>,线性增长(缓慢调整)</li>
<li>如果收到了新Ack,则<code>cwnd = ssthresh</code>,然后就进入了拥塞避免的算法了</li>
</ul>
<blockquote>
<p><code>cwnd</code>变化图   </p>
</blockquote>
<p><img src="/2018/10/22/net-coding/image-15.png" width="600px"></p>
<p><br><br><br></p>
<h3 id="TCP数据传输过程"><a href="#TCP数据传输过程" class="headerlink" title="TCP数据传输过程"></a>TCP数据传输过程</h3><ul>
<li><p>交互式与成块的数据</p>
</li>
<li><p>时间延迟确认</p>
</li>
<li><p>Nagle算法<br>让数据饱满,数据量小的不发出去,存着等一定量才发送,游戏开发一般关闭这个算法</p>
</li>
<li><p>接收窗口大小</p>
<p><code>windowsSize</code></p>
</li>
</ul>
<p><br> </p>
<h3 id="TCP的定时器"><a href="#TCP的定时器" class="headerlink" title="TCP的定时器"></a>TCP的定时器</h3><ul>
<li><p>重传定时器</p>
<p>当客户端给另一机器发送信息,对方没有确认也没返回错误,过一段时间tcp底层会认为要重传数据包</p>
</li>
<li><p>坚持定时器(Persist)</p>
<p>tcp两边传输会通过接收窗口windowsSize,一边狂穿另一边会给对方windowsSize为0,表示无法处理发送过来的大量信息,后期通过坚持定时器来看windowsSize是否可在接受数据不为0</p>
</li>
<li><p>保活定时器(KeepAlive)</p>
<p>当双方不传消息,无法探知对方还存在,tcp实现底层可通过保活定时器来确定是否对方在否</p>
<p>一般应用程序都不这个定时器,直接发送数据包过去,收到就是存活,由应用程序来确认而不需要tcp自己通过保活定时器来确认</p>
</li>
<li><p>2MSL定时器(TIME_WAIT)</p>
<p>两倍最大生存时间</p>
</li>
</ul>
<p><br> </p>
<h3 id="WireShark"><a href="#WireShark" class="headerlink" title="WireShark"></a>WireShark</h3><p>以太网有头部和尾部,但是在wireShark没有头尾,wireShark也只是模拟捕获以太网传输的数据,如果这个数据在以太网没法通过也不会到应用程序,所以wireShark只是模拟,CIC检查和所以就去掉了</p>
<p><img src="/2018/10/22/net-coding/image-08.png" width="700px"></p>
<p><br> </p>
<h4 id="tcp头部为何先放端口信息"><a href="#tcp头部为何先放端口信息" class="headerlink" title="tcp头部为何先放端口信息?"></a>tcp头部为何先放端口信息?</h4><p>当tcp消息到达处理计算机,先根据端口有没有程序处理,如果端口都没有是不是没有必要考虑后面的检查</p>
<h4 id="三次握手会不会被恶意使用"><a href="#三次握手会不会被恶意使用" class="headerlink" title="三次握手会不会被恶意使用"></a>三次握手会不会被恶意使用</h4><p>假如说server端遇到恶意客户端,客户端发送SYN,服务到那返回SYN+ACK,但客户端没有返回ACK挂起了了服务端消耗的资源,客户端无所谓……..这就所谓的DDOS</p>
<h4 id="消息确认有没有弱点"><a href="#消息确认有没有弱点" class="headerlink" title="消息确认有没有弱点"></a>消息确认有没有弱点</h4><p>seq,ack,以前A机器发送B机器,但是C机器截获,通过分析预测,来模拟seq和ack,从而串改数据包,在linux底层做了预防和处理</p>
<p><br><br><br> </p>
<h3 id="SocketApi"><a href="#SocketApi" class="headerlink" title="SocketApi"></a>SocketApi</h3><p>对于C级别的SocketApi,伯克利Socket</p>
<blockquote>
<p>小于1024的端口位需要root权限</p>
</blockquote>
<h4 id="Api历史"><a href="#Api历史" class="headerlink" title="Api历史"></a>Api历史</h4><p>伯克利Socket,也称为BSD Socket</p>
<p>4.2版本发布1983年非常成熟</p>
<p>1989年的时候全部的UNIX操作系统均可采用</p>
<p>最终成为POSIX标准2008</p>
<h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><ul>
<li><p><code>sys/socket.h</code>函数和数据结构定义在头文件中</p>
</li>
<li><p><code>netinet/in.h</code> IPv4和v6相关的协议族需要的信息</p>
</li>
<li><code>sys/un.h</code>UNIX机器间通信的相关信息</li>
<li><code>arpa/inet.h</code>处理数字从操作系统字节序到网络字节序,这里将LittleEndian和BigEndian的字节序</li>
<li><code>netdb.h</code>映射服务到IP地址</li>
</ul>
<h4 id="SocketApi函数"><a href="#SocketApi函数" class="headerlink" title="SocketApi函数"></a>SocketApi函数</h4><ul>
<li><p><code>socket()</code> 创建socket</p>
</li>
<li><p><code>bind()</code>绑定socket到IP地址和端口</p>
</li>
<li><p><code>listen()</code>服务器监听客户端的链接</p>
</li>
<li><p><code>connect()</code>客户端连接到服务器</p>
</li>
<li><p><code>accept()</code>应用程序完成3此握手的客户端链接</p>
</li>
<li><p><code>send()</code>,<code>recv()</code>,<code>write()</code>,<code>read()</code>机器间相互发送数据,返回的True,只是表示本机已经写入操作系统等信息,并不是到达网络目标机器</p>
<p>read返回-1网络故障</p>
<p>read返回0是操作成功但是无数据了</p>
<p>read非0是读了多少字节到buffer</p>
</li>
<li><p><code>close()</code>关闭socket,双工的两个通道全部关闭了,不是我这边关闭单通道</p>
</li>
<li><p><code>gethostbyname()</code>,<code>gethostbyaddr()</code>v4专有</p>
</li>
<li><p><code>select()</code>,<code>poll()</code>处理多个连接的读、写和错误状态</p>
</li>
<li><p><code>getsocketopt()</code>得到对应的socket选项值</p>
</li>
<li><p><code>setsocketopt()</code>设置对应的socket选项值</p>
</li>
<li><p><code>kqueue</code>,<code>epoll</code>,<code>iocp</code>各个平台有各个单独的处理多个连接的优化,出来先后顺序就是这个</p>
</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>基于linux,该实例实现了服务端传了一个hello world给客户端。</p>
<ul>
<li>socket()创建socket</li>
<li>bind()绑定socket到IP地址和端口</li>
<li>listen()服务器监听客户端的连接</li>
<li>connect()客户端连接到服务器</li>
<li>accept()应用程序接受完成3次握手的客户端连接</li>
<li>send() recv() write() read()机器间相互发送数据</li>
<li>close() 关闭socket</li>
<li>gethostbyname()   gethostbyaddr() V4专有</li>
<li>select() poll() 处理多个连接的读、写和错误状态</li>
<li>getsockopt()得到对应socket的选项值</li>
<li>setsockopt()设置对应socket的选项值</li>
</ul>
<p>具体代码如下：</p>
<blockquote>
<p>服务端部分</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> hello[] = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="keyword">int</span> SocketFD = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); <span class="comment">//返回-1表示资源不够</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == SocketFD) &#123;</span><br><span class="line">        perror(<span class="string">"cannot create socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span> sa); <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    sa.sin_family = AF_INET;</span><br><span class="line">    sa.sin_port = htons(<span class="number">2222</span>);</span><br><span class="line">    sa.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == bind(SocketFD, (struct sockaddr*)&amp;sa, <span class="keyword">sizeof</span> sa)) &#123;</span><br><span class="line">        <span class="comment">// 端口小于1024需要root权限</span></span><br><span class="line">        perror(<span class="string">"bind failed"</span>);</span><br><span class="line">        close(SocketFD); <span class="comment">//失败了还得释放FD</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == listen(SocketFD, <span class="number">10</span>)) &#123; <span class="comment">// listen的10相当于一个连接的队列,相当于系数</span></span><br><span class="line">        perror(<span class="string">"listen failed"</span>);</span><br><span class="line">        close(SocketFD); <span class="comment">//失败了还得释放FD</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> ConnectFD = accept(SocketFD, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//接收一个三次握手成功的链接,connectFD就是一个socket pair,ip端口四元组占位符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &gt; ConnectFD) &#123;</span><br><span class="line">            perror(<span class="string">"accept failed"</span>);</span><br><span class="line">            close(SocketFD);  <span class="comment">//失败释放socketFD</span></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> writeSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">size_t</span> totalWrite = <span class="number">0</span>; <span class="comment">// 这里不用int而用size_t是因为sizeof会返回无符号,int跟无符号整型做比较,无符号先转换有符号所以直接导致一些bug</span></span><br><span class="line">        <span class="keyword">while</span> (totalWrite &lt; <span class="keyword">sizeof</span>(hello)) &#123; <span class="comment">//查询写入情况是否满足需要发送数据的大小</span></span><br><span class="line">            <span class="comment">//就先往这个connectFD写入</span></span><br><span class="line">            <span class="comment">//一切皆文件,所以这个connectFD充当了连接四元组</span></span><br><span class="line">            writeSize =</span><br><span class="line">                write(ConnectFD, hello + totalWrite, <span class="keyword">sizeof</span>(hello) - totalWrite);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">-1</span> == writeSize) &#123;</span><br><span class="line">                perror(<span class="string">"write failed"</span>);</span><br><span class="line">                close(ConnectFD);</span><br><span class="line">                close(SocketFD);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//真实写入情况大小总和</span></span><br><span class="line">            totalWrite += writeSize;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关掉可放入参数可以关一个通道还是双通道</span></span><br><span class="line">        <span class="comment">//close的话双通道全部关闭</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span>==shutdown(ConnectFD,SHUT_RDWR))&#123;</span><br><span class="line">            perror(<span class="string">"shutdown failed"</span>);</span><br><span class="line">            close(ConnectFD);</span><br><span class="line">            close(SocketFD);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);        </span><br><span class="line">        &#125;</span><br><span class="line">        close(ConnectFD);    </span><br><span class="line">    &#125;</span><br><span class="line">    close(SocketFD);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>客户端部分</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> hello[] = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="keyword">int</span> SocketFD = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == SocketFD) &#123;</span><br><span class="line">        perror(<span class="string">"cannot create socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span> sa);</span><br><span class="line"></span><br><span class="line">    sa.sin_family = AF_INET;</span><br><span class="line">    sa.sin_port = htons(<span class="number">2222</span>);</span><br><span class="line">    res = inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;sa.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == connect(SocketFD, (struct sockaddr*)&amp;sa, <span class="keyword">sizeof</span> sa)) &#123;</span><br><span class="line">        perror(<span class="string">"connect failed"</span>);</span><br><span class="line">        close(SocketFD);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">int</span> totalRead = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> readSize = <span class="number">0</span>;</span><br><span class="line">        readSize = read(SocketFD, buffer + totalRead, <span class="keyword">sizeof</span>(buffer) - totalRead); <span class="comment">//一切皆文件,直接从文件读取</span></span><br><span class="line">        <span class="keyword">if</span> (readSize == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//没有东西读,完毕传输</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (readSize == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">//-1的情况很多,有点error可能是系统繁忙,并不是网络中断</span></span><br><span class="line">            perror(<span class="string">"read failed"</span>);</span><br><span class="line">            close(SocketFD);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);        </span><br><span class="line">        &#125;</span><br><span class="line">        totalRead += readSize;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[totalRead] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get from server:%s\n"</span>, buffer);</span><br><span class="line">    </span><br><span class="line">    (<span class="keyword">void</span>)shutdown(SocketFD, SHUT_RDWR);</span><br><span class="line">    close(SocketFD);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端和服务端哪一边主动的调用了close函数,哪一边进入TIME_WAIT</p>
<p><img src="/2018/10/22/net-coding/image-09.png" width="500px"></p>
<p>哪一边主动close哪边就进入TIME_WAIT,发生在了服务器的TIME_WAIT</p>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2018/10/22/net-coding/';
        this.page.title = 'TCP网络编程笔记';
        this.page.identifier = '2018/10/22/net-coding/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
