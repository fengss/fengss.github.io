<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Go Kernel分析 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="Golang 内核体系架构
初始化12345/usr/local/go/src/runtime/runtime1.go/usr/local/go/src/runtime/os_linux.go/usr/local/go/src/runtime/proc.go

runtime1.go

函数args整理命令行参数
12345func args(c int32, v **byte) &amp;#123;	argc = c	argv = v	sysargs(c, v)&amp;#125;

os_linux.go ">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Go/Rust</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">系统内核</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">威胁追踪</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">数据库</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化"><span class="toc-number">1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存分配"><span class="toc-number">2.</span> <span class="toc-text">内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础概念"><span class="toc-number">2.1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存管理单元"><span class="toc-number">2.2.</span> <span class="toc-text">内存管理单元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存管理组件"><span class="toc-number">2.3.</span> <span class="toc-text">内存管理组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache"><span class="toc-number">2.3.1.</span> <span class="toc-text">Cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Central"><span class="toc-number">2.3.2.</span> <span class="toc-text">Central</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Heap"><span class="toc-number">2.3.3.</span> <span class="toc-text">Heap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分配流程"><span class="toc-number">2.4.</span> <span class="toc-text">分配流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发调度"><span class="toc-number">3.</span> <span class="toc-text">并发调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#P、M、G关系"><span class="toc-number">3.1.</span> <span class="toc-text">P、M、G关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调度流程简述"><span class="toc-number">3.2.</span> <span class="toc-text">调度流程简述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#启动过程"><span class="toc-number">3.2.1.</span> <span class="toc-text">启动过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建goroutine-G"><span class="toc-number">3.2.2.</span> <span class="toc-text">创建goroutine(G)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建内核线程-M"><span class="toc-number">3.2.3.</span> <span class="toc-text">创建内核线程(M)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调度核心"><span class="toc-number">3.2.4.</span> <span class="toc-text">调度核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调度点"><span class="toc-number">3.2.5.</span> <span class="toc-text">调度点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#现场处理"><span class="toc-number">3.2.6.</span> <span class="toc-text">现场处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#垃圾回收"><span class="toc-number">4.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#标记-清扫"><span class="toc-number">4.1.</span> <span class="toc-text">标记-清扫</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三色标记法"><span class="toc-number">4.2.</span> <span class="toc-text">三色标记法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#何时触发-GC"><span class="toc-number">4.2.1.</span> <span class="toc-text">何时触发 GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-触发条件"><span class="toc-number">4.2.2.</span> <span class="toc-text">GC 触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收流程"><span class="toc-number">4.2.3.</span> <span class="toc-text">垃圾回收流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码步骤"><span class="toc-number">4.2.4.</span> <span class="toc-text">源码步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#标记-STW-phase-1"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">标记 STW phase 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mark"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">Mark</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mark-termination-STW-phase-2"><span class="toc-number">4.2.4.3.</span> <span class="toc-text">Mark termination (STW phase 2)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#清扫"><span class="toc-number">4.2.4.4.</span> <span class="toc-text">清扫</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Select-amp-Channel分析"><span class="toc-number">5.</span> <span class="toc-text">Select&amp;Channel分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Select"><span class="toc-number">5.1.</span> <span class="toc-text">Select</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Channel"><span class="toc-number">5.2.</span> <span class="toc-text">Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#发送"><span class="toc-number">5.2.1.</span> <span class="toc-text">发送</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#直接发送"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">直接发送</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓冲区"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#阻塞发送"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">阻塞发送</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接收"><span class="toc-number">5.2.2.</span> <span class="toc-text">接收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#直接接收"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">直接接收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓冲区-1"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#阻塞接收"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">阻塞接收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-number">5.2.3.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#声明"><span class="toc-number">6.</span> <span class="toc-text">声明</span></a></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            Go Kernel分析
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2018/05/10/go-kernel/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-05-10T05:39:17.000Z" itemprop="datePublished">2018-05-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/go/">go</a>, <a class="article-tag-link" href="/tags/go-kernel/">go-kernel</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>Golang 内核体系架构<br><a id="more"></a></p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/go/src/runtime/runtime1.go</span><br><span class="line"></span><br><span class="line">/usr/local/go/src/runtime/os_linux.go</span><br><span class="line"></span><br><span class="line">/usr/local/go/src/runtime/proc.go</span><br></pre></td></tr></table></figure>
<blockquote>
<p>runtime1.go</p>
</blockquote>
<p>函数args整理命令行参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">args</span><span class="params">(c <span class="keyword">int32</span>, v **<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	argc = c</span><br><span class="line">	argv = v</span><br><span class="line">	sysargs(c, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>os_linux.go  </p>
</blockquote>
<p>osinit确定cpu core数量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">osinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ncpu = getproccount()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>proc.go  </p>
</blockquote>
<p>最关键的schedinit这里,几乎要关注的所有运行时环境初始化构造都在这里被调用  </p>
<p>内存分配器、垃圾回收器、并发调度器的初始化细节需要涉猎很多专属特征  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The bootstrap sequence is:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	call osinit</span></span><br><span class="line"><span class="comment">//	call schedinit</span></span><br><span class="line"><span class="comment">//	make &amp; queue new G</span></span><br><span class="line"><span class="comment">//	call runtime·mstart</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The new G calls runtime·main.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		_g_.racectx, raceprocctx0 = raceinit()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 系统最大线程数量限制  </span></span><br><span class="line">	sched.maxmcount = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//栈、内存分配器、调度器相关初始化</span></span><br><span class="line">	tracebackinit()</span><br><span class="line">	moduledataverify()</span><br><span class="line">	stackinit()</span><br><span class="line">	mallocinit()</span><br><span class="line">	mcommoninit(_g_.m)</span><br><span class="line">	cpuinit()       <span class="comment">// must run before alginit</span></span><br><span class="line">	alginit()       <span class="comment">// maps must not be used before this call</span></span><br><span class="line">	modulesinit()   <span class="comment">// provides activeModules</span></span><br><span class="line">	typelinksinit() <span class="comment">// uses maps, activeModules</span></span><br><span class="line">	itabsinit()     <span class="comment">// uses activeModules</span></span><br><span class="line"></span><br><span class="line">	msigsave(_g_.m)</span><br><span class="line">	initSigmask = _g_.m.sigmask</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 垃圾回收初始化</span></span><br><span class="line">	goargs()</span><br><span class="line">	goenvs()</span><br><span class="line">	parsedebugvars()</span><br><span class="line">	gcinit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过CPU core和GOMAXPROCS环境变量确定P数量</span></span><br><span class="line">	sched.lastpoll = <span class="keyword">uint64</span>(nanotime())</span><br><span class="line">	procs := ncpu</span><br><span class="line">	<span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">"GOMAXPROCS"</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		procs = n</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调整P数量</span></span><br><span class="line">	<span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"unknown runnable goroutine during bootstrap"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// For cgocheck &gt; 1, we turn on the write barrier at all times</span></span><br><span class="line">	<span class="comment">// and check all pointer writes. We can't do this until after</span></span><br><span class="line">	<span class="comment">// procresize because the write barrier needs a P.</span></span><br><span class="line">	<span class="keyword">if</span> debug.cgocheck &gt; <span class="number">1</span> &#123;</span><br><span class="line">		writeBarrier.cgo = <span class="literal">true</span></span><br><span class="line">		writeBarrier.enabled = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">			p.wbBuf.reset()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> buildVersion == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="comment">// Condition should never trigger. This code just serves</span></span><br><span class="line">		<span class="comment">// to ensure runtime·buildVersion is kept in the resulting binary.</span></span><br><span class="line">		buildVersion = <span class="string">"unknown"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来要执行runtime.main而不是用户逻辑入口函数main.main</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The main goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Racectx of m0-&gt;g0 is used only as the parent of the main goroutine.</span></span><br><span class="line">	<span class="comment">// It must not be used for anything else.</span></span><br><span class="line">	g.m.g0.racectx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行栈的最大限制: 1GB on 64-bit, 250MB on 32-bit</span></span><br><span class="line">	<span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">		maxstacksize = <span class="number">1000000000</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		maxstacksize = <span class="number">250000000</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow newproc to start new Ms.</span></span><br><span class="line">	mainStarted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动系统后台监控(定时垃圾回收,以及并发任务调度相关的信息)  </span></span><br><span class="line">	<span class="keyword">if</span> GOARCH != <span class="string">"wasm"</span> &#123; <span class="comment">// no threads on wasm yet, so no sysmon</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			newm(sysmon, <span class="literal">nil</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lock the main goroutine onto this, the main OS thread,</span></span><br><span class="line">	<span class="comment">// during initialization. Most programs won't care, but a few</span></span><br><span class="line">	<span class="comment">// do require certain calls to be made by the main thread.</span></span><br><span class="line">	<span class="comment">// Those can arrange for main.main to run in the main thread</span></span><br><span class="line">	<span class="comment">// by calling runtime.LockOSThread during initialization</span></span><br><span class="line">	<span class="comment">// to preserve the lock.</span></span><br><span class="line">	lockOSThread()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> g.m != &amp;m0 &#123;</span><br><span class="line">		throw(<span class="string">"runtime.main not on m0"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行runtime包内所有的初始化函数 init </span></span><br><span class="line">	runtime_init() <span class="comment">// must be before defer</span></span><br><span class="line">	<span class="keyword">if</span> nanotime() == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"nanotime returning zero"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Defer unlock so that runtime.Goexit during init does the unlock too.</span></span><br><span class="line">	needUnlock := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> needUnlock &#123;</span><br><span class="line">			unlockOSThread()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	runtimeInitTime = nanotime()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动垃圾回收器后台操作  </span></span><br><span class="line">	gcenable()</span><br><span class="line"></span><br><span class="line">	main_init_done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">if</span> iscgo &#123;</span><br><span class="line">		<span class="keyword">if</span> _cgo_thread_start == <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">"_cgo_thread_start missing"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> GOOS != <span class="string">"windows"</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> _cgo_setenv == <span class="literal">nil</span> &#123;</span><br><span class="line">				throw(<span class="string">"_cgo_setenv missing"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> _cgo_unsetenv == <span class="literal">nil</span> &#123;</span><br><span class="line">				throw(<span class="string">"_cgo_unsetenv missing"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> _cgo_notify_runtime_init_done == <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">"_cgo_notify_runtime_init_done missing"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Start the template thread in case we enter Go from</span></span><br><span class="line">		<span class="comment">// a C-created thread and need to create a new thread.</span></span><br><span class="line">		startTemplateThread()</span><br><span class="line">		cgocall(_cgo_notify_runtime_init_done, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行所有用户包的初始化函数init</span></span><br><span class="line">	fn := main_init <span class="comment">// make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime</span></span><br><span class="line">	fn()</span><br><span class="line">	<span class="built_in">close</span>(main_init_done)</span><br><span class="line"></span><br><span class="line">	needUnlock = <span class="literal">false</span></span><br><span class="line">	unlockOSThread()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行用户逻辑入口 main.main函数  </span></span><br><span class="line">	<span class="keyword">if</span> isarchive || islibrary &#123;</span><br><span class="line">		<span class="comment">// A program compiled with -buildmode=c-archive or c-shared</span></span><br><span class="line">		<span class="comment">// has a main, but it is not executed.</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fn = main_main <span class="comment">// make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime</span></span><br><span class="line">	fn()</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racefini()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make racy client program work: if panicking on</span></span><br><span class="line">	<span class="comment">// another goroutine at the same time as main returns,</span></span><br><span class="line">	<span class="comment">// let the other goroutine finish printing the panic trace.</span></span><br><span class="line">	<span class="comment">// Once it does, it will exit. See issues 3934 and 20018.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;runningPanicDefers) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Running deferred functions should not take long.</span></span><br><span class="line">		<span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="number">1000</span>; c++ &#123;</span><br><span class="line">			<span class="keyword">if</span> atomic.Load(&amp;runningPanicDefers) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			Gosched()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;panicking) != <span class="number">0</span> &#123;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonPanicWait, traceEvGoStop, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	exit(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> x *<span class="keyword">int32</span></span><br><span class="line">		*x = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>所有init函数都在同一个goroutine内执行  </p>
</li>
<li><p>所有init函数结束后才会执行main.main函数  </p>
</li>
</ul>
<p><br><br><br></p>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>在深入内存分配算法细节前,需了解基本概念   </p>
<ul>
<li>每次从操作系统申请一大块内存,减少系统调用  </li>
<li>将申请到的大块内存按特定大小预先切分成小块,构成链表  </li>
<li>为对象分配内存时,只须从大小合适的链表提取一个小块即可  </li>
<li>回收对象内存时,将该小块内存重新归还原链表以供复用  </li>
<li>如闲置内存过多,则归还部分内存给操作系统,降低整体开销  </li>
</ul>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>申请到的内存块被分配了三个区域,在X64上分别是512MB,16GB,512GB大小。</p>
<p><img src="/2018/05/10/go-kernel/image-02.png" width="600px">  </p>
<blockquote>
<p>arena</p>
</blockquote>
<p><code>arena</code>区域就是我们所谓的堆区,Go动态分配的内存都是在这个区域,它把内存分割成8KB大小的页,一些页组合起来称为mspan。</p>
<blockquote>
<p>bitmap</p>
</blockquote>
<p><code>bitmap</code>区域标识<code>arena</code>区域哪些地址保存了对象,并且用4bit标志位表示对象是否包含指针、GC标记信息。<code>bitmap</code>中一个byte大小的内存对应<code>arena</code>区域中4个指针大小(指针大小为 8B )的内存,所以bitmap区域的大小是<code>512GB/(4*8B)=16GB</code>。</p>
<p><img src="/2018/05/10/go-kernel/image-03.png" width="600px"></p>
<p><img src="/2018/05/10/go-kernel/image-04.png" width="600px"></p>
<p>可以看到bitmap的高地址部分指向arena区域的低地址部分,也就是说bitmap的地址是由高地址向低地址增长的</p>
<blockquote>
<p>spans </p>
</blockquote>
<p><code>spans</code>区域存放<code>mspan</code>(也就是一些arena分割的页组合起来的内存管理基本单元,后文会再讲)的指针  </p>
<p>每个指针对应一页,所以<code>spans</code>区域的大小就是<code>512GB/8KB*8B=512MB</code>。</p>
<p>除以8KB是计算<code>arena</code>区域的页数,而最后乘以8是计算<code>spans</code>区域所有指针的大小。</p>
<p>创建<code>mspan</code>的时候,按页填充对应的<code>spans</code>区域,在回收object时,根据地址很容易就能找到它所属的<code>mspan</code>。</p>
<p><br><br><br></p>
<h2 id="内存管理单元"><a href="#内存管理单元" class="headerlink" title="内存管理单元"></a>内存管理单元</h2><blockquote>
<p>内存块  </p>
</blockquote>
<ul>
<li><p>span: 是一个双端链表的形式,里面存储了它的一些位置信息组成的大块内存。</p>
<p>  通过一个基地址+(页号*页大小),就可以定位到这个MSpan的实际内存空间。</p>
</li>
</ul>
<ul>
<li>object: 将span按特定大小切分成多个小块,每个小块可存储一个对象  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mspan:Go中内存管理的基本单元,是由一片连续的8KB的页组成的大块内存。</span><br><span class="line"></span><br><span class="line">注意这里的页和操作系统本身的页并不是一回事,它一般是操作系统页大小的几倍。</span><br><span class="line">一句话概括:mspan是一个包含起始地址、mspan规格、页的数量等内容的双端链表。</span><br><span class="line"></span><br><span class="line">每个mspan按照它自身的属性Size Class的大小分割成若干个object,每个object可存储一个对象。并且会使用一个位图来标记其尚未使用的object。</span><br><span class="line">属性Size Class决定object大小,而mspan只会分配给和object尺寸大小接近的对象,当然,对象的大小要小于object大小。</span><br><span class="line"></span><br><span class="line">还有一个概念:Span Class,它和Size Class的含义差不多</span><br></pre></td></tr></table></figure>
<p><img src="/2018/05/10/go-kernel/image-05.png" width="300px"></p>
<p>Go1.9.2里mspan的Size Class共有67种,每种mspan分割的object大小是<code>8*2n</code>的倍数,这个是写死在代码里的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path: /usr/local/go/src/runtime/sizeclasses.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _NumSizeClasses = <span class="number">67</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> class_to_size = [_NumSizeClasses]<span class="keyword">uint16</span>&#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>, <span class="number">144</span>, <span class="number">160</span>, <span class="number">176</span>, <span class="number">192</span>, <span class="number">208</span>, <span class="number">224</span>, <span class="number">240</span>, <span class="number">256</span>, <span class="number">288</span>, <span class="number">320</span>, <span class="number">352</span>, <span class="number">384</span>, <span class="number">416</span>, <span class="number">448</span>, <span class="number">480</span>, <span class="number">512</span>, <span class="number">576</span>, <span class="number">640</span>, <span class="number">704</span>, <span class="number">768</span>, <span class="number">896</span>, <span class="number">1024</span>, <span class="number">1152</span>, <span class="number">1280</span>, <span class="number">1408</span>, <span class="number">1536</span>,<span class="number">1792</span>, <span class="number">2048</span>, <span class="number">2304</span>, <span class="number">2688</span>, <span class="number">3072</span>, <span class="number">3200</span>, <span class="number">3456</span>, <span class="number">4096</span>, <span class="number">4864</span>, <span class="number">5376</span>, <span class="number">6144</span>, <span class="number">6528</span>, <span class="number">6784</span>, <span class="number">6912</span>, <span class="number">8192</span>, <span class="number">9472</span>, <span class="number">9728</span>, <span class="number">10240</span>, <span class="number">10880</span>, <span class="number">12288</span>, <span class="number">13568</span>, <span class="number">14336</span>, <span class="number">16384</span>, <span class="number">18432</span>, <span class="number">19072</span>, <span class="number">20480</span>, <span class="number">21760</span>, <span class="number">24576</span>, <span class="number">27264</span>, <span class="number">28672</span>, <span class="number">32768</span>&#125;</span><br></pre></td></tr></table></figure>
<p>根据mspan的Size Class可以得到它划分的object大小。</p>
<p>比如Size Class等于3,object大小就是32B。 </p>
<p>32B大小的object可以存储对象大小范围在17B~32B的对象。</p>
<p>而对于微小对象(小于16B),分配器会将其进行合并,将几个对象分配到同一个object中。</p>
<p>数组里最大的数是32768,也就是32KB,超过此大小就是大对象了,它会被特别对待这个稍后会再介绍。</p>
<p>顺便提一句类型Size Class为0表示大对象,它实际上直接由堆内存分配,而小对象都要通过mspan来分配。</p>
<p><br></p>
<p>对于mspan来说,它的Size Class会决定它所能分到的页数,这也是写死在代码里的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _NumSizeClasses = <span class="number">67</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> class_to_allocnpages = [_NumSizeClasses]<span class="keyword">uint8</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
<p>比如当我们要申请一个object大小为32B的mspan的时候,在class_to_size里对应的索引是3,而索引3在class_to_allocnpages数组里对应的页数就是1。</p>
<blockquote>
<p>mspan结构体定义</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path: /usr/local/go/src/runtime/mheap.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//链表前向指针,用于将span链接起来</span></span><br><span class="line">    next *mspan </span><br><span class="line">    <span class="comment">//链表前向指针,用于将span链接起来</span></span><br><span class="line">    prev *mspan </span><br><span class="line">    <span class="comment">// 起始地址,也即所管理页的地址</span></span><br><span class="line">    startAddr <span class="keyword">uintptr</span> </span><br><span class="line">    <span class="comment">// 管理的页数</span></span><br><span class="line">    npages <span class="keyword">uintptr</span> </span><br><span class="line">    <span class="comment">// 块个数,表示有多少个块可供分配</span></span><br><span class="line">    nelems <span class="keyword">uintptr</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配位图,每一位代表一个块是否已分配</span></span><br><span class="line">    allocBits *gcBits </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已分配块的个数</span></span><br><span class="line">    allocCount <span class="keyword">uint16</span> </span><br><span class="line">    <span class="comment">// class表中的class ID,和Size Classs相关</span></span><br><span class="line">    spanclass spanClass  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// class表中的对象大小,也即块大小</span></span><br><span class="line">    elemsize <span class="keyword">uintptr</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/05/10/go-kernel/image-06.png" width="600px"></p>
<p>上图可以看到有两个S指向了同一个mspan,因为这两个S指向的P是同属一个mspan的。<br>所以通过arena上的地址可以快速找到指向它的S,通过S就能找到mspan,回忆一下前面我们说的mspan区域的每个指针对应一页。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设最左边第一个mspan的Size Class等于10,根据前面的class_to_size数组</span><br><span class="line">得出这个msapn分割的object大小是144B,算出可分配的对象个数是8KB/144B=56.89个,取整56个</span><br><span class="line">所以会有一些内存浪费掉了,Go的源码里有所有Size Class的mspan浪费的内存的大小;</span><br><span class="line">再根据class_to_allocnpages数组,得到这个mspan只由1个page组成;</span><br><span class="line">假设这个mspan是分配给无指针对象的,那么spanClass等于20。</span><br></pre></td></tr></table></figure>
<ul>
<li><code>startAddr</code>直接指向arena区域的某个位置,表示这个mspan的起始地址  </li>
<li><code>allocBits</code>指向一个位图,每位代表一个块是否被分配了对象  </li>
<li><code>allocCount</code>则表示总共已分配的对象个数    </li>
</ul>
<p><br><br><br></p>
<h2 id="内存管理组件"><a href="#内存管理组件" class="headerlink" title="内存管理组件"></a>内存管理组件</h2><ul>
<li>cache: 每个运行期工作线程都会绑定一个cache,用于无所object分配  </li>
<li>central: 为所有cache提供切分好的后备span资源  </li>
<li>heap: 分配堆,主要是负责向系统申请大块的内存,为下层MCentral和MCache提供内存服务。他管理的基本单位是MSpan(若干连续内存页的数据结构)</li>
</ul>
<p><img src="/2018/05/10/go-kernel/image-01.png" width="500px"></p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p><code>mcache</code>:每个工作线程都会绑定一个<code>mcache</code>,本地缓存可用的<code>mspan</code>资源,这样就可以直接给<code>Goroutine</code>分配,因为不存在多个<code>Goroutine</code>竞争的情况,所以不会消耗锁资源。</p>
<p><code>mcache</code>的结构体定义:  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//path: /usr/local/go/src/runtime/mcache.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">    alloc [numSpanClasses]*mspan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">numSpanClasses = _NumSizeClasses &lt;&lt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>mcache</code>用<code>Span Classes</code>作为索引管理多个用于分配的<code>mspan</code>,它包含所有规格的<code>mspan</code>。</p>
<p>它是_NumSizeClasses的2倍,也就是<code>67*2=134</code></p>
<p>为什么有一个两倍的关系,前面我们提到过:为了加速之后内存回收的速度,数组里一半的mspan中分配的对象不包含指针,另一半则包含指针。</p>
<p>对于无指针对象的mspan在进行垃圾回收的时候无需进一步扫描它是否引用了其他活跃的对象。 </p>
<p><img src="/2018/05/10/go-kernel/image-08.png" width="550px"></p>
<p><code>mcache</code>在初始化的时候是没有任何<code>mspan</code>资源的,在使用过程中会动态地从<code>mcentral</code>申请,之后会缓存下来。</p>
<p>当对象小于等于32KB大小时,使用<code>mcache</code>的相应规格的<code>mspan</code>进行分配。</p>
<p><br></p>
<h3 id="Central"><a href="#Central" class="headerlink" title="Central"></a>Central</h3><p><code>mcentral</code>:为所有<code>mcache</code>提供切分好的<code>mspan</code>资源。</p>
<p>每个<code>central</code>保存一种特定大小的全局<code>mspan</code>列表,包括已分配出去的和未分配出去的。 </p>
<p>每个<code>mcentral</code>对应一种<code>mspan</code>,而<code>mspan</code>的种类导致它分割的<code>object</code>大小不同。</p>
<p>当工作线程的<code>mcache</code>中没有合适(也就是特定大小的)的<code>mspan</code>时就会从<code>mcentral</code>获取。</p>
<p><code>mcentral</code>被所有的工作线程共同享有,存在多个Goroutine竞争的情况,因此会消耗锁资源。</p>
<p>结构体定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//path: /usr/local/go/src/runtime/mcentral.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 互斥锁</span></span><br><span class="line">    lock mutex </span><br><span class="line">    <span class="comment">// 规格</span></span><br><span class="line">    sizeclass <span class="keyword">int32</span> </span><br><span class="line">    <span class="comment">// 尚有空闲object的mspan链表</span></span><br><span class="line">    nonempty mSpanList </span><br><span class="line">    <span class="comment">// 没有空闲object的mspan链表,或者是已被mcache取走的msapn链表</span></span><br><span class="line">    empty mSpanList </span><br><span class="line">    <span class="comment">// 已累计分配的对象个数</span></span><br><span class="line">    nmalloc <span class="keyword">uint64</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/05/10/go-kernel/image-09.png" width="550px"></p>
<p><code>empty</code>表示这条链表里的<code>mspan</code>都被分配了<code>object</code>,或者是已经被<code>cache</code>取走了的<code>mspan</code></p>
<p>这个<code>mspan</code>就被那个工作线程独占了。而<code>nonempty</code>则表示有空闲对象的mspan列表。每个<code>central</code>结构体都在<code>mheap</code>中维护。</p>
<p>简单说下<code>mcache</code>从<code>mcentral</code>获取和归还mspan的流程:</p>
<ul>
<li>获取 加锁:从<code>nonempty</code>链表找到一个可用的<code>mspan</code>;并将其从<code>nonempty</code>链表删除;将取出的<code>mspan</code>加入到<code>empty</code>链表;将<code>mspan</code>返回给工作线程;解锁。</li>
<li>归还 加锁:将<code>mspan</code>从<code>empty</code>链表删除;将<code>mspan</code>加入到<code>nonempty</code>链表;解锁。</li>
</ul>
<p><br></p>
<h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p><code>mheap</code>:代表Go程序持有的所有堆空间,Go程序使用一个<code>mheap</code>的全局对象<code>_mheap</code>来管理堆内存。</p>
<p>当<code>mcentral</code>没有空闲的<code>mspan</code>时,会向<code>mheap</code>申请。</p>
<p>而<code>mheap</code>没有资源时,会向操作系统申请新内存。</p>
<p><code>mheap</code>主要用于大对象的内存分配,以及管理未切割的<code>mspan</code>,用于给<code>mcentral</code>切割成小对象。</p>
<p>同时我们也看到,<code>mheap</code>中含有所有规格的<code>mcentral</code>,所以当一个<code>mcache</code>从<code>mcentral</code>申请<code>mspan</code>时</p>
<p>只需要在独立的<code>mcentral</code>中使用锁,并不会影响申请其他规格的<code>mspan</code>。</p>
<p><code>mheap</code>结构体定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//path: /usr/local/go/src/runtime/mheap.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock mutex</span><br><span class="line">    <span class="comment">// spans: 指向mspans区域,用于映射mspan和page的关系</span></span><br><span class="line">    spans []*mspan </span><br><span class="line">    <span class="comment">// 指向bitmap首地址,bitmap是从高地址向低地址增长的</span></span><br><span class="line">    bitmap <span class="keyword">uintptr</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指示arena区首地址</span></span><br><span class="line">    arena_start <span class="keyword">uintptr</span> </span><br><span class="line">    <span class="comment">// 指示arena区已使用地址位置</span></span><br><span class="line">    arena_used  <span class="keyword">uintptr</span> </span><br><span class="line">    <span class="comment">// 指示arena区末地址</span></span><br><span class="line">    arena_end   <span class="keyword">uintptr</span> </span><br><span class="line"></span><br><span class="line">    central [<span class="number">67</span>*<span class="number">2</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">        mcentral mcentral</span><br><span class="line">        pad [sys.CacheLineSize - unsafe.Sizeof(mcentral&#123;&#125;)%sys.CacheLineSize]<span class="keyword">byte</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/05/10/go-kernel/image-10.png" width="500px"></p>
<h2 id="分配流程"><a href="#分配流程" class="headerlink" title="分配流程"></a>分配流程</h2><p>Go的内存分配器在分配对象时,根据对象的大小分成三类:小对象(小于等于16B)、一般对象(大于16B,小于等于32KB)、大对象(大于32KB)。</p>
<p>大体上的分配流程：</p>
<ul>
<li>32KB 的对象,直接从<code>mheap</code>上分配;</li>
<li>&lt;=16B 的对象使用<code>mcache</code>的tiny分配器分配;</li>
<li>(16B,32KB] 的对象首先计算对象的规格大小,然后使用<code>mcache</code>中相应规格大小的<code>mspan</code>分配;</li>
<li>如果<code>mcache</code>没有相应规格大小的<code>mspan</code>,则向<code>mcentral</code>申请</li>
<li>如果<code>mcentral</code>没有相应规格大小的<code>mspan</code>,则向<code>mheap</code>申请</li>
<li>如果<code>mheap</code>中也没有合适大小的<code>mspan</code>,则向操作系统申请</li>
</ul>
<p><br><br><br></p>
<h1 id="并发调度"><a href="#并发调度" class="headerlink" title="并发调度"></a>并发调度</h1><h2 id="P、M、G关系"><a href="#P、M、G关系" class="headerlink" title="P、M、G关系"></a>P、M、G关系</h2><p>用户空间线程和内核空间线程之间的映射关系有：N：1、1：1和M：N</p>
<ul>
<li>N:1是说,多个（N)用户线程始终在一个内核线程上跑,context上下文切换确实很快,但是无法真正的利用多核。</li>
<li>1:1是说,一个用户线程就只在一个内核线程上跑,这时可以利用多核,但是上下文switch很慢。</li>
<li>M:N是说,多个goroutine在多个内核线程上跑,这个看似可以集齐上面两者的优势,但是无疑增加了调度的难度。</li>
</ul>
<p><img src="/2018/05/10/go-kernel/image-11.png" width="400px"></p>
<p>Go的调度器内部有三个重要的结构：M,P,G<br>M：代表真正的内核OS线程,和POSIX里的thread差不多,真正干活的人<br>G：代表一个goroutine,它有自己的栈,instruction pointer和其他信息（正在等待的channel等等),用于调度。<br>P：代表调度的上下文,可以把它看做一个局部的调度器,使go代码在一个线程上跑,它是实现从N：1到N：M映射的关键。</p>
<p><img src="/2018/05/10/go-kernel/image-12.png" width="400px"></p>
<p>图中看,有2个物理线程M,每一个M都拥有一个context（P),每一个也都有一个正在运行的goroutine。<br>P的数量可以通过runtime.GOMAXPROCS()来设置,它其实也就代表了真正的并发度,即有多少个goroutine可以同时运行。<br>图中灰色的那些goroutine并没有运行,而是出于ready的就绪态,正在等待被调度。P维护着这个队列（称之为runqueue),<br>Go语言里,启动一个goroutine很容易：go function 就行,所以每有一个go语句被执行,runqueue队列就在其末尾加入一个<br>goroutine,在下一个调度点,就从runqueue中取出（如何决定取哪个goroutine？)一个goroutine执行。</p>
<p><br></p>
<blockquote>
<p>为何要维护多个上下文P？</p>
</blockquote>
<p>因为当一个OS线程被阻塞时,P可以转而投奔另一个OS线程！<br>图中看到,当一个OS线程M0陷入阻塞时,P转而在OS线程M1上运行。调度器保证有足够的线程来运行所有的context P。</p>
<p><img src="/2018/05/10/go-kernel/image-13.png" width="400px"></p>
<p>图中的M1可能是被创建,或者从线程缓存中取出。</p>
<p>当MO返回时它必须尝试取得一个context P来运行goroutine</p>
<p>一般情况下它会从其他的OS线程那里steal偷一个context过来,</p>
<p>如果没有偷到的话,它就把goroutine放在一个<code>global runqueue</code>里然后自己就去睡大觉了(放入线程缓存里)。</p>
<p>Contexts们也会周期性的检查<code>global runqueue</code>,否则<code>global runqueue</code>上的goroutine永远无法执行。</p>
<p><br></p>
<p><img src="/2018/05/10/go-kernel/image-14.png" width="400px">  </p>
<p>另一种情况是P所分配的任务G很快就执行完了(分配不均),这就导致了一个上下文P闲着没事儿干而系统却任然忙碌。</p>
<p>但是如果<code>global runqueue</code>没有任务G了,那么P就不得不从其他的上下文P那里拿一些G来执行。</p>
<p>一般来说如果上下文P从其他的上下文P那里要偷一个任务的话,一般就‘偷’runqueue的一半,这就确保了每个OS线程都能充分的使用。</p>
<h2 id="调度流程简述"><a href="#调度流程简述" class="headerlink" title="调度流程简述"></a>调度流程简述</h2><p>Go语言是原生支持语言级并发的,这个并发的最小逻辑单元就是goroutine。</p>
<p>goroutine就类似于Go语言提供的一种“用户态线程”</p>
<p>当然这种“用户态线程”是跑在内核级线程之上的。</p>
<p>当我们创建了很多的goroutine,并且它们都是跑在同一个内核线程之上的时候,就需要一个调度器来维护这些goroutine,确保所有的goroutine都使用CPU并且是尽可能公平的使用CPU资源。</p>
<p>这个调度器的原理以及实现值得我们去深入研究一下。</p>
<p>支撑整个调度器的主要有4个重要结构,分别是P、M、G、Sched前三个定义在runtime.h中,Sched定义在proc.c中。</p>
<ul>
<li>Sched结构就是调度器,它维护有存储M和G的队列以及调度器的一些状态信息等。</li>
<li>M代表内核级线程,一个M就是一个线程,goroutine就是跑在M之上的;M是一个很大的结构,里面维护小对象内存cache(mcache)、当前执行的goroutine、随机数发生器等等非常多的信息。</li>
<li>P全称是Processor,处理器,它的主要用途就是用来执行goroutine的,所以它也维护了一个goroutine队列,里面存储了所有需要它来执行的goroutine,这个P的角色可能有一点让人迷惑,一开始容易和M冲突,后面重点聊一下它们的关系。</li>
<li>G就是goroutine实现的核心结构了,G维护了goroutine需要的栈、程序计数器以及它所在的M等信息。</li>
</ul>
<p>理解M、P、G三者的关系对理解整个调度器非常重要,我从网络上找了一个图来说明其三者关系：</p>
<p><img src="/2018/05/10/go-kernel/image-15.png" width="100px">  </p>
<p>地鼠用小车运着一堆待加工的砖。</p>
<blockquote>
<p>M就可以看作图中的地鼠,P就是小车,G就是小车里装的砖。</p>
</blockquote>
<p>一图胜千言啊,弄清楚了它们三者的关系,下面我们就开始重点聊地鼠是如何在搬运砖块的。  </p>
<p><br></p>
<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>在关心绝大多数程序的内部原理的时候,我们都试图去弄明白其启动初始化过程,弄明白这个过程对后续的深入分析至关重要。</p>
<p>在asm_amd64.s文件中的汇编代码_rt0_amd64就是整个启动过程核心过程如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CALL	runtime.args(SB)</span><br><span class="line">CALL	runtime.osinit(SB)</span><br><span class="line">CALL	runtime.hashinit(SB)</span><br><span class="line">CALL	runtime.schedinit(SB)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// create a new goroutine to start program</span></span><br><span class="line">PUSHQ	$runtime.main.f(SB)		<span class="comment">// entry</span></span><br><span class="line">PUSHQ	$<span class="number">0</span>			<span class="comment">// arg size</span></span><br><span class="line">CALL	runtime.newproc(SB)</span><br><span class="line">POPQ	AX</span><br><span class="line">POPQ	AX</span><br><span class="line"> </span><br><span class="line"><span class="comment">// start this M</span></span><br><span class="line">CALL	runtime.mstart(SB)</span><br></pre></td></tr></table></figure>
<p>启动过程做了调度器初始化<code>runtime.schedinit</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启动过程中的调度器初始化runtime.schedinit函数主要根据用户设置的GOMAXPROCS值来创建一批小车(P)</span><br><span class="line"></span><br><span class="line">不管GOMAXPROCS设置为多大,最多也只能创建256个小车(P)。</span><br><span class="line"></span><br><span class="line">这些小车(p)初始创建好后都是闲置状态,也就是还没开始使用,所以它们都放置在调度器结构(Sched)的 pidle字段维护的链表中存储起来了,以备后续之需。</span><br></pre></td></tr></table></figure>
<p>再调用<code>runtime.newproc</code>创建出第一个<code>goroutine</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个goroutine将执行的函数是runtime.main,这第一个goroutine也就是所谓的主goroutine。</span><br><span class="line"></span><br><span class="line">我们写的最简单的Go程序`”hello,world”`就是完全跑在这个goroutine里,当然任何一个Go程序的入口都是从这个goroutine开始的。</span><br></pre></td></tr></table></figure>
<p>最后调用的<code>runtime.mstart</code>就是内核线程M真正的执行上一步创建的主goroutine。</p>
<p><br></p>
<p>查看<code>runtime.main</code>函数可以了解到主goroutine开始执行后,做的第一件事情是创建了一个新的内核级线程(地鼠M)</p>
<p>不过这个线程是一个特殊线程,它在整个运行期专门负责做特定的事情——系统监控(sysmon)。</p>
<p>接下来就是进入Go程序的main函数开始Go程序的执行。</p>
<p>至此,Go程序就被启动起来开始运行了。</p>
<p>一个真正干活的Go程序,一定创建有不少的goroutine,所以在Go程序开始运行后,就会向调度器添加goroutine,调度器就要负责维护好这些goroutine的正常执行。</p>
<p><br></p>
<h3 id="创建goroutine-G"><a href="#创建goroutine-G" class="headerlink" title="创建goroutine(G)"></a>创建goroutine(G)</h3><p>在Go程序中,时常会有类似代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> do_something()</span><br></pre></td></tr></table></figure>
<p>go关键字就是用来创建一个goroutine的,后面的函数就是这个goroutine需要执行的代码逻辑。</p>
<p>go关键字对应到调度器的接口就是<code>runtime.newproc</code>。</p>
<p><code>runtime.newproc</code>干的事情很简单,就负责制造一块砖(G),然后将这块砖(G)放入当前这个地鼠(M)的小车(P)中。</p>
<p><br></p>
<p>每个新的goroutine都需要有一个自己的栈,G结构的 sched字段维护了栈地址以及程序计数器等信息,这是最基本的调度信息</p>
<p>也就是说这个goroutine放弃cpu的时候需要保存这些信息,待下次重新获得cpu的时候需要将这些信息装载到对应的cpu寄存器中。</p>
<p>假设这个时候已经创建了大量的goroutne,就轮到调度器去维护这些goroutine了。</p>
<p><br></p>
<h3 id="创建内核线程-M"><a href="#创建内核线程-M" class="headerlink" title="创建内核线程(M)"></a>创建内核线程(M)</h3><p><img src="/2018/05/10/go-kernel/image-16.png" width="100px"></p>
<p>Go程序中没有语言级的关键字让你去创建一个内核线程,你只能创建goroutine,内核线程只能由runtime根据实际情况去创建。</p>
<blockquote>
<p>runtime什么时候创建线程？</p>
</blockquote>
<p>以地鼠运砖图来讲,砖(G)太多了,地鼠(M)又太少了,实在忙不过来,刚好还有空闲的小车(P)没有使用,那就从别处再借些地鼠(M)过来直到把小车(p)用完为止。这</p>
<p>里有一个地鼠(M)不够用,从别处借地鼠(M)的过程,这个过程就是创建一个内核线程(M)。创建M的接口函数是:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void newm(void (*fn)(void), P *p)</span><br></pre></td></tr></table></figure>
<p>newm函数的核心行为就是调用clone系统调用创建一个内核线程,每个内核线程的开始执行位置都是runtime.mstart函数。</p>
<p>参数p就是一辆空闲的小车(p)。</p>
<p>每个创建好的内核线程都从<code>runtime.mstart</code>函数开始执行了,它们将用分配给自己小车去搬砖了。</p>
<p><br></p>
<h3 id="调度核心"><a href="#调度核心" class="headerlink" title="调度核心"></a>调度核心</h3><p>newm接口只是给新创建的M分配了一个空闲的P,也就是相当于告诉借来的地鼠(M)——“接下来的日子,你将使用1号小车搬砖,记住是1号小车;待会自己到停车场拿车。”</p>
<p>地鼠(M)去拿小车(P)这个过程就是<code>acquirep</code>。</p>
<p><code>runtime.mstart</code>在进入<code>schedul</code>之前会给当前M装配上P,<code>runtime.mstart</code>函数中的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(m != &amp;runtime.m0) &#123;</span><br><span class="line">	acquirep(m-&gt;nextp);</span><br><span class="line">	m-&gt;nextp = nil;</span><br><span class="line">&#125;</span><br><span class="line">schedule();</span><br></pre></td></tr></table></figure>
<p>if分支的内容就是为当前M装配上P,nextp就是newm分配的空闲小车(P),只是到这个时候才真正拿到手罢了。</p>
<p>没有P,M是无法执行goroutine的,就像地鼠没有小车无法运砖一样的道理。</p>
<p>对应acquirep的动作是releasep,把M装配的P给载掉;活干完了,地鼠需要休息了,就把小车还到停车场,然后睡觉去。</p>
<p>地鼠(M)拿到属于自己的小车(P)后,就进入工场开始干活了,也就是上面的 schedule调用。简化schedule的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">schedule(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	G *gp;</span><br><span class="line"> </span><br><span class="line">	gp = runqget(m-&gt;p);</span><br><span class="line">	<span class="keyword">if</span>(gp == nil)</span><br><span class="line">		gp = findrunnable();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (m-&gt;p-&gt;runqhead != m-&gt;p-&gt;runqtail &amp;&amp;</span><br><span class="line">		runtime.atomicload(&amp;runtime.sched.nmspinning) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">		runtime.atomicload(&amp;runtime.sched.npidle) &gt; <span class="number">0</span>)  <span class="comment">// <span class="doctag">TODO:</span> fast atomic</span></span><br><span class="line">		wakep();</span><br><span class="line"> </span><br><span class="line">	execute(gp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>schedule函数被我简化了太多,主要是我不喜欢贴大段大段的代码,因此只保留主干代码了。</p>
<p>这里涉及到4大步逻辑：</p>
<p><img src="/2018/05/10/go-kernel/image-17.png" width="500px"></p>
<ul>
<li><p>runqget<br>  地鼠(M)试图从自己的小车(P)取出一块砖(G),当然结果可能失败,也就是这个地鼠的小车已经空了没有砖了。</p>
</li>
<li><p>findrunnable<br>  如果地鼠自己的小车中没有砖,那也不能闲着不干活是吧,所以地鼠就会试图跑去工场仓库取一块砖来处理;工场仓库也可能没砖啊,出现这种情况的时候,这个地鼠也没有偷懒停下干活,而是悄悄跑出去,随机盯上一个小伙伴(地鼠),然后从它的车里试图偷一半砖到自己车里。如果多次尝试偷砖都失败了,那说明实在没有砖可搬了,这个时候地鼠就会把小车还回停车场,然后 睡觉休息了。如果地鼠睡觉了,下面的过程当然都停止了,地鼠睡觉也就是线程sleep了。</p>
</li>
<li><p>wakep<br>  到这个过程的时候,可怜的地鼠发现自己小车里有好多砖啊,自己根本处理不过来;再回头一看停车场居然有闲置的小车,立马跑到宿舍一看,你妹,居然还有小伙伴在睡觉,直接给屁股一脚,<code>你妹,居然还在睡觉,老子都快累死了,赶紧起来干活,分担点工作。</code>,小伙伴醒了,拿上自己的小车,乖乖干活去了。有时候可怜的地鼠跑到宿舍却发现没有在睡觉的小伙伴,于是会很失望,最后只好向工场老板说:<code>停车场还有闲置的车啊,我快干不动了,赶紧从别的工场借个地鼠来帮忙吧。</code>,最后工场老板就搞来一个新的地鼠干活了。</p>
</li>
<li><p>execute<br>  地鼠拿着砖放入火种欢快的烧练起来。</p>
</li>
</ul>
<p>到这里貌似整个工场都正常的运转起来了,无懈可击的样子。</p>
<p>不对还有一个疑点没解决啊,假设地鼠的车里有很多砖,它把一块砖放入火炉中后,何时把它取出来,放入第二块砖呢？</p>
<p>难道要一直把第一块砖烧练好才取出来吗？那估计后面的砖真的是等得花儿都要谢了。</p>
<blockquote>
<p>这里就是要真正解决goroutine的调度上下文切换问题。</p>
</blockquote>
<p><br></p>
<h3 id="调度点"><a href="#调度点" class="headerlink" title="调度点"></a>调度点</h3><blockquote>
<p>runtime.park</p>
</blockquote>
<p>当我们翻看<code>channel</code>的实现代码可以发现,对<code>channel</code>读写操作的时候会触发调用<code>runtime.park</code>函数。</p>
<p><code>goroutine</code>调用<code>park</code>后,这个<code>goroutine</code>就会被设置位waiting状态放弃CPU。被park的<code>goroutine</code>处于<code>waiting</code>状态,并且这个<code>goroutine</code>不在小车(P)中,如果不对其调用<code>runtime.ready</code>,它是永远不会再被执行的。除了<code>channel</code>操作外,定时器、网络poll等都有可能<code>park goroutine</code>。</p>
<blockquote>
<p>runtime.gosched  </p>
</blockquote>
<p>除了<code>park</code>可以放弃cpu外,调用<code>runtime.gosched</code>函数也可以让当前<code>goroutine</code>放弃cpu,但和<code>park</code>完全不同;<code>gosched</code>是将<code>goroutine</code>设置为<code>runnable</code>状态,然后放入到调度器全局等待队列(也就是上面提到的工场仓库,这下就明白为何工场仓库会有砖块(G)了吧)。</p>
<p>除此之外就轮到系统调用了,有些系统调用也会触发重新调度。</p>
<p>Go语言完全是自己封装的系统调用,所以在封装系统调用的时候,可以做不少手脚,也就是进入系统调用的时候执行<code>entersyscall</code>,退出后又执行<code>exitsyscall</code>函数。 </p>
<p>也只有封装了<code>entersyscall</code>的系统调用才有可能触发重新调度,它将改变小车(P)的状态为syscall。</p>
<p>还记一开始提到的sysmon线程吗？</p>
<p>这个系统监控线程会扫描所有的小车(P),发现一个小车(P)处于了syscall的状态,就知道这个小车(P)遇到了goroutine在做系统调用,于是系统监控线程就会创建一个新的地鼠(M)去把这个处于syscall的小车给抢过来,开始干活,这样这个小车中的所有砖块(G)就可以绕过之前系统调用的等待了。</p>
<p>从goroutine的调度点可以看出,调度器还是挺粗暴的,调度粒度有点过大,公平性也没有想想的那么好。总之这个调度器还是比较简单的。</p>
<p>综上所述,goroutine上下文切换的调度时机可分为以下几个条件：</p>
<ul>
<li>goroutine阻塞(waiting)</li>
<li>显式调用runtime.gosched()</li>
<li>系统调用system call</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">协程一般都是这样工作的,但是从1.2开始为了避免饿死其它goroutine,就是在发生任意函数调用的时候,都有机会触发scheduler。</span><br><span class="line"></span><br><span class="line">所以从1.2开始如果你的goroutine中是纯计算,没有任何系统调用,scheduler仍然有机会介入,不会永远独占CPU。</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="现场处理"><a href="#现场处理" class="headerlink" title="现场处理"></a>现场处理</h3><p><code>goroutine</code>在cpu上换入换出,不断上下文切换的时候,必须要保证的事情就是<code>保存现场</code>和<code>恢复现场</code>;</p>
<ul>
<li><p>保存现场就是在<code>goroutine</code>放弃cpu的时候,将相关寄存器的值给保存到内存中;</p>
</li>
<li><p>恢复现场就是在<code>goroutine</code>重新获得cpu的时候,需要从内存把之前的寄存器信息全部放回到相应寄存器中去。</p>
</li>
</ul>
<p>goroutine在主动放弃cpu的时候(park/gosched),都会涉及到调用<code>runtime.mcall</code>函数,此函数也是汇编实现,主要将goroutine的栈地址和程序计数器保存到G结构的<code>sched</code>字段中</p>
<p><code>mcall</code>就完成了现场保存。恢复现场的函数是<code>runtime.gogocall</code>,这个函数主要在 <code>execute</code>中调用,就是在执行<code>goroutine</code>前,需要重新装载相应的寄存器。</p>
<p><br><br><br></p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><ul>
<li>v1.1 STW</li>
<li>v1.3 Mark STW, Sweep 并行</li>
<li>v1.5 三色标记法</li>
<li>v1.8 hybrid write barrier</li>
</ul>
<h2 id="标记-清扫"><a href="#标记-清扫" class="headerlink" title="标记-清扫"></a>标记-清扫</h2><p>标记-清扫算法是第一种自动内存管理,基于追踪的垃圾收集算法。</p>
<p>算法思想在 70 年代就提出了,是一种非常古老的算法。</p>
<p>内存单元并不会在变成垃圾立刻回收,而是保持不可达状态,直到到达某个阈值或者固定时间长度。</p>
<p>这个时候系统会挂起用户程序也就是 STW,转而执行垃圾回收程序。</p>
<p>垃圾回收程序对所有的存活单元进行一次全局遍历确定哪些单元可以回收。</p>
<p>算法分两个部分:<code>标记(mark)</code>和<code>清扫(sweep)</code>。</p>
<p>标记阶段表明所有的存活单元,清扫阶段将垃圾单元回收。可视化可以参考下图。</p>
<p><img src="/2018/05/10/go-kernel/image-19.gif"></p>
<h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><p>三色标记算法是对标记阶段的改进,原理如下：</p>
<ul>
<li>1:起初所有对象都是白色。</li>
<li>2:从根出发扫描所有可达对象,标记为灰色,放入待处理队列。</li>
<li>3:从队列取出灰色对象,将其引用对象标记为灰色放入队列,自身标记为黑色。</li>
<li>4:重复 3,直到灰色对象队列为空。此时白色对象即为垃圾,进行回收。</li>
</ul>
<p><img src="/2018/05/10/go-kernel/image-18.gif"></p>
<h3 id="何时触发-GC"><a href="#何时触发-GC" class="headerlink" title="何时触发 GC"></a>何时触发 GC</h3><p>在堆上分配大于<code>32K byte</code>对象的时候进行检测此时是否满足垃圾回收条件,如果满足则进行垃圾回收。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    shouldhelpgc := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 分配的对象小于 32K byte</span></span><br><span class="line">    <span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shouldhelpgc = <span class="literal">true</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// gcShouldStart() 函数进行触发条件检测</span></span><br><span class="line">    <span class="keyword">if</span> shouldhelpgc &amp;&amp; gcShouldStart(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// gcStart() 函数进行垃圾回收</span></span><br><span class="line">        gcStart(gcBackgroundMode, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是自动垃圾回收,还有一种是主动垃圾回收,通过调用<code>runtime.GC()</code>,这是阻塞式的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GC runs a garbage collection and blocks the caller until the</span></span><br><span class="line"><span class="comment">// garbage collection is complete. It may also block the entire</span></span><br><span class="line"><span class="comment">// program.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GC</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gcStart(gcForceBlockMode, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GC-触发条件"><a href="#GC-触发条件" class="headerlink" title="GC 触发条件"></a>GC 触发条件</h3><p>触发条件主要关注下面代码中的中间部分:<code>forceTrigger || memstats.heap_live &gt;= memstats.gc_trigger</code>。<code>forceTrigger</code>是<code>forceGC</code>的标志;</p>
<p>后面半句的意思是当前堆上的活跃对象大于我们初始化时候设置的 GC 触发阈值。在<code>malloc</code>以及<code>free</code>的时候<code>heap_live</code>会一直进行更新,这里就不再展开了。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcShouldStart returns true if the exit condition for the _GCoff</span></span><br><span class="line"><span class="comment">// phase has been met. The exit condition should be tested when</span></span><br><span class="line"><span class="comment">// allocating.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If forceTrigger is true, it ignores the current heap size, but</span></span><br><span class="line"><span class="comment">// checks all other conditions. In general this should be false.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcShouldStart</span><span class="params">(forceTrigger <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gcphase == _GCoff &amp;&amp; (forceTrigger || memstats.heap_live &gt;= memstats.gc_trigger) &amp;&amp; memstats.enablegc &amp;&amp; panicking == <span class="number">0</span> &amp;&amp; gcpercent &gt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化的时候设置 GC 的触发阈值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ = setGCPercent(readgogc())</span><br><span class="line">    memstats.gc_trigger = heapminimum</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动的时候通过 GOGC 传递百分比 x</span></span><br><span class="line"><span class="comment">// 触发阈值等于 x * defaultHeapMinimum (defaultHeapMinimum 默认是 4M)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readgogc</span><span class="params">()</span> <span class="title">int32</span></span> &#123;</span><br><span class="line">    p := gogetenv(<span class="string">"GOGC"</span>)</span><br><span class="line">    <span class="keyword">if</span> p == <span class="string">"off"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n, ok := atoi32(p); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="垃圾回收流程"><a href="#垃圾回收流程" class="headerlink" title="垃圾回收流程"></a>垃圾回收流程</h3><ul>
<li>首先从 root 开始遍历,root 包括全局指针和 goroutine 栈上的指针。</li>
<li>mark 有两个过程。<ul>
<li>从 root 开始遍历,标记为灰色。遍历灰色队列。</li>
<li>re-scan 全局指针和栈。因为 mark 和用户程序是并行的,所以在过程 1 的时候可能会有新的对象分配,这个时候就需要通过写屏障(write barrier)记录下来。re-scan 再完成检查一下。</li>
</ul>
</li>
<li>Stop The World 有两个过程。<ul>
<li>第一个是 GC 将要开始的时候,这个时候主要是一些准备工作,比如 enable write barrier。</li>
<li>第二个过程就是上面提到的 re-scan 过程。如果这个时候没有 stw,那么 mark 将无休止。</li>
</ul>
</li>
</ul>
<h3 id="源码步骤"><a href="#源码步骤" class="headerlink" title="源码步骤"></a>源码步骤</h3><h4 id="标记-STW-phase-1"><a href="#标记-STW-phase-1" class="headerlink" title="标记 STW phase 1"></a>标记 STW phase 1</h4><blockquote>
<p>在 GC 开始之前的准备工作。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcStart 是 GC 的入口函数,根据 gcMode 做处理。</span></span><br><span class="line"><span class="comment">// 1. gcMode == gcBackgroundMode（后台运行,也就是并行）, _GCoff -&gt; _GCmark</span></span><br><span class="line"><span class="comment">// 2. 否则 GCoff -&gt; _GCmarktermination,这个时候就是主动 GC </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(mode gcMode, forceTrigger <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(mode gcMode, forceTrigger <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//在后台启动 mark worker </span></span><br><span class="line">    <span class="keyword">if</span> mode == gcBackgroundMode &#123;</span><br><span class="line">        gcBgMarkStartWorkers()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Stop The World</span></span><br><span class="line">    systemstack(stopTheWorldWithSema)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> mode == gcBackgroundMode &#123;</span><br><span class="line">        <span class="comment">// GC 开始前的准备工作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理设置 GCPhase,setGCPhase 还会 enable write barrier</span></span><br><span class="line">        setGCPhase(_GCmark)</span><br><span class="line">          </span><br><span class="line">        gcBgMarkPrepare() <span class="comment">// Must happen before assist enable.</span></span><br><span class="line">        gcMarkRootPrepare()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mark all active tinyalloc blocks. Since we're</span></span><br><span class="line">        <span class="comment">// allocating from these, they need to be black like</span></span><br><span class="line">        <span class="comment">// other allocations. The alternative is to blacken</span></span><br><span class="line">        <span class="comment">// the tiny block on every allocation from it, which</span></span><br><span class="line">        <span class="comment">// would slow down the tiny allocator.</span></span><br><span class="line">        gcMarkTinyAllocs()</span><br><span class="line">          </span><br><span class="line">        <span class="comment">// Start The World</span></span><br><span class="line">        systemstack(startTheWorldWithSema)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="Mark"><a href="#Mark" class="headerlink" title="Mark"></a>Mark</h4><p>Mark 阶段是并行的运行,通过在后台一直运行 mark worker 来实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(mode gcMode, forceTrigger <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//在后台启动 mark worker </span></span><br><span class="line">    <span class="keyword">if</span> mode == gcBackgroundMode &#123;</span><br><span class="line">        gcBgMarkStartWorkers()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkStartWorkers</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Background marking is performed by per-P G's. Ensure that</span></span><br><span class="line">    <span class="comment">// each P has a background GC G.</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> &amp;allp &#123;</span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p.status == _Pdead &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> p.gcBgMarkWorker == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">go</span> gcBgMarkWorker(p)</span><br><span class="line">            notetsleepg(&amp;work.bgMarkReady, <span class="number">-1</span>)</span><br><span class="line">            noteclear(&amp;work.bgMarkReady)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcBgMarkWorker 是一直在后台运行的,大部分时候是休眠状态,通过 gcController 来调度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkWorker</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前 goroutine 休眠,直到满足某些条件</span></span><br><span class="line">        gopark(...)</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// mark 过程</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Mark our goroutine preemptible so its stack</span></span><br><span class="line">        <span class="comment">// can be scanned. This lets two mark workers</span></span><br><span class="line">        <span class="comment">// scan each other (otherwise, they would</span></span><br><span class="line">        <span class="comment">// deadlock). We must not modify anything on</span></span><br><span class="line">        <span class="comment">// the G stack. However, stack shrinking is</span></span><br><span class="line">        <span class="comment">// disabled for mark workers, so it is safe to</span></span><br><span class="line">        <span class="comment">// read from the G stack.</span></span><br><span class="line">        casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">        <span class="keyword">switch</span> _p_.gcMarkWorkerMode &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            throw(<span class="string">"gcBgMarkWorker: unexpected gcMarkWorkerMode"</span>)</span><br><span class="line">        <span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line">            gcDrain(&amp;_p_.gcw, gcDrainNoBlock|gcDrainFlushBgCredit)</span><br><span class="line">        <span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line">            gcDrain(&amp;_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">        <span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line">            gcDrain(&amp;_p_.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">        &#125;</span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">        &#125;)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Mark 阶段的标记代码主要在函数 gcDrain() 中实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcDrain scans roots and objects in work buffers, blackening grey</span></span><br><span class="line"><span class="comment">// objects until all roots and work buffers have been drained.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrain</span><span class="params">(gcw *gcWork, flags gcDrainFlags)</span></span> &#123;</span><br><span class="line">    ...    </span><br><span class="line">    <span class="comment">// Drain root marking jobs.</span></span><br><span class="line">    <span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">        <span class="keyword">for</span> !(preemptible &amp;&amp; gp.preempt) &#123;</span><br><span class="line">            job := atomic.Xadd(&amp;work.markrootNext, +<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> job &gt;= work.markrootJobs &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            markroot(gcw, job)</span><br><span class="line">            <span class="keyword">if</span> idle &amp;&amp; pollWork() &#123;</span><br><span class="line">                <span class="keyword">goto</span> done</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 处理 heap 标记</span></span><br><span class="line">    <span class="comment">// Drain heap marking jobs.</span></span><br><span class="line">    <span class="keyword">for</span> !(preemptible &amp;&amp; gp.preempt) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//从灰色列队中取出对象</span></span><br><span class="line">        <span class="keyword">var</span> b <span class="keyword">uintptr</span></span><br><span class="line">        <span class="keyword">if</span> blocking &#123;</span><br><span class="line">            b = gcw.get()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b = gcw.tryGetFast()</span><br><span class="line">            <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">                b = gcw.tryGet()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// work barrier reached or tryGet failed.</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扫描灰色对象的引用对象,标记为灰色,入灰色队列</span></span><br><span class="line">        scanobject(b, gcw)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="Mark-termination-STW-phase-2"><a href="#Mark-termination-STW-phase-2" class="headerlink" title="Mark termination (STW phase 2)"></a>Mark termination (STW phase 2)</h4><p>mark termination 阶段会 stop the world。</p>
<p>函数实现在 gcMarkTermination()。1.8 版本已经不会再对 goroutine stack 进行 re-scan 了。细节有点多,这里不细说了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkTermination</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// World is stopped.</span></span><br><span class="line">    <span class="comment">// Run gc on the g0 stack. We do this so that the g stack</span></span><br><span class="line">    <span class="comment">// we're currently running on will no longer change. Cuts</span></span><br><span class="line">    <span class="comment">// the root set down a bit (g0 stacks are not scanned, and</span></span><br><span class="line">    <span class="comment">// we don't need to scan gc's internal state).  We also</span></span><br><span class="line">    <span class="comment">// need to switch to g0 so we can shrink the stack.</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        gcMark(startTime)</span><br><span class="line">        <span class="comment">// Must return immediately.</span></span><br><span class="line">        <span class="comment">// The outer function's stack may have moved</span></span><br><span class="line">        <span class="comment">// during gcMark (it shrinks stacks, including the</span></span><br><span class="line">        <span class="comment">// outer function's stack), so we must not refer</span></span><br><span class="line">        <span class="comment">// to any of its variables. Return back to the</span></span><br><span class="line">        <span class="comment">// non-system stack to pick up the new addresses</span></span><br><span class="line">        <span class="comment">// before continuing.</span></span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="清扫"><a href="#清扫" class="headerlink" title="清扫"></a>清扫</h4><p>清扫相对来说就简单很多了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcSweep</span><span class="params">(mode gcMode)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//阻塞式</span></span><br><span class="line">    <span class="keyword">if</span> !_ConcurrentSweep || mode == gcForceBlockMode &#123;</span><br><span class="line">        <span class="comment">// Special case synchronous sweep.</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Sweep all spans eagerly.</span></span><br><span class="line">        <span class="keyword">for</span> sweepone() != ^<span class="keyword">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            sweep.npausesweep++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Do an additional mProf_GC, because all 'free' events are now real as well.</span></span><br><span class="line">        mProf_GC()</span><br><span class="line">        mProf_GC()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 并行式</span></span><br><span class="line">    <span class="comment">// Background sweep.</span></span><br><span class="line">    lock(&amp;sweep.lock)</span><br><span class="line">    <span class="keyword">if</span> sweep.parked &#123;</span><br><span class="line">        sweep.parked = <span class="literal">false</span></span><br><span class="line">        ready(sweep.g, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sweep.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于并行式清扫,在 GC 初始化的时候就会启动<code>bgsweep()</code>,然后在后台一直循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bgsweep</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sweep.g = getg()</span><br><span class="line"></span><br><span class="line">    lock(&amp;sweep.lock)</span><br><span class="line">    sweep.parked = <span class="literal">true</span></span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    goparkunlock(&amp;sweep.lock, <span class="string">"GC sweep wait"</span>, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> gosweepone() != ^<span class="keyword">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            sweep.nbgsweep++</span><br><span class="line">            Gosched()</span><br><span class="line">        &#125;</span><br><span class="line">        lock(&amp;sweep.lock)</span><br><span class="line">        <span class="keyword">if</span> !gosweepdone() &#123;</span><br><span class="line">            <span class="comment">// This can happen if a GC runs between</span></span><br><span class="line">            <span class="comment">// gosweepone returning ^0 above</span></span><br><span class="line">            <span class="comment">// and the lock being acquired.</span></span><br><span class="line">            unlock(&amp;sweep.lock)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        sweep.parked = <span class="literal">true</span></span><br><span class="line">        goparkunlock(&amp;sweep.lock, <span class="string">"GC sweep wait"</span>, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gosweepone</span><span class="params">()</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">uintptr</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ret = sweepone()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管是阻塞式还是并行式,都是通过 sweepone()函数来做清扫工作的。</p>
<p>内存管理都是基于 span 的, mheap_ 是一个全局的变量,所有分配的对象都会记录在 mheap_ 中。</p>
<p>在标记的时候,我们只要找到对对象对应的 span 进行标记,清扫的时候扫描 span,没有标记的 span 就可以回收了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sweeps one span</span></span><br><span class="line"><span class="comment">// returns number of pages returned to heap, or ^uintptr(0) if there is nothing to sweep</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sweepone</span><span class="params">()</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        s := mheap_.sweepSpans[<span class="number">1</span>-sg/<span class="number">2</span>%<span class="number">2</span>].pop()</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> !s.sweep(<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// Span is still in-use, so this returned no</span></span><br><span class="line">            <span class="comment">// pages to the heap and the span needs to</span></span><br><span class="line">            <span class="comment">// move to the swept in-use list.</span></span><br><span class="line">            npages = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sweep frees or collects finalizers for blocks not marked in the mark phase.</span></span><br><span class="line"><span class="comment">// It clears the mark bits in preparation for the next GC round.</span></span><br><span class="line"><span class="comment">// Returns true if the span was returned to heap.</span></span><br><span class="line"><span class="comment">// If preserve=true, don't return it to heap nor relink in MCentral lists;</span></span><br><span class="line"><span class="comment">// caller takes care of it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspan)</span> <span class="title">sweep</span><span class="params">(preserve <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="Select-amp-Channel分析"><a href="#Select-amp-Channel分析" class="headerlink" title="Select&amp;Channel分析"></a>Select&amp;Channel分析</h1><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p><img src="/2018/05/10/go-kernel/image-20.png" width="500px">  </p>
<blockquote>
<p>根据 select 中语句的不同选择了不同的优化路径:</p>
</blockquote>
<ul>
<li>空的 select 语句会被直接转换成 block 函数的调用,直接挂起当前 Goroutine；</li>
<li>如果 select 语句中只包含一个 case,就会被转换成 if ch == nil { block }; n; 表达式；<ul>
<li>首先判断操作的 Channel 是不是空的；</li>
<li>然后执行 case 结构中的内容；</li>
</ul>
</li>
<li>如果 select 语句中只包含两个 case 并且其中一个是 default,那么 Channel 和接收和发送操作都会使用 selectnbrecv 和 selectnbsend 非阻塞地执行接收和发送操作；</li>
<li>在默认情况下会通过 selectgo 函数选择需要执行的 case 并通过多个 if 语句执行 case 中的表达式；</li>
</ul>
<blockquote>
<p>在编译器已经对 select 语句进行优化之后,Go 语言会在运行时执行编译期间展开的 selectgo 函数,这个函数会按照以下的过程执行：</p>
</blockquote>
<ul>
<li>随机生成一个遍历的轮询顺序 pollOrder 并根据 Channel 地址生成一个用于遍历的锁定顺序 lockOrder；</li>
<li>根据 pollOrder 遍历所有的 case 查看是否有可以立刻处理的 Channel 消息；<ul>
<li>如果有消息就直接获取 case 对应的索引并返回；</li>
</ul>
</li>
<li>如果没有消息就会创建 sudog 结构体,将当前 Goroutine 加入到所有相关 Channel 的 sendq 和 recvq 队列中并调用 gopark 触发调度器的调度；</li>
<li>当调度器唤醒当前 Goroutine 时就会再次按照 lockOrder 遍历所有的 case,从中查找需要被处理的 sudog 结构并返回对应的索引；</li>
</ul>
<p>然而并不是所有的 select 控制结构都会走到 selectgo 上,很多情况都会被直接优化掉,没有机会调用 selectgo 函数。</p>
<p><br></p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><blockquote>
<p>在 Go 语言中,一个最常见的也是经常被人提及的设计模式就是<code>不要通过共享内存的方式进行通信,而是应该通过通信的方式共享内存</code>  </p>
</blockquote>
<p><img src="/2018/05/10/go-kernel/image-21.png" width="400px"></p>
<p>Go 语言对于并发编程的设计与上述这种共享内存的方式完全不同,虽然我们在 Golang 中也能使用共享内存加互斥锁来实现并发编程,但是与此同时,Go 语言也提供了一种不同的并发模型,也就是 CSP,即通信顺序进程（Communicating sequential processes）,</p>
<p>Goroutine 其实就是 CSP 中的实体,Channel 就是用于传递信息的通道,使用 CSP 并发模型的 Goroutine 就会通过 Channel 来传递消息。</p>
<p><img src="/2018/05/10/go-kernel/image-22.png" width="400px"></p>
<p>上图中的两个 Goroutine,一个会负责向 Channel 中发送消息,另一个会负责从 Channel 中接收消息,它们两者并没有任何直接的关联,能够独立地工作和运行,但是间接地通过 Channel 完成了通信。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="keyword">uint</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span></span><br><span class="line">	buf      unsafe.Pointer</span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	elemtype *_type</span><br><span class="line">	sendx    <span class="keyword">uint</span>  </span><br><span class="line">	recvx    <span class="keyword">uint</span></span><br><span class="line">	recvq    waitq</span><br><span class="line">	sendq    waitq</span><br><span class="line"></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>qcount、dataqsize、buf、sendx、recv 的主要作用就是构建底层的循环队列</p>
</blockquote>
<ul>
<li>qcount 保存了当前 Channel 中的元素个数</li>
<li>dataqsize 表示 Channel 中的循环队列的长度</li>
<li>buf 指向了一个长度为 dataqsiz 的数组</li>
<li>sendx 和 recvx 负责标识当前 Channel 的发送和接收已经处理到了数组中的哪个位置</li>
<li>elemsize 和 elemtype 分别表示了当前 Channel 能够收发的元素类型和大小  </li>
<li>sendq 和 recvq 的主要作用就是存储当前 Channel 由于缓冲区空间不足而阻塞的 Goroutine 列表</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Channel能够执行的操作其实也就只有创建、发送、接收和关闭几种  </p>
</blockquote>
<p><br></p>
<h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>channel发送数据类似<code>ch &lt;- i</code>表达式  </p>
<p>这个表达式会被编译器解析成<code>OSEND</code>节点,同样地在<code>SSA</code>中间代码的生成期间,这些<code>OSEND</code>节点也会被转换成<code>chansend1</code>的函数调用  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkexpr</span><span class="params">(n *Node, init *Nodes)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OSEND:</span><br><span class="line">		n1 := n.Right</span><br><span class="line">		n1 = assignconv(n1, n.Left.Type.Elem(), <span class="string">"chan send"</span>)</span><br><span class="line">		n1 = walkexpr(n1, init)</span><br><span class="line">		n1 = nod(OADDR, n1, <span class="literal">nil</span>)</span><br><span class="line">		n = mkcall1(chanfn(<span class="string">"chansend1"</span>, <span class="number">2</span>, n.Left.Type), <span class="literal">nil</span>, init, n.Left, n1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>chansend</code>就是向<code>Channel</code>中发送数据时最终会调用的函数,这个函数负责了发送数据的全部逻辑</p>
<p>在发送数据的逻辑执行之前会先为当前<code>Channel</code>加锁,防止出现竞争条件的问题</p>
<p>如果当前<code>Channel</code>结构已经通过<code>closed</code>字段被标记成了关闭</p>
<p>那么在向该<code>Channel</code>发送数据时就会直接 panic 报出一个非常常见的错误<code>&quot;send on closed channel&quot;</code>并返回。</p>
<p><br></p>
<h4 id="直接发送"><a href="#直接发送" class="headerlink" title="直接发送"></a>直接发送</h4><p>如果目标<code>Channel</code>被关闭并且已经有处于读等待的 Goroutine,那么<code>chansend</code>函数会通过<code>dequeue</code>从<code>recvq</code>中取出最先先入等待的<code>Goroutine</code>并直接向它发送数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">	send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		sendDirect(c.elemtype, sg, ep)</span><br><span class="line">		sg.elem = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp := sg.g</span><br><span class="line">	unlockf()</span><br><span class="line">	gp.param = unsafe.Pointer(sg)</span><br><span class="line">	goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/05/10/go-kernel/image-23.png" width="400px"></p>
<p>随后的<code>goready</code>函数会将等待接收数据的<code>Goroutine</code>标记成<code>Grunnable</code>并把该协程放到发送方所在的处理器P上等待执行</p>
<p>该处理器P在下一次调度时就会立刻唤醒消息接收方所在的协程。</p>
<p><img src="/2018/05/10/go-kernel/image-24.png" width="400px"></p>
<p><br></p>
<h4 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h4><p>向<code>Channel</code>中发送数据时遇到的第二种情况就是创建的<code>Channel</code>包含缓冲区并且<code>Channel</code>中的数据没有装满,在这时就会执行下面的这段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		c.sendx++</span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount++</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们首先会使用<code>chanbuf</code>计算出下一个可以放置待处理变量的位置,然后通过<code>typedmemmove</code>将发送的消息拷贝到缓冲区中并增加<code>sendx</code>索引和<code>qcount</code>计数器,在函数的最后会释放持有的锁。</p>
<p><img src="/2018/05/10/go-kernel/image-25.png" width="550px"></p>
<p><br></p>
<h4 id="阻塞发送"><a href="#阻塞发送" class="headerlink" title="阻塞发送"></a>阻塞发送</h4><p>最后要介绍的就是向<code>Channel</code>发送但是遇到下游无法处理的『阻塞发送』了,当然如果传入的参数<code>block=false</code>,那么就会直接释放持有的锁并返回<code>false</code>表示这一次的发送不成功。</p>
<p>在常见的场景中,向<code>Channel</code>发送消息的操作基本上都是阻塞的,在这时就会执行下面的代码,我们可以简单梳理一下这段代码的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用<code>getg</code>获取发送操作时使用的<code>Goroutine</code>协程；</li>
<li>执行<code>acquireSudog</code>函数获取一个<code>sudog</code>结构体并设置这一次阻塞发送的相关信息,例如发送的<code>Channel</code>、是否在<code>Select</code>控制结构中、发送数据所在的地址等；</li>
<li>将刚刚创建并初始化的<code>sudog</code>结构体加入<code>sendq</code>等待队列,并设置到当前<code>Goroutine</code>的<code>waiting</code>上,表示<code>Goroutine</code>正在等待该<code>sudog</code>准备就绪；</li>
<li>调用<code>goparkunlock</code>函数将当前的<code>Goroutine</code>更新成<code>Gwaiting</code>状态并解锁,该<code>Goroutine</code>可以被调用<code>goready</code>再次唤醒；</li>
<li>当前的<code>Goroutine</code>其实就会在这里陷入阻塞状态等待被调度器唤醒了；</li>
<li>如果被调度器唤醒就会执行一些收尾的工作,将一些属性置零并且释放<code>sudog</code>结构体；</li>
</ul>
<p>在最后,函数会返回 true 表示这一次发送的结束并继续运行当前 Goroutine 应该执行的逻辑。</p>
<p><br><br><br></p>
<h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><p>分析了<code>Channel</code>发送数据的过程之后,我们就可以继续介绍数据处理的另一端,也就是数据的接收了,我们在 Go 语言中其实有两种不同的方式去接收管道中的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i &lt;- ch</span><br><span class="line">i, ok &lt;- ch</span><br></pre></td></tr></table></figure>
<p>这两种不同的方法经过编译器的处理都会变成<code>ORECV</code>类型的节点,但是后者会在<code>类型检查</code>阶段被转换成<code>OAS2RECV</code>节点,我们可以简单看一下这里转换的路线图：</p>
<p><img src="/2018/05/10/go-kernel/image-26.png" width="550px">  </p>
<p>虽然这两种不同的接收方式会被转换成 chanrecv1 和 chanrecv2 两种不同函数的调用,但是这两个函数最终调用的还是 chanrecv。</p>
<p>chanrecv 处理数据接收时总共可以分成五种不同的情况,当我们从一个空 Channel 中接收数据时会直接调用 gopark 直接让出当前 Goroutine 处理器的使用权。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">"unreachable"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, ep)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前的 Channel 已经被关闭并且缓冲区中不存在任何的数据,那么就会直接解锁当前的 Channel 并清除 ep 指针的数据。</p>
<h4 id="直接接收"><a href="#直接接收" class="headerlink" title="直接接收"></a>直接接收</h4><p>当 Channel 的 sendq 队列中包含处于等待状态的 Goroutine 时,我们其实就会直接取出队列头的 Goroutine,这里处理的逻辑和发送时所差无几,只是发送数据时调用的是 send 函数,而这里是 recv 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">	recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>recv 函数的实现其实也与 send 非常相似,我们可以简单看一下这里执行的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			recvDirect(c.elemtype, sg, ep)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">	&#125;</span><br><span class="line">	sg.elem = <span class="literal">nil</span></span><br><span class="line">	gp := sg.g</span><br><span class="line">	unlockf()</span><br><span class="line">	gp.param = unsafe.Pointer(sg)</span><br><span class="line">	goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果当前 Channel 中不存在未被处理的数据,就会调用<code>recvDirect</code>,这个函数会将<code>sendq</code>中 Goroutine 存储的 elem 数据拷贝到目标内存地址中；</li>
<li>如果当前 Channel 已经满了,就会通过<code>typedmemmove</code>将队列中的数据拷贝到接收方的内存地址中并将发送方的数据拷贝到队列中,这样我们可以释放一个阻塞的发送方 Goroutine；</li>
<li>在最后会解锁 Channel 并调用 goready 函数将当前处理器的 runnext 设置成发送数据的 Goroutine,随后 &lt;-ch 会返回并执行下面的逻辑；</li>
</ul>
<p><img src="/2018/05/10/go-kernel/image-27.png" width="550px">  </p>
<p>上图展示了 Channel 在缓冲区已经没有空间并且 sendq 中存在等待的 Goroutine 时,使用 &lt;-ch 发生的变化,sendq 队列中的第一个 sudog 结构中的元素会替换 sendx/recvx 索引所在位置的元素,原有的元素会被拷贝到接收 &lt;-ch 结果的内存空间上。</p>
<p><br></p>
<h4 id="缓冲区-1"><a href="#缓冲区-1" class="headerlink" title="缓冲区"></a>缓冲区</h4><p>另一种接收数据时遇到的情况就是,Channel 的缓冲区中已经包含了一些元素,在这时如果使用 &lt;-ch 从 Channel 中接收元素,我们就会直接从缓冲区中 recvx 的索引位置中取出数据进行处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemclr(c.elemtype, qp)</span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount--</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>如果接收数据的内存地不为空,那么就会直接使用<code>typedmemmove</code>将缓冲区中的数据拷贝到内存中,在这之后会清除队列中的数据并完成收尾工作。</p>
<p><img src="/2018/05/10/go-kernel/image-28.png" width="550px">  </p>
<p>收尾工作就包括递增<code>recvx</code>索引的数据,当发现索引超过了当前队列的容量时,由于这是一个循环队列,所以就会将它归零；除此之外,这个函数还会减少<code>qcount</code>计数器并释放持有<code>Channel</code>的锁。</p>
<h4 id="阻塞接收"><a href="#阻塞接收" class="headerlink" title="阻塞接收"></a>阻塞接收</h4><p>当 Channel 的<code>sendq</code>队列中不存在等待的<code>Goroutine</code>并且缓冲区中也不存在任何数据时,从管道中接收数据的操作在大多数时候就会变成一个阻塞的操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	closed := gp.param == <span class="literal">nil</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种阻塞的情况下其实有一个例外,也就是与<code>select</code>语句结合使用时就可能会使用到非阻塞<code>block=false</code>的接收操作,这段代码在这时就会获取一个 sudog 结构体设置到当前<code>Goroutine</code>的<code>waiting</code>上并将其入队到<code>recvq</code>中。</p>
<p>除此之外,当前代码片段还会调用<code>goparkunlock</code>函数立刻触发<code>Goroutine</code>的调度,将当前<code>Goroutine</code>的状态改成<code>Gwaiting</code>并让出处理器的使用权,在这时<code>Goroutine</code>就会处于休眠状态等待调度器的调度,重新执行时就会从<code>gp.waiting = nil</code>处继续运行下面的代码对数据进行清理。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们简单梳理一下从 Channel 中接收数据时的几种情况：</p>
<ul>
<li>如果 Channel 是空的,那么就会直接调用<code>gopark</code>挂起当前的<code>Goroutine</code>；</li>
<li>如果 Channel 已经关闭并且缓冲区没有任何数据,<code>chanrecv</code>函数就会直接返回；</li>
<li>如果 Channel 上的<code>sendq</code>队列中存在挂起的<code>Goroutine</code>,就会将<code>recvx</code>索引所在的数据拷贝到接收变量所在的内存空间上并将 sendq 队列中 Goroutine 的数据拷贝到缓冲区中；</li>
<li>如果 Channel 的缓冲区中包含数据就会直接从<code>recvx</code>所在的索引上进行读取；</li>
<li>在默认情况下会直接挂起当前的<code>Goroutine</code>,将<code>sudog</code>结构加入<code>recvq</code>队列并更新<code>Goroutine</code>的<code>waiting</code>属性,最后陷入休眠等待调度器的唤醒;</li>
</ul>
<p>在从管道中接收数据的过程中,其实会在两个时间点触发 Goroutine 的调度,首先空的 Channel 意味着永远接收不到消息,那么就会直接挂起当前 Goroutine,第二个时间点是缓冲区中不存在数据,在这时也会直接挂起当前的 Goroutine 等待发送方发送数据。</p>
<p><br><br><br></p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>文献资料摘录于 </p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/54474448" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54474448</a></li>
<li>go语言学习笔记  </li>
<li><a href="https://johng.cn/goroutine1-pmg/" target="_blank" rel="noopener">https://johng.cn/goroutine1-pmg/</a>  </li>
<li><a href="https://draveness.me/golang-channel" target="_blank" rel="noopener">https://draveness.me/golang-channel</a>  </li>
</ul>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2018/05/10/go-kernel/';
        this.page.title = 'Go Kernel分析';
        this.page.identifier = '2018/05/10/go-kernel/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
