<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Go学习笔记 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="Golang 学习笔记  
基础命名关键字12345678910111213内建常量: true false iota nil内建类型: int int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrfloat32 float64 complex128 complex64 bool byte rune string error内建函数: make len cap new append copy close deletecompl">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Go/Rust</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">系统内核</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">逆向知识</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">数据库</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#命名"><span class="toc-number">1.1.</span> <span class="toc-text">命名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关键字"><span class="toc-number">1.1.1.</span> <span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量函数驼峰命名"><span class="toc-number">1.1.2.</span> <span class="toc-text">变量函数驼峰命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件名-报名下划线"><span class="toc-number">1.1.3.</span> <span class="toc-text">文件名/报名下划线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本知识"><span class="toc-number">1.2.</span> <span class="toc-text">基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常量的定义"><span class="toc-number">1.2.1.</span> <span class="toc-text">常量的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new函数"><span class="toc-number">1.2.2.</span> <span class="toc-text">new函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量生命周期"><span class="toc-number">1.2.3.</span> <span class="toc-text">变量生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域"><span class="toc-number">1.2.4.</span> <span class="toc-text">作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本数据类型"><span class="toc-number">1.3.</span> <span class="toc-text">基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#整型"><span class="toc-number">1.3.1.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浮点数"><span class="toc-number">1.3.2.</span> <span class="toc-text">浮点数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本命令"><span class="toc-number">1.4.</span> <span class="toc-text">基本命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">1.5.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slice切片"><span class="toc-number">1.6.</span> <span class="toc-text">Slice切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map"><span class="toc-number">1.7.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">1.8.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Painc-Recover-defer"><span class="toc-number">1.9.</span> <span class="toc-text">Painc/Recover/defer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Panic异常"><span class="toc-number">1.9.1.</span> <span class="toc-text">Panic异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Recover捕获异常"><span class="toc-number">1.9.2.</span> <span class="toc-text">Recover捕获异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Struct"><span class="toc-number">1.10.</span> <span class="toc-text">Struct</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Method"><span class="toc-number">1.11.</span> <span class="toc-text">Method</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口-interface"><span class="toc-number">1.12.</span> <span class="toc-text">接口 interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射"><span class="toc-number">1.13.</span> <span class="toc-text">反射</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发"><span class="toc-number">2.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础-1"><span class="toc-number">2.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel"><span class="toc-number">2.1.1.</span> <span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Select"><span class="toc-number">2.1.2.</span> <span class="toc-text">Select</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#goroutine"><span class="toc-number">3.</span> <span class="toc-text">goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#大致结构"><span class="toc-number">3.1.</span> <span class="toc-text">大致结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行情况"><span class="toc-number">3.2.</span> <span class="toc-text">运行情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#普通运行"><span class="toc-number">3.2.1.</span> <span class="toc-text">普通运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞运行"><span class="toc-number">3.2.2.</span> <span class="toc-text">阻塞运行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#M空闲"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">M空闲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P空闲"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">P空闲</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络调用"><span class="toc-number">3.3.</span> <span class="toc-text">网络调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构体"><span class="toc-number">3.4.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体M"><span class="toc-number">3.4.1.</span> <span class="toc-text">结构体M</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体G"><span class="toc-number">3.4.2.</span> <span class="toc-text">结构体G</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构体P"><span class="toc-number">3.5.</span> <span class="toc-text">结构体P</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#goroutine优势"><span class="toc-number">3.6.</span> <span class="toc-text">goroutine优势</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#垃圾回收"><span class="toc-number">4.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Golang-GC"><span class="toc-number">4.1.</span> <span class="toc-text">Golang#GC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#何时触发-GC"><span class="toc-number">4.2.</span> <span class="toc-text">何时触发 GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gcTrigger-GC触发条件"><span class="toc-number">4.2.1.</span> <span class="toc-text">gcTrigger/GC触发条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#空间"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">时间</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存管理"><span class="toc-number">5.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础内存"><span class="toc-number">5.1.</span> <span class="toc-text">基础内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-number">5.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结分配逻辑"><span class="toc-number">5.3.</span> <span class="toc-text">总结分配逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#指针操作-unsafe"><span class="toc-number">6.</span> <span class="toc-text">指针操作/unsafe</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">6.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例子"><span class="toc-number">6.2.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#网络-netpoller"><span class="toc-number">7.</span> <span class="toc-text">网络/netpoller</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#读取操作"><span class="toc-number">7.1.</span> <span class="toc-text">读取操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞中唤醒操作"><span class="toc-number">7.2.</span> <span class="toc-text">阻塞中唤醒操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">7.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优势"><span class="toc-number">7.4.</span> <span class="toc-text">优势</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他"><span class="toc-number">8.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#包和工具"><span class="toc-number">8.1.</span> <span class="toc-text">包和工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#包的匿名导入"><span class="toc-number">8.1.1.</span> <span class="toc-text">包的匿名导入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#性能分析"><span class="toc-number">9.</span> <span class="toc-text">性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pprof搜集"><span class="toc-number">9.1.</span> <span class="toc-text">pprof搜集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pprof分析"><span class="toc-number">9.2.</span> <span class="toc-text">pprof分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU性能分析"><span class="toc-number">9.2.1.</span> <span class="toc-text">CPU性能分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存性能分析"><span class="toc-number">9.2.2.</span> <span class="toc-text">内存性能分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞性能分析"><span class="toc-number">9.2.3.</span> <span class="toc-text">阻塞性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pprof文件分析"><span class="toc-number">9.3.</span> <span class="toc-text">pprof文件分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#链接"><span class="toc-number">10.</span> <span class="toc-text">链接</span></a></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            Go学习笔记
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2018/03/11/go-study/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-03-11T15:40:23.000Z" itemprop="datePublished">2018-03-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/go/">go</a>, <a class="article-tag-link" href="/tags/microservice/">microservice</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>Golang 学习笔记<br><a id="more"></a>  </p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">内建常量: true false iota nil</span><br><span class="line">内建类型: int int8 int16 int32 int64</span><br><span class="line">uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line">float32 float64 complex128 complex64 bool byte rune string error</span><br><span class="line">内建函数: make len cap new append copy close delete</span><br><span class="line">complex real imag panic recover</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">break default func interface select case defer go map struct</span><br><span class="line">chan else</span><br><span class="line">const fallthrough continue for</span><br><span class="line">goto package switch if range type</span><br><span class="line">import return var</span><br></pre></td></tr></table></figure>
<h3 id="变量函数驼峰命名"><a href="#变量函数驼峰命名" class="headerlink" title="变量函数驼峰命名"></a>变量函数驼峰命名</h3><blockquote>
<p>几个单词组成优先使用大小写分隔,而不是下划线分隔    </p>
</blockquote>
<h3 id="文件名-报名下划线"><a href="#文件名-报名下划线" class="headerlink" title="文件名/报名下划线"></a>文件名/报名下划线</h3><blockquote>
<p>几个单词组成优先下划线分隔,而不是使用大小写分隔   </p>
</blockquote>
<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><ul>
<li>16位整型：int16/uint16<ul>
<li>长度：2字节</li>
<li>取值范围：-32768~32767/0~65535</li>
</ul>
</li>
<li>32位整型：int32（rune）/uint32<ul>
<li>长度：4字节</li>
<li>取值范围：-2^32/2~2^32/2-1/0~2^32-1</li>
</ul>
</li>
<li>64位整型：int64/uint64<ul>
<li>长度：8字节</li>
<li>取值范围：-2^64/2~2^64/2-1/0~2^64-1</li>
</ul>
</li>
<li>浮点型：float32/float64<ul>
<li>长度：4/8字节</li>
<li>小数位：精确到7/15小数位</li>
</ul>
</li>
<li>复数：complex64/complex128<ul>
<li>长度：8/16字节</li>
</ul>
</li>
<li><p>足够保存指针的 32 位或 64 位整数型：uintptr</p>
</li>
<li><p>其它值类型：</p>
<ul>
<li>array、struct、string</li>
</ul>
</li>
<li><p>引用类型：</p>
<ul>
<li>slice、map、chan</li>
</ul>
</li>
<li><p>接口类型：inteface</p>
</li>
<li>函数类型：func</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前程序的包名</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入其它的包</span></span><br><span class="line"><span class="keyword">import</span> std <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量的定义</span></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量的声明与赋值</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"gopher"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般类型声明</span></span><br><span class="line"><span class="keyword">type</span> newType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构的声明</span></span><br><span class="line"><span class="keyword">type</span> gopher <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口的声明</span></span><br><span class="line"><span class="keyword">type</span> golang <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由 main 函数作为程序入口点启动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    std.Println(<span class="string">"Hello world!你好，世界！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>main包下有main函数     </li>
<li>import下<code>.</code>可直接使用内部函数不需要类似<code>fmt</code>,或者<code>package</code>取别名   </li>
<li>import可<code>()</code>导入大批量   </li>
</ul>
<h3 id="常量的定义"><a href="#常量的定义" class="headerlink" title="常量的定义"></a>常量的定义</h3><ul>
<li>常量的值在编译时就已经确定  </li>
<li>常量的定义格式与变量基本相同  </li>
<li>等号右侧必须是常量或者常量表达式  </li>
<li>常量表达式中的函数必须是内置函数  </li>
</ul>
<p>常量的初始化规则与枚举</p>
<ul>
<li>在定义常量组时，如果不提供初始值，则表示将使用上行的表达式</li>
<li>使用相同的表达式不代表具有相同的值</li>
<li>iota是常量的计数器，从0开始，组中每定义1个常量自动递增1</li>
<li>通过初始化规则与iota可以达到枚举的效果</li>
<li>每遇到一个const关键字，iota就会重置为0</li>
</ul>
<h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h3><ul>
<li>new(T)将创建一个T类型的匿名变量   </li>
<li>初始化为T类型的零值,然后返回变量地址,返回的指针类型为*T    </li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="keyword">int</span>)   <span class="comment">// p, *int 类垄, 挃向匿名的 int 发量</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// "0"</span></span><br><span class="line">*p=<span class="number">2</span>            <span class="comment">// 设置 int 匿名发量的值为 2</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// "2"</span></span><br></pre></td></tr></table></figure>
<p>由二new叧是一丧预定的函数,它并不是是关键字<br>因此我们可以将 new 名字重新定义为别的类型。<br>例如下面的例子:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delta</span><span class="params">(old, <span class="built_in">new</span> <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">new</span> - old &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="变量生命周期"><a href="#变量生命周期" class="headerlink" title="变量生命周期"></a>变量生命周期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">包一级声明的变量来说,它们的生命周期和整个程序的运行周期是一致的  </span><br><span class="line"></span><br><span class="line">而局部遍历的声明周期是动态的</span><br><span class="line">从每次创建一个新变量声明开始知道该变量不再被引用为止</span><br><span class="line">然后变量的存储空间就会被回收</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数多返回值和多参数值需要最后末尾参数也加,逗号<br>是为了不会导致编译错误,这是Go编译器的一个特性    </p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global *<span class="keyword">int</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span> x=<span class="number">1</span> global = &amp;x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">    y := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">    *y = <span class="number">1</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>f函数x变量必须堆上分配,因为函数退出后通过包一级变量global变量找到<br>x局部变量在函数f中逃逸了   </p>
</blockquote>
<blockquote>
<p>相反g函数返回,变量<em>y将是不可达,必须马上回收<br>因此</em>y并没有存函数g中逃逸,编译器将选择栈上分配*y的存储空间    </p>
</blockquote>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><blockquote>
<p>语法块内部    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法快像函数体或循环体花括弧对应的语法块   </span><br><span class="line">语法块内部声明是无法被外部语法块访问</span><br><span class="line">语法决定了内部声明的名字的作用域范围</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">函数外部声明可在同一个包的任何源文件访问</span><br><span class="line">对于导入包则对应源文件级的作用域</span><br><span class="line">此称为全局域</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Go 同时提供了有符号和无符号类垄的整数运算。</span><br><span class="line">返里有 int8、 int16、int32 和 int64 四种截然不同大小的有符号整形数类型</span><br><span class="line">分别对应 8、 16、32、64bit 大小的有符号整形数</span><br><span class="line">不此对应的是 uint8、uint16、uint32 和 uint64 四种无符号整形数类型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其中int 是应用最广泛的数值类型。</span><br><span class="line">返两种类型都有同样的大 小，32 或 64bit</span><br><span class="line">但是我们不能对此做任何的假设;</span><br><span class="line">因为不同的编诌器即使在相同癿硬件平台上可能产生不同的大小。</span><br></pre></td></tr></table></figure>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Go提供两种精度的浮点数,float32或float64</span><br><span class="line"></span><br><span class="line">常量 math.MaxFloat32 表示 float32 能表示的最大数值大约是 3.4e38;</span><br><span class="line">对应的math.MaxFloat64 常量大约是 1.8e308。</span><br><span class="line"></span><br><span class="line">它们分别能表示癿最小值近似为 1.4e-45 和 4.9e-324</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>Go常用命令简介</p>
<ul>
<li>go get：获取远程包（需 提前安装 git或hg）</li>
<li>go run：直接运行程序</li>
<li>go build：测试编译，检查是否有编译错误</li>
<li>go fmt：格式化源码（部分IDE在保存时自动调用）</li>
<li>go install：编译包文件并编译整个程序</li>
<li>go test：运行测试文件</li>
<li>go doc：查看文档（CHM手册）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">默认情况,go build命令构建的指定包和依赖的包</span><br><span class="line">然后丢弃除了最后可执行文件之外所有的中间编译结果</span><br><span class="line"></span><br><span class="line">go install 和go build很相似,但是它会保存每个包的编译成果</span><br><span class="line">而不是将它们丢弃,被编译的包会被保存到$GOPATH/pkg目录下</span><br><span class="line">目录路径和src目录路径对应,可执行程序被保存到$GOPATH/bin目录</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>数组固定了大小     </p>
</blockquote>
<p>数组Array</p>
<ul>
<li>定义数组的格式：var <varname> [n]<type>，n&gt;=0</type></varname></li>
<li>数组长度也是类型的一部分，因此具有不同长度的数组为不同类型</li>
<li>注意区分指向数组的指针和指针数组</li>
<li>数组在Go中为值类型</li>
<li>数组之间可以使用==或!=进行比较，但不可以使用&lt;或&gt;</li>
<li>可以使用new来创建数组，此方法返回一个指向数组的指针</li>
<li>Go支持多维数组</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>] <span class="keyword">int</span></span><br><span class="line"><span class="comment">//[0, 0, 0]</span></span><br><span class="line"></span><br><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">//[1,2,3]</span></span><br><span class="line"></span><br><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">//[0, 0, 1]</span></span><br><span class="line"></span><br><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>:<span class="number">2</span>, <span class="number">2</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *[<span class="number">3</span>] <span class="keyword">int</span> = &amp;a</span><br><span class="line"><span class="comment">//数组的地址</span></span><br><span class="line"><span class="comment">//&amp;[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">x, y := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">a := [...]*<span class="keyword">int</span>(&amp;x, &amp;y)</span><br><span class="line"><span class="comment">//[0X111地址, 0X222地址]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组=操作是拷贝非地址引用传递</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p := <span class="built_in">new</span>([<span class="number">3</span>]<span class="keyword">int</span>)</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment">//p: &amp;[1, 0, 0]</span></span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="Slice切片"><a href="#Slice切片" class="headerlink" title="Slice切片"></a>Slice切片</h2><p>slice具有len和cap两个,具体为长度和容量<br>如果容量不够将x2的方式扩展</p>
<p>切片Slice</p>
<ul>
<li>其本身并不是数组，它指向底层的数组</li>
<li>作为变长数组的替代方案，可以关联底层数组的局部或全部</li>
<li>为引用类型</li>
<li>可以直接创建或从底层数组获取生成</li>
<li>使用len()获取元素个数，cap()获取容量</li>
<li>一般使用make()创建</li>
<li>如果多个slice指向相同底层数组，其中一个的值改变会影响全部</li>
<li>make([]T, len, cap)</li>
<li>其中cap可以省略，则和len的值相同</li>
<li>len表示存数的元素个数，cap表示容量</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">2</span>, <span class="number">2</span>:<span class="number">3</span>&#125;</span><br><span class="line">s1 := a[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line"><span class="comment">//s1:[2, 3]</span></span><br><span class="line"></span><br><span class="line">s2 := a[<span class="number">1</span>:<span class="built_in">len</span>(a)]</span><br><span class="line"><span class="comment">//s2:[2, 3]</span></span><br><span class="line"></span><br><span class="line">s3 := a[<span class="number">1</span>:]</span><br><span class="line"><span class="comment">//s3:[2, 3]</span></span><br><span class="line"></span><br><span class="line">s4 := a[:<span class="number">1</span>]</span><br><span class="line"><span class="comment">//s4:[1, 2]</span></span><br><span class="line"></span><br><span class="line">s5 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">s6 := []<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">//[0,2]</span></span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul>
<li>类似其它语言中的哈希表或者字典,以key-value形式存储数据</li>
<li>Key必须是支持==或!=比较运算的类型，不可以是函数、map或slice</li>
<li>Map查找比线性搜索快很多，但比使用索引访问数据的类型慢100倍</li>
<li>Map使用make()创建，支持 := 这种简写方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">make([keyType]valueType, cap)，cap表示容量，可省略</span><br><span class="line">超出容量时会自动扩容，但尽量提供一个合理的初始值</span><br><span class="line">使用len()获取元素个数</span><br><span class="line"></span><br><span class="line">键值对不存在时自动添加，使用delete()删除某键值对</span><br><span class="line">使用 for range 对map和slice进行迭代操作</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> countryCapitalMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">/*创建集合 */</span></span><br><span class="line">    countryCapitalMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* map插入key - value对,各个国家对应的首都 */</span></span><br><span class="line">    countryCapitalMap [ <span class="string">"France"</span> ] = <span class="string">"Paris"</span></span><br><span class="line">    countryCapitalMap [ <span class="string">"Italy"</span> ] = <span class="string">"罗马"</span></span><br><span class="line">    countryCapitalMap [ <span class="string">"Japan"</span> ] = <span class="string">"东京"</span></span><br><span class="line">    countryCapitalMap [ <span class="string">"India "</span> ] = <span class="string">"新德里"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*使用键输出地图值 */</span> <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">        fmt.Println(country, <span class="string">"首都是"</span>, countryCapitalMap [country])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*查看元素在集合中是否存在 */</span></span><br><span class="line">    captial, ok := countryCapitalMap [ <span class="string">"美国"</span> ] <span class="comment">/*如果确定是真实的,则存在,否则不存在 */</span></span><br><span class="line">    <span class="comment">/*fmt.Println(captial) */</span></span><br><span class="line">    <span class="comment">/*fmt.Println(ok) */</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        fmt.Println(<span class="string">"美国的首都是"</span>, captial)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"美国的首都不存在"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//France 首都是 Paris</span></span><br><span class="line"><span class="comment">//Italy 首都是 罗马</span></span><br><span class="line"><span class="comment">//Japan 首都是 东京</span></span><br><span class="line"><span class="comment">//India  首都是 新德里</span></span><br><span class="line"><span class="comment">//美国的首都不存在</span></span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数function</p>
<ul>
<li>Go 函数 不支持 嵌套、重载和默认参数   </li>
<li>但支持以下特性:   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无需声明原型、不定长度变参、多返回值、命名返回值参数</span><br><span class="line">匿名函数、闭包</span><br></pre></td></tr></table></figure>
<ul>
<li>定义函数使用关键字 func，且左大括号不能另起一行   </li>
<li>函数也可以作为一种类型使用   </li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span><span class="params">(a, b, c <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> a, b, c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(a ...<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    <span class="comment">//a [1, 2]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//匿名函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数执行完才执行,并且逆排</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"a"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// b a</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>相关值和引用地址传递</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    s1 := []<span class="keyword">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    A(s1)</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(s[] <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    s[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">    s[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//s1: 4, 5, 6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    A(a, b);</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(a ...<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a = 1, b = 2</span></span><br></pre></td></tr></table></figure>
<h2 id="Painc-Recover-defer"><a href="#Painc-Recover-defer" class="headerlink" title="Painc/Recover/defer"></a>Painc/Recover/defer</h2><ul>
<li>defer的执行方式类似其它语言中的析构函数，在函数体执行结束后    </li>
</ul>
<blockquote>
<p>按照调用顺序的相反顺序逐个执行   </p>
</blockquote>
<ul>
<li>即使函数发生严重错误也会执行   </li>
<li>支持匿名函数的调用   </li>
<li>常用于资源清理、文件关闭、解锁以及记录时间等操作   </li>
<li>通过与匿名函数配合可在return之后修改函数计算结果   </li>
<li>如果函数体内某个变量作为defer时匿名函数的参数   </li>
</ul>
<blockquote>
<p>则在定义defer时即已经获得了拷贝，否则则是引用某个变量的地址   </p>
</blockquote>
<ul>
<li>Go 没有异常机制，但有 panic/recover 模式来处理错误   </li>
<li>Panic 可以在任何地方引发，但recover只有在defer调用的函数中有效   </li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"func A"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">    painc(<span class="string">"Painc in B"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"func C"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A()</span><br><span class="line">    B()</span><br><span class="line">    C()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Func A</span></span><br><span class="line"><span class="comment">//Painc in B</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err!=<span class="literal">nil</span>&#123;</span><br><span class="line">            fmt.Println(<span class="string">"Recover In B"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    painc(<span class="string">"Painc in B"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Func A</span></span><br><span class="line"><span class="comment">//Recover In B</span></span><br><span class="line"><span class="comment">//Func C</span></span><br></pre></td></tr></table></figure>
<h3 id="Panic异常"><a href="#Panic异常" class="headerlink" title="Panic异常"></a>Panic异常</h3><blockquote>
<p>当panic异常发生,程序中断运行并立即执行该goroutine的defer被延迟函数<br>随后输出崩溃日志     </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">日志包含panic value和函数调用的堆栈跟踪信息  </span><br><span class="line">runtime.Stack为何能输出被释放的函数堆栈信息</span><br><span class="line">因为延迟函数的调用在释放堆栈信息之前</span><br></pre></td></tr></table></figure>
<h3 id="Recover捕获异常"><a href="#Recover捕获异常" class="headerlink" title="Recover捕获异常"></a>Recover捕获异常</h3><p>本不应该去对panic异常做任何处理,但是也许有需求从异常中恢复  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当web服务器遇到不可预料的严重问题时</span><br><span class="line">做一些操作,在崩溃前应该将所有的连接关闭</span><br><span class="line">如果不作任何处理,客户端会一直处于等待状态</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(input <span class="keyword">string</span>)</span> <span class="params">(s *Syntax, err error)</span></span> &#123; </span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">"internal error: %v"</span>, p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// ...parser...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><p>结构struct</p>
<ul>
<li>Go 中的struct与C中的struct非常相似，并且Go没有class    </li>
<li>使用 type <name> struct{} 定义结构，名称遵循可见性规则   </name></li>
<li>支持指向自身的指针类型成员   </li>
<li>支持匿名结构，可用作成员或定义成员变量   </li>
<li>匿名结构也可以用于map的值    </li>
<li>可以使用字面值对结构进行初始化   </li>
<li>允许直接通过指针来读写结构成员<br>-相同类型的成员可进行直接拷贝赋值   </li>
<li>支持 == 与 !=比较运算符，但不支持 &gt; 或 &lt;   </li>
<li>支持匿名字段，本质上是定义了以某个类型名为名称的字段   </li>
<li>嵌入结构作为匿名字段看起来像继承，但不是继承   </li>
<li>可以使用匿名字段指针   </li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">    Contract <span class="keyword">struct</span>&#123;</span><br><span class="line">        Phone <span class="keyword">string</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person1 <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> human <span class="keyword">struct</span> &#123;</span><br><span class="line">    Sex <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span>&#123;</span><br><span class="line">    human</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//a := person&#123;&#125;</span></span><br><span class="line">    <span class="comment">//a.Name = "张三"</span></span><br><span class="line">    <span class="comment">//a.Age = 13</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//简便初始化</span></span><br><span class="line">    a := person&#123;</span><br><span class="line">        Name:<span class="string">"张三"</span>,</span><br><span class="line">        Age:<span class="number">13</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(a) <span class="comment">//13</span></span><br><span class="line">    A(a) <span class="comment">//15</span></span><br><span class="line">    fmt.Println(a) <span class="comment">//13</span></span><br><span class="line">    B(&amp;a) <span class="comment">//15</span></span><br><span class="line">    fmt.Println(a) <span class="comment">//15</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//或者初始化的时候直接取地址符号</span></span><br><span class="line">    b := &amp;person&#123;</span><br><span class="line">        Name:<span class="string">"张三"</span>,</span><br><span class="line">        Age:<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//直接匿名结构</span></span><br><span class="line">    c := &amp;<span class="keyword">struct</span>&#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Age <span class="keyword">int</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        Name:<span class="string">"张三"</span>,</span><br><span class="line">        Age:<span class="number">13</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(c)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结构套结构</span></span><br><span class="line">    d := &amp; Person&#123;</span><br><span class="line">        Name:<span class="string">"张三"</span>,</span><br><span class="line">        Age: <span class="number">10</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    d.Contract.Phone = <span class="string">"13912345678"</span></span><br><span class="line">    fmt.Println(d)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//匿名字段结构</span></span><br><span class="line">    e := &amp;Person1&#123;</span><br><span class="line">        <span class="string">"nihao"</span>, <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//结构组合,go是无继承的</span></span><br><span class="line">    f := &amp;student&#123;</span><br><span class="line">        Name:<span class="string">"张三"</span>,</span><br><span class="line">        Age: <span class="number">10</span>,</span><br><span class="line">        human:human&#123;</span><br><span class="line">            Sex:<span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//f.human.Sex = 20 如果有名称冲突可以这样用</span></span><br><span class="line">    f.Sex = <span class="number">10</span></span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//只是值的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(per person)</span></span>&#123;</span><br><span class="line">    per.Age = <span class="number">15</span></span><br><span class="line">    fmt.Println(<span class="string">"A"</span>, per)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">(per *person)</span></span>&#123;</span><br><span class="line">    per.Age = <span class="number">15</span>;</span><br><span class="line">    fmt.Println(<span class="string">"A"</span>, per)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><blockquote>
<p>结构中带有method      </p>
</blockquote>
<ul>
<li>Go 中虽没有class,但依旧有method     </li>
<li>通过显示说明receiver来实现与某个类型的组合     </li>
<li>只能为同一个包中的类型定义方法    </li>
<li>Receiver 可以是类型的值或者指针    </li>
<li>不存在方法重载    </li>
<li>可以使用值或指针来调用方法，编译器会自动完成转换    </li>
<li>从某种意义上来说，方法是函数的语法糖，因为receiver其实就是   <blockquote>
<p>方法所接收的第1个参数(Method Value vs. Method Expression)    </p>
</blockquote>
</li>
<li>如果外部结构和嵌入结构存在同名方法，则优先调用外部结构的方法    </li>
<li>类型别名不会拥有底层类型所附带的方法    </li>
<li>方法可以调用结构中的非公开字段   </li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StructMethodTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := A&#123;</span><br><span class="line">        Name :<span class="string">"张三"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    a.Say()</span><br><span class="line"></span><br><span class="line">    b := B&#123;</span><br><span class="line">        Name:<span class="string">"李四"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    b.Say()</span><br><span class="line"></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    fmt.Println(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不仅仅struct类型 仅仅一个int也能支持增加method方法</span></span><br><span class="line">    tz := TZ(<span class="number">10</span>)</span><br><span class="line">    tz.Say()</span><br><span class="line">    (*TZ).Say(&amp;tz)</span><br><span class="line">    (*TZ).Eat(&amp;tz, <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(b B)</span><span class="title">Say</span><span class="params">()</span></span>&#123;</span><br><span class="line">    b.Name = <span class="string">"say test"</span></span><br><span class="line">    fmt.Println(<span class="string">"I'm say in "</span>+ b.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a *A)</span><span class="title">Say</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果name小写则会在package范围内才能修改</span></span><br><span class="line">    a.Name = <span class="string">"say test"</span></span><br><span class="line">    fmt.Println(<span class="string">"I'm "</span> +a.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//func(a A)Say(string msg)&#123;</span></span><br><span class="line"><span class="comment">//  fmt.Println("I'm " + a.Name + " " + msg)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//这是不可行,不支持重载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TZ <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(tz *TZ)</span><span class="title">Say</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"haha tz"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(tz *TZ)</span><span class="title">Eat</span><span class="params">(numb <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"hhahaha"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h2><ul>
<li>接口是一个或多个方法签名的集合   </li>
<li>只要某个类型拥有该接口的所有方法签名,即算实现该接口   <blockquote>
<p>无需显示声明实现了哪个接口，这称为 Structural Typing    </p>
</blockquote>
</li>
<li>接口只有方法声明，没有实现，没有数据字段   </li>
<li>接口可以匿名嵌入其它接口，或嵌入到结构中   </li>
<li>将对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个   <blockquote>
<p>复制品的指针，既无法修改复制品的状态，也无法获取指针   </p>
</blockquote>
</li>
<li>只有当接口存储的类型和对象都为nil时，接口才等于nil   </li>
<li>接口调用不会做receiver的自动转换     </li>
<li>接口同样支持匿名字段方法     </li>
<li>接口也可实现类似OOP中的多态     </li>
<li>空接口可以作为任何类型数据的容器     </li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span>&#123;</span><br><span class="line">    Name() <span class="keyword">string</span></span><br><span class="line">    Connecter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PhoneUSB <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌入接口</span></span><br><span class="line"><span class="keyword">type</span> Connecter <span class="keyword">interface</span>&#123;</span><br><span class="line">    Connect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phoneUsb PhoneUSB)</span><span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> phoneUsb.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phoneUsb PhoneUSB)</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    phoneUsb.name = <span class="string">"手机连接成功"</span></span><br><span class="line">    fmt.Println(<span class="string">"connect"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Disconnect</span><span class="params">(usb USB)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> mobile, ok := usb.(PhoneUSB); ok&#123;</span><br><span class="line">        fmt.Println(<span class="string">"Disconnect "</span>+ mobile.Name())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用switch去判断</span></span><br><span class="line">    <span class="keyword">switch</span> usb.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> Connecter:</span><br><span class="line">        fmt.Println(<span class="string">"this is connecter"</span>)</span><br><span class="line">    <span class="keyword">case</span> PhoneUSB:</span><br><span class="line">        fmt.Println(<span class="string">"this is phoneUsb"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Unknow"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestInterface</span><span class="params">()</span></span>&#123;</span><br><span class="line">    usb := PhoneUSB&#123;</span><br><span class="line">        name:<span class="string">"手机"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    usb.Connect()</span><br><span class="line">    Disconnect(usb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射reflection    </p>
<ul>
<li>反射可大大提高程序的灵活性，使得 interface{} 有更大的发挥余地   </li>
<li>反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息   </li>
<li>反射会将匿名字段作为独立字段(匿名字段本质)   </li>
<li>想要利用反射修改对象状态，前提是 interface.data 是 settable,即 pointer-interface      </li>
<li>通过反射可以”动态”调用方法   </li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="keyword">int</span></span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(u User)</span> <span class="title">Hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(u.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(u User)</span> <span class="title">Say</span><span class="params">(msg <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"I'm say %v \n"</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Set</span><span class="params">(o <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">    v := reflect.ValueOf(o)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断类型是否指针 &amp;&amp; 是否可写</span></span><br><span class="line">    <span class="keyword">if</span> k:=v.Kind();k==reflect.Ptr&amp;&amp;!v.Elem().CanSet()&#123;</span><br><span class="line">        fmt.Println(<span class="string">"XXX"</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        v = v.Elem()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字段为string并且是否有找到</span></span><br><span class="line">    <span class="keyword">if</span> f:=v.FieldByName(<span class="string">"Name"</span>); f.Kind() == reflect.String &amp;&amp; f.IsValid()&#123;</span><br><span class="line">        f.SetString(<span class="string">"Set"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Info</span><span class="params">(o <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">    t := reflect.TypeOf(o)</span><br><span class="line">    v := reflect.ValueOf(o)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前对象是否属于某个对象</span></span><br><span class="line">    <span class="keyword">if</span> k:=t.Kind(); k!= reflect.Struct&#123;</span><br><span class="line">        fmt.Println(<span class="string">"当前不为Struct,无法反射"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">"当前匹配成功"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Type:"</span>, t.Name())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt; t.NumField(); i++ &#123;</span><br><span class="line">        f := t.Field(i)</span><br><span class="line">        val := v.Field(i).Interface()</span><br><span class="line">        fmt.Printf(<span class="string">"%5s %3v  %3v\n"</span>, f.Name, f.Type, val)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的Method和Field都是要公共方法和字段</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j&lt;t.NumMethod(); j++ &#123;</span><br><span class="line">        m := t.Method(j)</span><br><span class="line">        fmt.Printf(<span class="string">"%6s : %v \n"</span>, m.Name, m.Type)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">    User</span><br><span class="line">    title <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    user := User&#123;<span class="number">1</span>, <span class="string">"李四"</span>&#125;</span><br><span class="line">    Info(user)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取复杂字段的操作</span></span><br><span class="line">    u := Manager&#123;User: User&#123;<span class="number">1</span>, <span class="string">"ok"</span>&#125;, title:<span class="string">"title"</span>&#125;</span><br><span class="line">    t := reflect.TypeOf(u)</span><br><span class="line">    fmt.Printf(<span class="string">"%v \n"</span>, t.Field(<span class="number">0</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%v \n"</span>, t.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">0</span>&#125;))</span><br><span class="line">    fmt.Printf(<span class="string">"%v \n"</span>, t.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;))</span><br><span class="line">    fmt.Printf(<span class="string">"%v \n"</span>, t.Field(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基本类型操作</span></span><br><span class="line">    x := <span class="number">123</span></span><br><span class="line">    v := reflect.ValueOf(&amp;x)</span><br><span class="line">    v.Elem().SetInt(<span class="number">999</span>)</span><br><span class="line">    fmt.Println(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//user复杂struct操作</span></span><br><span class="line">    Set(&amp;user)</span><br><span class="line">    fmt.Println(user.Name)</span><br><span class="line">    userV := reflect.ValueOf(user)</span><br><span class="line">    <span class="comment">//取args等信息</span></span><br><span class="line">    method := userV.MethodByName(<span class="string">"Say"</span>)</span><br><span class="line">    args := []reflect.Value&#123;reflect.ValueOf(<span class="string">"Hi"</span>)&#125;</span><br><span class="line">    method.Call(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">从源码的解析来看,goroutine 只是由官方实现的超级&quot;线程池&quot;而已。   </span><br><span class="line">不过话说回来,每个实例 4-5KB 的栈内存占用和由于实现机制而大幅</span><br><span class="line">减少的创建和销毁开销,是制造 Go 号称的高并发的根本原因。</span><br><span class="line">另外,goroutine 的简单易用,也在语言层面上给予了开发者巨大的便利。</span><br><span class="line"></span><br><span class="line">并发主要由切换时间片来实现&quot;同时&quot;运行</span><br><span class="line">在并行则是直接利用多核实现多线程的运行</span><br><span class="line">但 Go 可以设置使用核数,以发挥多核计算机的能力。</span><br><span class="line"></span><br><span class="line">Goroutine 奉行通过通信来共享内存，而不是共享内存来通信。</span><br></pre></td></tr></table></figure>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel 是 goroutine 沟通的桥梁，大都是阻塞同步的<br>通过 make 创建，close 关闭<br>Channel 是引用类型<br>可以使用 for range 来迭代不断操作 channel<br>可以设置单向或双向通道<br>可以设置缓存大小，在未被填满前不会发生阻塞</p>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>可处理一个或多个 channel 的发送与接收<br>同时有多个可用的 channel时按随机顺序处理<br>可用空的 select 来阻塞 main 函数<br>可设置超时</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//channel 完成了消息的发生</span></span><br><span class="line">v := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"go"</span>)</span><br><span class="line">    v &lt;- <span class="number">10</span></span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(&lt;- v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//channel 完成了消息的发生使用for range迭代不断操作channel</span></span><br><span class="line"><span class="comment">//必须要close  </span></span><br><span class="line">v := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"go"</span>)</span><br><span class="line">    v &lt;- <span class="number">10</span></span><br><span class="line">    <span class="built_in">close</span>(v)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//fmt.Println(&lt;- v)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> v&#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><h2 id="大致结构"><a href="#大致结构" class="headerlink" title="大致结构"></a>大致结构</h2><p><img src="/2018/03/11/go-study/image-03.png" alt="img"></p>
<blockquote>
<p>Go的调度器内部有三个重要的结构：M,P,S;    </p>
</blockquote>
<ul>
<li>M:代表真正的内核OS线程,和POSIX里的thread差不多,真正干活的人</li>
<li>G:代表一个<code>goroutine</code>,它有自己的栈,<code>instruction pointer</code>和其他信息(正在等待的channel等等),用于调度。</li>
<li>P:代表调度的上下文,可以把它看做一个局部的调度器,使go代码在一个线程上跑  </li>
</ul>
<p><br></p>
<p><br></p>
<h2 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h2><h3 id="普通运行"><a href="#普通运行" class="headerlink" title="普通运行"></a>普通运行</h3><p><img src="/2018/03/11/go-study/image-04.png" alt="img"></p>
<p>有2个物理线程M,每一个M都拥有一个<code>context(P)</code>,每一个也都有一个正在运行的<code>goroutine</code>。  </p>
<p>P的数量可以通过<code>GOMAXPROCS()</code>来设置,它其实也就代表了真正的并发度,即有多少个<code>goroutine</code>可以同时运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果是IO类型程序,设置GOMAXPROCS就像一个多路复用器</span><br><span class="line">goroutine设置为大于CPU的核数,io性能提升明显,直到达到最大的IOPS(磁盘每秒输入输出量)</span><br><span class="line"></span><br><span class="line">如果是CPU类型程序,默认即可,默认值已经设置为CPU的核数</span><br></pre></td></tr></table></figure>
<p>图中灰色的那些<code>goroutine</code>并没有运行,而是出于ready的就绪态,正在等待被调度。<br>P维护着这个队列(称之为<code>runqueue</code>)    </p>
<blockquote>
<p>Go语言里,启动一个goroutine很容易:go function 就行  </p>
<p>所以每有一个go语句被执行runqueue队列就在其末尾加入一个  </p>
<p>goroutine在下一个调度点,就从runqueue中取出一个goroutine执行。</p>
</blockquote>
<h3 id="阻塞运行"><a href="#阻塞运行" class="headerlink" title="阻塞运行"></a>阻塞运行</h3><p><img src="/2018/03/11/go-study/image-01.png" alt="img"></p>
<p>当一个OS线程被阻塞时,P可以转而投奔另一个OS线程!   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当一个OS线程M0陷入阻塞时,P转而在OS线程M1上运行。 </span><br><span class="line">调度器保证有足够的线程来运行所有的context P。 </span><br><span class="line">图中的M1可能是被创建，或者从线程缓存中取出。</span><br></pre></td></tr></table></figure>
<h4 id="M空闲"><a href="#M空闲" class="headerlink" title="M空闲"></a>M空闲</h4><p>当有M0空闲的时候,它必须尝试取得一个context P来运行goroutine,<br>一般情况下,它会从其他的OS线程那里偷一个context P过来。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果没有偷到的话,它就把goroutine放在一个global runqueue里</span><br><span class="line">然后自己就去睡大觉了(放入线程缓存里)。    </span><br><span class="line">Context P们也会周期性的检查global runqueue</span><br><span class="line">否则global runqueue上的goroutine永远无法执行。</span><br></pre></td></tr></table></figure>
<h4 id="P空闲"><a href="#P空闲" class="headerlink" title="P空闲"></a>P空闲</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">另一种情况是P所分配的任务G很快就执行完了(分配不均)</span><br><span class="line">这就导致了一个上下文P闲着没事儿干而系统却任然忙碌。</span><br><span class="line">但是如果global runqueue没有任务G了,那么P就不得不从其他的上下文P那里拿一些G来执行。</span><br><span class="line">如果上下文P从其他的上下文P那里要偷一个任务的话,一般就‘偷’run queue的一半</span><br><span class="line">这就确保了每个OS线程都能充分的使用。</span><br></pre></td></tr></table></figure>
<p><code>转自知乎</code></p>
<h2 id="网络调用"><a href="#网络调用" class="headerlink" title="网络调用"></a>网络调用</h2><p>所有网络io调用都与调度器集成在一起了</p>
<p>也就是说所有网络io操作都是nonblocking的</p>
<p>数据没收完时G不会占用物理线程</p>
<p>而网络poller(epoll，kqueue)发现G又有数据可读时会重新将G放回runqueue</p>
<p>所以调度器直接支持的网络层是这样的工作的。</p>
<p>自己基于epoll写大概也是这个样子。 </p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="结构体M"><a href="#结构体M" class="headerlink" title="结构体M"></a>结构体M</h3><p>M是machine的缩写,是对机器的抽象,每个m都是对应到一条操作系统的物理线程    </p>
<p>M必须关联了P才可以执行Go代码,但是当它处理阻塞或者系统调用中时,可以不需要关联P。   </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> M</span><br><span class="line">&#123;</span><br><span class="line">    G*    g0;        <span class="comment">// 带有调度栈的goroutine</span></span><br><span class="line">    G*    gsignal;    <span class="comment">// signal-handling G 处理信号的goroutine</span></span><br><span class="line">    void    (*mstartfn)(void);</span><br><span class="line">    G*    curg;        <span class="comment">// M中当前运行的goroutine</span></span><br><span class="line">    P*    p;        <span class="comment">// 关联P以执行Go代码 (如果没有执行Go代码则P为nil)</span></span><br><span class="line">    P*    nextp;</span><br><span class="line">    <span class="keyword">int32</span>    id;</span><br><span class="line">    <span class="keyword">int32</span>    mallocing; <span class="comment">//状态</span></span><br><span class="line">    <span class="keyword">int32</span>    throwing;</span><br><span class="line">    <span class="keyword">int32</span>    gcing;</span><br><span class="line">    <span class="keyword">int32</span>    locks;</span><br><span class="line">    <span class="keyword">int32</span>    helpgc;        <span class="comment">//不为0表示此m在做帮忙gc。helpgc等于n只是一个编号</span></span><br><span class="line">    <span class="keyword">bool</span>    blockingsyscall;</span><br><span class="line">    <span class="keyword">bool</span>    spinning;</span><br><span class="line">    Note    park;</span><br><span class="line">    M*    alllink;    <span class="comment">// 这个域用于链接allm</span></span><br><span class="line">    M*    schedlink;</span><br><span class="line">    MCache    *mcache;</span><br><span class="line">    G*    lockedg;</span><br><span class="line">    M*    nextwaitm;    <span class="comment">// next M waiting for lock</span></span><br><span class="line">    GCStats    gcstats;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="结构体G"><a href="#结构体G" class="headerlink" title="结构体G"></a>结构体G</h3><ul>
<li>栈信息:stackbase,stackguard</li>
<li>上下文:sched</li>
<li>运行函数:fnstart</li>
<li>传递参数:param</li>
<li>goroutineId标识:goid</li>
</ul>
<p>栈信息stackbase和stackguard,有运行的函数信息fnstart。<br>这些就足够成为一个可执行的单元了,只要得到CPU就可以运行。<br>goroutine切换时，上下文信息保存在结构体的sched域中,goroutine是轻量级的线程或者称为协程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> G</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uintptr</span>    stackguard;    <span class="comment">// 分段栈的可用空间下界</span></span><br><span class="line">    <span class="keyword">uintptr</span>    stackbase;    <span class="comment">// 分段栈的栈基址</span></span><br><span class="line">    Gobuf    sched;        <span class="comment">//goroutine切换时，利用sched域来保存上下文</span></span><br><span class="line">    <span class="keyword">uintptr</span>    stack0;</span><br><span class="line">    FuncVal*    fnstart;        <span class="comment">// goroutine运行的函数</span></span><br><span class="line">    void*    param;        <span class="comment">// 用于传递参数，睡眠时其它goroutine设置param，唤醒时此goroutine可以获取</span></span><br><span class="line">    <span class="keyword">int16</span>    status;        <span class="comment">// 状态Gidle,Grunnable,Grunning,Gsyscall,Gwaiting,Gdead</span></span><br><span class="line">    <span class="keyword">int64</span>    goid;        <span class="comment">// goroutine的id号</span></span><br><span class="line">    G*    schedlink;</span><br><span class="line">    M*    m;        <span class="comment">// for debuggers, but offset not hard-coded</span></span><br><span class="line">    M*    lockedm;    <span class="comment">// G被锁定只能在这个m上运行</span></span><br><span class="line">    <span class="keyword">uintptr</span>    gopc;    <span class="comment">// 创建这个goroutine的go表达式的pc</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="结构体P"><a href="#结构体P" class="headerlink" title="结构体P"></a>结构体P</h2><blockquote>
<p>Processor的缩写。P的加入是为了提高Go程序的并发度,实现更好的调度。M代表OS线程。P代表Go代码执行时需要的资源。    </p>
</blockquote>
<p>当M执行Go代码时,它需要关联一个P,当M为idle或者在系统调用中时,它也需要P。有刚好GOMAXPROCS个P。所有的P被组织为一个数组,在P上实现了工作流窃取的调度器。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> P</span><br><span class="line">&#123;</span><br><span class="line">    Lock;</span><br><span class="line">    <span class="keyword">uint32</span>    status;  <span class="comment">// Pidle或Prunning等</span></span><br><span class="line">    P*    link;</span><br><span class="line">    <span class="keyword">uint32</span>    schedtick;   <span class="comment">// 每次调度时将它加一</span></span><br><span class="line">    M*    m;    <span class="comment">// 链接到它关联的M (nil if idle)</span></span><br><span class="line">    MCache*    mcache;</span><br><span class="line"></span><br><span class="line">    G*    runq[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int32</span>    runqhead;</span><br><span class="line">    <span class="keyword">int32</span>    runqtail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Available G's (status == Gdead)</span></span><br><span class="line">    G*    gfree;</span><br><span class="line">    <span class="keyword">int32</span>    gfreecnt;</span><br><span class="line">    <span class="keyword">byte</span>    pad[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体P中也有相应的状态：</span></span><br><span class="line">Pidle,</span><br><span class="line">Prunning,</span><br><span class="line">Psyscall,</span><br><span class="line">Pgcstop,</span><br><span class="line">Pdead,</span><br></pre></td></tr></table></figure>
<h2 id="goroutine优势"><a href="#goroutine优势" class="headerlink" title="goroutine优势"></a>goroutine优势</h2><blockquote>
<p>在程序中任何对系统<code>API</code>的调用,都会被<code>runtime</code>层拦截来方便调度。<code>Golang</code>的<code>runtime</code>实现了<code>goroutine</code>和<code>OS thread</code>的M:N模型</p>
</blockquote>
<ul>
<li><p>其实<code>goroutine</code>用到的就是线程池的技术,当<code>goroutine</code>需要执行时,会从<code>thread pool</code>中选出一个可用的<code>M</code>或者新建一个<code>M</code>。而<code>thread pool</code>中如何选取线程,扩建线程,回收线程,<code>Go Scheduler</code>进行了封装,对程序透明,只管调用就行,从而简化了<code>thread pool</code>的使用。</p>
</li>
<li><p><code>Python coroutine</code> 只会使用一个线程,所以只能利用单核。<code>Goroutine</code>可以被多个线程调度,可以利用多核。</p>
</li>
</ul>
<p>goroutine的并发模型定义为以下几个要点:</p>
<ul>
<li>基于Thread的轻量级协程</li>
<li>通过channel来进行协程间的消息传递</li>
<li>只暴露协程，屏蔽线程操作的接口</li>
</ul>
<p><br></p>
<blockquote>
<p>在操作系统的OS Thread和编程语言的User Thread之间,实际上存在3中线程对应模型,也就是:1:1,1:N,M:N。</p>
</blockquote>
<ul>
<li>N:1是说，多个（N）用户线程始终在一个内核线程上跑，context上下文切换确实很快，但是无法真正的利用多核。 </li>
<li>1:1是说，一个用户线程就只在一个内核线程上跑，这时可以利用多核，但是上下文switch很慢，频繁切换效率很低。 </li>
<li>M:N是说， 多个goroutine在多个内核线程上跑，这个看似可以集齐上面两者的优势，但是无疑增加了调度的难度。</li>
</ul>
<p><br><br><br></p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>首先对于常见的垃圾回收算法做个简单的介绍：</p>
<ul>
<li>引用计数:这是一种最简单的垃圾回收算法，对每一个对象维护一个应用的计数，当引用该对象的对象被销毁的时候，这个被引用对象的引用计数会自动减一；当有被引用的对象被创建时，计数器加一。当计数器为0的时候，就回收该对象。该GC算法的最大的好处是将内存的管理和用户程序的执行放在一起，这样可以把GC的代价分散到整个程序，不会出现STW；而且可以做到对象很快被回收，不像其他算法在heap被耗尽或者达到某一个阈值才回收。但是缺点是该算法不能处理循环引用；而且在实时地维护引用计数时会一定程度上需要额外资源。其中Python和PHP就是使用的该GC方式。</li>
<li>标记-清除：这是一个很古老的算法了，该算法分为两个步骤，首先从根变量迭代遍历所有被引用的对象，能够访问到的对象会被标记为“被引用”；然后会对没有标记过的进行回收。优点是解决了引用计数的不足。缺点则是需要STW，而且垃圾回收后可能存在大量的磁盘碎片。标记-清除算法后面有了一种变种三色标记法，Golang现在就是使用的该算法，后面我们再细说。</li>
<li>分代收集：分代收集的思想是把heap两个或者多个代空间，新创建的对象存放在称为新生代中，随着垃圾回收的重复执行，生命周期较长的对象会被提升到老年代中，对于新生代的区域的垃圾回收频率要明显高于老年代区域。这样对不同的区域可以使用不用回收算法，这样可以达到更优的性能，但是其缺点是实现太复杂。该算法在JVM的各种GC算法中大量被运用到。</li>
</ul>
<h2 id="Golang-GC"><a href="#Golang-GC" class="headerlink" title="Golang#GC"></a>Golang#GC</h2><p>Golang的GC经历了以下几代的发展    </p>
<ul>
<li>v1.1 STW</li>
<li>v1.3 Mark STW, Sweep 并行</li>
<li>v1.5 三色标记法</li>
<li>v1.8 hybrid write barrier</li>
</ul>
<p>Golang的GC的过程其实就是一个三色标记法的实现,对于三色标记法，”三色”的概念可以简单的理解为:</p>
<ul>
<li>白色：还没有搜索过的对象(白色对象会被当成垃圾对象)   </li>
<li>灰色：正在搜索的对象   </li>
<li>黑色：搜索完成的对象(不会当成垃圾对象，不会被GC)   </li>
</ul>
<p>其过程可以大体总结为:   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、首先创建三个集合：白、灰、黑。</span><br><span class="line">2、将所有对象放入白色集合中。</span><br><span class="line">3、然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入灰色集合。</span><br><span class="line">4、之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合。</span><br><span class="line">5、重复4直到灰色中无任何对象。</span><br><span class="line">6、通过写屏障检测对象有变化，重复以上操作。</span><br><span class="line">7、回收所有白色对象</span><br></pre></td></tr></table></figure>
<h2 id="何时触发-GC"><a href="#何时触发-GC" class="headerlink" title="何时触发 GC"></a>何时触发 GC</h2><ul>
<li><p>自动垃圾回收</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在堆上分配大于 32K byte 对象的时候进行检测此时是否满足垃圾回收条件，如果满足则进行垃圾回收。再判断满足gcTrigger的条件</span><br></pre></td></tr></table></figure>
</li>
<li><p>主动垃圾回收</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过调用runtime.GC(),这是阻塞式的</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="gcTrigger-GC触发条件"><a href="#gcTrigger-GC触发条件" class="headerlink" title="gcTrigger/GC触发条件"></a>gcTrigger/GC触发条件</h3><h4 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h4><p><code>memstats.heap_live &gt;= memstats.gc_trigger</code>    </p>
<blockquote>
<p>当前堆上的活跃对象大于我们初始化时候设置的 GC 触发阈值    </p>
</blockquote>
<p><code>memstats.gc_trigger</code>相关的值如下    </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">trigger := ^<span class="keyword">uint64</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> gcpercent &gt;= <span class="number">0</span> &#123;</span><br><span class="line">    trigger = <span class="keyword">uint64</span>(<span class="keyword">float64</span>(memstats.heap_marked) * (<span class="number">1</span> + triggerRatio))</span><br><span class="line">    minTrigger := heapminimum</span><br><span class="line">    <span class="keyword">if</span> trigger &lt; minTrigger &#123;</span><br><span class="line">        trigger = minTrigger</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">memstats.gc_trigger = trigger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//minTrigger默认是4MB*GOGC/100，而GOGC默认为100，所有这个minTrigger为4MB</span></span><br><span class="line"><span class="comment">//uint64(float64(memstats.heap_marked) * (1 + triggerRatio))</span></span><br><span class="line"><span class="comment">//而triggerRatio的规则复杂,其大体结论是根据当前与上次的heap size的比例来决定,默认情况下是GOGC=100，即新增一倍就会触发</span></span><br></pre></td></tr></table></figure>
<h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><blockquote>
<p>Golang程序运行时，会启动一个forcegc的helper goroutine</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在gcTriggerTime该模式下需要满足当前时间距离上一次GC时间需大于forcegcperiod</span></span><br><span class="line"><span class="comment">//这个值在Golang里面为两分钟var forcegcperiod int64 = 2 * 60 * 1e9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> forcegchelper()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forcegchelper</span><span class="params">()</span></span> &#123;</span><br><span class="line">    forcegc.g = getg()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        lock(&amp;forcegc.lock)</span><br><span class="line">        <span class="keyword">if</span> forcegc.idle != <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"forcegc: phase error"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        atomic.Store(&amp;forcegc.idle, <span class="number">1</span>)</span><br><span class="line">        goparkunlock(&amp;forcegc.lock, <span class="string">"force gc (idle)"</span>, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> debug.gctrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"GC forced"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        gcStart(gcBackgroundMode, gcTrigger&#123;kind: gcTriggerTime, now: nanotime()&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="number">0</span> &#123;</span><br><span class="line">            lock(&amp;forcegc.lock)</span><br><span class="line">            forcegc.idle = <span class="number">0</span></span><br><span class="line">            forcegc.g.schedlink = <span class="number">0</span></span><br><span class="line">            injectglist(forcegc.g)</span><br><span class="line">            unlock(&amp;forcegc.lock)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="基础内存"><a href="#基础内存" class="headerlink" title="基础内存"></a>基础内存</h2><blockquote>
<p>如何得知变量是分配在栈(stack)上还是堆(heap)上？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。</span><br><span class="line"></span><br><span class="line">知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。然而，如果编译器不能确保变量在函数 return 之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。</span><br><span class="line"></span><br><span class="line">当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上。然而，还要对这些变量做逃逸分析，如果函数 return 之后，变量不再被引用，则将其分配到栈上。</span><br></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>关键数据结构:</p>
<ul>
<li><p>mspan:作为内存管理的基本单位而存在</p>
<blockquote>
<p>其数据结构为若干连续内存页,一个双端链表的形式,里面存储了它的一些位置信息。通过一个基地址+(页号*页大小),就可以定位到这个mspan的实际内存空间</p>
</blockquote>
  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">next *mspan    </span><br><span class="line">prev *mspan    </span><br><span class="line">list *mSpanList </span><br><span class="line"></span><br><span class="line">startAddr <span class="keyword">uintptr</span></span><br><span class="line">npages    <span class="keyword">uintptr</span> <span class="comment">// span中的页的数量</span></span><br><span class="line"></span><br><span class="line">manualFreeList gclinkptr</span><br><span class="line"></span><br><span class="line">freeindex <span class="keyword">uintptr</span></span><br><span class="line">nelems <span class="keyword">uintptr</span> <span class="comment">// span中块的总数目</span></span><br><span class="line"></span><br><span class="line">allocCache <span class="keyword">uint64</span> </span><br><span class="line">state       mSpanState <span class="comment">// span有四种状态：_MSpanDead,_MSpanInUse,_MSpanManual,_MSpanFree</span></span><br><span class="line">elemsize    <span class="keyword">uintptr</span> <span class="comment">// 通过spanClass或者npages算出来</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mcache:mcache是绑定在每个P上面的内存</p>
<blockquote>
<p>主要用于小对象,正因为是每个P私有的，所以分配的时候就不用加锁。per-P cache,可以认为是 local cache。</p>
</blockquote>
  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">    next_sample <span class="keyword">int32</span>  </span><br><span class="line">    local_scan  <span class="keyword">uintptr</span> </span><br><span class="line">    tiny             <span class="keyword">uintptr</span></span><br><span class="line">    tinyoffset       <span class="keyword">uintptr</span></span><br><span class="line">    local_tinyallocs <span class="keyword">uintptr</span> </span><br><span class="line"></span><br><span class="line">    alloc [numSpanClasses]*mspan </span><br><span class="line">    stackcache [_NumStackOrders]stackfreelist</span><br><span class="line"></span><br><span class="line">    local_nlookup    <span class="keyword">uintptr</span>                </span><br><span class="line">    local_largefree  <span class="keyword">uintptr</span>                    local_nlargefree <span class="keyword">uintptr</span>                </span><br><span class="line">    local_nsmallfree [_NumSizeClasses]<span class="keyword">uintptr</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mcentral:全局cache,如果P里面的mcache不够用的时候向 mcentral 申请。</p>
<blockquote>
<p>其中nonempty是mspan的双向链表，表示当前mcentral中可用的mspan list；而empty是已经被用了的mspan list，或者是在mcache里面已经被缓存了。注意这里有一个lock，因为不同于mcache，mcentral是全局的，会存在多个P访问mcentral的情况，所以这里的lock是非常有必要的。</p>
</blockquote>
  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock      mutex</span><br><span class="line">    spanclass spanClass</span><br><span class="line">    nonempty  mSpanList </span><br><span class="line">    empty     mSpanList </span><br><span class="line"></span><br><span class="line">    nmalloc <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mSpanList <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *mspan </span><br><span class="line">    last  *mspan </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mheap:当mcentral 也不够用的时候,通过 mheap 向操作系统申请。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在初始化的时候，mheap会被初始化一个全局变量mheap_。可以看到其内存布局为：</span><br><span class="line"></span><br><span class="line">+--------------+----------+-------------------------+</span><br><span class="line">| spans .......| bitmap   | arena ..................|</span><br><span class="line">+--------------+----------+-------------------------+</span><br><span class="line"></span><br><span class="line">arena是Golang中用于分配内存的连续虚拟地址区域。堆上申请的所有内存都来自arena。操作系统常见有两种做法标志内存可用：一种是用链表将所有的可用内存都串起来；另一种是使用位图来标志内存块是否可用。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="总结分配逻辑"><a href="#总结分配逻辑" class="headerlink" title="总结分配逻辑"></a>总结分配逻辑</h2><p>总结一下Golang内存分配的逻辑:</p>
<ul>
<li>object size&gt;32KB, 则直接使用mheap来分配空间；</li>
<li>object size&lt;16Byte, 则通过mcache的tiny分配器来分配；</li>
<li>object size在上面两者之间，首先尝试通过sizeclass对应的分配器分配;</li>
<li>如果mcache没有空闲的span，则向mcentral申请空闲块；</li>
<li>如果mcentral也没空闲块，则向mheap申请并进行切分；</li>
<li>如果mheap也没合适的span，则向操作系统申请。</li>
</ul>
<p><br><br><br></p>
<h1 id="指针操作-unsafe"><a href="#指针操作-unsafe" class="headerlink" title="指针操作/unsafe"></a>指针操作/unsafe</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Pointer与uintptr</p>
<ul>
<li>unsafe.Pointer:只是一个指针的类型,但是不能像C中的指针那样作计算，而只能用于转化不同类型的指针；如果unsafe.Pointer变量仍然有效,则由unsafe.Pointer变量表示的地址处的数据不会被GC回收；</li>
<li>uintptr:是可以用于指针运算的,但是无法持有对象，GC并不把uintptr当做指针，所以uintptr类型的目标会被回收。</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><blockquote>
<p>通过unsafe.Pointer来转化类型<br>在此之前提示一下这里我们说的类型的转化，是转化前后变量为同一变量，而不是这样为两个变量：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int64</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">float64</span> = <span class="keyword">float64</span>(a)</span><br><span class="line">    fmt.Println(&amp;a) <span class="comment">// 0xc42000e248</span></span><br><span class="line">    fmt.Println(&amp;b) <span class="comment">// 0xc42000e250</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们要来做一个强制的转化的话，a = float64(a),Golang会报错：cannot use float64(a) (type float64) as type int64 in assignment。</p>
<p>使用unsafe.Pointer来将T1转化为T2，一个大致的语法为<em>(</em>T2)(unsafe.Pointer(&amp;t1))<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int64</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> pn = &amp;n <span class="comment">// n的指针</span></span><br><span class="line">    <span class="keyword">var</span> pf = (*<span class="keyword">float64</span>)(unsafe.Pointer(pn)) <span class="comment">// 通过Pointer来将n的类型转为float</span></span><br><span class="line">    fmt.Println(*pf) <span class="comment">// 2.5e-323</span></span><br><span class="line">    *pf = <span class="number">3.5</span></span><br><span class="line">    fmt.Println(n) <span class="comment">// 4615063718147915776</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(pf) <span class="comment">// 0xc42007a050</span></span><br><span class="line">    fmt.Println(pn) <span class="comment">// 0xc42007a050</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子虽然没有实际的意义，但是绕过了Golang类型系统和内存安全，将一个变量的类型作了转化。</p>
<blockquote>
<p>通过uintptr来计算偏移量      </p>
</blockquote>
<p>我们可以通过增减偏移量来定位不同的成员变量<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    p1 := unsafe.Pointer(&amp;a[<span class="number">1</span>]) <span class="comment">// index为1的元素</span></span><br><span class="line">    p3 := unsafe.Pointer(<span class="keyword">uintptr</span>(p1) + <span class="number">2</span> * unsafe.Sizeof(a[<span class="number">0</span>])) <span class="comment">// 拿到index为3的指针</span></span><br><span class="line">    *(*<span class="keyword">int</span>)(p3) = <span class="number">4</span> <span class="comment">// 重新赋值</span></span><br><span class="line">    fmt.Println(a) <span class="comment">// a = [0 1 2 4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="网络-netpoller"><a href="#网络-netpoller" class="headerlink" title="网络/netpoller"></a>网络/netpoller</h1><p>所谓的netpoller,其实是Golang实利用了OS提供的非阻塞IO访问模式,并配合epll/kqueue等IO事件监控机制;<br>为了弥合OS的异步机制与Golang接口的差异,而在<code>runtime</code>上做的一层封装。以此来实现网络IO优化。</p>
<p>实际的实现(<code>epoll</code>/<code>kqueue</code>)必须定义以下函数：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span>;     //初始化轮询器</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="keyword">uintptr</span>, pd *pollDesc)</span> <span class="title">int32</span>; //为<span class="title">fd</span>和<span class="title">pd</span>启动边缘触发通知</span></span><br></pre></td></tr></table></figure>
<p>pollDesc包含了2个二进制的信号,分别负责读写goroutine的暂停,该信号的两个状态：</p>
<ul>
<li>pdReady:IO就绪通知，一个goroutine将状态置为nil来消费一个通知；</li>
<li>pdWait:一个goroutine准备暂停在信号上，但是还没有完成暂停。</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pdReady <span class="keyword">uintptr</span> = <span class="number">1</span></span><br><span class="line">    pdWait  <span class="keyword">uintptr</span> = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当一个goroutine进行io阻塞时,会去被放到等待队列。<br>这里面就关键的就是建立起文件描述符和goroutine之间的关联。<br>pollDesc结构体就是完成这个任务的。它的结构体定义如下</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">    link *pollDesc</span><br><span class="line">    lock    mutex </span><br><span class="line">    fd      <span class="keyword">uintptr</span></span><br><span class="line">    closing <span class="keyword">bool</span></span><br><span class="line">    seq     <span class="keyword">uintptr</span> </span><br><span class="line">    rg      <span class="keyword">uintptr</span> </span><br><span class="line">    rt      timer </span><br><span class="line">    rd      <span class="keyword">int64</span>   </span><br><span class="line">    wg      <span class="keyword">uintptr</span> </span><br><span class="line">    wt      timer  </span><br><span class="line">    wd      <span class="keyword">int64</span>  </span><br><span class="line">    user    <span class="keyword">uint32</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lock锁对象保护了<br><code>pollOpen,pollSetDeadline,pollUnblock和deadlineimpl</code>操作。<br>而这些操作又完全包含了对<code>seq,rt,tw</code>变量。      </p>
<blockquote>
<p>fd在PollDesc整个生命过程中都是一个常量。<br>处理<code>pollReset,pollWait,pollWaitCanceled</code>和<code>runtime.netpollready(IO就绪通知)</code>不需要用到锁<br>所以<code>closing,rg,rd,wg和wd</code>的所有操作都是一个无锁的操作。    </p>
</blockquote>
<h2 id="读取操作"><a href="#读取操作" class="headerlink" title="读取操作"></a>读取操作</h2><blockquote>
<p>当从网络连接的文件描述符读取数据时,调用system call,循环从fd.sysfd读取数据</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := fd.pd.prepareRead(fd.isFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fd.IsStream &amp;&amp; <span class="built_in">len</span>(p) &gt; maxRW &#123;</span><br><span class="line">        p = p[:maxRW]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := syscall.Read(fd.Sysfd, p)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            n = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() &#123;</span><br><span class="line">                <span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        err = fd.eofError(n, err)</span><br><span class="line">        <span class="keyword">return</span> n, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>读取的时候只处理EAGAIN类型的错误,其他错误一律返回给调用者,因为对于非阻塞的网络连接的文件描述符,如果错误是EAGAIN,说明Socket的缓冲区为空,未读取到任何数据,则调用<code>fd.pd.WaitRead</code>    </p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span> <span class="title">waitRead</span><span class="params">(isFile <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pd.wait(<span class="string">'r'</span>, isFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span> <span class="title">wait</span><span class="params">(mode <span class="keyword">int</span>, isFile <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> pd.runtimeCtx == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"waiting for unsupported file type"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    res := runtime_pollWait(pd.runtimeCtx, mode)</span><br><span class="line">    <span class="keyword">return</span> convertErr(res, isFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>res是runtime_pollWait函数返回的结果,由conevertErr函数包装后返回,<br>其中0表示io已经准备好了,1表示链接已经关闭,2表示io超时。再来看看pollWait的实现     </p>
</blockquote>
<p>调用netpollblock来判断IO是否准备好了        </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="keyword">int32</span>, waitio <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        old := *gpp</span><br><span class="line">        <span class="keyword">if</span> old == pdReady &#123;</span><br><span class="line">            *gpp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> old != <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"runtime: double wait"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.Casuintptr(gpp, <span class="number">0</span>, pdWait) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == <span class="number">0</span> &#123;</span><br><span class="line">        gopark(netpollblockcommit, unsafe.Pointer(gpp), <span class="string">"IO wait"</span>, traceEvGoBlockNet, <span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">        old := atomic.Xchguintptr(gpp, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> old &gt; pdWait &#123;</span><br><span class="line">        throw(<span class="string">"runtime: corrupted polldesc"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> old == pdReady</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回true说明IO已经准备好,返回false说明IO操作已经超时或者已经关闭。<br>否则当waitio为false,且io不出现错误或者超时才会挂起当前goroutine。<br>最后的gopark函数,就是将当前的goroutine(调用者)设置为waiting状态。</p>
<h2 id="阻塞中唤醒操作"><a href="#阻塞中唤醒操作" class="headerlink" title="阻塞中唤醒操作"></a>阻塞中唤醒操作</h2><p>goroutine的调度在sysmon中会不断地调用epoll函数,<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lastpoll := <span class="keyword">int64</span>(atomic.Load64(&amp;sched.lastpoll))</span><br><span class="line">now := nanotime()</span><br><span class="line"><span class="keyword">if</span> lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">        atomic.Cas64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(lastpoll), <span class="keyword">uint64</span>(now))</span><br><span class="line">        gp := netpoll(<span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">                   injectglist(gp)</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>netpol</code>l会根据操作系统的不同而调用epll/kqueue,寻找到IO就绪的socket文件描述符,<br>并找到这些socket文件描述符对应的轮询器中附带的信息,<br>根据这些信息将之前等待这些socket文件描述符就绪的goroutine状态修改为Grunnable。<br>执行完netpoll之后,会找到一个就绪的goroutine列表,接下来将就绪的goroutine加入到调度队列中,等待调度运行。也就是<code>injectglist(gp)</code>的作用,把g放到sched中去执行,<br>底层仍然是调用的之前在goroutine里面提到的<code>startm</code>函数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>netpoller的最终的效果就是用户层阻塞,底层非阻塞。<br>当goroutine读或写阻塞时会被放到等待队列,这个goroutine失去了运行权,<br>但并不是真正的整个系统“阻塞”于系统调用。<br>而通过后台的poller不停地poll,所有的文件描述符都被添加到了这个poller中的,<br>当某个时刻一个文件描述符准备好了,poller就会唤醒之前因它而阻塞的goroutine,于是goroutine重新运行起来。</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>不同于使用Unix系统中的select或是poll方法,Golang的netpoller查询的是能被调度的goroutine而不是那些函数指针、包含了各种状态变量的struct等,这样就不用管理这些状态,也不用重新检查函数指针等,这些都是你在传统Unix网络I/O需要操心的问题。</p>
<p><br><br><br></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="包和工具"><a href="#包和工具" class="headerlink" title="包和工具"></a>包和工具</h2><p>Go语言编译器的编译速度明显快于其他编译语言主要得益于以下三点    </p>
<ul>
<li>所有导入的包必须在每个文件开头显式声明  </li>
<li>禁止包的环状依赖,因为没有循环依赖,包的依赖关系就形成有向无环图       </li>
<li><p>包的独立编译,诱导了并发编译</p>
</li>
<li><p>编译后的包目标文件不仅仅记录包本身的导出信息,目标文件还记录包的依赖关系    </p>
</li>
</ul>
<blockquote>
<p>因此编译包的时候,编译器只需读取每个直接导入包的目标文件,而不需要遍历所有依赖的文件     </p>
</blockquote>
<h3 id="包的匿名导入"><a href="#包的匿名导入" class="headerlink" title="包的匿名导入"></a>包的匿名导入</h3><blockquote>
<p>有时候我们只是想利用导入包而产生的副作用    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">它会计算包级变量的初始化表达式和执行导入包的init初始化函数</span><br><span class="line">这时候又需要抑制&quot;unused import&quot;编译错误</span><br><span class="line">所以就需要用下划线_重命名导入的包</span><br><span class="line"></span><br><span class="line">数据库包 database/sql 也是采用了类似癿技术</span><br><span class="line">让用户可以根据自己需要选择导入必要的数据库驱动</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"image/png"</span> <span class="comment">// register PNG decoder</span></span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><h2 id="pprof搜集"><a href="#pprof搜集" class="headerlink" title="pprof搜集"></a>pprof搜集</h2><ul>
<li>pprof web端</li>
<li>pprof 手动</li>
</ul>
<blockquote>
<p>pprof 手动搜集资源消耗</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要在运行项目时，在参数中声明 -cpuprofile cpu.prof -memprofile mem.prof</span></span><br><span class="line"><span class="comment">//获取命令行入参</span></span><br><span class="line"><span class="keyword">var</span> cpuprofile = flag.String(<span class="string">"cpuprofile"</span>, <span class="string">""</span>, <span class="string">"write cpu profile `file`"</span>)</span><br><span class="line"><span class="keyword">var</span> memprofile = flag.String(<span class="string">"memprofile"</span>, <span class="string">""</span>, <span class="string">"write memory profile to `file`"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">go</span> cpuProfile()</span><br><span class="line">	<span class="comment">//程序的退出函数</span></span><br><span class="line">    quit()    </span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------	</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//结束CPU记时</span></span><br><span class="line">	log.Info(<span class="string">"停止CPU运行记录"</span>)</span><br><span class="line">	pprof.StopCPUProfile()</span><br><span class="line">	<span class="comment">//记录当前内存状况 以主协程运行 开子协程若主协程执行完 将无法记录下内存状态</span></span><br><span class="line">	memProfile()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cpuProfile</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> *cpuprofile != <span class="string">""</span> &#123;</span><br><span class="line">		f, err := os.Create(*cpuprofile)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Error(<span class="string">"创建CPU运行记录文件失败: "</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := pprof.StartCPUProfile(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Error(<span class="string">"创建CPU运行状态记录失败: "</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">memProfile</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> *memprofile != <span class="string">""</span> &#123;</span><br><span class="line">		f, err := os.Create(*memprofile)</span><br><span class="line">		<span class="keyword">defer</span> f.Close()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Error(<span class="string">"创建内存使用情况记录文件失败: "</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//runtime.GC() // 调用GC清理内存 可以查看GC后的内存使用情况</span></span><br><span class="line">		<span class="keyword">if</span> err := pprof.WriteHeapProfile(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Error(<span class="string">"获取内存使用情况失败: "</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>web搜集pprof</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	_ <span class="string">"net/http/pprof"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		http.ListenAndServe(<span class="string">"localhost:6060"</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pprof分析"><a href="#pprof分析" class="headerlink" title="pprof分析"></a>pprof分析</h2><ul>
<li>cpu性能分析</li>
<li>内存性能分析</li>
<li>阻塞分析</li>
</ul>
<h3 id="CPU性能分析"><a href="#CPU性能分析" class="headerlink" title="CPU性能分析"></a>CPU性能分析</h3><p>当 CPU 性能分析启用后，Go runtime 会每 <code>10ms</code> 就暂停以下，记录当前运行的 Goroutine 的调用堆栈及相关数据。</p>
<h3 id="内存性能分析"><a href="#内存性能分析" class="headerlink" title="内存性能分析"></a>内存性能分析</h3><p>内存性能分析则是在<strong>堆(Heap)分配</strong>的时候，记录一下调用堆栈。<em>默认512kb进行 一次采样，当我们认为数据不够细致时，可以调节采样率runtime.MemProfileRate</em>,就意味着分析器将会在每分配指定的字节数量后对内存使用情况进行取样 </p>
<p><strong>栈(Stack)分配</strong> 由于会随时释放，因此<strong>不会</strong>被内存分析所记录。</p>
<p>由于内存分析是<strong>取样</strong>方式，并且也因为其记录的<strong>是分配内存，而不是使用内存</strong>。因此使用内存性能分析工具来准确判断程序具体的内存使用是比较困难的。</p>
<h3 id="阻塞性能分析"><a href="#阻塞性能分析" class="headerlink" title="阻塞性能分析"></a>阻塞性能分析</h3><p>阻塞分析是一个很独特的分析。它有点儿类似于 CPU 性能分析，但是它所记录的是 goroutine 等待资源所花的时间。</p>
<p>阻塞分析对分析程序<strong>并发瓶颈</strong>非常有帮助。阻塞性能分析可以显示出什么时候出现了大批的 goroutine 被阻塞了。阻塞包括：</p>
<ul>
<li>发送、接受无缓冲的 channel；</li>
<li>发送给一个满缓冲的 channel，或者从一个空缓冲的 channel 接收；</li>
<li>试图获取已被另一个 go routine 锁定的 <code>sync.Mutex</code> 的锁；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rate = 1 时, 统计所有的 block event, </span></span><br><span class="line"><span class="comment">// rate &lt;=0 时，则关闭block profiling</span></span><br><span class="line"><span class="comment">// rate &gt; 1 时，为 ns 数，阻塞时间t&gt;rate的event 一定会被统计，小于rate则有t/rate 的几率被统计</span></span><br><span class="line"><span class="comment">// 参考 https://github.com/golang/go/blob/release-branch.go1.9/src/runtime/mprof.go#L397</span></span><br><span class="line">runtime.SetBlockProfileRate(<span class="number">1</span> * <span class="number">1000</span> * <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<h2 id="pprof文件分析"><a href="#pprof文件分析" class="headerlink" title="pprof文件分析"></a>pprof文件分析</h2><p>在runtime/pprof生成对应的方法后，在命令行中使用go tool pprof工具可以对profile文件进行性能分析。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> tool pprof XXX.prof #即可分析对应prof文件</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> tool pprof localhost:[port]/debug/pprof/profile #cpu性能分析</span><br><span class="line"><span class="keyword">go</span> tool pprof localhost:[port]/debug/pprof/heap	   #内存性能分析数据</span><br><span class="line"><span class="keyword">go</span> tool pprof localhost:[port]/debug/pprof/block   #阻塞性能分析</span><br><span class="line"></span><br><span class="line">进入命令行后</span><br><span class="line">top [number] #输出对应前N位的数据信息</span><br><span class="line">web #使用grapgviz生成对应svg图 </span><br><span class="line">web &gt; [name].svg #生成svg图后修改名字 存放到同级目录下</span><br><span class="line">list <span class="function"><span class="keyword">func</span> #显示耗时几个函数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#使用<span class="title">go</span>-<span class="title">torch</span>进行性能分析 <span class="title">svg</span>更好的表现了其中的关系但若想要直观看到所使用资源的占比 <span class="title">falmeGraph</span>会更为直观</span></span><br><span class="line"><span class="function"><span class="title">go</span>-<span class="title">torch</span> <span class="title">xxx</span>.<span class="title">prof</span> #生成对应火焰图 <span class="title">X</span>轴显示占用资源量 <span class="title">Y</span>轴显示调用栈深度</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>另外可用go-torch 专门针对cpu文件进行火焰图分析</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span>-torch -u http:<span class="comment">//localhost:6060 -t 30</span></span><br></pre></td></tr></table></figure>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul>
<li><a href="http://legendtkl.com/2017/04/02/golang-alloc/" target="_blank" rel="noopener">Go内存管理</a></li>
</ul>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2018/03/11/go-study/';
        this.page.title = 'Go学习笔记';
        this.page.identifier = '2018/03/11/go-study/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
