<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>区块链Eth,SkyCoin解析 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="区块链相关见解资料摘录
概念区块链简史

区块链能做什么
数字货币  

比特币、莱特币、以太币等

区块链应用

供应链管理、防伪、溯源、信息共享、社会诚信等

游戏 

CryptoKitties(加密猫)、 ETHERBOTS(以太机器人)、 EtherCraft(以太飞船)等
早期应用1990 年 8 月,Bellcore(1984 年由 AT&amp;amp;T 拆分而来的研究机构)的 Stuart Haber 和 W. Scott Stornetta 在论文《How to Time-Stam">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java后端</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C嵌入式</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Go云原生</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">Linux安全</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">Win安全</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">大数据处理</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Net/">Net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nosql/">Nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rust/">Rust</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/嵌入式/">嵌入式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概念"><span class="toc-number">1.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#区块链简史"><span class="toc-number">1.1.</span> <span class="toc-text">区块链简史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#区块链能做什么"><span class="toc-number">1.2.</span> <span class="toc-text">区块链能做什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#早期应用"><span class="toc-number">1.2.1.</span> <span class="toc-text">早期应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#区块链是什么"><span class="toc-number">1.3.</span> <span class="toc-text">区块链是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本原理"><span class="toc-number">1.3.1.</span> <span class="toc-text">基本原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#区块链基本特征"><span class="toc-number">1.4.</span> <span class="toc-text">区块链基本特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#区块链的基本名词"><span class="toc-number">1.5.</span> <span class="toc-text">区块链的基本名词</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#交易"><span class="toc-number">1.5.1.</span> <span class="toc-text">交易</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区块"><span class="toc-number">1.5.2.</span> <span class="toc-text">区块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#区块链的基本流程"><span class="toc-number">1.6.</span> <span class="toc-text">区块链的基本流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#交易-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">交易</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区块-1"><span class="toc-number">1.6.2.</span> <span class="toc-text">区块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SkyCoin解析"><span class="toc-number">2.</span> <span class="toc-text">SkyCoin解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#网络相关-daeman-pool连接池"><span class="toc-number">2.1.</span> <span class="toc-text">网络相关:daeman/pool连接池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Config-amp-amp-New"><span class="toc-number">2.1.1.</span> <span class="toc-text">Config &amp;&amp; New</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pool-Run"><span class="toc-number">2.1.2.</span> <span class="toc-text">Pool Run</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#processStrand"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">processStrand</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sendLoop"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">sendLoop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readLoop"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">readLoop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#receiveMessage"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">receiveMessage</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#区块相关-coin-Block"><span class="toc-number">2.2.</span> <span class="toc-text">区块相关: coin/Block</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#区块数据结构"><span class="toc-number">2.2.1.</span> <span class="toc-text">区块数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Block新建过程"><span class="toc-number">2.2.2.</span> <span class="toc-text">Block新建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区块链相关结构"><span class="toc-number">2.2.3.</span> <span class="toc-text">区块链相关结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#交易事务相关-coin-transaction"><span class="toc-number">2.3.</span> <span class="toc-text">交易事务相关 coin/transaction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#交易结构"><span class="toc-number">2.3.1.</span> <span class="toc-text">交易结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关键方法"><span class="toc-number">2.3.2.</span> <span class="toc-text">关键方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#未花费的交易UTXO-coin-outputs"><span class="toc-number">2.4.</span> <span class="toc-text">未花费的交易UTXO coin/outputs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UTXO结构"><span class="toc-number">2.4.1.</span> <span class="toc-text">UTXO结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Address地址-cipher-address"><span class="toc-number">2.5.</span> <span class="toc-text">Address地址 cipher/address</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本结构"><span class="toc-number">2.5.1.</span> <span class="toc-text">基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Address制造过程"><span class="toc-number">2.5.2.</span> <span class="toc-text">Address制造过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#过程分析"><span class="toc-number">2.6.</span> <span class="toc-text">过程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建交易过程"><span class="toc-number">2.6.1.</span> <span class="toc-text">创建交易过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#验证流程"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">验证流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组装流程"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">组装流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#广播交易流程"><span class="toc-number">2.6.2.</span> <span class="toc-text">广播交易流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接受交易造区块流程"><span class="toc-number">2.6.3.</span> <span class="toc-text">接受交易造区块流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#节点发现过程"><span class="toc-number">2.6.4.</span> <span class="toc-text">节点发现过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环处理过程"><span class="toc-number">2.6.5.</span> <span class="toc-text">循环处理过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加密过程"><span class="toc-number">2.6.6.</span> <span class="toc-text">加密过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Eth"><span class="toc-number">3.</span> <span class="toc-text">Eth</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#客户端"><span class="toc-number">3.1.</span> <span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#交互式控制台"><span class="toc-number">3.2.</span> <span class="toc-text">交互式控制台</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参数说明"><span class="toc-number">3.3.</span> <span class="toc-text">参数说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步"><span class="toc-number">3.4.</span> <span class="toc-text">同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#私链"><span class="toc-number">3.4.1.</span> <span class="toc-text">私链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#操作"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全量同步"><span class="toc-number">3.4.2.</span> <span class="toc-text">全量同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#操作-1"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#轻量级同步"><span class="toc-number">3.4.3.</span> <span class="toc-text">轻量级同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#操作-2"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速同步"><span class="toc-number">3.4.4.</span> <span class="toc-text">快速同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#操作-3"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web3"><span class="toc-number">3.4.5.</span> <span class="toc-text">Web3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件"><span class="toc-number">3.4.6.</span> <span class="toc-text">事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-number">3.5.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础结构"><span class="toc-number">3.5.1.</span> <span class="toc-text">基础结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Trie树-字典树"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">Trie树,字典树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Patricia-Trie树"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">Patricia Trie树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Merkle树"><span class="toc-number">3.5.1.3.</span> <span class="toc-text">Merkle树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Merkle-Patricia-Tree树"><span class="toc-number">3.5.1.4.</span> <span class="toc-text">Merkle Patricia Tree树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#key编码"><span class="toc-number">3.5.1.4.1.</span> <span class="toc-text">key编码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Raw编码"><span class="toc-number">3.5.1.4.2.</span> <span class="toc-text">Raw编码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Hex编码"><span class="toc-number">3.5.1.4.3.</span> <span class="toc-text">Hex编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区块结构"><span class="toc-number">3.5.2.</span> <span class="toc-text">区块结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#交易树"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">交易树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#收据树"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">收据树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#状态树"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">状态树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络"><span class="toc-number">3.6.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#网络映射"><span class="toc-number">3.6.1.</span> <span class="toc-text">网络映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP打洞"><span class="toc-number">3.6.2.</span> <span class="toc-text">UDP打洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#节点协作"><span class="toc-number">3.6.3.</span> <span class="toc-text">节点协作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kad协议"><span class="toc-number">3.6.4.</span> <span class="toc-text">Kad协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#拓扑结构"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">拓扑结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#距离算法"><span class="toc-number">3.6.4.2.</span> <span class="toc-text">距离算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#路由算法"><span class="toc-number">3.6.4.3.</span> <span class="toc-text">路由算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#K桶"><span class="toc-number">3.6.4.3.1.</span> <span class="toc-text">K桶</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#节点搜索"><span class="toc-number">3.6.4.3.2.</span> <span class="toc-text">节点搜索</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#共识算法"><span class="toc-number">4.</span> <span class="toc-text">共识算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#POW"><span class="toc-number">4.1.</span> <span class="toc-text">POW</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POS"><span class="toc-number">4.2.</span> <span class="toc-text">POS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#流程"><span class="toc-number">4.2.1.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺点"><span class="toc-number">4.2.2.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Casper"><span class="toc-number">4.2.3.</span> <span class="toc-text">Casper</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何工作"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">如何工作?</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            区块链Eth,SkyCoin解析
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2018/09/11/blockchain/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-09-11T15:33:57.000Z" itemprop="datePublished">2018-09-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/eth/">eth</a>, <a class="article-tag-link" href="/tags/skycoin/">skycoin</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>区块链相关见解资料摘录<br><a id="more"></a></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="区块链简史"><a href="#区块链简史" class="headerlink" title="区块链简史"></a>区块链简史</h2><img src="http://www.plantuml.com/plantuml/svg/JP71KjfG58RtFWKFa0MbuqmhExhkjlkCuzIC3dGqtNGLH4rCW0HBWOgfsAfaW2HqYfBS03wCzzmJti9Bq4mtTt7l-V__-yyzbCK3UMChbys-Wt2oHGENNOxYyW3CHdpjn1vXBVL9qPdVnBCGWZAVKB1VmwCG_92VU76CpNjmBQoFbse3_qKONJqfXi1C2rH2oMbXlxIzzs5Nb8hinvZLF8o-ir_7-IJp_IepzSPv0wDBvlw1cKa37ScZWAFHAl1CurGmKnYnmFlDj2aE_JMXa1ApQei7WjQbGGkg1EmscFgBVjJSpD9Wa2ObwM-oIUDv5-VjfLgD5mjq320cD3hOTBYC1cggY2Sk3SSqce8oostYeWud5TwTwSFOSkYimoezq89y9fCuvrRE1KdUBad5p4Vni_XDAkwiYwsnNxXybQyNXps1HWP6jJGDpglWdsAl3EvTFEdp6u7PH_3ONgdlfvGG6XhS0CP_MSS7gyxiMqv3erku6O2jyrVK7bvftYOzNz_uXg1lS8jFaYpkItkPmbTvvq0gSci8Alp3_fkq-URnvnmlF1hU2M3ve3jyOdaTOjVBRnpAfI_F">
<p><br></p>
<h2 id="区块链能做什么"><a href="#区块链能做什么" class="headerlink" title="区块链能做什么"></a>区块链能做什么</h2><blockquote>
<p>数字货币  </p>
</blockquote>
<p>比特币、莱特币、以太币等</p>
<blockquote>
<p>区块链应用</p>
</blockquote>
<p>供应链管理、防伪、溯源、信息共享、社会诚信等</p>
<blockquote>
<p>游戏 </p>
</blockquote>
<p>CryptoKitties(加密猫)、 ETHERBOTS(以太机器人)、 EtherCraft(以太飞船)等</p>
<h3 id="早期应用"><a href="#早期应用" class="headerlink" title="早期应用"></a>早期应用</h3><p>1990 年 8 月,Bellcore(1984 年由 AT&amp;T 拆分而来的研究机构)的 Stuart Haber 和 W. Scott Stornetta 在论文《How to Time-Stamp a Digital Document》中就提出利用链式结构来解决防篡改问题,其中新生成的时间证明需要包括之前证明的 Hash 值。这可以被认为是区块链结构的最早雏形。</p>
<p>后来,2005 年 7 月,在 Git 等开源软件中,也使用了类似区块链结构的机制来记录提交历史。</p>
<p>区块链结构最早的大规模应用出现在 2009 年初上线的比特币项目中。</p>
<p>在无集中式管理的情况下,比特币网络持续稳定,支持了海量的交易记录,并且从未出现严重的漏洞,引发了广泛关注。这些都与区块链结构自身强校验的特性密切相关。</p>
<h2 id="区块链是什么"><a href="#区块链是什么" class="headerlink" title="区块链是什么"></a>区块链是什么</h2><blockquote>
<p>区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。</p>
</blockquote>
<p><img src="/2018/09/11/blockchain/image-17.png" width="500px"></p>
<ul>
<li>1.狭义来讲:区块链是一种按照时间顺序将数据区块以顺序相连的方式组合成的一种链式数据结构,并以密码学方式保证的不可篡改和不可伪造的分布式账本。</li>
<li>2.广义来讲:区块链技术是利用块链式数据结构来验证与存储数据、利用分布式节点共识算法来生成和更新数据、利用密码学的方式保证数据传输和访问的安全、利用由自动化脚本代码组成的智能合约来编程和操作数据的一种全新的分布式基础架构与计算方式。</li>
</ul>
<blockquote>
<p>区块与交易的细节</p>
</blockquote>
<p><img src="/2018/09/11/blockchain/image-20.png" width="500px"><br><img src="/2018/09/11/blockchain/image-19.jpg" width="500px"></p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>区块链的基本原理理解起来并不复杂。首先来看三个基本概念：</p>
<ul>
<li>交易(Transaction)：一次对账本的操作,导致账本状态的一次改变,如添加一条转账记录；</li>
<li>区块(Block)：记录一段时间内发生的所有交易和状态结果等,是对当前账本状态的一次共识；</li>
<li>链(Chain)：由区块按照发生顺序串联而成,是整个账本状态变化的日志记录。</li>
</ul>
<p>如果把区块链系统作为一个状态机,则每次交易意味着一次状态改变；生成的区块,就是参与者对其中交易导致状态改变结果的共识。</p>
<p>区块链的目标是实现一个分布的数据记录账本,这个账本只允许添加、不允许删除。</p>
<p>账本底层的基本结构是一个线性的链表。链表由一个个“区块”串联组成(如下图所示),后继区块中记录前导区块的哈希(Hash)值。</p>
<p>某个区块(以及块里的交易)是否合法,可通过计算哈希值的方式进行快速检验。</p>
<p>网络中节点可以提议添加一个新的区块,但必须经过共识机制来对区块达成确认。</p>
<p><img src="/2018/09/11/blockchain/image-18.png" width="500px"></p>
<p><br></p>
<h2 id="区块链基本特征"><a href="#区块链基本特征" class="headerlink" title="区块链基本特征"></a>区块链基本特征</h2><blockquote>
<p>1.去中心化</p>
</blockquote>
<p>由大量节点共同组成的一个点对点网络,任一节点的权利和义务都是均等的,不存在中心化的硬件或管理机构。</p>
<blockquote>
<p>2.基于共识建立信任</p>
</blockquote>
<p>它运用一套基于共识的数学算法,在机器之间建立“信任”网络,从而通过技术背书而非中心化信用机构来建立信用。</p>
<blockquote>
<p>3.信息不可篡改</p>
</blockquote>
<p>区块链是基于时间戳形成不可篡改、不可伪造的数据库,存储了所有交易历史,并可追本溯源逐笔验证。</p>
<p>随之带来的业务特性将可能包括：</p>
<ul>
<li>可信任性:区块链技术可以提供天然可信的分布式账本平台,不需要额外第三方中介机构参与;</li>
<li>降低成本:跟传统技术相比,区块链技术可能通过自动化合约执行带来更快的交易,同时降低维护成本;</li>
<li>增强安全:区块链技术将有利于安全、可靠的审计管理和账目清算,减少犯罪风险。</li>
</ul>
<p><br></p>
<h2 id="区块链的基本名词"><a href="#区块链的基本名词" class="headerlink" title="区块链的基本名词"></a>区块链的基本名词</h2><h3 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h3><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p><br> </p>
<h2 id="区块链的基本流程"><a href="#区块链的基本流程" class="headerlink" title="区块链的基本流程"></a>区块链的基本流程</h2><h3 id="交易-1"><a href="#交易-1" class="headerlink" title="交易"></a>交易</h3><blockquote>
<p>交易提交-验证-广播</p>
</blockquote>
<img src="http://www.plantuml.com/plantuml/svg/RP3DIW9H5CVtzoakjYbeDYrR26Cl48GBbrDUQM2Q4Rr4IvM4hCainIId3p59XD62ibJIb_5--1RDpBsZ89tT-Vhzp_ySwqa4KvQ53wqpW7Li83WVlz96bNxbMVTAeJSLBrSMFPiFyWePpUYT2xGZR6LWXDMwzE8x0hKiJC2D34e2a52Y4MAFoUFzeZhbbmLM6Ad1W0ft1KhGVOH-gc44LQ0gKQyBQRb3QqFP3clj77tkY1fxEATkcxNwDFS6W6RWyD2W2A2CSBFvIUllrEbvFTwNglJZPJDk7gIHYVSjozYEctkMcT8p9twsjKJuxFHEcltUieaZJ12tGPpkSa8AhLkD1LPZdhnub3GJRY0ZYzR1yv_h_zc-2J8jak9mFgcBMJvxyfv4AcK-Q_AMBUYaObEtiz8mao3GaOwT4XyCm0gRy7zJgfBcappEN_W3">
<p><br></p>
<h3 id="区块-1"><a href="#区块-1" class="headerlink" title="区块"></a>区块</h3><blockquote>
<p>区块打包-验证-广播 </p>
</blockquote>
<img src="http://www.plantuml.com/plantuml/svg/jPHHRz9G5CVV-obkzgIn_G8yaBI-BF5b2TcJyG57vuZOcj54ZJ61QQMoeWJOO30LJ153GjdY9BHJ-3ASs_PRUCibBGndoD0-DBtttFC_v_n_DzrB9aIqAylAG_aveoILb8X0j-5Z5V_8EjyEEVok3BhAULtTxMSviCQur6EO3Nh6Au_S_85pOF4RA9v6FEAYv1L1ODPnTO0Bd_1frscPhcbCR0FNolYyUNzRkYjBkydz9rkod7hWrD_G41CcQmO-xj6wD4OEuSmbbFJ9iE2-_kKEL7USentueTCC61qmBI_t8LJ1JGiNJ7TyCh4RL0L-Pg1pI7LfyjpfkLtIEOkRBJBnhEbQ7ufVeQZXxqTXnYnsT4QgE9NFM2jEXfd9i8kFpqXFL_LfRNVS0BKDwhdRV-kOLQB7pYyYM_8pyWNv1jrboSBxKeDHrUbLS4kRjwW1bxRJ6q6nG4j5wBnq0SO5b3KOwflnzDwc64-8-tTcTdMoNgajfEITnp5nvvxu0l9D8lDokiF6aezUBQ4LfcW5lxHmGxHXyZfe0vMLq8QdLqKRPAo4Dfpfdw2Ti-Z_eOsd52HGgg1gVZyvczP7329Fw5dZWWoxJFZMjXHxAagApvTTe7rxAl2Nk-DVMu6BylGFCZFHpmakDVt52A752r7yleqhWp3AuhpbdHWyQ7LA-Bgy6umYfj8YulzerFhYWO20Y0BFHOKbIm8Er19-SRIGqjGI_gebmZMMh4LNb18Cm_m6">
<p><br><br><br></p>
<h1 id="SkyCoin解析"><a href="#SkyCoin解析" class="headerlink" title="SkyCoin解析"></a>SkyCoin解析</h1><ul>
<li>Coin:区块/未消费交易/事务核心逻辑</li>
<li>Cipher:加密相关工具</li>
<li>Consensus:共识</li>
<li>Daemon:核心处理器/引擎</li>
<li>Util:工具类</li>
<li>Api:http相关接口</li>
<li>Visor:所有可用操作,操作器   </li>
</ul>
<blockquote>
<p>相关节点操作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">M-&gt;Slave</span><br><span class="line">↓</span><br><span class="line">Slave</span><br><span class="line"></span><br><span class="line">Node#Slave用来接收验证区块和交易的节点,需要配置DefaultConnection可信任节点,从而获取到其他peers,否则为单个节点无法通信</span><br><span class="line">Node#Master用来打包交易生产区块的节点</span><br><span class="line">Node#Slave想要成为Master,必须有私钥</span><br><span class="line"></span><br><span class="line">Slave -&gt; 接收交易 -&gt; 验证交易 -&gt; Update(UnSpentPool,UnConfirmPool) -&gt; 广播交易</span><br><span class="line">Master -&gt; 接收交易 -&gt; 验证交易 -&gt; 产区块打包交易 -&gt; Update(UnSpentPool,UnConfirmPool) -&gt; 广播区块</span><br><span class="line">Slave -&gt; 验证区块 -&gt; 验证交易合法 -&gt; Update(UnSpentPool,UnConfirmPool) -&gt; 广播区块</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="网络相关-daeman-pool连接池"><a href="#网络相关-daeman-pool连接池" class="headerlink" title="网络相关:daeman/pool连接池"></a>网络相关:daeman/pool连接池</h2><h3 id="Config-amp-amp-New"><a href="#Config-amp-amp-New" class="headerlink" title="Config &amp;&amp; New"></a>Config &amp;&amp; New</h3><blockquote>
<p>connectionPool:连接池    </p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewPoolConfig creates pool config</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPoolConfig</span><span class="params">()</span> <span class="title">PoolConfig</span></span> &#123;</span><br><span class="line">    <span class="comment">//defIdleLimit := time.Minute</span></span><br><span class="line">    <span class="keyword">return</span> PoolConfig&#123;</span><br><span class="line">        port:                              <span class="number">6677</span>,</span><br><span class="line">        address:                           <span class="string">""</span>,</span><br><span class="line">        DialTimeout:                       time.Second * <span class="number">30</span>,</span><br><span class="line">        MessageHandlingRate:               time.Millisecond * <span class="number">50</span>,</span><br><span class="line">        PingRate:                          <span class="number">5</span> * time.Second,</span><br><span class="line">        IdleLimit:                         <span class="number">60</span> * time.Second,</span><br><span class="line">        IdleCheckRate:                     <span class="number">1</span> * time.Second,</span><br><span class="line">        ClearStaleRate:                    <span class="number">1</span> * time.Second,</span><br><span class="line">        EventChannelSize:                  <span class="number">4096</span>,</span><br><span class="line">        MaxConnections:                    <span class="number">128</span>,</span><br><span class="line">        MaxDefaultPeerOutgoingConnections: <span class="number">1</span>,</span><br><span class="line">        DefaultPeerConnections:            <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pool maintains config and pool</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    Config PoolConfig</span><br><span class="line">    Pool   *gnet.ConnectionPool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewPool creates pool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPool</span><span class="params">(cfg PoolConfig, d *Daemon)</span> *<span class="title">Pool</span></span> &#123;</span><br><span class="line">    gnetCfg := gnet.NewConfig()</span><br><span class="line">    gnetCfg.DialTimeout = cfg.DialTimeout</span><br><span class="line">    gnetCfg.Port = <span class="keyword">uint16</span>(cfg.port)</span><br><span class="line">    gnetCfg.Address = cfg.address</span><br><span class="line">    gnetCfg.ConnectCallback = d.onGnetConnect</span><br><span class="line">    gnetCfg.DisconnectCallback = d.onGnetDisconnect</span><br><span class="line">    gnetCfg.MaxConnections = cfg.MaxConnections</span><br><span class="line">    gnetCfg.MaxDefaultPeerOutgoingConnections = cfg.MaxDefaultPeerOutgoingConnections</span><br><span class="line">    gnetCfg.DefaultPeerConnections = cfg.DefaultPeerConnections</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;Pool&#123;</span><br><span class="line">        Config: cfg,</span><br><span class="line">        Pool:   gnet.NewConnectionPool(gnetCfg, d),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConnectionPool</span><span class="params">(c Config, state <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">ConnectionPool</span></span> &#123;</span><br><span class="line">    pool := &amp;ConnectionPool&#123;</span><br><span class="line">        Config:                 c,</span><br><span class="line">        pool:                   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*Connection),</span><br><span class="line">        addresses:              <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Connection),</span><br><span class="line">        defaultPeerConnections: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">        SendResults:            <span class="built_in">make</span>(<span class="keyword">chan</span> SendResult, c.SendResultsSize),</span><br><span class="line">        messageState:           state,</span><br><span class="line">        quit:                   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">        done:                   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">        strandDone:             <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">        reqC:                   <span class="built_in">make</span>(<span class="keyword">chan</span> strand.Request),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *ConnectionPool)</span> <span class="title">NewConnection</span><span class="params">(conn net.Conn, solicited <span class="keyword">bool</span>)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">    a := conn.RemoteAddr().String()</span><br><span class="line">    <span class="keyword">var</span> nc *Connection</span><br><span class="line">    <span class="keyword">if</span> err := pool.strand(<span class="string">"NewConnection"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := pool.addresses[a]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"Already connected to %s"</span>, a)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> _, ok := pool.Config.DefaultPeerConnections[a]; ok &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(pool.defaultPeerConnections) &gt;= pool.Config.MaxDefaultPeerOutgoingConnections &amp;&amp; solicited &#123;</span><br><span class="line">                <span class="keyword">return</span> ErrMaxDefaultConnectionsReached</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pool.defaultPeerConnections[a] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool.connID++</span><br><span class="line">        nc = NewConnection(pool, pool.connID, conn, pool.Config.ConnectionWriteQueueSize, solicited)</span><br><span class="line"></span><br><span class="line">        pool.pool[nc.ID] = nc</span><br><span class="line">        pool.addresses[a] = nc</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码<br>由此新建相关的连接    </p>
</blockquote>
<h3 id="Pool-Run"><a href="#Pool-Run" class="headerlink" title="Pool Run"></a>Pool Run</h3><blockquote>
<p>ConnectionPool 主循环<br>loop中每个连接进来都会进行Connection accept相关的连接,并处理相关conn   </p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *ConnectionPool)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(pool.done)</span><br><span class="line">    <span class="keyword">defer</span> logger.Info(<span class="string">"Connection pool closed"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置相关的地址和端口</span></span><br><span class="line">    addr := fmt.Sprintf(<span class="string">"%s:%v"</span>, pool.Config.Address, pool.Config.Port)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool.listener = ln</span><br><span class="line"></span><br><span class="line">    pool.wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> pool.wg.Done()</span><br><span class="line">        <span class="comment">//处理Strand</span></span><br><span class="line">        pool.processStrand()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := ln.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-pool.quit:</span><br><span class="line">                <span class="keyword">break</span> loop</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                logger.Error(err)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool.wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> pool.wg.Done()</span><br><span class="line">            <span class="keyword">if</span> err := pool.handleConnection(conn, <span class="literal">false</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                logger.Errorf(<span class="string">"pool.handleConnection error: %v"</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    pool.wg.Wait()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *ConnectionPool)</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn, solicited <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> logger.Debugf(<span class="string">"Connection %s closed"</span>, conn.RemoteAddr())</span><br><span class="line">    addr := conn.RemoteAddr().String()</span><br><span class="line"></span><br><span class="line">    c, err := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(c *Connection, err error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> closeErr := conn.Close(); closeErr != <span class="literal">nil</span> &#123;</span><br><span class="line">                    logger.Errorf(<span class="string">"conn.Close() %s error: %v"</span>, addr, closeErr)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        exist, err := pool.IsConnExist(addr)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> exist &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">"Connection %s already exists"</span>, addr)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c, err = pool.NewConnection(conn, solicited)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">"Create connection to %s failed: %v"</span>, addr, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c, err</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pool.Config.ConnectCallback != <span class="literal">nil</span> &#123;</span><br><span class="line">        pool.Config.ConnectCallback(c.Addr(), solicited)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgC := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>, <span class="number">32</span>)</span><br><span class="line">    errC := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    qc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">if</span> err := pool.readLoop(c, msgC, qc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            errC &lt;- err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">if</span> err := pool.sendLoop(c, pool.Config.WriteTimeout, qc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            errC &lt;- err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        elapser := elapse.NewElapser(receiveMessageDurationThreshold, logger)</span><br><span class="line">        <span class="keyword">defer</span> elapser.CheckForDone()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> msg, ok := &lt;-msgC:</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                elapser.Register(fmt.Sprintf(<span class="string">"pool.receiveMessage address=%s"</span>, addr))</span><br><span class="line">                <span class="keyword">if</span> err := pool.receiveMessage(c, msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    errC &lt;- err</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                elapser.CheckForDone()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-pool.quit:</span><br><span class="line">        <span class="keyword">if</span> err := conn.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            logger.Errorf(<span class="string">"conn.Close() %s error: %v"</span>, addr, err)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> err = &lt;-errC:</span><br><span class="line">        <span class="keyword">if</span> err := pool.Disconnect(c.Addr(), err); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            logger.Errorf(<span class="string">"Disconnect %s failed: %v"</span>, addr, err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.Debugf(<span class="string">"Disconnected from %s"</span>, addr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(qc)</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码引出以下几类循环loop    </p>
</blockquote>
<ul>
<li>processStrand 循环信道消息处理  </li>
<li>sendLoop 循环发送消息信道处理  </li>
<li>readLoop 循环读取信息信道处理   </li>
<li>pool.receiveMessage 循环消息接受机制    </li>
</ul>
<h4 id="processStrand"><a href="#processStrand" class="headerlink" title="processStrand"></a>processStrand</h4><blockquote>
<p>处理Pool级别的Strand信道处理    </p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *ConnectionPool)</span> <span class="title">processStrand</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(pool.strandDone)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-pool.quit:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> req := &lt;-pool.reqC:</span><br><span class="line">            <span class="keyword">if</span> err := req.Func(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                logger.Errorf(<span class="string">"req.Func %s failed: %v"</span>, req.Name, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//其中pool.reqC为reqC chan strand.Request</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Func <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function">//用于<span class="title">strand</span>.<span class="title">Request</span>&lt;- 处理<span class="title">pool</span>级别的<span class="title">req</span>.<span class="title">Func</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h4 id="sendLoop"><a href="#sendLoop" class="headerlink" title="sendLoop"></a>sendLoop</h4><p>监听conn.WriteQueue的chan,如果有线程往conn.WriteQueue丢入msg,则直接被取出并sendMessage<br>然后通过网络net.write信息后封装newSendResult将发送结果丢入chan,由daemon的loop中处理    </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *ConnectionPool)</span> <span class="title">sendLoop</span><span class="params">(conn *Connection, timeout time.Duration, qc <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    elapser := elapse.NewElapser(sendLoopDurationThreshold, logger)</span><br><span class="line">    <span class="keyword">defer</span> elapser.CheckForDone()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        elapser.CheckForDone()</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-pool.quit:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-qc:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> m := &lt;-conn.WriteQueue:</span><br><span class="line">            elapser.Register(fmt.Sprintf(<span class="string">"conn.WriteQueue address=%s"</span>, conn.Addr()))</span><br><span class="line">            <span class="keyword">if</span> m == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            err := sendMessage(conn.Conn, m, timeout)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> err := pool.updateLastSent(conn.Addr(), Now()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    logger.Warningf(<span class="string">"updateLastSent(%s) failed"</span>, conn.Addr())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sr := newSendResult(conn.Addr(), m, err)</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-qc:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">case</span> pool.SendResults &lt;- sr:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                logger.Warningf(<span class="string">"SendResults queue full address=%s"</span>, conn.Addr())</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="readLoop"><a href="#readLoop" class="headerlink" title="readLoop"></a>readLoop</h4><p>监听网络上的数据,一旦有数据就会丢入msgChan,msgChan又是一个chan,后期转交给pool.receiveMessage处理    </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *ConnectionPool)</span> <span class="title">readLoop</span><span class="params">(conn *Connection, msgChan <span class="keyword">chan</span> []<span class="keyword">byte</span>, qc <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(msgChan)</span><br><span class="line">    <span class="comment">// read data from connection</span></span><br><span class="line">    reader := bufio.NewReader(conn.Conn)</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    elapser := elapse.NewElapser(readLoopDurationThreshold, logger)</span><br><span class="line">    sendInMsgChanElapser := elapse.NewElapser(sendInMsgChanDurationThreshold, logger)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> elapser.CheckForDone()</span><br><span class="line">    <span class="keyword">defer</span> sendInMsgChanElapser.CheckForDone()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        elapser.Register(fmt.Sprintf(<span class="string">"readLoop address=%s"</span>, conn.Addr()))</span><br><span class="line">        deadline := time.Time&#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> pool.Config.ReadTimeout != <span class="number">0</span> &#123;</span><br><span class="line">            deadline = time.Now().Add(pool.Config.ReadTimeout)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := conn.Conn.SetReadDeadline(deadline); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ErrDisconnectSetReadDeadlineFailed</span><br><span class="line">        &#125;</span><br><span class="line">        data, err := readData(reader, buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> data == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write data to buffer</span></span><br><span class="line">        <span class="keyword">if</span> _, err := conn.Buffer.Write(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// decode data</span></span><br><span class="line">        datas, err := decodeData(conn.Buffer, pool.Config.MaxMessageLength)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, d := <span class="keyword">range</span> datas &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-qc:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-pool.quit:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">case</span> msgChan &lt;- d:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> errors.New(<span class="string">"readLoop msgChan is closed or full"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sendInMsgChanElapser.CheckForDone()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="receiveMessage"><a href="#receiveMessage" class="headerlink" title="receiveMessage"></a>receiveMessage</h4><p>它会一直在chan监听msg到来,一旦有msg到来就会丢入receiveMessage,<br>至此convertToMessage会将msg转换成专业的Message信息去处理,<br>每个msg数据前都有msgID,通过msssageIdReverseMap映射相关的Message种类,<br>最后再根据反射Reflect.new(种类)实例相关的Message,<br>最后使用Message#Handler方法,例如PingMessage    </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ping *PingMessage)</span> <span class="title">Handle</span><span class="params">(mc *gnet.MessageContext, daemon <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ping.c = mc</span><br><span class="line">    <span class="keyword">return</span> daemon.(*Daemon).recordMessageEvent(ping, mc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dm *Daemon)</span> <span class="title">recordMessageEvent</span><span class="params">(m AsyncMessage, c *gnet.MessageContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    dm.messageEvents &lt;- MessageEvent&#123;m, c&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接通过Daemon制造MessageEvent,Message被包裹在MessageEvent内,<br>在Daemon的loop主循环中处理MessageEvent,最终实则使用了Message#Process     </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> m := &lt;-dm.messageEvents:</span><br><span class="line">    elapser.Register(<span class="string">"dm.messageEvents"</span>)</span><br><span class="line">    <span class="keyword">if</span> dm.Config.DisableNetworking &#123;</span><br><span class="line">        logger.Error(<span class="string">"There should be no message events"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    dm.processMessageEvent(m)</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dm *Daemon)</span> <span class="title">processMessageEvent</span><span class="params">(e MessageEvent)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dm.needsIntro(e.Context.Addr) &#123;</span><br><span class="line">        _, isIntro := e.Message.(*IntroductionMessage)</span><br><span class="line">        <span class="keyword">if</span> !isIntro &#123;</span><br><span class="line">            dm.Pool.Pool.Disconnect(e.Context.Addr, ErrDisconnectNoIntroduction)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    e.Message.Process(dm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下为Message大致种类     </p>
<p>以下为主体代码    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">go func() &#123;</span><br><span class="line">    defer wg.Done()</span><br><span class="line">    elapser := elapse.NewElapser(receiveMessageDurationThreshold, logger)</span><br><span class="line">    defer elapser.CheckForDone()</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case msg, ok := &lt;-msgC:</span><br><span class="line">            if !ok &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            elapser.Register(fmt.Sprintf(&quot;pool.receiveMessage address=%s&quot;, addr))</span><br><span class="line">            if err := pool.receiveMessage(c, msg); err != nil &#123;</span><br><span class="line">                errC &lt;- err</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            elapser.CheckForDone()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">func (pool *ConnectionPool) receiveMessage(c *Connection, msg []byte) error &#123;</span><br><span class="line">    m, err := convertToMessage(c.ID, msg, pool.Config.DebugPrint)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    if err := pool.updateLastRecv(c.Addr(), Now()); err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    return m.Handle(NewMessageContext(c), pool.messageState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区块相关-coin-Block"><a href="#区块相关-coin-Block" class="headerlink" title="区块相关: coin/Block"></a>区块相关: coin/Block</h2><h3 id="区块数据结构"><a href="#区块数据结构" class="headerlink" title="区块数据结构"></a>区块数据结构</h3><ul>
<li>Block 总区块体</li>
<li>HashPair 哈希对  </li>
<li>BlockHeader 区块头   </li>
<li>BlockBody 区块体  </li>
<li>SignedBlock 加签区块  </li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block represents the block struct</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Head BlockHeader</span><br><span class="line">    Body BlockBody</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// HashPair including current block hash and previous block hash.</span></span><br><span class="line"><span class="keyword">type</span> HashPair <span class="keyword">struct</span> &#123;</span><br><span class="line">    Hash    cipher.SHA256</span><br><span class="line">    PreHash cipher.SHA256</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BlockHeader records the block header</span></span><br><span class="line"><span class="keyword">type</span> BlockHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Version <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    Time  <span class="keyword">uint64</span></span><br><span class="line">    BkSeq <span class="keyword">uint64</span> <span class="comment">// Increment every block</span></span><br><span class="line">    Fee   <span class="keyword">uint64</span> <span class="comment">// Fee in block</span></span><br><span class="line"></span><br><span class="line">    PrevHash cipher.SHA256 <span class="comment">// Hash of header of previous block</span></span><br><span class="line">    BodyHash cipher.SHA256 <span class="comment">// 默克尔树hash</span></span><br><span class="line"></span><br><span class="line">    UxHash cipher.SHA256 <span class="comment">// XOR of sha256 of elements in unspent output set</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BlockBody represents the block body</span></span><br><span class="line"><span class="keyword">type</span> BlockBody <span class="keyword">struct</span> &#123;</span><br><span class="line">    Transactions Transactions</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SignedBlock signed block</span></span><br><span class="line"><span class="keyword">type</span> SignedBlock <span class="keyword">struct</span> &#123;</span><br><span class="line">    Block</span><br><span class="line">    Sig cipher.Sig <span class="comment">//cipher.SignHash(Block.HashHeader(), genSecret) 以上是Sig的由来     </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默克尔树的hash给予BodyHash</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Hash returns the merkle hash of contained transactions</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bb BlockBody)</span> <span class="title">Hash</span><span class="params">()</span> <span class="title">cipher</span>.<span class="title">SHA256</span></span> &#123;</span><br><span class="line">    hashes := <span class="built_in">make</span>([]cipher.SHA256, <span class="built_in">len</span>(bb.Transactions))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> bb.Transactions &#123;</span><br><span class="line">        hashes[i] = bb.Transactions[i].Hash()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Merkle hash of transactions</span></span><br><span class="line">    <span class="keyword">return</span> cipher.Merkle(hashes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Block新建过程"><a href="#Block新建过程" class="headerlink" title="Block新建过程"></a>Block新建过程</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//prev := Block&#123;Head: BlockHeader&#123;Version: 0x02, Time: 100, BkSeq: 98&#125;&#125;</span></span><br><span class="line"><span class="comment">//currentTime := uint64(133)</span></span><br><span class="line"><span class="comment">//uxHash := testutil.RandSHA256(t)</span></span><br><span class="line"><span class="comment">//txns := Transactions&#123;Transaction&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment">//t := func(t *Transaction) (uint64, error) &#123;return fee, nil&#125;</span></span><br><span class="line"><span class="comment">//NewBlock(prev, currentTime, uxHash, txns, func(t *Transaction) (uint64, error) &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewBlock creates new block.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(prev Block, currentTime <span class="keyword">uint64</span>, uxHash cipher.SHA256, txns Transactions, calc FeeCalculator)</span> <span class="params">(*Block, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(txns) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Refusing to create block with no transactions"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fee, err := txns.Fees(calc)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// This should have been caught earlier</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Invalid transaction fees: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body := BlockBody&#123;txns&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;Block&#123;</span><br><span class="line">        Head: NewBlockHeader(prev.Head, uxHash, currentTime, fee, body),</span><br><span class="line">        Body: body,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NewBlockHeader  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// NewBlockHeader creates block header</span><br><span class="line">func NewBlockHeader(prev BlockHeader, uxHash cipher.SHA256, currentTime, fee uint64, body BlockBody) BlockHeader &#123;</span><br><span class="line">    if currentTime &lt;= prev.Time &#123;</span><br><span class="line">        logger.Panic(&quot;Time can only move forward&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    prevHash := prev.Hash() //SHA256</span><br><span class="line">    return BlockHeader&#123;</span><br><span class="line">        BodyHash: body.Hash(),  //默克尔</span><br><span class="line">        Version:  prev.Version,</span><br><span class="line">        PrevHash: prevHash,</span><br><span class="line">        Time:     currentTime,</span><br><span class="line">        BkSeq:    prev.BkSeq + 1,</span><br><span class="line">        Fee:      fee,</span><br><span class="line">        UxHash:   uxHash,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区块链相关结构"><a href="#区块链相关结构" class="headerlink" title="区块链相关结构"></a>区块链相关结构</h3><blockquote>
<p>区块链的数据结构主要为了存储,数据库利用了<code>bolt</code>     </p>
</blockquote>
<p>并且在<code>bolt</code>中的bucket为桶结构,是为一系列key的集合,类似Mysql#Table结构    </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Blockchain <span class="keyword">struct</span> &#123;</span><br><span class="line">    db    *dbutil.DB</span><br><span class="line">    cfg   BlockchainConfig</span><br><span class="line">    store chainStore</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> chainStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    Head(*dbutil.Tx) (*coin.SignedBlock, error)</span><br><span class="line">    HeadSeq(*dbutil.Tx) (<span class="keyword">uint64</span>, <span class="keyword">bool</span>, error)</span><br><span class="line">    Len(*dbutil.Tx) (<span class="keyword">uint64</span>, error)</span><br><span class="line">    AddBlock(*dbutil.Tx, *coin.SignedBlock) error</span><br><span class="line">    GetBlockByHash(*dbutil.Tx, cipher.SHA256) (*coin.Block, error)</span><br><span class="line">    GetSignedBlockByHash(*dbutil.Tx, cipher.SHA256) (*coin.SignedBlock, error)</span><br><span class="line">    GetSignedBlockBySeq(*dbutil.Tx, <span class="keyword">uint64</span>) (*coin.SignedBlock, error)</span><br><span class="line">    UnspentPool() blockdb.UnspentPool</span><br><span class="line">    GetGenesisBlock(*dbutil.Tx) (*coin.SignedBlock, error)</span><br><span class="line">    GetBlockSignature(*dbutil.Tx, *coin.Block) (cipher.Sig, <span class="keyword">bool</span>, error)</span><br><span class="line">    ForEachBlock(*dbutil.Tx, <span class="function"><span class="keyword">func</span><span class="params">(*coin.Block)</span> <span class="title">error</span>) <span class="title">error</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">BlockchainConfig</span> <span class="title">configures</span> <span class="title">Blockchain</span> <span class="title">options</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">BlockchainConfig</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">    <span class="comment">// Arbitrating mode: if in arbitrating mode, when master node execute blocks,</span></span><br><span class="line">    <span class="comment">// the invalid transaction will be skipped and continue the next; otherwise,</span></span><br><span class="line">    <span class="comment">// node will throw the error and return.</span></span><br><span class="line">    Arbitrating <span class="keyword">bool</span></span><br><span class="line">    Pubkey      cipher.PubKey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="交易事务相关-coin-transaction"><a href="#交易事务相关-coin-transaction" class="headerlink" title="交易事务相关 coin/transaction"></a>交易事务相关 coin/transaction</h2><h3 id="交易结构"><a href="#交易结构" class="headerlink" title="交易结构"></a>交易结构</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transaction transaction struct</span></span><br><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">    Length    <span class="keyword">uint32</span>        <span class="comment">//length prefix</span></span><br><span class="line">    Type      <span class="keyword">uint8</span>         <span class="comment">//transaction type</span></span><br><span class="line">    InnerHash cipher.SHA256 <span class="comment">//inner hash SHA256 of In[],Out[]</span></span><br><span class="line"></span><br><span class="line">    Sigs []cipher.Sig        <span class="comment">//list of signatures, 64+1 bytes each</span></span><br><span class="line">    In   []cipher.SHA256     <span class="comment">//ouputs being spent</span></span><br><span class="line">    Out  []TransactionOutput <span class="comment">//ouputs being created</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TransactionOutput hash output/name is function of Hash</span></span><br><span class="line"><span class="keyword">type</span> TransactionOutput <span class="keyword">struct</span> &#123;</span><br><span class="line">    Address cipher.Address <span class="comment">//address to send to</span></span><br><span class="line">    Coins   <span class="keyword">uint64</span>         <span class="comment">//amount to be sent in coins</span></span><br><span class="line">    Hours   <span class="keyword">uint64</span>         <span class="comment">//amount to be sent in coin hours 币时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h3><blockquote>
<p>交易事务的Hash  </p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hash an entire Transaction struct, including the TransactionHeader</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(txn *Transaction)</span> <span class="title">Hash</span><span class="params">()</span> <span class="title">cipher</span>.<span class="title">SHA256</span></span> &#123;</span><br><span class="line">    b := txn.Serialize()</span><br><span class="line">    <span class="keyword">return</span> cipher.SumSHA256(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>获取交易长度</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Size returns the encoded byte size of the transaction</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(txn *Transaction)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(txn.Serialize())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对所有Input进行私钥签名  </p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SignInputs signs all inputs in the transaction</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(txn *Transaction)</span> <span class="title">SignInputs</span><span class="params">(keys []cipher.SecKey)</span></span> &#123;</span><br><span class="line">    txn.InnerHash = txn.HashInner() <span class="comment">// update hash</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(txn.Sigs) != <span class="number">0</span> &#123;</span><br><span class="line">        logger.Panic(<span class="string">"Transaction has been signed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(keys) != <span class="built_in">len</span>(txn.In) &#123;</span><br><span class="line">        logger.Panic(<span class="string">"Invalid number of keys"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(keys) &gt; math.MaxUint16 &#123;</span><br><span class="line">        logger.Panic(<span class="string">"Too many keys"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(keys) == <span class="number">0</span> &#123;</span><br><span class="line">        logger.Panic(<span class="string">"No keys"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigs := <span class="built_in">make</span>([]cipher.Sig, <span class="built_in">len</span>(txn.In))</span><br><span class="line">    innerHash := txn.HashInner()</span><br><span class="line">    <span class="keyword">for</span> i, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        h := cipher.AddSHA256(innerHash, txn.In[i]) <span class="comment">// hash to sign</span></span><br><span class="line">        sigs[i] = cipher.SignHash(h, k)</span><br><span class="line">    &#125;</span><br><span class="line">    txn.Sigs = sigs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="未花费的交易UTXO-coin-outputs"><a href="#未花费的交易UTXO-coin-outputs" class="headerlink" title="未花费的交易UTXO coin/outputs"></a>未花费的交易UTXO coin/outputs</h2><h3 id="UTXO结构"><a href="#UTXO结构" class="headerlink" title="UTXO结构"></a>UTXO结构</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unspent Outputs</span></span><br><span class="line"><span class="comment">// UxOut represents uxout</span></span><br><span class="line"><span class="keyword">type</span> UxOut <span class="keyword">struct</span> &#123;</span><br><span class="line">    Head UxHead</span><br><span class="line">    Body UxBody <span class="comment">//hashed part</span></span><br><span class="line">    <span class="comment">//Meta UxMeta</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UxHead metadata (not hashed)</span></span><br><span class="line"><span class="keyword">type</span> UxHead <span class="keyword">struct</span> &#123;</span><br><span class="line">    Time  <span class="keyword">uint64</span> <span class="comment">//time of block it was created in</span></span><br><span class="line">    BkSeq <span class="keyword">uint64</span> <span class="comment">//block it was created in, used to calculate depth</span></span><br><span class="line">    <span class="comment">// SpSeq uint64 //block it was spent in</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UxBody uxbody</span></span><br><span class="line"><span class="keyword">type</span> UxBody <span class="keyword">struct</span> &#123;</span><br><span class="line">    SrcTransaction cipher.SHA256  <span class="comment">// Inner Hash of Transaction</span></span><br><span class="line">    Address        cipher.Address <span class="comment">// Address of receiver</span></span><br><span class="line">    Coins          <span class="keyword">uint64</span>         <span class="comment">// Number of coins</span></span><br><span class="line">    Hours          <span class="keyword">uint64</span>         <span class="comment">// Coin hours</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Address地址-cipher-address"><a href="#Address地址-cipher-address" class="headerlink" title="Address地址 cipher/address"></a>Address地址 cipher/address</h2><blockquote>
<p>正常情况用户地址生成过程    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通过传入的seed生成私钥</span><br><span class="line">⇣</span><br><span class="line">通过传入私钥生成公钥</span><br><span class="line">⇣</span><br><span class="line">通过传入公钥生成地址</span><br></pre></td></tr></table></figure>
<p>当然address也可以直接从私钥上产生或者直接一些byte数组上产生  </p>
<ul>
<li>AddressFromSecKey  </li>
<li>AddressFromPubKey  </li>
<li>AddressFromBytes  </li>
</ul>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Address version is after Key to enable better vanity address generation</span></span><br><span class="line"><span class="comment">// Address stuct is a 25 byte with a 20 byte publickey hash, 1 byte address</span></span><br><span class="line"><span class="comment">// type and 4 byte checksum.</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Version <span class="keyword">byte</span>      <span class="comment">//1 byte</span></span><br><span class="line">    Key     Ripemd160 <span class="comment">//20 byte pubkey hash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Address制造过程"><a href="#Address制造过程" class="headerlink" title="Address制造过程"></a>Address制造过程</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BitcoinAddressFromPubkey prints the bitcoin address for a seckey</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BitcoinAddressFromPubkey</span><span class="params">(pubkey PubKey)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    b1 := SumSHA256(pubkey[:])</span><br><span class="line">    b2 := HashRipemd160(b1[:])</span><br><span class="line">    b3 := <span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(<span class="number">0</span>)&#125;, b2[:]...)</span><br><span class="line">    b4 := DoubleSHA256(b3)</span><br><span class="line">    b5 := <span class="built_in">append</span>(b3, b4[<span class="number">0</span>:<span class="number">4</span>]...)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(base58.Hex2Base58(b5))</span><br><span class="line">    <span class="comment">// return Address&#123;</span></span><br><span class="line">    <span class="comment">//  Version: 0,</span></span><br><span class="line">    <span class="comment">//  Key:     b2,</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h2><h3 id="创建交易过程"><a href="#创建交易过程" class="headerlink" title="创建交易过程"></a>创建交易过程</h3><blockquote>
<p>首先在Api的package里面造一个http端口访问/spend的url,用来进行发起交易<br>不可缺少以下参数   </p>
</blockquote>
<ul>
<li>发起方Address   </li>
<li>接收方Address   </li>
<li>交易金额   </li>
</ul>
<blockquote>
<p>接下来无非就是以下结果   </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Slave -&gt; 接收交易 -&gt; 验证交易 -&gt; Update(UnSpentPool,UnConfirmPool) -&gt; 广播交易</span><br><span class="line">Master -&gt; 接收交易 -&gt; 验证交易 -&gt; 产区块打包交易 -&gt; Update(UnSpentPool,UnConfirmPool) -&gt; 广播区块</span><br><span class="line"></span><br><span class="line">代码会执行以下流程</span><br><span class="line">GateWay#CreateTransaction //创建交易</span><br><span class="line">GateWay#InjectBroadcastTransaction //广播交易</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大体流程如下   </p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get unspent outputs, while checking that there are no unconfirmed outputs</span></span><br><span class="line">auxs, err = gw.getUnspentsForSpending(addrs)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create and sign transaction</span></span><br><span class="line">txn, inputs, err = gw.v.Wallets.CreateAndSignTransactionAdvanced(params, auxs, head.Time())</span><br><span class="line"></span><br><span class="line"><span class="comment">// The wallet can create transactions that would not pass all validation, such as the decimal restriction</span></span><br><span class="line"><span class="comment">// because the wallet is not aware of visor-level constraints.</span></span><br><span class="line"><span class="comment">// Check that the transaction is valid before returning it to the caller.</span></span><br><span class="line">err = gw.v.VerifySingleTxnAllConstraints(txn)</span><br></pre></td></tr></table></figure>
<h4 id="验证流程"><a href="#验证流程" class="headerlink" title="验证流程"></a>验证流程</h4><ul>
<li>交易金额不能为0</li>
<li>交易金额不能为空</li>
<li>从交易发起方获取Address<ul>
<li>根据Address取Mysql数据库相关私钥,判断私钥    </li>
</ul>
</li>
</ul>
<h4 id="组装流程"><a href="#组装流程" class="headerlink" title="组装流程"></a>组装流程</h4><ul>
<li><p>根据交易事务的Input来拿Unspent Pool池中相关此Address的UTXO   </p>
  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">    Length    <span class="keyword">uint32</span>        <span class="comment">//length prefix</span></span><br><span class="line">    Type      <span class="keyword">uint8</span>         <span class="comment">//transaction type</span></span><br><span class="line">    InnerHash cipher.SHA256 <span class="comment">//inner hash SHA256 of In[],Out[]</span></span><br><span class="line"></span><br><span class="line">    Sigs []cipher.Sig        <span class="comment">//list of signatures, 64+1 bytes each</span></span><br><span class="line">    In   []cipher.SHA256     <span class="comment">//ouputs being spent</span></span><br><span class="line">    Out  []TransactionOutput <span class="comment">//ouputs being created</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UxOut represents uxout</span></span><br><span class="line"><span class="keyword">type</span> UxOut <span class="keyword">struct</span> &#123;</span><br><span class="line">    Head UxHead</span><br><span class="line">    Body UxBody <span class="comment">//hashed part</span></span><br><span class="line">    <span class="comment">//Meta UxMeta</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UxHead metadata (not hashed)</span></span><br><span class="line"><span class="keyword">type</span> UxHead <span class="keyword">struct</span> &#123;</span><br><span class="line">    Time  <span class="keyword">uint64</span> <span class="comment">//time of block it was created in</span></span><br><span class="line">    BkSeq <span class="keyword">uint64</span> <span class="comment">//block it was created in, used to calculate depth</span></span><br><span class="line">    <span class="comment">// SpSeq uint64 //block it was spent in</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UxBody uxbody</span></span><br><span class="line"><span class="keyword">type</span> UxBody <span class="keyword">struct</span> &#123;</span><br><span class="line">    SrcTransaction cipher.SHA256  <span class="comment">// Inner Hash of Transaction</span></span><br><span class="line">    Address        cipher.Address <span class="comment">// Address of receiver</span></span><br><span class="line">    Coins          <span class="keyword">uint64</span>         <span class="comment">// Number of coins</span></span><br><span class="line">    Hours          <span class="keyword">uint64</span>         <span class="comment">// Coin hours</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拿取Transaction.In</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> Transaction.In&#123;</span><br><span class="line">    unspent.Get(v)</span><br><span class="line">    .......</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对取出所有的utxo按照交易金额由小到大排序,尽可能多的消费utxo    </p>
  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spendOutputs, err := chooseSpends(uxouts, totalCoins)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看是否需要找零,如果需要找零,则新增一项receiveAddresses为自己,并设置相关的coin剩余币    </p>
</li>
<li><p>组装Transaction</p>
  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transaction transaction struct</span></span><br><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">    Length    <span class="keyword">uint32</span>        <span class="comment">//length prefix</span></span><br><span class="line">    Type      <span class="keyword">uint8</span>         <span class="comment">//transaction type</span></span><br><span class="line">    InnerHash cipher.SHA256 <span class="comment">//inner hash SHA256 of In[],Out[]</span></span><br><span class="line"></span><br><span class="line">    Sigs []cipher.Sig        <span class="comment">//list of signatures, 64+1 bytes each</span></span><br><span class="line">    In   []cipher.SHA256     <span class="comment">//ouputs being spent</span></span><br><span class="line">    Out  []TransactionOutput <span class="comment">//ouputs being created</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TransactionOutput hash output/name is function of Hash</span></span><br><span class="line"><span class="keyword">type</span> TransactionOutput <span class="keyword">struct</span> &#123;</span><br><span class="line">    Address cipher.Address <span class="comment">//address to send to</span></span><br><span class="line">    Coins   <span class="keyword">uint64</span>         <span class="comment">//amount to be sent in coins</span></span><br><span class="line">    Hours   <span class="keyword">uint64</span>         <span class="comment">//amount to be sent in coin hours</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>TransactionOutput <ul>
<li>Address:此为receiveAddresses(如果有剩余币可能还会指向自己)</li>
<li>Coins:此为每个receiveAddresses的coin(付费的金币)</li>
<li>Hourse:币时,呈2次递减</li>
</ul>
</li>
<li><p>In</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先查找有几个发送者的UTXO</span><br><span class="line">后遍历每个发送者的UTXO并且进行utxo.Body.Hash()然后每个都append形成最终的In</span><br></pre></td></tr></table></figure>
</li>
<li><p>Sigs:对交易中的所有input进行签名        </p>
</li>
<li>InnerHash:内部SHA256 of In[],Out[]   </li>
</ul>
</li>
</ul>
<p><br><br><br></p>
<h3 id="广播交易流程"><a href="#广播交易流程" class="headerlink" title="广播交易流程"></a>广播交易流程</h3><blockquote>
<p>广播交易     </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slave -&gt; 接收交易 -&gt; 验证交易 -&gt; Update(UnSpentPool,UnConfirmPool) -&gt; 广播交易</span><br><span class="line">Master -&gt; 接收交易 -&gt; 验证交易 -&gt; 产区块打包交易 -&gt; Update(UnSpentPool,UnConfirmPool) -&gt; 广播区块</span><br></pre></td></tr></table></figure>
<p>以上代码执行了以下创建交易流程<br>GateWay#CreateTransaction</p>
<p>接下来是广播交易<br>GateWay#InjectBroadcastTransaction</p>
<ul>
<li><p>首先还是验证交易   </p>
<ul>
<li><p>单个交易的软硬约束: VerifySingleTxnAllConstraints     </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">判断交易的utxo是否已存在</span><br><span class="line">判断未花费交易池是否已经存在对应的utxo,若存在,校验失败</span><br></pre></td></tr></table></figure>
</li>
<li><p>在验证交易的整个大小是否超过maxSize     </p>
  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(txn.Serialize()) &gt; maxSize</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>更新本节点未确认交易池</p>
  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UnconfirmedTxnPool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createUnconfirmedTxn</span><span class="params">(txn coin.Transaction)</span> <span class="title">UnconfirmedTxn</span></span> &#123;</span><br><span class="line">    now := utc.Now()</span><br><span class="line">    <span class="keyword">return</span> UnconfirmedTxn&#123;</span><br><span class="line">        Txn:       txn,</span><br><span class="line">        Received:  now.UnixNano(),</span><br><span class="line">        Checked:   now.UnixNano(),</span><br><span class="line">        Announced: time.Time&#123;&#125;.UnixNano(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>再者才是广播交易   </p>
  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// broadcastTransaction broadcasts a single transaction to all peers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vs *Visor)</span> <span class="title">broadcastTransaction</span><span class="params">(t coin.Transaction, pool *Pool)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> vs.Config.DisableNetworking &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m := NewGiveTxnsMessage(coin.Transactions&#123;t&#125;)</span><br><span class="line">    l, err := pool.Pool.Size()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    err = pool.Pool.BroadcastMessage(m)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Errorf(<span class="string">"Broadcast GivenTxnsMessage failed: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建GiveTxnsMessage</li>
<li>通过pool.Pool.BroadcastMessage传递消息出去,通过writeQueue传递到Sendloop   <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BroadcastMessage sends a Message to all connections in the Pool.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *ConnectionPool)</span> <span class="title">BroadcastMessage</span><span class="params">(msg Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> pool.Config.DebugPrint &#123;</span><br><span class="line">        logger.Debugf(<span class="string">"Broadcast, Msg Type: %s"</span>, reflect.TypeOf(msg))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fullWriteQueue := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> err := pool.strand(<span class="string">"BroadcastMessage"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pool.pool) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> errors.New(<span class="string">"Connection pool is empty"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, conn := <span class="keyword">range</span> pool.pool &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> conn.WriteQueue &lt;- msg:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                logger.Critical().Infof(<span class="string">"Write queue full for address %s"</span>, conn.Addr())</span><br><span class="line">                fullWriteQueue = <span class="built_in">append</span>(fullWriteQueue, conn.Addr())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(fullWriteQueue) == <span class="built_in">len</span>(pool.pool) &#123;</span><br><span class="line">            <span class="keyword">return</span> ErrNoReachableConnections</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><br><br><br></p>
<h3 id="接受交易造区块流程"><a href="#接受交易造区块流程" class="headerlink" title="接受交易造区块流程"></a>接受交易造区块流程</h3><blockquote>
<p>相关节点接收到<code>GiveTxnsMessage</code>的Message信息    </p>
</blockquote>
<ul>
<li>根据Message#Process准备丢入交易池</li>
<li>进入<code>InjectTransaction</code>,往<code>未确认交易池</code>创建注入交易    <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UnconfirmedTxn unconfirmed transaction</span></span><br><span class="line"><span class="keyword">type</span> UnconfirmedTxn <span class="keyword">struct</span> &#123;</span><br><span class="line">    Txn coin.Transaction  <span class="comment">//交易结构</span></span><br><span class="line">    <span class="comment">// Time the txn was last received  上一次接收时间</span></span><br><span class="line">    Received <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// Time the txn was last checked against the blockchain  检查时间</span></span><br><span class="line">    Checked <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// Last time we announced this txn   广播时间</span></span><br><span class="line">    Announced <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// If this txn is valid   是否验证</span></span><br><span class="line">    IsValid <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>更新bolt数据库相关<code>未确认交易池</code>     </p>
</blockquote>
<ul>
<li>Daemon定时判断交易是否是合法的,如合法就标识这笔<code>未确认交易</code>有效    </li>
<li>Daemon定时去查询所有<code>未确认交易池</code><ul>
<li>判断打包交易的总和不能超过区块的最大容量     </li>
<li>根据这些交易开始打包区块<code>NewBlock</code>   </li>
<li>打包区块时,校验交易是否合法<code>processTransactions</code>    <ul>
<li>校验输出utxo的唯一性</li>
<li>判断输入的utxo是否在未花费池中</li>
<li>再次校验,确保不存在相同的交易,已经交易中不存在相同的utxo输入</li>
</ul>
</li>
<li>交易数据生成一个新的区块  </li>
<li>创建签名区块:根据区块头哈希<code>HashHeader</code>+区块私钥<code>BlockSecKey</code>加签<code>{Block,Sig}</code></li>
<li>添加区块信息到数据库</li>
<li>移除未确认交易</li>
</ul>
</li>
</ul>
<p><br><br><br></p>
<h3 id="节点发现过程"><a href="#节点发现过程" class="headerlink" title="节点发现过程"></a>节点发现过程</h3><ul>
<li>pex:主要的peer运行容器类   </li>
<li>peerlist:一个peer列表  </li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> peerlist <span class="keyword">struct</span> &#123;</span><br><span class="line">    peers <span class="keyword">map</span>[<span class="keyword">string</span>]*Peer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Peer <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr            <span class="keyword">string</span> <span class="comment">// An address of the form ip:port</span></span><br><span class="line">    LastSeen        <span class="keyword">int64</span>  <span class="comment">// Unix timestamp when this peer was last seen</span></span><br><span class="line">    Private         <span class="keyword">bool</span>   <span class="comment">// Whether it should omitted from public requests</span></span><br><span class="line">    Trusted         <span class="keyword">bool</span>   <span class="comment">// Whether this peer is trusted</span></span><br><span class="line">    HasIncomingPort <span class="keyword">bool</span>   <span class="comment">// Whether this peer has accessable public port</span></span><br><span class="line">    RetryTimes      <span class="keyword">int</span>    <span class="string">`json:"-"`</span> <span class="comment">// records the retry times</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Daemon#Run</code>即将会运行<code>connectToTrustPeer</code>  </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dm *Daemon)</span> <span class="title">connectToTrustPeer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dm.Config.DisableIncomingConnections &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.Info(<span class="string">"Connect to trusted peers"</span>)</span><br><span class="line">    <span class="comment">// Make connections to all trusted peers</span></span><br><span class="line">    peers := dm.Pex.TrustedPublic()</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> peers &#123;</span><br><span class="line">        dm.connectToPeer(p)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">⇣</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := dm.Pool.Pool.Connect(p.Addr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        dm.connectionErrors &lt;- ConnectionError&#123;p.Addr, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">⇣</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> pool.wg.Done()</span><br><span class="line">    <span class="keyword">if</span> err := pool.handleConnection(conn, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Errorf(<span class="string">"pool.handleConnection error: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>至此<code>pool.handleConnection</code>会启动以下三个loop  </p>
</blockquote>
<ul>
<li>receiveMessage  </li>
<li>readLoop </li>
<li>sendLoop  </li>
</ul>
<p>跟Daemon#Run起线程去Pool#Run作为服务监听连接Accept相关连接一样的道理     </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">if</span> dm.Config.DisableIncomingConnections &#123;</span><br><span class="line">        <span class="keyword">if</span> err := dm.Pool.RunOffline(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            logger.WithError(err).Error(<span class="string">"daemon.Pool.RunOffline failed"</span>)</span><br><span class="line">            errC &lt;- err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := dm.Pool.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            logger.WithError(err).Error(<span class="string">"daemon.Pool.Run failed"</span>)</span><br><span class="line">            errC &lt;- err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>后期就进行Ping/PongMessage维持这些Connection   </p>
<p><br><br><br></p>
<h3 id="循环处理过程"><a href="#循环处理过程" class="headerlink" title="循环处理过程"></a>循环处理过程</h3><blockquote>
<p>大多情况下例如节点发现需要实时的不中断地跑        </p>
</blockquote>
<blockquote>
<p>所以在Daemon#Run方法有这样的TimeTicker   </p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">idlePingTicker := time.Tick(time.Duration)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-idlePingTicker:</span><br><span class="line">            <span class="comment">// 发送pings消息(必需)</span></span><br><span class="line">            ........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><blockquote>
<p>因为Master是出块节点可信任节点,所以并没有SignScript,PubKeyScript这类    </p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交易整体结构</span></span><br><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">    Length    <span class="keyword">uint32</span>              <span class="comment">//长度</span></span><br><span class="line">    InnerHash cipher.SHA256       <span class="comment">//内部hash</span></span><br><span class="line">    Signs     []cipher.Sig        <span class="comment">//签名</span></span><br><span class="line">    Inputs    []cipher.SHA256     <span class="comment">//发送方UTXO</span></span><br><span class="line">    Outputs   []TransactionOutput <span class="comment">//接收方地址</span></span><br><span class="line">    Data      <span class="keyword">string</span>              <span class="comment">//额外数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交易输出结构</span></span><br><span class="line"><span class="keyword">type</span> TransactionOutput <span class="keyword">struct</span> &#123;</span><br><span class="line">    Address address.Address <span class="comment">//地址</span></span><br><span class="line">    Coins   <span class="keyword">uint64</span>          <span class="comment">//交易金额</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Inputs结构  </span></span><br><span class="line"><span class="keyword">for</span> _, utxo := <span class="keyword">range</span> spends &#123;</span><br><span class="line">    senderUtxos = <span class="built_in">append</span>(senderUtxos, utxo.Body.Hash())</span><br><span class="line">    spendingCoins += utxo.Body.Coins</span><br><span class="line">    toSigns = <span class="built_in">append</span>(toSigns, toSign) <span class="comment">//SignInputs的参数keys []cipher.SecKey </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对交易中的所有input进行签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(txn *Transaction)</span> <span class="title">SignInputs</span><span class="params">(keys []cipher.SecKey)</span></span> &#123;</span><br><span class="line">    txn.InnerHash = txn.HashInner()</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    signs := <span class="built_in">make</span>([]cipher.Sig, <span class="built_in">len</span>(txn.Inputs))</span><br><span class="line">    innerHash := txn.HashInner()</span><br><span class="line">    <span class="keyword">for</span> i, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        <span class="comment">//每个input的</span></span><br><span class="line">        h := cipher.AddSHA256(innerHash, txn.Inputs[i])</span><br><span class="line">        signs[i] = cipher.SignHash(h, k)</span><br><span class="line">    &#125;</span><br><span class="line">    txn.Signs = signs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据交易的所有input和output计算出hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(txn *Transaction)</span> <span class="title">HashInner</span><span class="params">()</span> <span class="title">cipher</span>.<span class="title">SHA256</span></span> &#123;</span><br><span class="line">    input := encoder.Serialize(txn.Inputs)</span><br><span class="line">    output := encoder.Serialize(txn.Outputs)</span><br><span class="line">    txs := <span class="built_in">append</span>(input, output...)</span><br><span class="line">    <span class="keyword">return</span> cipher.SumSHA256(txs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Eth"><a href="#Eth" class="headerlink" title="Eth"></a>Eth</h1><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>下载源码</p>
<p><a href="https://github.com/ethereum/go-ethereum" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make geth</span><br><span class="line">//build geth 可执行文件</span><br></pre></td></tr></table></figure>
<p>或直接下载安装客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew tap ethereum/ethereum</span><br><span class="line">brew install ethereum</span><br><span class="line"></span><br><span class="line">https://ethereum.github.io/go-ethereum/downloads/</span><br></pre></td></tr></table></figure>
<p><a href="https://learnblockchain.cn/2017/11/29/geth_cmd_options/" target="_blank" rel="noopener">各类参数说明</a></p>
<p><img src="/2018/09/11/blockchain/image-08.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">➜  go-ethereum :</span><br><span class="line">.</span><br><span class="line">├── accounts        // 以太坊的钱包和账户管理</span><br><span class="line">    ├── abi         // 以太坊合约的ABI代码</span><br><span class="line">    ├── keystore    // 支持 keystore 模式的钱包</span><br><span class="line">    └── usbwallet   // 支持 USB 模式的钱包</span><br><span class="line">├── bmt             // 二进制的 Merkle 树的实现</span><br><span class="line">├── build           // 编译与构建的一些脚本和配置</span><br><span class="line">├── cmd             // 命令行工具集</span><br><span class="line">    ├── abigen      // ABI 生成器</span><br><span class="line">    ├── bootnode    // 启动一个仅仅实现网络发现的节点</span><br><span class="line">    ├── ethkey</span><br><span class="line">    ├── evm         // 以太坊虚拟机的开发工具</span><br><span class="line">    ├── faucet</span><br><span class="line">    ├── geth        // geth 命令行工具</span><br><span class="line">    ├── p2psim      // 提供了一个工具来模拟 HTTP 的 API</span><br><span class="line">    ├── puppeth     // 创建一个新的以太坊网络的向导</span><br><span class="line">    ├── rlpdump     // RLP 数据的格式化输出</span><br><span class="line">    ├── swarm       // swarm 网络的接入点</span><br><span class="line">    ├── utils       // 公共工具</span><br><span class="line">    └── wnode       // 一个简单的 whisper 节点,可以用作独立的引导节点。此外,可以用于不同的测试和诊断目的</span><br><span class="line">├── common          // 提供了一些公共通用的工具类</span><br><span class="line">├── compression     // 压缩</span><br><span class="line">├── consensus       // 提供了以太坊的一些共识算法,比如：ethhash</span><br><span class="line">├── console         // 控制台</span><br><span class="line">├── containers      // 支持 docker 和 vagrant 等容器</span><br><span class="line">├── contracts       // 合约管理</span><br><span class="line">├── core            // 核心数据结构和算法(EVM,state,Blockchain,布隆过滤器等)</span><br><span class="line">├── crypto          // 加密相关</span><br><span class="line">├── dashboard       // </span><br><span class="line">├── eth             // 在其中实现了以太坊的协议</span><br><span class="line">├── ethclient       // geth 客户端入口</span><br><span class="line">├── ethdb           // eth 的数据库(包括生产环境的leveldb和供测试用的内存数据库)</span><br><span class="line">├── ethstats        // 提供以太坊网络状态的报告</span><br><span class="line">├── event           // 用于处理实时事件</span><br><span class="line">├── les             // 以太坊的轻量级协议子集(Light Ethereum Subprotocol)</span><br><span class="line">├── light           // 实现为以太坊轻量级客户端提供按需检索的功能</span><br><span class="line">├── log             // 日志模块</span><br><span class="line">├── metrics         // 度量和检测</span><br><span class="line">├── miner           // 提供以太坊的区块创建和挖矿</span><br><span class="line">├── mobile          // 移动端的一些 wrapper</span><br><span class="line">├── node            // 以太坊的多种类型的节点</span><br><span class="line">├── p2p             // P2P 网络协议</span><br><span class="line">├── params          // 参数管理</span><br><span class="line">├── rlp             // 以太坊的序列化处理(rlp 递归长度前缀编码)</span><br><span class="line">├── rpc             // rpc 远程方法调用</span><br><span class="line">├── swarm           // swarm 网络存储和处理</span><br><span class="line">├── trie            // 以太坊中的重要数据结构,Merkle Patricia Tries</span><br><span class="line">└── whisper         // whisper 节点协议</span><br></pre></td></tr></table></figure>
<h2 id="交互式控制台"><a href="#交互式控制台" class="headerlink" title="交互式控制台"></a>交互式控制台</h2><ul>
<li>eth：包含一些跟操作区块链相关的方法</li>
<li>net：包含以下查看p2p网络状态的方法</li>
<li>admin：包含一些与管理节点相关的方法</li>
<li>miner：包含启动&amp;停止挖矿的一些方法</li>
<li>personal：主要包含一些管理账户的方法</li>
<li>txpool：包含一些查看交易内存池的方法</li>
<li>web3：包含了以上对象,还包含一些单位换算的方法</li>
</ul>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">--config value          TOML 配置文件</span><br><span class="line">--datadir “xxx”         数据库和keystore密钥的数据目录</span><br><span class="line">--keystore              keystore存放目录(默认在datadir内)</span><br><span class="line">--nousb                 禁用监控和管理USB硬件钱包</span><br><span class="line">--networkid value       网络标识符(整型, 1=Frontier, 2=Morden (弃用), 3=Ropsten, 4=Rinkeby) (默认: 1)</span><br><span class="line">--testnet               Ropsten网络:预先配置的POW(proof-of-work)测试网络</span><br><span class="line">--rinkeby               Rinkeby网络: 预先配置的POA(proof-of-authority)测试网络</span><br><span class="line">--syncmode "fast"       同步模式 ("fast", "full", or "light")</span><br><span class="line">--ethstats value        上报ethstats service  URL (nodename:secret@host:port)</span><br><span class="line">--identity value        自定义节点名</span><br><span class="line">--lightserv value       允许LES请求时间最大百分比(0 – 90)(默认值:0) </span><br><span class="line">--lightpeers value      最大LES client peers数量(默认值:20)</span><br><span class="line">--lightkdf              在KDF强度消费时降低key-derivation RAM&amp;CPU使用</span><br><span class="line"></span><br><span class="line">//开发者专用</span><br><span class="line">--dev               使用POA共识网络,默认预分配一个开发者账户并且会自动开启挖矿。</span><br><span class="line">--dev.period value  开发者模式下挖矿周期 (0 = 仅在交易时) (默认: 0)</span><br><span class="line">--vmdebug        记录VM及合约调试信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--ethash.cachedir                        ethash验证缓存目录(默认 = datadir目录内)</span><br><span class="line">--ethash.cachesinmem value               在内存保存的最近的ethash缓存个数  (每个缓存16MB ) (默认: 2)</span><br><span class="line">--ethash.cachesondisk value              在磁盘保存的最近的ethash缓存个数 (每个缓存16MB) (默认: 3)</span><br><span class="line">--ethash.dagdir ""                       存ethash DAGs目录 (默认 = 用户hom目录)</span><br><span class="line">--ethash.dagsinmem value                 在内存保存的最近的ethash DAGs 个数 (每个1GB以上) (默认: 1)</span><br><span class="line">--ethash.dagsondisk value                在磁盘保存的最近的ethash DAGs 个数 (每个1GB以上) (默认: 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--txpool.nolocals            为本地提交交易禁用价格豁免</span><br><span class="line">--txpool.journal value       本地交易的磁盘日志：用于节点重启 (默认: "transactions.rlp")</span><br><span class="line">--txpool.rejournal value     重新生成本地交易日志的时间间隔 (默认: 1小时)</span><br><span class="line">--txpool.pricelimit value    加入交易池的最小的gas价格限制(默认: 1)</span><br><span class="line">--txpool.pricebump value     价格波动百分比(相对之前已有交易) (默认: 10)</span><br><span class="line">--txpool.accountslots value  每个帐户保证可执行的最少交易槽数量  (默认: 16)</span><br><span class="line">--txpool.globalslots value   所有帐户可执行的最大交易槽数量 (默认: 4096)</span><br><span class="line">--txpool.accountqueue value  每个帐户允许的最多非可执行交易槽数量 (默认: 64)</span><br><span class="line">--txpool.globalqueue value   所有帐户非可执行交易最大槽数量  (默认: 1024)</span><br><span class="line">--txpool.lifetime value      非可执行交易最大入队时间(默认: 3小时)</span><br><span class="line"></span><br><span class="line">//性能调优的选项</span><br><span class="line">--cache value                分配给内部缓存的内存MB数量,缓存值(最低16 mb /数据库强制要求)(默认:128)</span><br><span class="line">--trie-cache-gens value      保持在内存中产生的trie node数量(默认:120)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//帐户选项</span><br><span class="line">--unlock value              需解锁账户用逗号分隔</span><br><span class="line">--password value            用于非交互式密码输入的密码文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//API和控制台选项</span><br><span class="line">--rpc                       启用HTTP-RPC服务器</span><br><span class="line">--rpcaddr value             HTTP-RPC服务器接口地址(默认值:“localhost”)</span><br><span class="line">--rpcport value             HTTP-RPC服务器监听端口(默认值:8545)</span><br><span class="line">--rpcapi value              基于HTTP-RPC接口提供的API(默认值:“eth,net,web3”)</span><br><span class="line">--ws                        启用WS-RPC服务器</span><br><span class="line">--wsaddr value              WS-RPC服务器监听接口地址(默认值:“localhost”)</span><br><span class="line">--wsport value              WS-RPC服务器监听端口(默认值:8546)</span><br><span class="line">--wsapi  value              基于WS-RPC的接口提供的API</span><br><span class="line">--wsorigins value           websockets请求允许的源</span><br><span class="line">--ipcdisable                禁用IPC-RPC服务器</span><br><span class="line">--ipcpath                   包含在datadir里的IPC socket/pipe文件名(转义过的显式路径)</span><br><span class="line">--rpccorsdomain value       允许跨域请求的域名列表(逗号分隔)(浏览器强制)</span><br><span class="line">--jspath loadScript         JavaScript加载脚本的根路径(默认值:“.”)</span><br><span class="line">--exec value                执行JavaScript语句(只能结合console/attach使用)</span><br><span class="line">--preload value             预加载到控制台的JavaScript文件列表(逗号分隔)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//网络选项</span><br><span class="line">--bootnodes value    用于P2P发现引导的enode urls(逗号分隔)(对于light servers用v4+v5代替)</span><br><span class="line">--bootnodesv4 value  用于P2P v4发现引导的enode urls(逗号分隔) (light server, 全节点)</span><br><span class="line">--bootnodesv5 value  用于P2P v5发现引导的enode urls(逗号分隔) (light server, 轻节点)</span><br><span class="line">--port value         网卡监听端口(默认值:30303)</span><br><span class="line">--maxpeers value     最大的网络节点数量(如果设置为0,网络将被禁用)(默认值:25)</span><br><span class="line">--maxpendpeers value    最大尝试连接的数量(如果设置为0,则将使用默认值)(默认值:0)</span><br><span class="line">--nat value             NAT端口映射机制 (any|none|upnp|pmp|extip:&lt;IP&gt;) (默认: “any”)</span><br><span class="line">--nodiscover            禁用节点发现机制(手动添加节点)</span><br><span class="line">--v5disc                启用实验性的RLPx V5(Topic发现)机制</span><br><span class="line">--nodekey value         P2P节点密钥文件</span><br><span class="line">--nodekeyhex value      十六进制的P2P节点密钥(用于测试)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//矿工选项</span><br><span class="line">--mine                  打开挖矿</span><br><span class="line">--minerthreads value    挖矿使用的CPU线程数量(默认值:8)</span><br><span class="line">--etherbase value       挖矿奖励地址(默认=第一个创建的帐户)(默认值:“0”)</span><br><span class="line">--targetgaslimit value  目标gas限制：设置最低gas限制(低于这个不会被挖) (默认值:“4712388”)</span><br><span class="line">--gasprice value        挖矿接受交易的最低gas价格</span><br><span class="line">--extradata value       矿工设置的额外块数据(默认=client version)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//GAS价格选项</span><br><span class="line">--gpoblocks value      用于检查gas价格的最近块的个数  (默认: 10)</span><br><span class="line">--gpopercentile value  建议gas价参考最近交易的gas价的百分位数,(默认: 50)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//日志和调试选项</span><br><span class="line">--metrics            启用metrics收集和报告</span><br><span class="line">--fakepow            禁用proof-of-work验证</span><br><span class="line">--verbosity value    日志详细度:0=silent, 1=error, 2=warn, 3=info, 4=debug, 5=detail (default: 3)</span><br><span class="line">--vmodule value      每个模块详细度:以 &lt;pattern&gt;=&lt;level&gt;的逗号分隔列表 (比如 eth/*=6,p2p=5)</span><br><span class="line">--backtrace value    请求特定日志记录堆栈跟踪 (比如 “block.go:271”)</span><br><span class="line">--debug                     突出显示调用位置日志(文件名及行号)</span><br><span class="line">--pprof                     启用pprof HTTP服务器</span><br><span class="line">--pprofaddr value           pprof HTTP服务器监听接口(默认值:127.0.0.1)</span><br><span class="line">--pprofport value           pprof HTTP服务器监听端口(默认值:6060)</span><br><span class="line">--memprofilerate value      按指定频率打开memory profiling    (默认:524288)</span><br><span class="line">--blockprofilerate value    按指定频率打开block profiling    (默认值:0)</span><br><span class="line">--cpuprofile value          将CPU profile写入指定文件</span><br><span class="line">--trace value               将execution trace写入指定文件</span><br></pre></td></tr></table></figure>
<p><code>geth dumpconfig</code>导出相关配置</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Eth]</span></span><br><span class="line"><span class="attr">NetworkId</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">SyncMode</span> = <span class="string">"full"</span></span><br><span class="line"><span class="attr">LightPeers</span> = <span class="number">100</span></span><br><span class="line"><span class="attr">DatabaseCache</span> = <span class="number">768</span></span><br><span class="line"><span class="attr">GasPrice</span> = <span class="number">18000000000</span></span><br><span class="line"><span class="attr">EnablePreimageRecording</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Eth.Ethash]</span></span><br><span class="line"><span class="attr">CacheDir</span> = <span class="string">"ethash"</span></span><br><span class="line"><span class="attr">CachesInMem</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">CachesOnDisk</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">DatasetDir</span> = <span class="string">"/root/.ethash"</span></span><br><span class="line"><span class="attr">DatasetsInMem</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">DatasetsOnDisk</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">PowMode</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Eth.TxPool]</span></span><br><span class="line"><span class="attr">NoLocals</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">Journal</span> = <span class="string">"transactions.rlp"</span></span><br><span class="line"><span class="attr">Rejournal</span> = <span class="number">3600000000000</span></span><br><span class="line"><span class="attr">PriceLimit</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">PriceBump</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">AccountSlots</span> = <span class="number">16</span></span><br><span class="line"><span class="attr">GlobalSlots</span> = <span class="number">4096</span></span><br><span class="line"><span class="attr">AccountQueue</span> = <span class="number">64</span></span><br><span class="line"><span class="attr">GlobalQueue</span> = <span class="number">1024</span></span><br><span class="line"><span class="attr">Lifetime</span> = <span class="number">10800000000000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Eth.GPO]</span></span><br><span class="line"><span class="attr">Blocks</span> = <span class="number">20</span></span><br><span class="line"><span class="attr">Percentile</span> = <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Shh]</span></span><br><span class="line"><span class="attr">MaxMessageSize</span> = <span class="number">1048576</span></span><br><span class="line"><span class="attr">MinimumAcceptedPOW</span> = <span class="number">2</span>e-<span class="number">01</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Node]</span></span><br><span class="line"><span class="attr">DataDir</span> = <span class="string">"/root/.ethereum"</span></span><br><span class="line"><span class="attr">IPCPath</span> = <span class="string">"geth.ipc"</span></span><br><span class="line"><span class="attr">HTTPPort</span> = <span class="number">8545</span></span><br><span class="line"><span class="attr">HTTPVirtualHosts</span> = [<span class="string">"localhost"</span>]</span><br><span class="line"><span class="attr">HTTPModules</span> = [<span class="string">"net"</span>, <span class="string">"web3"</span>, <span class="string">"eth"</span>, <span class="string">"shh"</span>]</span><br><span class="line"><span class="attr">WSPort</span> = <span class="number">8546</span></span><br><span class="line"><span class="attr">WSModules</span> = [<span class="string">"net"</span>, <span class="string">"web3"</span>, <span class="string">"eth"</span>, <span class="string">"shh"</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[Node.P2P]</span></span><br><span class="line"><span class="attr">MaxPeers</span> = <span class="number">25</span></span><br><span class="line"><span class="attr">NoDiscovery</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">BootstrapNodes</span> = [<span class="string">"enode://a979fb575495b8d6db44f750317d0f4622bf4c2aa3365d6af7c284339968eef29b69ad0dce72a4d8db5ebb4968de0e3bec910127f134779fbcb0cb6d3331163c@52.16.188.185:30303"</span>, <span class="string">"enode://3f1d12044546b76342d59d4a05532c14b85aa669704bfe1f864fe079415aa2c02d743e03218e57a33fb94523adb54032871a6c51b2cc5514cb7c7e35b3ed0a99@13.93.211.84:30303"</span>, <span class="string">"enode://78de8a0916848093c73790ead81d1928bec737d565119932b98c6b100d944b7a95e94f847f689fc723399d2e31129d182f7ef3863f2b4c820abbf3ab2722344d@191.235.84.50:30303"</span>, <span class="string">"enode://158f8aab45f6d19c6cbf4a089c2670541a8da11978a2f90dbf6a502a4a3bab80d288afdbeb7ec0ef6d92de563767f3b1ea9e8e334ca711e9f8e2df5a0385e8e6@13.75.154.138:30303"</span>, <span class="string">"enode://1118980bf48b0a3640bdba04e0fe78b1add18e1cd99bf22d53daac1fd9972ad650df52176e7c7d89d1114cfef2bc23a2959aa54998a46afcf7d91809f0855082@52.74.57.123:30303"</span>, <span class="string">"enode://979b7fa28feeb35a4741660a16076f1943202cb72b6af70d327f053e248bab9ba81760f39d0701ef1d8f89cc1fbd2cacba0710a12cd5314d5e0c9021aa3637f9@5.1.83.226:30303"</span>]</span><br><span class="line"><span class="attr">BootstrapNodesV5</span> = [<span class="string">"enode://06051a5573c81934c9554ef2898eb13b33a34b94cf36b202b69fde139ca17a85051979867720d4bdae4323d4943ddf9aeeb6643633aa656e0be843659795007a@35.177.226.168:30303"</span>, <span class="string">"enode://0cc5f5ffb5d9098c8b8c62325f3797f56509bff942704687b6530992ac706e2cb946b90a34f1f19548cd3c7baccbcaea354531e5983c7d1bc0dee16ce4b6440b@40.118.3.223:30304"</span>, <span class="string">"enode://1c7a64d76c0334b0418c004af2f67c50e36a3be60b5e4790bdac0439d21603469a85fad36f2473c9a80eb043ae60936df905fa28f1ff614c3e5dc34f15dcd2dc@40.118.3.223:30306"</span>, <span class="string">"enode://85c85d7143ae8bb96924f2b54f1b3e70d8c4d367af305325d30a61385a432f247d2c75c45c6b4a60335060d072d7f5b35dd1d4c45f76941f62a4f83b6e75daaf@40.118.3.223:30307"</span>]</span><br><span class="line"><span class="attr">StaticNodes</span> = []</span><br><span class="line"><span class="attr">TrustedNodes</span> = []</span><br><span class="line"><span class="attr">ListenAddr</span> = <span class="string">":30303"</span></span><br><span class="line"><span class="attr">EnableMsgEvents</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Dashboard]</span></span><br><span class="line"><span class="attr">Host</span> = <span class="string">"localhost"</span></span><br><span class="line"><span class="attr">Port</span> = <span class="number">8080</span></span><br><span class="line"><span class="attr">Refresh</span> = <span class="number">5000000000</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置说明</p>
</blockquote>
<table>
<thead>
<tr>
<th>域</th>
<th>配置项</th>
<th>对应参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Eth</td>
<td>NetworkId</td>
<td>–networkid value</td>
<td>Network标识符(integer类型,1=Frontier,2=Morden(disused),3=Ropsten,4=Rinkeby),默认为1。如果建立在私网上,使用另外的任意值,比如：3369</td>
</tr>
<tr>
<td>Eth</td>
<td>DatabaseCache</td>
<td>null</td>
<td>(个人理解)为database申请的系统内存,单位为MB,最小值和默认值是16MB</td>
</tr>
<tr>
<td>Eth</td>
<td>GasPrice</td>
<td>–gasprice “18000000000”</td>
<td>接受挖掘事务的最低gas价格。可能指miner的报酬</td>
</tr>
<tr>
<td>Eth.Ethash</td>
<td>CacheDir</td>
<td>–ethash.cachedir</td>
<td>存储ethash证明缓存的目录(默认在 <em>datadir</em> 目录里)</td>
</tr>
<tr>
<td>Eth.Ethash</td>
<td>CachesInMem</td>
<td>–ethash.cachesinmem value</td>
<td>保留在内存中的最新ethash缓存的数目(每16MB)(默认：2)。</td>
</tr>
<tr>
<td>Eth.Ethash</td>
<td>CachesOnDisk</td>
<td>–ethash.cachesondisk value</td>
<td>保留在磁盘中的最新ethash缓存的数目(每16MB)(默认：3)。</td>
</tr>
<tr>
<td>Eth.Ethash</td>
<td>DatasetDir</td>
<td>–ethash.dagdir “/home/karalabe/.ethash”</td>
<td>存储ethash挖掘DAGs的目录(默认在home目录里)</td>
</tr>
<tr>
<td>Eth.Ethash</td>
<td>DatasetsInMem</td>
<td>–ethash.dagsinmem value</td>
<td>保留在内存中的最新ethash挖掘DAGs(每1+GB)(默认：1)。</td>
</tr>
<tr>
<td>Eth.Ethash</td>
<td>DatasetsOnDisk</td>
<td>–ethash.dagsondisk value</td>
<td>保留在磁盘中的最新ethash挖掘DAGs(每1+GB)(默认：2)。</td>
</tr>
<tr>
<td>Eth.TxPool</td>
<td>NoLocals</td>
<td>–txpool.nolocals</td>
<td>免除本地提交事务的费用</td>
</tr>
<tr>
<td>Eth.TxPool</td>
<td>Journal</td>
<td>–txpool.journal value</td>
<td>用于节点重启的本地事务磁盘日志(默认：”transactions.rlp”)</td>
</tr>
<tr>
<td>Eth.TxPool</td>
<td>Rejournal</td>
<td>–txpool.rejournal value</td>
<td>重新生成本地事务日志的时间间隔(默认：1h0m0s)</td>
</tr>
<tr>
<td>Eth.TxPool</td>
<td>PriceLimit</td>
<td>–txpool.pricelimit value</td>
<td>强制接纳入池的最小gas价格限制(默认：1)</td>
</tr>
<tr>
<td>Eth.TxPool</td>
<td>PriceBump</td>
<td>–txpool.pricebump value</td>
<td>替代一个已经存在的事务的价格碰撞百分比(默认：10)</td>
</tr>
<tr>
<td>Eth.TxPool</td>
<td>AccountSlots</td>
<td>–txpool.accountslots value</td>
<td>每个账户担保的可执行事务时隙的最小数目(默认：16)</td>
</tr>
<tr>
<td>Eth.TxPool</td>
<td>GlobalSlots</td>
<td>–txpool.globalslots value</td>
<td>所有账户的可执行事务时隙的最大数目(默认：4096)</td>
</tr>
<tr>
<td>Eth.TxPool</td>
<td>AccountQueue</td>
<td>–txpool.accountqueue value</td>
<td>每个账户许可的非可执行事务时隙的最大数目(默认：64)</td>
</tr>
<tr>
<td>Eth.TxPool</td>
<td>GlobalQueue</td>
<td>–txpool.globalqueue</td>
<td>所有账户的非可执行事务时隙的最大数目(默认：1024)</td>
</tr>
<tr>
<td>Eth.TxPool</td>
<td>Lifetime</td>
<td>–txpool.lifetime value</td>
<td>非可执行事务的排队最大时间(默认：3h0m0s)</td>
</tr>
<tr>
<td>Eth.GPO</td>
<td>Blocks</td>
<td>–gpoblocks value</td>
<td>检查gas价格的最新区块的数目(默认：10)</td>
</tr>
<tr>
<td>Eth.GPO</td>
<td>Percentile</td>
<td>–gpopercentile value</td>
<td>建议的gas价格是一组最新事务gas价格的百分位(默认：50)</td>
</tr>
<tr>
<td>Shh</td>
<td>MaxMessageSize</td>
<td>–shh.maxmessagesize value</td>
<td>可接受的最大信息大小(默认：1048576)</td>
</tr>
<tr>
<td>Shh</td>
<td>MinimumAcceptedPOW</td>
<td>–shh.pow value</td>
<td>可接受的最小POW(默认：0.2)</td>
</tr>
<tr>
<td>Node</td>
<td>DataDir</td>
<td>–datadir “/home/karalabe/.ethereum”</td>
<td>databases和keystore的数据目录</td>
</tr>
<tr>
<td>Node</td>
<td>IPCPath</td>
<td>–ipcpath</td>
<td>datadir里的IPC socket/pipe的文件名</td>
</tr>
<tr>
<td>Node</td>
<td>HTTPPort</td>
<td>–rpcport value</td>
<td>HTTP-RPC服务监听端口(默认：8545)</td>
</tr>
<tr>
<td>Node</td>
<td>HTTPVirtualHosts</td>
<td>–rpcaddr value</td>
<td>HTTP-RPC服务监听接口(默认：”localhost”)</td>
</tr>
<tr>
<td>Node</td>
<td>HTTPModules</td>
<td>null</td>
<td>经由HTTP RPC接口暴露的API modules列表</td>
</tr>
<tr>
<td>Node</td>
<td>WSPort</td>
<td>–wsport value</td>
<td>WS-RPC 服务监听端口(默认：8546)</td>
</tr>
<tr>
<td>Node</td>
<td>WSModules</td>
<td>null</td>
<td>经由websocket RPC接口暴露的API modules列表,如果modules是空的,所有指向public的RPC API端点将会被暴露</td>
</tr>
<tr>
<td>Node.P2P</td>
<td>MaxPeers</td>
<td>–maxpeers value</td>
<td>network peers的最大数目(如果设置为0,network失效)(默认：25)</td>
</tr>
<tr>
<td>Node.P2P</td>
<td>NoDiscovery</td>
<td>–nodiscover</td>
<td>使peer发现机制无效(手动peer添加)。<strong>这里设置为false,以便使用这个配置文件的新节点可以被发现</strong>。</td>
</tr>
<tr>
<td>Node.P2P</td>
<td>BootstrapNodes</td>
<td>–bootnodes value</td>
<td>逗号分割的P2P discovery bootstrap enode URLs(对于 light servers,设置 v4+v5 代替)。<strong>将上面启动bootnodes时获取的enode URL替换IP后添加到这里</strong>。</td>
</tr>
<tr>
<td>Node.P2P</td>
<td>BootstrapNodesV5</td>
<td>–bootnodesv5 value</td>
<td>逗号分割的P2P v5 discovery bootstrap enode URLs(light server,light nodes)</td>
</tr>
<tr>
<td>Node.P2P</td>
<td>StaticNodes</td>
<td>null</td>
<td>配置作为static nodes的节点enode URLs列表</td>
</tr>
<tr>
<td>Node.P2P</td>
<td>TrustedNodes</td>
<td>null</td>
<td>配置作为trusted nodes的节点enode URLs列表</td>
</tr>
<tr>
<td>Node.P2P</td>
<td>ListenAddr</td>
<td>–port</td>
<td>network监听端口(默认：30303)</td>
</tr>
<tr>
<td>Node.P2P</td>
<td>EnableMsgEvents</td>
<td>null</td>
<td>如果EnableMsgEvents被设置,服务器将发出PeerEvents,无论一个peer何时发送或接收一条信息</td>
</tr>
<tr>
<td>Dashboard</td>
<td>Host</td>
<td>null</td>
<td>启动dashboard服务的主机接口,如果这个域为空,则没有dashboard将被启动</td>
</tr>
<tr>
<td>Dashboard</td>
<td>Port</td>
<td>null</td>
<td>启动dashboard服务的TCP端口数字。默认0值是有效的,并将使用一个随机端口数字(用于临时节点)</td>
</tr>
<tr>
<td>Dashboard</td>
<td>Refresh</td>
<td>null</td>
<td>数据更新的刷新速率,chartEntry将被经常收集</td>
</tr>
</tbody>
</table>
<p>在你的操作目录创建config文件夹,将写好的配置文件<code>config.toml</code></p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="私链"><a href="#私链" class="headerlink" title="私链"></a>私链</h3><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//创世区块配置文件</span><br><span class="line">//genesis.json</span><br><span class="line">&#123;</span><br><span class="line">  "nonce": "0x0000000000000042",//nonce就是一个64位随机数用于挖矿</span><br><span class="line">  "difficulty": "0x020000", //设置当前区块的难度,如果难度过大,cpu挖矿就很难,这里设置较小难度</span><br><span class="line">  "mixhash": "0x0000000000000000000000000000000000000000000000000000000000000000",//与nonce配合用于挖矿</span><br><span class="line">  "coinbase": "0x0000000000000000000000000000000000000000",//矿工的账号</span><br><span class="line">  "timestamp": "0x00", //创世块的时间戳</span><br><span class="line">  "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",//上一个区块的hash值,因创世块所以是0</span><br><span class="line">  "extraData": "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",//附加信息</span><br><span class="line">  "gasLimit": "0x45c1e20beebc000",//该值设置对GAS的消耗总量限制</span><br><span class="line">  "config": &#123;</span><br><span class="line">      "homesteadBlock": 0,</span><br><span class="line">      "eip155Block": 0,</span><br><span class="line">      "eip158Block": 0</span><br><span class="line">  &#125;,</span><br><span class="line">  "alloc": &#123;</span><br><span class="line">    "9a926d9f8ee4a6a0853385ade430d61eb95cfc78":&#123;</span><br><span class="line">        "balance": "1050000000030000000000000000"</span><br><span class="line">    &#125;,</span><br><span class="line">    "00a9f34ab4976053b996fb5bb3c56a77579bebbe":&#123;</span><br><span class="line">        "balance": "30000000000000000000000000"</span><br><span class="line">    &#125;,</span><br><span class="line">    "d4df96d1bd86bf0c976aee416d182b590e60c44e":&#123;</span><br><span class="line">        "balance": "30000000000000000000000000"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">geth init genesis.json</span><br><span class="line"></span><br><span class="line">//默认为/用户目录/.ethereum目录</span><br><span class="line">geth --rpc --rpcaddr 0.0.0.0 --rpcapi &quot;net,web3,eth,personal&quot; --dev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--dev开发者模式</span><br><span class="line">//使用POA共识网络,默认预分配一个开发者账户并且会自动开启挖矿</span><br><span class="line">//开发者账号余额:1.15792089237316195423570985008687907853269984665640564039457584007913129639927e+77</span><br><span class="line">//--dev.period value  开发者模式下挖矿周期 (0 = 仅在交易时) (默认: 0,在有交易时才会挖矿)</span><br><span class="line">//内存上存储,不持久化磁盘</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--identity：</code>指定节点 ID；</li>
<li><code>--rpc：</code>表示开启 HTTP-RPC 服务；</li>
<li><code>--rpcaddr：</code>HTTP-RPC 服务ip地址；</li>
<li><code>--rpcport：</code>指定 HTTP-RPC 服务监听端口号(默认为 8545)；</li>
<li><code>--datadir：</code>指定区块链数据的存储位置；</li>
<li><code>--port：</code>指定和其他节点连接所用的端口号(默认为 30303)；</li>
<li><code>--nodiscover：</code>关闭节点发现机制,防止加入有同样初始配置的陌生节点。</li>
<li><code>--networkid：</code>设置当前区块链的网络ID,用于区分不同的网络,是一个数字</li>
</ul>
<h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><blockquote>
<p>获取区块的header&amp;body</p>
<p>从一开始的创始块开始校验每一个元素,需要下载所有区块数据信息。</p>
</blockquote>
<h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul>
<li>修改<code>config.toml</code>中<code>SyncMode = &quot;full&quot;</code>,后执行<code>geth --config config.toml</code></li>
<li>或者命令参数覆盖配置,<code>geth --syncmode full</code></li>
</ul>
<p>可适当附带以下参数</p>
<p><code>--cache 1024 --targetgaslimit 1500000 --gasprice 20000000000</code></p>
<p><code>cache</code>默认16M,建议设置为<code>1G(1024)~2G(2048)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">这种模式通过下载区块头和区块体来构建区块链</span><br><span class="line">Imported new chain segment               blocks=2 txs=323</span><br><span class="line"></span><br><span class="line">//insertChain 插入区块</span><br><span class="line">同步的过程就和普通的区块插入的过程一样</span><br><span class="line">包括区块头的验证,交易的验证,交易执行,账户状态的改变等操作维护出一系列的状态和收据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 验证区块头是有效的.</span><br><span class="line">abort, results := bc.engine.VerifyHeaders(bc, headers, seals)</span><br><span class="line"></span><br><span class="line">//验证区块体</span><br><span class="line">err = bc.Validator().ValidateBody(block)</span><br><span class="line"></span><br><span class="line">// 处理区块,生成交易,收据,日志等信息. </span><br><span class="line">// 实际上调用了state_processor.go 里面的 Process方法.</span><br><span class="line">receipts, logs, usedGas, err := bc.processor.Process(block, state, bc.vmConfig)</span><br><span class="line"></span><br><span class="line">// 再次验证,验证状态是否合法</span><br><span class="line">err = bc.Validator().ValidateState(block, parent, state, receipts, usedGas)</span><br><span class="line"></span><br><span class="line">// 写入区块和状态还有收据</span><br><span class="line">status, err := bc.WriteBlockAndState(block, receipts, state)</span><br></pre></td></tr></table></figure>
<h3 id="轻量级同步"><a href="#轻量级同步" class="headerlink" title="轻量级同步"></a>轻量级同步</h3><blockquote>
<p><code>light</code>模式,仅获取当前状态。验证元素需要向full节点发起相应的请求。</p>
</blockquote>
<h4 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h4><ul>
<li>修改<code>config.toml</code>中<code>SyncMode = &quot;light&quot;</code>,后执行<code>geth --config config.toml</code></li>
<li>或者命令参数覆盖配置,<code>geth --syncmode light</code>,其他配置则按照默认属性来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">轻量级同步操作导入区块头部</span><br><span class="line">Imported new block headers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//InsertHeaderChain  插入头部区块链</span><br><span class="line">后期请求转向fullnode之后</span><br><span class="line">收据和交易,fullnode只会返回Merkle树的路径和路径其他节点的信息</span><br><span class="line">lightnode会根据这些路径信息对比之前下载的header中root验证数据的准确性</span><br></pre></td></tr></table></figure>
<h3 id="快速同步"><a href="#快速同步" class="headerlink" title="快速同步"></a>快速同步</h3><blockquote>
<p>获取区块的header&amp;body在同步到当前块-1024之前不处理任何事务。</p>
<p>此后full节点一样进行后面的同步操作。</p>
</blockquote>
<h4 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h4><ul>
<li>修改<code>config.toml</code>中<code>SyncMode = &quot;fast&quot;</code>,后执行<code>geth --config config.toml</code></li>
<li>或者命令参数覆盖配置,<code>geth --syncmode fast</code>,其他配置则按照默认属性来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">快速同步操作导入区块头部,区块收据Merkle树和区块状态MPT树</span><br><span class="line">Imported new block headers</span><br><span class="line">Imported new block receipts</span><br><span class="line">Imported new state entries</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//经过一系列的fetch函数:fetch header、fetch body、 fetch receipt、process header、syncState</span><br><span class="line">//InsertHeaderChain  插入头部区块链</span><br><span class="line">//InsertReceiptChain 插入收据链</span><br><span class="line">//rawdb.WriteFastTrieProgress(stateDB,syncStatsState) 写入stateDb</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/ethereum/go-ethereum/pull/1889" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/pull/1889</a></p>
<p>概要：</p>
<ul>
<li><p>与原有的同步类似,下载组成区块链的区块头和区块体</p>
</li>
<li><p>类似于原有的同步,验证区块头的一致性(POW,总难度等)</p>
</li>
<li><p>下载由区块头定义的交易收据而非处理区块。</p>
</li>
<li><p>存储下载的区块链,沿着交易收据链启用所有历史查询</p>
</li>
<li><p>当链条达到最近的状态(头部 - 1024个块)时,暂停状态同步：</p>
<ul>
<li>获取由中心节点定义的区块的完整的MPT状态树</li>
<li>对于MPT状态树里面的每个账户,获取他的合约代码和中间存储的Trie</li>
</ul>
</li>
<li>MPT状态树下载成功后,将中心节点定义的区块作为当前的区块头</li>
<li>通过像原有的同步一样对其进行完全处理,导入所有剩余的块(1024)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过下载和验证整个头部链,我们可以保证传统同步的所有安全性,头部中包含的哈希(收据,状态尝试等)是有效的。 基于这些哈希,我们可以自信地下载交易收据和整个状态树。 </span><br><span class="line">另外,通过将中心节点(快速同步切换到传统区块同步)放置在当前区块头(1024块)的下方一点</span><br></pre></td></tr></table></figure>
<p>以上为2015年10月22日的merge提交</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minCheckedHeaders    = 1024</span><br><span class="line">minFullBlocks        = 1024</span><br><span class="line">头部控制1024个块于新版已砍掉</span><br><span class="line"></span><br><span class="line">fsMinFullBlocks      = 64</span><br></pre></td></tr></table></figure>
<p>后期最新的变成到同步当前的区块节点blockNumber(低于任何快速同步节点block - 64个块)</p>
<h3 id="Web3"><a href="#Web3" class="headerlink" title="Web3"></a>Web3</h3><ul>
<li><a href="https://github.com/ethereum/web3.py" target="_blank" rel="noopener">Web3Py</a></li>
<li><p><a href="https://github.com/ethereum/web3.js" target="_blank" rel="noopener">Web3Js</a></p>
</li>
<li><p><a href="https://github.com/web3j/web3j" target="_blank" rel="noopener">Web3J</a></p>
</li>
<li><a href="https://github.com/regcostajr/go-web3" target="_blank" rel="noopener">Web3GO</a></li>
</ul>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>blocks 2.4 million to 2.7 million</p>
<p>以太坊(ETH)网络遭受垃圾交易攻击属于DDoS (<code>Transaction spam attak</code>)。矿工和节点需要花费很长的时间(20-60秒)来处理一些区块。因为处理事务需要大约50,000个磁盘提取</p>
<p>造成这次攻击的原因是一个EXTCODESIZE 操作码,它具有相当低的gas价格,需要节点从磁盘中读取状态信息。攻击交易调用此操作码的频率大约是50000次每区块。</p>
<blockquote>
<p> 防攻击方案</p>
</blockquote>
<ul>
<li>缓存调整 <code>--cache 1024</code></li>
<li>设置挖矿最低gas限制<code>--targetgaslimit</code></li>
<li>挖矿接受交易的最低gas价格<code>gasprice</code></li>
<li>增加需要读取帐户状态(SLOAD,EXTCODESIZE,CALL等)的操作码的气体成本,至少500可能就足够了</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h3><h4 id="Trie树-字典树"><a href="#Trie树-字典树" class="headerlink" title="Trie树,字典树"></a>Trie树,字典树</h4><p><img src="/2018/09/11/blockchain/image-01.png" width="300px"></p>
<h4 id="Patricia-Trie树"><a href="#Patricia-Trie树" class="headerlink" title="Patricia Trie树"></a>Patricia Trie树</h4><blockquote>
<p>又被称为Radix Tree或紧凑前缀树(compact prefix tree)</p>
</blockquote>
<p><img src="/2018/09/11/blockchain/image-02.png" width="300px"></p>
<h4 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h4><blockquote>
<p>也叫Hash Tree</p>
</blockquote>
<p><img src="/2018/09/11/blockchain/image-04.png" alt="image"></p>
<h4 id="Merkle-Patricia-Tree树"><a href="#Merkle-Patricia-Tree树" class="headerlink" title="Merkle Patricia Tree树"></a>Merkle Patricia Tree树</h4><ul>
<li><p>空节点:空节点用来表示空串。</p>
</li>
<li><p>叶子节点(leaf):表示为[key,value]的一个键值对,其中key是key的一种特殊十六进制编码,value是value的RLP编码。</p>
</li>
<li>扩展节点(extension);也是[key,value]的一个键值对,但是这里的value是其他节点的hash值,这个hash可以被用来查询数据库中的节点。也就是说通过hash链接到其他节点。</li>
<li>分支节点(branch);因为MPT树中的key被编码成一种特殊的16进制的表示,再加上最后的value,所以分支节点是一个长度为17的list,前16个元素对应着key中的16个可能的十六进制字符,如果有一个[key,value]对在这个分支节点终止,最后一个元素代表一个值,即分支节点既可以搜索路径的终止也可以是路径的中间节点。</li>
</ul>
<p><img src="/2018/09/11/blockchain/image-13.png" alt="image-20180902162458572"></p>
<h5 id="key编码"><a href="#key编码" class="headerlink" title="key编码"></a>key编码</h5><p>三种编码方式分别为：</p>
<ol>
<li>Raw编码(原生的字符)</li>
<li>Hex编码(扩展的16进制编码)</li>
<li>Hex-Prefix编码(16进制前缀编码)</li>
</ol>
<h5 id="Raw编码"><a href="#Raw编码" class="headerlink" title="Raw编码"></a>Raw编码</h5><p>Raw编码就是原生的key值,不做任何改变。这种编码方式的key,是MPT对外提供接口的默认编码方式。</p>
<blockquote>
<p>例如一条key为“cat”,value为“dog”的数据项,其Raw编码就是[‘c’, ‘a’, ‘t’],换成ASCII表示方式就是[63, 61, 74]</p>
</blockquote>
<h5 id="Hex编码"><a href="#Hex编码" class="headerlink" title="Hex编码"></a>Hex编码</h5><p>在介绍分支节点的时候,我们介绍了,为了减少分支节点孩子的个数,需要将key的编码进行转换,将原key的高低四位分拆成两个字节进行存储。这种转换后的key的编码方式,就是Hex编码。</p>
<p>从Raw编码向Hex编码的转换规则是：</p>
<ul>
<li>将Raw编码的每个字符,根据高4位低4位拆成两个字节；</li>
<li>若该Key对应的节点存储的是真实的数据项内容(即该节点是叶子节点),则在末位添加一个ASCII值为16的字符作为终止标志符；</li>
<li>若该key对应的节点存储的是另外一个节点的哈希索引(即该节点是扩展节点),则不加任何字符；</li>
</ul>
<blockquote>
<p>key为“cat”, value为“dog”的数据项,其Hex编码为[3, 15, 3, 13, 4, 10, 16]</p>
</blockquote>
<p><em>Hex编码用于对内存中MPT树节点key进行编码</em></p>
<h3 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h3><p><img src="/2018/09/11/blockchain/image-09.png" alt="img"></p>
<p><img src="/2018/09/11/blockchain/image-10.png" alt="img"></p>
<p>以太坊的区块头包含三颗MPT树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三棵树求取根哈希,可以得到 区块头中的StateRoot,TransactionsRoot,ReceiptsRoot三个字段。</span><br><span class="line">这样就建立了交易和区块头字段的映射。</span><br><span class="line">当其他用户收到块根据块里的交易可以计算出收据和状态,</span><br><span class="line">计算三个根哈希后和区块头的三个字段进行验证,判断这是否为合法的块。</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 其中交易树和收据树是Merkle树,状态树是Merkle Patricia Tree</p>
</blockquote>
<h4 id="交易树"><a href="#交易树" class="headerlink" title="交易树"></a>交易树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">交易为:外部账户可以创建交易,用自己的私钥进行签名之发送消息给另一个外部账户或合约账户。</span><br><span class="line">两个外部账户之间传送的消息即为转账操作。</span><br><span class="line">从外部账户到合约账户的消息会激活合约账户的代码,执行各种操作,也就是我们常说的调用智能合约。</span><br><span class="line">可以通过向0地址发起交易来创建合约账户。</span><br><span class="line">交易包含以下主要字段：</span><br><span class="line">Type：交易的类型,</span><br><span class="line">ContractCreation(创建合约)还是MessageCall(调用合约或转账)</span><br><span class="line">Nonce: 发送地址的交易计数</span><br><span class="line">Value: 向目标账户发送的金额</span><br><span class="line">ReceiveAddress：接受方地址</span><br><span class="line">GasPrice:为交易付出的Gas价格</span><br><span class="line">Gas:为交易付出的Gas</span><br><span class="line">Data：交易的附加数据</span><br><span class="line">VRS:交易签名结构体</span><br></pre></td></tr></table></figure>
<h4 id="收据树"><a href="#收据树" class="headerlink" title="收据树"></a>收据树</h4><blockquote>
<p>收据树(交易执行过程中的一些数据)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">收据为:账户创建交易并向其它节点广播后,会被其它节点执行并放入准备打包的区块。在这个过程中会生成一个收据。</span><br><span class="line">收据的主要字段有：</span><br><span class="line">blockHash: 交易所在块的哈希值</span><br><span class="line">blockNumber: 交易在块的序号</span><br><span class="line">transactionHash: 交易的哈希值</span><br><span class="line">transactionIndex: 交易在块中的序号</span><br><span class="line">from: 发送者地址</span><br><span class="line">to: 接受者地址,为空时候表示创建合约</span><br><span class="line">cumulativeGasUsed: 执行完此交易时候,块内消耗的总的gas值</span><br><span class="line">gasUsed:本交易所消耗的gas</span><br><span class="line">contractAddress: 当此交易为创建合约时,表示所创建合约的地址,否则为空</span><br><span class="line">logs: 此交易的日志</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="状态树"><a href="#状态树" class="headerlink" title="状态树"></a>状态树</h4><blockquote>
<p>状态树(账号信息, 合约账户和用户账户)</p>
</blockquote>
<p><img src="/2018/09/11/blockchain/image-16.png" alt="statetransition.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">以太坊是基于状态的。多个账户的状态共同组成了以太坊的全局状态。</span><br><span class="line">账户分为两种：外部账户(Externally owned account),被私钥控制且没有任何代码与之关联。</span><br><span class="line">一个外部账户可以创建交易,来发送消息给另一个外部账户或合约账户</span><br><span class="line">以此来触发转账交易和智能合约的调用、创建</span><br><span class="line"></span><br><span class="line">合约账户(Contract account)被它们的合约代码控制且有代码与之关联。</span><br><span class="line">合约账户不可以自己发起一个交易,只能被外部账户调用</span><br></pre></td></tr></table></figure>
<p><img src="/2018/09/11/blockchain/image-11.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">每个账户包含了以下的字段：</span><br><span class="line">Balance：该账户的余额Nonce：该账户为外部账户时候,表示该账户创建的交易序号,每做一次交易都会加1。</span><br><span class="line">该账户为合约账户时候,表示该账户创建的合约序号,每创建一次会加1。</span><br><span class="line"></span><br><span class="line">CodeHash：该账户为合约账户时候,表示合约的哈希值,否则为空字符串的哈希</span><br><span class="line"></span><br><span class="line">StorageRoot：该账户的存储内容组成Merkle树后求得的根哈希值</span><br></pre></td></tr></table></figure>
<p><img src="/2018/09/11/blockchain/image-12.png" alt="img"></p>
<p>其中交易树和收据树是Merkle树,如上图所示。状态树是Merkle Patricia Tree</p>
<p><img src="/2018/09/11/blockchain/image-05.png" width="600px"></p>
<p>以上状态树最新状态会呈现在最近区块中,状态不变的则在以往区块中存储</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">	MainnetGenesisHash = common.HexToHash(&quot;0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3&quot;) // Mainnet genesis hash to enforce below configs on</span><br><span class="line">	TestnetGenesisHash = common.HexToHash(&quot;0x41941023680923e0fe4d74a34bdac8141f2540e3ae90623718e47d66d1ca4a2d&quot;) // Testnet genesis hash to enforce below configs on</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>绝大多数人在使用的网络被称为<strong>主网络(Mainnet)</strong>,用户在其上交易、构建智能合约,矿工在其上挖矿。</p>
<p>由于使用的人数众多,主网络的鲁棒性很强,能够对抗攻击,区块链也不易被篡改,因此主网络是具有功能的,其上的以太币是有价值的。</p>
<p>于是出于测试和学习的目的,便会有一小部分节点,使用与主网络不同的创世区块,开启一条全新的区块链,并在上面挖矿和测试,这就是<strong>测试网络(Testnet)</strong>。</p>
<blockquote>
<p>以太坊公开的测试网络共有4个,目前仍在运行的有3个。</p>
<p>每个网络都有自己的创世区块和名字,按开始运行时间的早晚</p>
</blockquote>
<ul>
<li><p><strong>Morden(已退役)</strong></p>
<p>自2015年7月开始运行。到2016年11月时,由于难度炸弹已经严重影响出块速度,不得不退役,重新开启一条新的区块链。Morden的共识机制为PoW</p>
</li>
<li><p><strong>Ropsten(</strong><a href="https://link.zhihu.com/?target=https%3A//ropsten.etherscan.io/" target="_blank" rel="noopener">区块链浏览器</a><strong>)</strong></p>
</li>
</ul>
<p>目前仍在运行,共识机制为PoW。测试网络上的以太币并无实际价值,因此Ropsten的挖矿难度很低,目前在755M左右,仅仅只有主网络的0.07%。这样低的难度一方面使一台普通笔记本电脑的CPU也可以挖出区块,获得测试网络上的以太币,方便开发人员测试软件,但是却不能阻止攻击。</p>
<p>2017年2月,Ropsten便遭到了一次利用测试网络的低难度进行的攻击,攻击者发送了千万级的垃圾交易,并逐渐把区块Gas上限从正常的4,700,000提高到了90,000,000,000,</p>
<ul>
<li><p><strong>Kovan(</strong><a href="https://link.zhihu.com/?target=https%3A//kovan.etherscan.io/" target="_blank" rel="noopener">区块链浏览器</a><strong>)</strong></p>
<p>为了解决测试网络中PoW共识机制的问题,以太坊钱包Parity的开发团队发起了一个新的测试网络Kovan。Kovan使用了权威证明(Proof-of-Authority)的共识机制,简称PoA。</p>
</li>
<li><p><strong>Rinkeby(</strong><a href="https://link.zhihu.com/?target=https%3A//rinkeby.etherscan.io/" target="_blank" rel="noopener">区块链浏览器</a><strong>)</strong></p>
</li>
</ul>
<p>Rinkeby也是以太坊官方提供的测试网络,使用PoA共识机制。与Kovan不同,以太坊团队提供了Rinkeby的PoA共识机制说明文档,理论上任何以太坊钱包都可以根据这个说明文档,支持Rinkeby测试网络,目前Rinkeby已经开始运行。 </p>
<blockquote>
<p> Rinkeby可通过水龙头获取以太币,有github账号+时间期限限制</p>
</blockquote>
<h3 id="网络映射"><a href="#网络映射" class="headerlink" title="网络映射"></a>网络映射</h3><p>nat是网络地址转换,nat下面有upnp和pmp两种网络协议。</p>
<p>以上协议可以把内网的IP+端口 映射为路由器的IP+端口,等于内网的程序有了外网的IP</p>
<p>公网的用户可以直接进行访问了。</p>
<p>但是这类场景限制在你的上层网关有运营商协商好的公网IP分配,否则你上层网络可能还在某一局域网络内</p>
<h3 id="UDP打洞"><a href="#UDP打洞" class="headerlink" title="UDP打洞"></a>UDP打洞</h3><p>natp是内部机器通过路由器也就是网关向外部发送网络请求时,路由器记住内部机器的ip和端口</p>
<p>同时跟真正发送数据的外网端口绑定,产生一个临时映射表,当收到外网数据以后通过这个映射表将数据转发给内部机器。</p>
<p>这个临时映射表时效性在几分钟到几个小时不等,看路由器而决定,natp必须先有内部机器向外部发起请求才会产生</p>
<p><img src="/2018/09/11/blockchain/eth-network.png" alt="image"></p>
<p>NAT设备的类型对于TCP穿越NAT,有着十分重要的影响,根据端口映射方式,NAT可分为如下4类,前3种NAT类型可统称为cone类型。</p>
<p>　　(1)全克隆( Full Cone) : NAT把所有来自相同内部IP地址和端口的请求映射到相同的外部IP地址和端口。任何一个外部主机均可通过该映射发送IP包到该内部主机。</p>
<p>　　(2)限制性克隆(Restricted Cone) : NAT把所有来自相同内部IP地址和端口的请求映射到相同的外部IP地址和端口。但是,只有当内部主机先给IP地址为X的外部主机发送IP包,该外部主机才能向该内部主机发送IP包。</p>
<p>　　(3)端口限制性克隆( Port Restricted Cone) :端口限制性克隆与限制性克隆类似,只是多了端口号的限制,即只有内部主机先向IP地址为X,端口号为P的外部主机发送1个IP包,该外部主机才能够把源端口号为P的IP包发送给该内部主机。</p>
<p>　　(4)对称式NAT ( Symmetric NAT) :这种类型的NAT与上述3种类型的不同,在于当同一内部主机使用相同的端口与不同地址的外部主机进行通信时, NAT对该内部主机的映射会有所不同。对称式NAT不保证所有会话中的私有地址和公开IP之间绑定的一致性。相反,它为每个新的会话分配一个新的端口号。</p>
<h3 id="节点协作"><a href="#节点协作" class="headerlink" title="节点协作"></a>节点协作</h3><p>在 P2P 文件共享的发展史上,出现过3种不同的技术路线(三代)。  　　</p>
<blockquote>
<p><strong>第1代</strong> 　　</p>
</blockquote>
<p>采用【中央服务器】的模式——每个节点都需要先连接到中央服务器,然后才能查找到自己想要的在哪里。</p>
<p>这种技术的最大缺点是——中央服务器成为整个 P2P 网络的【单点故障】</p>
<blockquote>
<p><strong>第2代</strong> 　　</p>
</blockquote>
<p>采用【广播】的模式——要找资料的时候,每个节点都向自己相连的【所有节点】进行询问；</p>
<p>被询问的节点如果不知道这个文件在哪里,就再次进行“广播”……如此往复,直至找到所需文件。 　　</p>
<p>这种技术的最大缺点是——会引发“广播风暴”并严重占用网络带宽,也会严重消耗节点的系统资源。</p>
<blockquote>
<p><strong>第3代</strong> 　　</p>
</blockquote>
<p>DHT 不但避免了第一代技术的【单点故障】,也避免了第二代技术的【广播风暴】。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DHT拿数据的散列值+节点ID作为 key,数据本身作为value。</span><br><span class="line">为防止hash碰撞,DHT都会采用大于等于 128 比特的散列值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">拓扑结构+路由算法+距离算法以及数据定位(put,get)</span><br></pre></td></tr></table></figure>
<h3 id="Kad协议"><a href="#Kad协议" class="headerlink" title="Kad协议"></a>Kad协议</h3><p>实际应用的 DHT 大部分都采用 Kad 及其变种</p>
<h4 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h4><p>一颗二叉树,所有key节点信息都被当作一颗二叉树的叶子</p>
<p>并且每一个节点的位置都由其 ID 值的最短前缀唯一的确定。 </p>
<p>Kad 使用 160 比特的散列算法如SHA1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">即使有几百万个节点,相比keyspace(2160)也只是很小很小很小的一个子集,key 的分布是【高度随机】的。</span><br><span class="line"></span><br><span class="line">因此也是【高度离散】的——任何两个 key都【不会】非常临近。 　　</span><br><span class="line"></span><br><span class="line">所以使用“最短唯一前缀”来处理 key 的二进制形式,得到的结果就会很短(远远小于 160 个数位)</span><br></pre></td></tr></table></figure>
<p><img src="/2018/09/11/blockchain/image-06.png" width="500px"></p>
<h4 id="距离算法"><a href="#距离算法" class="headerlink" title="距离算法"></a>距离算法</h4><p>节点 0011 通过连续查询来找到节点 1110  </p>
<p><img src="/2018/09/11/blockchain/image-07.png" width="500px"></p>
<p>判断两个节点 x,y 的距离远近是基于数学上的异或的二进制运算,d(x,y) = x⊕y,既 对应位相同时结果为 0,不同时结果为 1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	010101 </span><br><span class="line"></span><br><span class="line">XOR	110001 </span><br><span class="line"></span><br><span class="line">-------------------</span><br><span class="line">	100100</span><br></pre></td></tr></table></figure>
<p>则这两个节点的距离为 32+4=36。 </p>
<h4 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h4><p>对每一个节点,都可以【按照自己的视角】对整个二叉树进行拆分。 拆分的规则是：先从根节点开始,把【不包含】自己的那个子树拆分出来；然后在剩下的子树再拆分不包含自己的下一层子树；以此类推,直到最后只剩下自己。 </p>
<p><img src="/2018/09/11/blockchain/image-14.png" alt="image"></p>
<h5 id="K桶"><a href="#K桶" class="headerlink" title="K桶"></a>K桶</h5><p>每个节点在完成子树拆分后,只需要知道每个子树里面的一个节点,在每个网络节点上存储每个子树的一个节点就足以实现全遍历</p>
<p>但是考虑分布式系统的节点是动态变化,光知道一个显然是不够滴,需要知道多个才比较保险。所以形成了K桶结构</p>
<p><img src="/2018/09/11/blockchain/image-15.png" alt="image"></p>
<p>以以太坊为例,有256位的散列所以共256个K桶,而且每个K桶包含16个节点。</p>
<blockquote>
<p> K-桶(K-bucket)的刷新机制</p>
</blockquote>
<ul>
<li><ol>
<li>主动收集节点 　　</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任何节点都可以主动发起“查询节点”的请求(对应于协议类型 FIND_NODE),从而刷新 K 桶中的节点信息(下面聊“节点的加入”时,会提及这种)</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="2">
<li>被动收集节点 　　<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果收到其它节点发来的请求(协议类型 FIND_NODE 或 FIND_VALUE),会把对方的 ID 加入自己的某个 K 桶中。</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="3">
<li>探测失效节点 　　<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kad 还是支持一种探测机制(协议类型 PING),可以判断某个 ID 的节点是否在线。因此就可以定期探测路由表中的每一个节点,然后把下线的节点从路由表中干掉。</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h5 id="节点搜索"><a href="#节点搜索" class="headerlink" title="节点搜索"></a>节点搜索</h5><ul>
<li>1:任何一个新来的节点(假设叫 A),需要先跟 DHT 中已有的任一节点(假设叫 B)建立连接。 　　</li>
<li>2:A 随机生成一个散列值作为自己的 ID(对于足够大的散列值空间,ID 相同的概率忽略不计) 　　</li>
<li>3:A 向 B 发起一个查询请求(协议类型 FIND_NODE),请求的 ID 是自己(通俗地说,就是查询自己) 　　</li>
<li>4:B 收到该请求之后,(如前面所说)会先把 A 的 ID 加入自己的某个 K 桶中。 　　然后,根据 FIND_NODE 协议的约定,B 会找到【K个】最接近 A 的节点,并返回给 A。 　　(B 怎么知道哪些节点接近 A 捏？这时候,【用 XOR 表示距离】的算法就发挥作用啦) 　　</li>
<li>5:A 收到这 K 个节点的 ID 之后,(仅仅根据这批 ID 的值)就可以开始初始化自己的 K 桶。 　　</li>
<li>6:然后 A 会继续向刚刚拿到的这批节点发送查询请求(协议类型 FIND_NODE),如此往复(递归),直至 A 建立了足够详细的路由表。</li>
</ul>
<p><br><br><br></p>
<h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><p>共识算法的选择与应用场景高度相关</p>
<blockquote>
<p>可信环境使用paxos 或者raft<br>带许可的联盟可使用pbft<br>非许可链可以是pow,pos,ripple共识等   </p>
</blockquote>
<p>根据对手方信任度分级,自由选择共识机制,这样才是真的最优   </p>
<blockquote>
<p>共识相关具体问题如下?       </p>
</blockquote>
<ul>
<li>具体使用哪种算法选择出块节点(PoW与PoS之争)?</li>
<li>哪些节点在接收到数据块时该如何验证(PoS与DPoS之争)?</li>
<li>节点之间的数据以什么方式进行传播(DAG与链式结构之争)?</li>
<li>以及如何确保一条交易被大多数参与节点所接受(PBFT、Paxos、RAFT)?</li>
<li>以及各种分叉解决方案等算法之争?</li>
</ul>
<h2 id="POW"><a href="#POW" class="headerlink" title="POW"></a>POW</h2><blockquote>
<p>工作量证明(Proof of Work)   </p>
</blockquote>
<ul>
<li>矿工解答谜题以“挖出”一个区块并加入到区块链上。</li>
<li>这一个过程要求大量的电力和运算。在系统中,这些谜题已经被设计成艰难而又繁重。</li>
<li>当一个矿工解决一个谜题的时候,他们发布他们的区块到网络上接受验证。</li>
<li>验证一个区块是否属于一条链是一个非常简单的过程。</li>
</ul>
<p>解决谜题是困难的,但检查答案是否正确则是容易的。<br>它也是比特币(Bitcoin)和Ethereum(直到现在)一直在用的系统。   </p>
<p>矿池可以联合起来并在比特币网络上发动51%攻击。<br>所以以太坊开始关注权益证明    </p>
<h2 id="POS"><a href="#POS" class="headerlink" title="POS"></a>POS</h2><blockquote>
<p>权益证明:将让整个挖矿过程虚拟化,并以验证者作为出块节点。  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PoS更倾向于类似Raft投票机制,通过固定时间协调所有节点参与投票</span><br><span class="line">根据某种规则(例如持有代币数量、或提供存储空间大小等)</span><br><span class="line">判断每个节点的权重,最后选取权重最高的节点作为检查点节点。</span><br><span class="line">而在数据库一致性选择的Raft算法中,普遍会根据最新事务号作为权重</span><br><span class="line">多个节点之间优先选择包含最新事务记录的节点作为主节点。</span><br></pre></td></tr></table></figure>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li>验证者必须锁定一些他们拥有的币作为保证金。</li>
<li>在此之后,他们将开始验证区块。同时,当他们发现一个他们认为可以被加到链上的区块时,他们会通过下赌注来验证它。</li>
<li>如果该区块成功上链,验证者就将得到一个与他们的赌注成比例的奖励。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote>
<p>如果出现分叉,红蓝两条链<br>如果你是一个验证者,你可以简单地把钱投到红蓝两条链上<br>完全无需担心间接的不良后果。不管发生什么事,你都总不会失去任何东西,不管你的行为有多恶意</p>
</blockquote>
<p>所以引出<code>Casper</code>  </p>
<h3 id="Casper"><a href="#Casper" class="headerlink" title="Casper"></a>Casper</h3><blockquote>
<p>一种基于保证金的经济激励共识协议<br>Csaper是以太坊选择实行的PoS协议  </p>
</blockquote>
<ul>
<li>协议中的节点,作为“锁定保证金的验证人(bonded validators)”</li>
</ul>
<blockquote>
<p>必须先缴纳保证金(这一步叫做锁定保证金,”bonding”)才可以参与出块和共识形成</p>
</blockquote>
<ul>
<li>如果一个验证人作出了任何Casper认为“无效”的事情,他的保证金将被罚没,出块和参与共识的权利也会被取消。</li>
</ul>
<h4 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作?"></a>如何工作?</h4><p>权益证明在Casper下是如何工作的</p>
<ul>
<li>验证者押下一定比例的他们拥有的以太币作为保证金。  </li>
<li>然后他们将开始验证区块。也就是说,当他们发现一个可以他们认为可以被加到链上的区块的时候,他们将以通过押下赌注来验证它。     </li>
<li>如果该区块被加到链上,然后验证者们将得到一个跟他们的赌注成比例的奖励。      </li>
<li>但是如果一个验证者采用一种恶意的方式行动、试图做“无利害关系”的事,他们将立即遭到惩罚,他们所有的权益都会被砍掉。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://hyperledgercn.github.io" target="_blank" rel="noopener">超级账本中文指南</a></li>
</ul>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2018/09/11/blockchain/';
        this.page.title = '区块链Eth,SkyCoin解析';
        this.page.identifier = '2018/09/11/blockchain/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
