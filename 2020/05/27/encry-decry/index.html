<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>加密与解密[笔记篇] | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="加密与解密相关详解笔记  
基础篇逆向分析技术
静态分析

通过反汇编得到程序清单, 前后的程序片段所完成的功能宏观了解软件的编程思路, 静态分析工具有IDA

动态分析 

执行时往往要使用前一模块处理的结果, 不同的结果在不同的条件下有不同的分支和转移
许多加密软件在一段很短的程序区间是明文, 动态调试可对这一块进行解密反汇编 
ASCII与Unicode字符集pediy的ASCII码和Unicode码各是以下情况 
ASCII: 70h 65h 64h 69h 79hUnicode: 00">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Golang</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">System</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">BigData</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/ai">Math/AI</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/book">计划</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mesos/">Mesos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scikit/">Scikit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SofaMesh/">SofaMesh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TroubleShoot/">TroubleShoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows内核/">Windows内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows内核驱动/">Windows内核驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内网穿透/">内网穿透</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础篇"><span class="toc-number">1.</span> <span class="toc-text">基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#逆向分析技术"><span class="toc-number">1.1.</span> <span class="toc-text">逆向分析技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASCII与Unicode字符集"><span class="toc-number">1.2.</span> <span class="toc-text">ASCII与Unicode字符集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows操作系统"><span class="toc-number">1.3.</span> <span class="toc-text">Windows操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Win32Api函数"><span class="toc-number">1.3.1.</span> <span class="toc-text">Win32Api函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WOW64"><span class="toc-number">1.3.2.</span> <span class="toc-text">WOW64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows消息机制"><span class="toc-number">1.3.3.</span> <span class="toc-text">Windows消息机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟内存"><span class="toc-number">1.3.4.</span> <span class="toc-text">虚拟内存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#调试篇"><span class="toc-number">2.</span> <span class="toc-text">调试篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#动态分析技术"><span class="toc-number">2.1.</span> <span class="toc-text">动态分析技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OllyDbg调试器"><span class="toc-number">2.1.1.</span> <span class="toc-text">OllyDbg调试器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#算法分析"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">算法分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用断点"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">常用断点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#INT3-断点"><span class="toc-number">2.1.1.2.1.</span> <span class="toc-text">INT3 断点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#硬件断点"><span class="toc-number">2.1.1.2.2.</span> <span class="toc-text">硬件断点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存断点"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">内存断点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存访问一次性断点"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">内存访问一次性断点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消息断点"><span class="toc-number">2.1.1.5.</span> <span class="toc-text">消息断点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#条件断点"><span class="toc-number">2.1.1.6.</span> <span class="toc-text">条件断点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#按寄存器条件中断"><span class="toc-number">2.1.1.6.1.</span> <span class="toc-text">按寄存器条件中断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#按存储器条件中断"><span class="toc-number">2.1.1.6.2.</span> <span class="toc-text">按存储器条件中断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x64dbg-调试器"><span class="toc-number">2.1.2.</span> <span class="toc-text">x64dbg 调试器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MDebug调试器"><span class="toc-number">2.1.3.</span> <span class="toc-text">MDebug调试器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WinDbg调试器"><span class="toc-number">2.1.4.</span> <span class="toc-text">WinDbg调试器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态分析技术"><span class="toc-number">2.2.</span> <span class="toc-text">静态分析技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件类型分析"><span class="toc-number">2.2.1.</span> <span class="toc-text">文件类型分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反汇编引擎"><span class="toc-number">2.2.2.</span> <span class="toc-text">反汇编引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Udis86"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">Udis86</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeaEngine"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">BeaEngine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OllyDbg的ODDisasm"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">OllyDbg的ODDisasm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AsmJit"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">AsmJit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDAPro静态反汇编"><span class="toc-number">2.2.3.</span> <span class="toc-text">IDAPro静态反汇编</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态分析技术应用实例"><span class="toc-number">2.2.4.</span> <span class="toc-text">静态分析技术应用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解密初步"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">解密初步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#逆向工程初步"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">逆向工程初步</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解密篇"><span class="toc-number">3.</span> <span class="toc-text">解密篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#逆向分析技术-1"><span class="toc-number">3.1.</span> <span class="toc-text">逆向分析技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32位软件逆向"><span class="toc-number">3.1.1.</span> <span class="toc-text">32位软件逆向</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#启动函数"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">启动函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据结构"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚函数"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#控制语句"><span class="toc-number">3.1.1.5.</span> <span class="toc-text">控制语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#循环语句"><span class="toc-number">3.1.1.6.</span> <span class="toc-text">循环语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数学运算符"><span class="toc-number">3.1.1.7.</span> <span class="toc-text">数学运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文字字符串"><span class="toc-number">3.1.1.8.</span> <span class="toc-text">文字字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指令修改技巧"><span class="toc-number">3.1.1.9.</span> <span class="toc-text">指令修改技巧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64未软件逆向"><span class="toc-number">3.1.2.</span> <span class="toc-text">64未软件逆向</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#寄存器"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数-1"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据结构-1"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#循环语句-1"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">循环语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数学运算符-1"><span class="toc-number">3.1.2.5.</span> <span class="toc-text">数学运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚函数-1"><span class="toc-number">3.1.2.6.</span> <span class="toc-text">虚函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#各类保护技术"><span class="toc-number">3.2.</span> <span class="toc-text">各类保护技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#序列号保护方式"><span class="toc-number">3.2.1.</span> <span class="toc-text">序列号保护方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#警告窗口"><span class="toc-number">3.2.2.</span> <span class="toc-text">警告窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间限制"><span class="toc-number">3.2.3.</span> <span class="toc-text">时间限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#菜单功能限制"><span class="toc-number">3.2.4.</span> <span class="toc-text">菜单功能限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KeyFile保护"><span class="toc-number">3.2.5.</span> <span class="toc-text">KeyFile保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络验证"><span class="toc-number">3.2.6.</span> <span class="toc-text">网络验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#光盘检测"><span class="toc-number">3.2.7.</span> <span class="toc-text">光盘检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加密算法"><span class="toc-number">3.3.</span> <span class="toc-text">加密算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单向散列算法"><span class="toc-number">3.3.1.</span> <span class="toc-text">单向散列算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MD5"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">MD5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHA"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">SHA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SM3"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">SM3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对称加密算法"><span class="toc-number">3.3.2.</span> <span class="toc-text">对称加密算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RC4流密码"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">RC4流密码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TEA算法"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">TEA算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IDEA算法"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">IDEA算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BlowFish算法"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">BlowFish算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AES算法"><span class="toc-number">3.3.2.5.</span> <span class="toc-text">AES算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SM4分组密码算法"><span class="toc-number">3.3.2.6.</span> <span class="toc-text">SM4分组密码算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#公开密钥加密算法"><span class="toc-number">3.3.3.</span> <span class="toc-text">公开密钥加密算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RSA算法"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">RSA算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ElGamal公钥算法"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">ElGamal公钥算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DSA数字签名算法"><span class="toc-number">3.3.3.3.</span> <span class="toc-text">DSA数字签名算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#椭圆曲线密码"><span class="toc-number">3.3.3.4.</span> <span class="toc-text">椭圆曲线密码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SM2算法"><span class="toc-number">3.3.3.5.</span> <span class="toc-text">SM2算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他算法"><span class="toc-number">3.3.4.</span> <span class="toc-text">其他算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CRC32算法"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">CRC32算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Base64编码"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">Base64编码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见加密库与识别"><span class="toc-number">3.3.5.</span> <span class="toc-text">常见加密库与识别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Miracl大数运算库"><span class="toc-number">3.3.5.1.</span> <span class="toc-text">Miracl大数运算库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FGInt"><span class="toc-number">3.3.5.2.</span> <span class="toc-text">FGInt</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#系统篇"><span class="toc-number">4.</span> <span class="toc-text">系统篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows内核基础"><span class="toc-number">4.1.</span> <span class="toc-text">Windows内核基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内核理论基础"><span class="toc-number">4.1.1.</span> <span class="toc-text">内核理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#权限级别"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">权限级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存空间布局"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">内存空间布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Wndows与内核启动过程"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">Wndows与内核启动过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Window-R3与R0通信"><span class="toc-number">4.1.1.4.</span> <span class="toc-text">Window R3与R0通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内核函数"><span class="toc-number">4.1.1.5.</span> <span class="toc-text">内核函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内核驱动模块"><span class="toc-number">4.1.1.6.</span> <span class="toc-text">内核驱动模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核重要数据结构"><span class="toc-number">4.1.2.</span> <span class="toc-text">内核重要数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内核对象"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">内核对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSDT"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">SSDT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TEB"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">TEB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PEB"><span class="toc-number">4.1.2.4.</span> <span class="toc-text">PEB</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows下的异常处理"><span class="toc-number">4.2.</span> <span class="toc-text">Windows下的异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异常处理的基本概念"><span class="toc-number">4.2.1.</span> <span class="toc-text">异常处理的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEH的概念及基本知识"><span class="toc-number">4.2.2.</span> <span class="toc-text">SEH的概念及基本知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEH异常处理程序原理及涉及"><span class="toc-number">4.2.3.</span> <span class="toc-text">SEH异常处理程序原理及涉及</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#向量化异常处理"><span class="toc-number">4.2.4.</span> <span class="toc-text">向量化异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x64平台上的异常处理"><span class="toc-number">4.2.5.</span> <span class="toc-text">x64平台上的异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常处理程序涉及中的注意事项"><span class="toc-number">4.2.6.</span> <span class="toc-text">异常处理程序涉及中的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常处理的实际应用"><span class="toc-number">4.2.7.</span> <span class="toc-text">异常处理的实际应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Win32调试Api"><span class="toc-number">4.3.</span> <span class="toc-text">Win32调试Api</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调试相关函数说明"><span class="toc-number">4.3.1.</span> <span class="toc-text">调试相关函数说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试事件"><span class="toc-number">4.3.2.</span> <span class="toc-text">调试事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建并跟踪进程"><span class="toc-number">4.3.3.</span> <span class="toc-text">创建并跟踪进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试循环体"><span class="toc-number">4.3.4.</span> <span class="toc-text">调试循环体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理调试事件"><span class="toc-number">4.3.5.</span> <span class="toc-text">处理调试事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程环境"><span class="toc-number">4.3.6.</span> <span class="toc-text">线程环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将代码注入进程"><span class="toc-number">4.3.7.</span> <span class="toc-text">将代码注入进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PE文件格式"><span class="toc-number">4.4.</span> <span class="toc-text">PE文件格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PE的概念"><span class="toc-number">4.4.1.</span> <span class="toc-text">PE的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基地址"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">基地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟地址"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">虚拟地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#相对虚拟地址"><span class="toc-number">4.4.1.3.</span> <span class="toc-text">相对虚拟地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文件偏移地址"><span class="toc-number">4.4.1.4.</span> <span class="toc-text">文件偏移地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MS-DOS头部"><span class="toc-number">4.4.2.</span> <span class="toc-text">MS-DOS头部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PE文件头"><span class="toc-number">4.4.3.</span> <span class="toc-text">PE文件头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区块"><span class="toc-number">4.4.4.</span> <span class="toc-text">区块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#区块表"><span class="toc-number">4.4.4.1.</span> <span class="toc-text">区块表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常见区块与区块合并"><span class="toc-number">4.4.4.2.</span> <span class="toc-text">常见区块与区块合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#区块的对齐值"><span class="toc-number">4.4.4.3.</span> <span class="toc-text">区块的对齐值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文件偏移与虚拟地址转换"><span class="toc-number">4.4.4.4.</span> <span class="toc-text">文件偏移与虚拟地址转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输入表"><span class="toc-number">4.4.5.</span> <span class="toc-text">输入表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#输入函数的调用"><span class="toc-number">4.4.5.1.</span> <span class="toc-text">输入函数的调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输入表的结构"><span class="toc-number">4.4.5.2.</span> <span class="toc-text">输入表的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输入地址表"><span class="toc-number">4.4.5.3.</span> <span class="toc-text">输入地址表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输入表实例分析"><span class="toc-number">4.4.5.4.</span> <span class="toc-text">输入表实例分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绑定输入"><span class="toc-number">4.4.6.</span> <span class="toc-text">绑定输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输出表"><span class="toc-number">4.4.7.</span> <span class="toc-text">输出表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#输出表的结构"><span class="toc-number">4.4.7.1.</span> <span class="toc-text">输出表的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输出表实例分析"><span class="toc-number">4.4.7.2.</span> <span class="toc-text">输出表实例分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基址重定位"><span class="toc-number">4.4.8.</span> <span class="toc-text">基址重定位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基址重定位的概念"><span class="toc-number">4.4.8.1.</span> <span class="toc-text">基址重定位的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基址重定位表的结构"><span class="toc-number">4.4.8.2.</span> <span class="toc-text">基址重定位表的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基址重定位表实例分析"><span class="toc-number">4.4.8.3.</span> <span class="toc-text">基址重定位表实例分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#资源"><span class="toc-number">4.4.9.</span> <span class="toc-text">资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#资源结构"><span class="toc-number">4.4.9.1.</span> <span class="toc-text">资源结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#资源结构实例分析"><span class="toc-number">4.4.9.2.</span> <span class="toc-text">资源结构实例分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#资源编辑工具"><span class="toc-number">4.4.9.3.</span> <span class="toc-text">资源编辑工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS初始化"><span class="toc-number">4.4.10.</span> <span class="toc-text">TLS初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试目录"><span class="toc-number">4.4.11.</span> <span class="toc-text">调试目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#延迟载入数据"><span class="toc-number">4.4.12.</span> <span class="toc-text">延迟载入数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试目录-1"><span class="toc-number">4.4.13.</span> <span class="toc-text">调试目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#延迟载入数据-1"><span class="toc-number">4.4.14.</span> <span class="toc-text">延迟载入数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序异常数据"><span class="toc-number">4.4.15.</span> <span class="toc-text">程序异常数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注入技术"><span class="toc-number">4.5.</span> <span class="toc-text">注入技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dll注入技术"><span class="toc-number">4.5.1.</span> <span class="toc-text">Dll注入技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dll注入应用"><span class="toc-number">4.5.2.</span> <span class="toc-text">Dll注入应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dll注入的防范"><span class="toc-number">4.5.3.</span> <span class="toc-text">Dll注入的防范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#驱动层防范"><span class="toc-number">4.5.3.1.</span> <span class="toc-text">驱动层防范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#应用层防范"><span class="toc-number">4.5.3.2.</span> <span class="toc-text">应用层防范</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hook技术"><span class="toc-number">4.6.</span> <span class="toc-text">Hook技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook概述"><span class="toc-number">4.6.1.</span> <span class="toc-text">Hook概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Address-Hook"><span class="toc-number">4.6.1.1.</span> <span class="toc-text">Address Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PE的IAT"><span class="toc-number">4.6.1.1.1.</span> <span class="toc-text">PE的IAT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PE的EAT"><span class="toc-number">4.6.1.1.2.</span> <span class="toc-text">PE的EAT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#user32-dll的回调函数表"><span class="toc-number">4.6.1.1.3.</span> <span class="toc-text">user32.dll的回调函数表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IDT-系统的中断描述符表"><span class="toc-number">4.6.1.1.4.</span> <span class="toc-text">IDT(系统的中断描述符表)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SSDT和Shadow-SSDT"><span class="toc-number">4.6.1.1.5.</span> <span class="toc-text">SSDT和Shadow SSDT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-类的虚函数表"><span class="toc-number">4.6.1.1.6.</span> <span class="toc-text">C++类的虚函数表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#COM接口的功能函数列表"><span class="toc-number">4.6.1.1.7.</span> <span class="toc-text">COM接口的功能函数列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DRIVER-OBJECT中的MajorFunction及FastIo派遣例程地址"><span class="toc-number">4.6.1.1.8.</span> <span class="toc-text">DRIVER_OBJECT中的MajorFunction及FastIo派遣例程地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StartIo等特殊例程的地址"><span class="toc-number">4.6.1.1.9.</span> <span class="toc-text">StartIo等特殊例程的地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OBJECT-TYPE中-OBJECT-TYPE-INITIALIZER中包含的各种处理过程"><span class="toc-number">4.6.1.1.10.</span> <span class="toc-text">OBJECT_TYPE中_OBJECT_TYPE_INITIALIZER中包含的各种处理过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#特殊寄存器中的地址"><span class="toc-number">4.6.1.1.11.</span> <span class="toc-text">特殊寄存器中的地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#特殊的函数指针"><span class="toc-number">4.6.1.1.12.</span> <span class="toc-text">特殊的函数指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inline-Hook"><span class="toc-number">4.6.1.2.</span> <span class="toc-text">Inline Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-jmp-XXxXXXxx-5字节"><span class="toc-number">4.6.1.2.1.</span> <span class="toc-text">1. jmp XXxXXXxx (5字节)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-push-xxxxxx-rein-6字节"><span class="toc-number">4.6.1.2.2.</span> <span class="toc-text">2. push xxxxxx/rein ( 6字节)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-mov-eax-xxxxxxxx-jmp-eax-7字节"><span class="toc-number">4.6.1.2.3.</span> <span class="toc-text">3. mov eax, xxxxxxxx/jmp eax(7字节)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-call-Hook-更换指令或输入表"><span class="toc-number">4.6.1.2.4.</span> <span class="toc-text">4. call Hook(更换指令或输入表)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-HotPatch-Hook"><span class="toc-number">4.6.1.2.5.</span> <span class="toc-text">5. HotPatch Hook</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基于异常处理的Hook"><span class="toc-number">4.6.1.3.</span> <span class="toc-text">基于异常处理的Hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不是Hook的Hook"><span class="toc-number">4.6.1.4.</span> <span class="toc-text">不是Hook的Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PE病毒感染-修改了EntryPoint"><span class="toc-number">4.6.1.4.1.</span> <span class="toc-text">PE病毒感染,修改了EntryPoint</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#系统回调机制与分层模型"><span class="toc-number">4.6.1.4.2.</span> <span class="toc-text">系统回调机制与分层模型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#案例"><span class="toc-number">4.6.1.5.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IAT-Hook篡改MessageBox消息"><span class="toc-number">4.6.1.5.1.</span> <span class="toc-text">IAT Hook篡改MessageBox消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Inline-Hook篡改MessageBox消息"><span class="toc-number">4.6.1.5.2.</span> <span class="toc-text">Inline Hook篡改MessageBox消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook的位置挑选"><span class="toc-number">4.6.2.</span> <span class="toc-text">Hook的位置挑选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook的典型过程"><span class="toc-number">4.6.3.</span> <span class="toc-text">Hook的典型过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Address-Hook的实施过程"><span class="toc-number">4.6.3.1.</span> <span class="toc-text">Address Hook的实施过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inline-Hook的实施过程"><span class="toc-number">4.6.3.2.</span> <span class="toc-text">Inline Hook的实施过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基于异常处理的Hook的实施过程"><span class="toc-number">4.6.3.3.</span> <span class="toc-text">基于异常处理的Hook的实施过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二次Hook的注意事项"><span class="toc-number">4.6.3.4.</span> <span class="toc-text">二次Hook的注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通过Hook引擎的实现"><span class="toc-number">4.6.3.5.</span> <span class="toc-text">通过Hook引擎的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Detour函数的用法"><span class="toc-number">4.6.4.</span> <span class="toc-text">Detour函数的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook中的注意事项"><span class="toc-number">4.6.5.</span> <span class="toc-text">Hook中的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook在x64平台上的新问题"><span class="toc-number">4.6.6.</span> <span class="toc-text">Hook在x64平台上的新问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook技术的应用"><span class="toc-number">4.6.7.</span> <span class="toc-text">Hook技术的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hook的检测、恢复"><span class="toc-number">4.6.7.1.</span> <span class="toc-text">Hook的检测、恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hook的对抗"><span class="toc-number">4.6.7.2.</span> <span class="toc-text">Hook的对抗</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#漏洞篇"><span class="toc-number">5.</span> <span class="toc-text">漏洞篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞分析技术"><span class="toc-number">5.1.</span> <span class="toc-text">漏洞分析技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#软件漏洞原理"><span class="toc-number">5.1.1.</span> <span class="toc-text">软件漏洞原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#缓冲区溢出漏洞"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">缓冲区溢出漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#整型溢出漏洞"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">整型溢出漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UAF漏洞"><span class="toc-number">5.1.1.3.</span> <span class="toc-text">UAF漏洞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ShellCode"><span class="toc-number">5.1.2.</span> <span class="toc-text">ShellCode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ShellCode的结构"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">ShellCode的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ShellCode通用技术"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">ShellCode通用技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实战ShellCode的编写"><span class="toc-number">5.1.2.3.</span> <span class="toc-text">实战ShellCode的编写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞利用"><span class="toc-number">5.1.3.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#漏洞利用基本技术"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">漏洞利用基本技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#漏洞利用高级技术"><span class="toc-number">5.1.3.2.</span> <span class="toc-text">漏洞利用高级技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞样本"><span class="toc-number">5.1.4.</span> <span class="toc-text">漏洞样本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#样本分析"><span class="toc-number">5.1.5.</span> <span class="toc-text">样本分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#准备工作"><span class="toc-number">5.1.5.1.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态分析"><span class="toc-number">5.1.5.2.</span> <span class="toc-text">静态分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态调试"><span class="toc-number">5.1.5.3.</span> <span class="toc-text">动态调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#追根溯源"><span class="toc-number">5.1.5.4.</span> <span class="toc-text">追根溯源</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#脱壳篇"><span class="toc-number">6.</span> <span class="toc-text">脱壳篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#专用加密软件"><span class="toc-number">6.1.</span> <span class="toc-text">专用加密软件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#认识壳"><span class="toc-number">6.1.1.</span> <span class="toc-text">认识壳</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#壳的引擎"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">壳的引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#压缩引擎"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">压缩引擎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#压缩壳"><span class="toc-number">6.1.2.</span> <span class="toc-text">压缩壳</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UPX"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">UPX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ASPack"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">ASPack</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加密壳"><span class="toc-number">6.1.3.</span> <span class="toc-text">加密壳</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ASProtect"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">ASProtect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Armadillo"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">Armadillo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EXECryptor"><span class="toc-number">6.1.3.3.</span> <span class="toc-text">EXECryptor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Themida"><span class="toc-number">6.1.3.4.</span> <span class="toc-text">Themida</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟机保护软件"><span class="toc-number">6.1.4.</span> <span class="toc-text">虚拟机保护软件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟机介绍"><span class="toc-number">6.1.4.1.</span> <span class="toc-text">虚拟机介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VMProtect简介"><span class="toc-number">6.1.4.2.</span> <span class="toc-text">VMProtect简介</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#脱壳技术"><span class="toc-number">6.2.</span> <span class="toc-text">脱壳技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本知识"><span class="toc-number">6.2.1.</span> <span class="toc-text">基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#壳的加载过程"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">壳的加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#脱壳机"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">脱壳机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#手动脱壳"><span class="toc-number">6.2.1.3.</span> <span class="toc-text">手动脱壳</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寻找OEP"><span class="toc-number">6.2.2.</span> <span class="toc-text">寻找OEP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#根据跨段指令寻找OEP"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">根据跨段指令寻找OEP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存访问断点寻找OEP"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">内存访问断点寻找OEP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#根据栈平衡原理寻找OEP"><span class="toc-number">6.2.2.3.</span> <span class="toc-text">根据栈平衡原理寻找OEP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#根据编译语言特点寻找OEP"><span class="toc-number">6.2.2.4.</span> <span class="toc-text">根据编译语言特点寻找OEP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抓取内存映像"><span class="toc-number">6.2.3.</span> <span class="toc-text">抓取内存映像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dump原理"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">Dump原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反Dump技术"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">反Dump技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重建输入表"><span class="toc-number">6.2.4.</span> <span class="toc-text">重建输入表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#输入表重建的原理"><span class="toc-number">6.2.4.1.</span> <span class="toc-text">输入表重建的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#确定IAT的地址和大小"><span class="toc-number">6.2.4.2.</span> <span class="toc-text">确定IAT的地址和大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#根据IAT的地址和大小"><span class="toc-number">6.2.4.3.</span> <span class="toc-text">根据IAT的地址和大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#根据IAT重建输入表"><span class="toc-number">6.2.4.4.</span> <span class="toc-text">根据IAT重建输入表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用Import-REC重建输入表"><span class="toc-number">6.2.4.5.</span> <span class="toc-text">用Import REC重建输入表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输入表加密概括"><span class="toc-number">6.2.4.6.</span> <span class="toc-text">输入表加密概括</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dll文件脱壳"><span class="toc-number">6.2.5.</span> <span class="toc-text">Dll文件脱壳</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#寻找OEP-1"><span class="toc-number">6.2.5.1.</span> <span class="toc-text">寻找OEP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dump映像文件"><span class="toc-number">6.2.5.2.</span> <span class="toc-text">Dump映像文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重建Dll的输入表"><span class="toc-number">6.2.5.3.</span> <span class="toc-text">重建Dll的输入表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造重定位表"><span class="toc-number">6.2.5.4.</span> <span class="toc-text">构造重定位表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#附加数据"><span class="toc-number">6.2.6.</span> <span class="toc-text">附加数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PE文件的优化"><span class="toc-number">6.2.7.</span> <span class="toc-text">PE文件的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#压缩壳-1"><span class="toc-number">6.2.8.</span> <span class="toc-text">压缩壳</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UPX外壳"><span class="toc-number">6.2.8.1.</span> <span class="toc-text">UPX外壳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ASPack外壳"><span class="toc-number">6.2.8.2.</span> <span class="toc-text">ASPack外壳</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加密壳-1"><span class="toc-number">6.2.9.</span> <span class="toc-text">加密壳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态脱壳"><span class="toc-number">6.2.10.</span> <span class="toc-text">静态脱壳</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#外壳Loader分析"><span class="toc-number">6.2.10.1.</span> <span class="toc-text">外壳Loader分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编写静态脱壳器"><span class="toc-number">6.2.10.2.</span> <span class="toc-text">编写静态脱壳器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#保护篇"><span class="toc-number">7.</span> <span class="toc-text">保护篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#软件保护技术"><span class="toc-number">7.1.</span> <span class="toc-text">软件保护技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#防范算法求逆"><span class="toc-number">7.1.1.</span> <span class="toc-text">防范算法求逆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本概念"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堡垒战术"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">堡垒战术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#游击战术"><span class="toc-number">7.1.1.3.</span> <span class="toc-text">游击战术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抵静态分析"><span class="toc-number">7.1.2.</span> <span class="toc-text">抵静态分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#花指令"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">花指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SMC技术实现"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">SMC技术实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#信息隐藏"><span class="toc-number">7.1.2.3.</span> <span class="toc-text">信息隐藏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简单的多态变形技术"><span class="toc-number">7.1.2.4.</span> <span class="toc-text">简单的多态变形技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件完整性校验"><span class="toc-number">7.1.3.</span> <span class="toc-text">文件完整性校验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#磁盘文件校验的实现"><span class="toc-number">7.1.3.1.</span> <span class="toc-text">磁盘文件校验的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#校验和"><span class="toc-number">7.1.3.2.</span> <span class="toc-text">校验和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存映像校验"><span class="toc-number">7.1.3.3.</span> <span class="toc-text">内存映像校验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码和数据结合"><span class="toc-number">7.1.4.</span> <span class="toc-text">代码和数据结合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#准备工作-1"><span class="toc-number">7.1.4.1.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加密算法的选用"><span class="toc-number">7.1.4.2.</span> <span class="toc-text">加密算法的选用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#手动加密代码"><span class="toc-number">7.1.4.3.</span> <span class="toc-text">手动加密代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使-txt区块可写"><span class="toc-number">7.1.4.4.</span> <span class="toc-text">使.txt区块可写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反跟踪技术"><span class="toc-number">7.2.</span> <span class="toc-text">反跟踪技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#由BeingDebugged引发的蝴蝶效应"><span class="toc-number">7.2.1.</span> <span class="toc-text">由BeingDebugged引发的蝴蝶效应</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BeingDebugged"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">BeingDebugged</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NtGlobalFlag"><span class="toc-number">7.2.1.2.</span> <span class="toc-text">NtGlobalFlag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HeapMagic"><span class="toc-number">7.2.1.3.</span> <span class="toc-text">HeapMagic</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回归Native-用户态的梦魇"><span class="toc-number">7.2.2.</span> <span class="toc-text">回归Native:用户态的梦魇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CheckRemoteDebuggerPresent"><span class="toc-number">7.2.2.1.</span> <span class="toc-text">CheckRemoteDebuggerPresent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ProcessDebugPort"><span class="toc-number">7.2.2.2.</span> <span class="toc-text">ProcessDebugPort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadHideFromDebugger"><span class="toc-number">7.2.2.3.</span> <span class="toc-text">ThreadHideFromDebugger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DebugObject"><span class="toc-number">7.2.2.4.</span> <span class="toc-text">DebugObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SystemKernelDebuggerInformation"><span class="toc-number">7.2.2.5.</span> <span class="toc-text">SystemKernelDebuggerInformation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NativeApi"><span class="toc-number">7.2.2.6.</span> <span class="toc-text">NativeApi</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hook和AntiHook"><span class="toc-number">7.2.2.7.</span> <span class="toc-text">Hook和AntiHook</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#真正的奥义-小技巧一览"><span class="toc-number">7.2.3.</span> <span class="toc-text">真正的奥义:小技巧一览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SoftICE检测方法"><span class="toc-number">7.2.3.1.</span> <span class="toc-text">SoftICE检测方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OllyDbg检测方法"><span class="toc-number">7.2.3.2.</span> <span class="toc-text">OllyDbg检测方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调试器漏洞"><span class="toc-number">7.2.3.3.</span> <span class="toc-text">调试器漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#防止调试器附加"><span class="toc-number">7.2.3.4.</span> <span class="toc-text">防止调试器附加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#父进程检测"><span class="toc-number">7.2.3.5.</span> <span class="toc-text">父进程检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间差"><span class="toc-number">7.2.3.6.</span> <span class="toc-text">时间差</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通过Trap-Flag检测"><span class="toc-number">7.2.3.7.</span> <span class="toc-text">通过Trap Flag检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双进程保护"><span class="toc-number">7.2.3.8.</span> <span class="toc-text">双进程保护</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#外壳编写基础"><span class="toc-number">7.3.</span> <span class="toc-text">外壳编写基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#外壳结构"><span class="toc-number">7.3.1.</span> <span class="toc-text">外壳结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加壳主程序"><span class="toc-number">7.3.2.</span> <span class="toc-text">加壳主程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#判断文件是否PE格式"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">判断文件是否PE格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文件基本数据读入"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">文件基本数据读入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#附加数据读取"><span class="toc-number">7.3.2.3.</span> <span class="toc-text">附加数据读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输入表的处理"><span class="toc-number">7.3.2.4.</span> <span class="toc-text">输入表的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重定位表的处理"><span class="toc-number">7.3.2.5.</span> <span class="toc-text">重定位表的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文件的压缩"><span class="toc-number">7.3.2.6.</span> <span class="toc-text">文件的压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#资源数据的处理"><span class="toc-number">7.3.2.7.</span> <span class="toc-text">资源数据的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#区块的融合"><span class="toc-number">7.3.2.8.</span> <span class="toc-text">区块的融合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用汇编写外壳部分"><span class="toc-number">7.3.3.</span> <span class="toc-text">用汇编写外壳部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#外壳的加载过程"><span class="toc-number">7.3.3.1.</span> <span class="toc-text">外壳的加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自建输入表"><span class="toc-number">7.3.3.2.</span> <span class="toc-text">自建输入表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#外壳引导段"><span class="toc-number">7.3.3.3.</span> <span class="toc-text">外壳引导段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将外壳添加至源程序"><span class="toc-number">7.3.3.4.</span> <span class="toc-text">将外壳添加至源程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-编写外壳部分"><span class="toc-number">7.3.4.</span> <span class="toc-text">C++编写外壳部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机设计"><span class="toc-number">7.4.</span> <span class="toc-text">虚拟机设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟机保护技术原理"><span class="toc-number">7.4.1.</span> <span class="toc-text">虚拟机保护技术原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#反汇编引擎-1"><span class="toc-number">7.4.1.1.</span> <span class="toc-text">反汇编引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指令分类"><span class="toc-number">7.4.1.2.</span> <span class="toc-text">指令分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动框架和调用约定"><span class="toc-number">7.4.2.</span> <span class="toc-text">启动框架和调用约定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#调度器"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">调度器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟环境"><span class="toc-number">7.4.2.2.</span> <span class="toc-text">虚拟环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#平衡栈vBegin和vCheckESP"><span class="toc-number">7.4.2.3.</span> <span class="toc-text">平衡栈vBegin和vCheckESP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handler的设计"><span class="toc-number">7.4.3.</span> <span class="toc-text">Handler的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#辅助的Handler"><span class="toc-number">7.4.3.1.</span> <span class="toc-text">辅助的Handler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#普通Handler和指令拆解"><span class="toc-number">7.4.3.2.</span> <span class="toc-text">普通Handler和指令拆解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标志位的问题"><span class="toc-number">7.4.3.3.</span> <span class="toc-text">标志位的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#相同作用的指令"><span class="toc-number">7.4.3.4.</span> <span class="toc-text">相同作用的指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#转移指令"><span class="toc-number">7.4.3.5.</span> <span class="toc-text">转移指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#转移跳转指令的另一种实现"><span class="toc-number">7.4.3.6.</span> <span class="toc-text">转移跳转指令的另一种实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call指令"><span class="toc-number">7.4.3.7.</span> <span class="toc-text">call指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#retn指令"><span class="toc-number">7.4.3.8.</span> <span class="toc-text">retn指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不可模拟指令"><span class="toc-number">7.4.3.9.</span> <span class="toc-text">不可模拟指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#托管代码的异常处理"><span class="toc-number">7.4.4.</span> <span class="toc-text">托管代码的异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VC-的异常处理"><span class="toc-number">7.4.4.1.</span> <span class="toc-text">VC++的异常处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VMProtect逆向和还原浅析"><span class="toc-number">7.5.</span> <span class="toc-text">VMProtect逆向和还原浅析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#VMProtect逆向分析"><span class="toc-number">7.5.1.</span> <span class="toc-text">VMProtect逆向分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VMProtect虚拟执行引擎的全景图"><span class="toc-number">7.5.1.1.</span> <span class="toc-text">VMProtect虚拟执行引擎的全景图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VMProtect虚拟引擎的基本架构"><span class="toc-number">7.5.1.2.</span> <span class="toc-text">VMProtect虚拟引擎的基本架构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VMProtect的还原"><span class="toc-number">7.5.2.</span> <span class="toc-text">VMProtect的还原</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟执行系统"><span class="toc-number">7.5.2.1.</span> <span class="toc-text">虚拟执行系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生成完整的字节码流程图"><span class="toc-number">7.5.2.2.</span> <span class="toc-text">生成完整的字节码流程图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Handler命名并添加语义动作"><span class="toc-number">7.5.2.3.</span> <span class="toc-text">Handler命名并添加语义动作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字节码的低级描述转为中级描述"><span class="toc-number">7.5.2.4.</span> <span class="toc-text">字节码的低级描述转为中级描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#清除无用的字节码"><span class="toc-number">7.5.2.5.</span> <span class="toc-text">清除无用的字节码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用真值表化简要逻辑指令"><span class="toc-number">7.5.2.6.</span> <span class="toc-text">用真值表化简要逻辑指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从特征中建立部分寄存器映射信息"><span class="toc-number">7.5.2.7.</span> <span class="toc-text">从特征中建立部分寄存器映射信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他无法确定的寄存器图着色算法"><span class="toc-number">7.5.2.8.</span> <span class="toc-text">其他无法确定的寄存器图着色算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用DAG匹配生成指令"><span class="toc-number">7.5.2.9.</span> <span class="toc-text">使用DAG匹配生成指令</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#软件重构篇"><span class="toc-number">8.</span> <span class="toc-text">软件重构篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#补丁技术"><span class="toc-number">8.1.</span> <span class="toc-text">补丁技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件补丁"><span class="toc-number">8.1.1.</span> <span class="toc-text">文件补丁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存补丁"><span class="toc-number">8.1.2.</span> <span class="toc-text">内存补丁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#跨进程内存存取机制"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">跨进程内存存取机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DebugApi机制"><span class="toc-number">8.1.2.2.</span> <span class="toc-text">DebugApi机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#利用调试器寄存器机制"><span class="toc-number">8.1.2.3.</span> <span class="toc-text">利用调试器寄存器机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#利用Dll注入技术"><span class="toc-number">8.1.2.4.</span> <span class="toc-text">利用Dll注入技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#利用Hook技术"><span class="toc-number">8.1.2.5.</span> <span class="toc-text">利用Hook技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#利用VT技术"><span class="toc-number">8.1.2.6.</span> <span class="toc-text">利用VT技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMC补丁技术"><span class="toc-number">8.1.3.</span> <span class="toc-text">SMC补丁技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单层SMC补丁技术"><span class="toc-number">8.1.3.1.</span> <span class="toc-text">单层SMC补丁技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多层SMC补丁技术"><span class="toc-number">8.1.3.2.</span> <span class="toc-text">多层SMC补丁技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补丁工具"><span class="toc-number">8.1.4.</span> <span class="toc-text">补丁工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码的二次开发"><span class="toc-number">8.2.</span> <span class="toc-text">代码的二次开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据对齐"><span class="toc-number">8.2.1.</span> <span class="toc-text">数据对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增加空间"><span class="toc-number">8.2.2.</span> <span class="toc-text">增加空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#区块间隙"><span class="toc-number">8.2.2.1.</span> <span class="toc-text">区块间隙</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#手动构造区块"><span class="toc-number">8.2.2.2.</span> <span class="toc-text">手动构造区块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工具辅助构造区块"><span class="toc-number">8.2.2.3.</span> <span class="toc-text">工具辅助构造区块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获得函数的调用信息"><span class="toc-number">8.2.3.</span> <span class="toc-text">获得函数的调用信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#增加输入函数"><span class="toc-number">8.2.3.1.</span> <span class="toc-text">增加输入函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#显式链接调用Dll"><span class="toc-number">8.2.3.2.</span> <span class="toc-text">显式链接调用Dll</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码的重定位"><span class="toc-number">8.2.4.</span> <span class="toc-text">代码的重定位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#修复重定位表"><span class="toc-number">8.2.4.1.</span> <span class="toc-text">修复重定位表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码的自定位技术"><span class="toc-number">8.2.4.2.</span> <span class="toc-text">代码的自定位技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增加输出函数"><span class="toc-number">8.2.5.</span> <span class="toc-text">增加输出函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息循环"><span class="toc-number">8.2.6.</span> <span class="toc-text">消息循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WinProc函数"><span class="toc-number">8.2.6.1.</span> <span class="toc-text">WinProc函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#寻找消息循环"><span class="toc-number">8.2.6.2.</span> <span class="toc-text">寻找消息循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WinProc汇编形式"><span class="toc-number">8.2.6.3.</span> <span class="toc-text">WinProc汇编形式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#菜单扩展"><span class="toc-number">8.2.7.</span> <span class="toc-text">菜单扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#扩充WinProc"><span class="toc-number">8.2.7.1.</span> <span class="toc-text">扩充WinProc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩充Exit菜单功能"><span class="toc-number">8.2.7.2.</span> <span class="toc-text">扩充Exit菜单功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩充Open菜单的功能"><span class="toc-number">8.2.7.3.</span> <span class="toc-text">扩充Open菜单的功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dll扩展"><span class="toc-number">8.2.8.</span> <span class="toc-text">Dll扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展接口"><span class="toc-number">8.2.8.1.</span> <span class="toc-text">扩展接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展消息循环"><span class="toc-number">8.2.8.2.</span> <span class="toc-text">扩展消息循环</span></a></li></ol></li></ol></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            加密与解密[笔记篇]
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2020/05/27/encry-decry/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2020-05-27T02:13:40.000Z" itemprop="datePublished">2020-05-27</time>
</a>

            

        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>加密与解密相关详解笔记<br><a id="more"></a>  </p>
<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="逆向分析技术"><a href="#逆向分析技术" class="headerlink" title="逆向分析技术"></a>逆向分析技术</h2><ul>
<li>静态分析</li>
</ul>
<p>通过反汇编得到程序清单, 前后的程序片段所完成的功能宏观了解软件的编程思路, 静态分析工具有IDA</p>
<ul>
<li>动态分析 </li>
</ul>
<p>执行时往往要使用前一模块处理的结果, 不同的结果在不同的条件下有不同的分支和转移</p>
<p>许多加密软件在一段很短的程序区间是明文, 动态调试可对这一块进行解密反汇编 </p>
<h2 id="ASCII与Unicode字符集"><a href="#ASCII与Unicode字符集" class="headerlink" title="ASCII与Unicode字符集"></a>ASCII与Unicode字符集</h2><p>pediy的ASCII码和Unicode码各是以下情况 </p>
<p><code>ASCII</code>: <code>70h 65h 64h 69h 79h</code><br><code>Unicode</code>: <code>0070h 00065h 0064h 0069h 0079h</code> </p>
<p>Intel处理器在内存中一个字占2字节, 存放按<code>Little-endian</code>方存入</p>
<p>低地址: <code>70 00 65 00 64 00 69 00 79 00</code></p>
<p>大端序: 高位字节存入低地址, 低位字节存入高地址<br>小端序: 低位字节存入低地址, 高位字节存入高地址 </p>
<p><img src="/2020/05/27/encry-decry/image-01.png" width="350px"></p>
<h2 id="Windows操作系统"><a href="#Windows操作系统" class="headerlink" title="Windows操作系统"></a>Windows操作系统</h2><h3 id="Win32Api函数"><a href="#Win32Api函数" class="headerlink" title="Win32Api函数"></a>Win32Api函数</h3><p><img src="/2020/05/27/encry-decry/image-02.png" width="350px"></p>
<ul>
<li>Kernel32.dll : 操作系统核心功能服务,包括进程与现场控制、内存管理、文件访问等 </li>
<li>User32.dll: 负责用户接口,包括键盘和鼠标输入、窗口和菜单管理  </li>
<li>GDI: 图形设备接口,允许程序在屏幕和打印机显示文本和图形 </li>
<li>Shell32.dll: 用户界面外壳</li>
<li>NetApi32.dll: 网络</li>
<li>ComCTL32.dll: 通用控件</li>
</ul>
<p>在Win32Api函数字中, “A”标识ANSI,”W”标识Widechars即(Unicode), 前者单字节后者宽字节;<br>程序员通常不必关心这问题, 编译模块会根据设置来决定采用哪个</p>
<h3 id="WOW64"><a href="#WOW64" class="headerlink" title="WOW64"></a>WOW64</h3><p>Wow64(Windows on Windows 64-bit)是64位的Windows操作系统的子系统;使32为不进行修改允许64位操作系统上 </p>
<h3 id="Windows消息机制"><a href="#Windows消息机制" class="headerlink" title="Windows消息机制"></a>Windows消息机制</h3><p>Windows两种消息队列, 一种系统消息队列, 另一种应用程序消息队列;</p>
<p>Windows将输入的消息放入系统消息队列, 再将输入的消息复制到西昂赢的应用程序队列中<br>应用程序再消息循环中检索每个消息并发送给相应的窗口函数<br>消息非抢先性, 即不论事件的急与缓, 总是按到达的先后排队 </p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>每个进程都有自己的虚拟空间, 这个地址空间是4GB,因为32位指针拥有00000000h~FFFFFFFFh的任何值 </p>
<p>通过映射的方法使可用虚拟地址达到4GB, 每个应用程序可以获得2GB的虚拟地址, 剩下的2GB给操作系统自用 </p>
<p><img src="/2020/05/27/encry-decry/image-03.png" width="550px"></p>
<ul>
<li>应用程序不会直接访问物理地址</li>
<li>虚拟内存管理通过虚拟地址的访问请求来控制所有的物理地址访问 </li>
<li>每个应用都有4GB寻址空间</li>
<li>Dll程序没有私有空间, 他们总被映射到其他应用程序的地址空间中,作为其他应用程序的一部分运行,如果Dll不处于同一空间,应用程序无法调用</li>
</ul>
<p>使用虚拟内存简化了内存管理,弥补了物理内存的不足,防止多任务下应用程序之间的冲突 </p>
<p>64位Windows操作系统提供了16TB的有效寻址空间,一半可用于用户模式的应用程序 </p>
<h1 id="调试篇"><a href="#调试篇" class="headerlink" title="调试篇"></a>调试篇</h1><h2 id="动态分析技术"><a href="#动态分析技术" class="headerlink" title="动态分析技术"></a>动态分析技术</h2><h3 id="OllyDbg调试器"><a href="#OllyDbg调试器" class="headerlink" title="OllyDbg调试器"></a>OllyDbg调试器</h3><p>OlldyDbg打开TraceMe.exe会中断再第1条指令处;有些程序可以再启动时不停在入口点,以达到反调试目的 </p>
<ul>
<li>虚拟地址: 同一程序的同一条指令在不同系统环境下此值相同 </li>
<li>机器码: CPU执行的机器代码 </li>
<li>汇编指令: 与机器码对应的程序代码 </li>
</ul>
<p><img src="/2020/05/27/encry-decry/image-04.png" width="450px"></p>
<p>在分析一个程序, 以哪个APi函数作为切入点尤为重要<br>如果有一些编程经验就得心应手 </p>
<p><img src="/2020/05/27/encry-decry/image-05.png" width="550px"></p>
<p>如果已经进入系统Dll提供的Api函数,可快捷键”Alt+F9”执行<code>Execute till user code</code>(执行到用户代码)命令</p>
<p>Win32程序大量调用系统提供的Api函数, 使用合适的Api函数设置断点就能很快定位关键代码</p>
<blockquote>
<p>注意事项 </p>
</blockquote>
<ul>
<li>清楚各Api函数的鼎易 </li>
<li>Api函数大都采用__stdcall调用约定(函数入口参数从右到左顺序入栈,被调用者清栈,返回值在eax)</li>
<li>C代码中的子程序采用C调用约定(入参从右到左入栈,调用者清栈)</li>
<li>了解调用约定、参数传递等知识</li>
</ul>
<h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p><img src="/2020/05/27/encry-decry/image-06.png" width="750px"></p>
<p><img src="/2020/05/27/encry-decry/image-07.png" width="750px"></p>
<h4 id="常用断点"><a href="#常用断点" class="headerlink" title="常用断点"></a>常用断点</h4><h5 id="INT3-断点"><a href="#INT3-断点" class="headerlink" title="INT3 断点"></a>INT3 断点</h5><p>OllyDbg中”F2”快捷键设置/取消断点<br>它做的是哪里设置断点就替换INT3指令,只是OllyDbg隐藏了INT3显示原来的指令</p>
<p>Int3机器码是<code>0xCC</code>,所以也称CC指令;INT3指令会导致一个异常,调试器捕捉异常从而停在断点上,可无数个断点 </p>
<p>缺点改变了原程序的机器码,容易被检测到;例如有些软件防范系统Api被下断点,会检测API首地址是否是<code>0xCC</code></p>
<p><img src="/2020/05/27/encry-decry/image-08.png" width="750px"></p>
<h5 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h5><p><img src="/2020/05/27/encry-decry/image-09.png" width="750px"></p>
<p>DRX调试寄存器有8个(DR0~7)</p>
<ul>
<li>DRO~DR3: 调试地址寄存器,保存监视的地址</li>
<li>DR4~DR5: 保留,未公开作用</li>
<li>DR6: 调试寄存器组状态寄存器 </li>
<li>DR7: 调试寄存器组控制寄存器 </li>
</ul>
<p>原理:使用DR0~3设定地址, DR7设定状态, 因此最多4个断点 </p>
<p>设置断点方法:<code>BreakPoint-&gt;Hardware,on execution</code></p>
<h4 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h4><p>OllyDbg设置内存访问断点或内存写入断点 </p>
<p>原理:所设地址不可访问/写入,这样访问/写入的时候会产生异常,比较异常地址是否是断点地址, 如果是中断让用户继续操作 </p>
<p>设置断点方法:<code>Breakpoint-&gt;Memory on write</code></p>
<h4 id="内存访问一次性断点"><a href="#内存访问一次性断点" class="headerlink" title="内存访问一次性断点"></a>内存访问一次性断点</h4><p>Windows对内存使用段页式管理,OllyDbg使用”Alt+M”快捷显示内存<br>可以看到多个段,每个段都有不可访问、读、写、执行属性 </p>
<p>在相应段设置<code>Set break-on-access</code>,当所在段被读取或执行时就会中断  </p>
<h4 id="消息断点"><a href="#消息断点" class="headerlink" title="消息断点"></a>消息断点</h4><p>Windows本身消息驱动;当某个特定窗口函数接收到某个特定消息时,消息断点将程序中断;</p>
<p>与INT3断点区别在于:INT3断点可以在程序启动之前设置, 消息断点只有在窗口被创建之后设置并拦截 </p>
<p>设置方法:<code>View-&gt;Windows</code>后在句柄上<code>Message breakpoint on ClassProc</code></p>
<h4 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h4><h5 id="按寄存器条件中断"><a href="#按寄存器条件中断" class="headerlink" title="按寄存器条件中断"></a>按寄存器条件中断</h5><p><code>add Condition</code>:<code>eax == 04000000</code></p>
<h5 id="按存储器条件中断"><a href="#按存储器条件中断" class="headerlink" title="按存储器条件中断"></a>按存储器条件中断</h5><p>实际应用成百上千调用<code>CreateFileA</code>函数,因此OllyDbg在<code>CreateFileA</code>函数打开所需文件十分必要  </p>
<h3 id="x64dbg-调试器"><a href="#x64dbg-调试器" class="headerlink" title="x64dbg 调试器"></a>x64dbg 调试器</h3><h3 id="MDebug调试器"><a href="#MDebug调试器" class="headerlink" title="MDebug调试器"></a>MDebug调试器</h3><h3 id="WinDbg调试器"><a href="#WinDbg调试器" class="headerlink" title="WinDbg调试器"></a>WinDbg调试器</h3><h2 id="静态分析技术"><a href="#静态分析技术" class="headerlink" title="静态分析技术"></a>静态分析技术</h2><h3 id="文件类型分析"><a href="#文件类型分析" class="headerlink" title="文件类型分析"></a>文件类型分析</h3><h3 id="反汇编引擎"><a href="#反汇编引擎" class="headerlink" title="反汇编引擎"></a>反汇编引擎</h3><h4 id="Udis86"><a href="#Udis86" class="headerlink" title="Udis86"></a>Udis86</h4><h4 id="BeaEngine"><a href="#BeaEngine" class="headerlink" title="BeaEngine"></a>BeaEngine</h4><h4 id="OllyDbg的ODDisasm"><a href="#OllyDbg的ODDisasm" class="headerlink" title="OllyDbg的ODDisasm"></a>OllyDbg的ODDisasm</h4><h4 id="AsmJit"><a href="#AsmJit" class="headerlink" title="AsmJit"></a>AsmJit</h4><h3 id="IDAPro静态反汇编"><a href="#IDAPro静态反汇编" class="headerlink" title="IDAPro静态反汇编"></a>IDAPro静态反汇编</h3><h3 id="静态分析技术应用实例"><a href="#静态分析技术应用实例" class="headerlink" title="静态分析技术应用实例"></a>静态分析技术应用实例</h3><h4 id="解密初步"><a href="#解密初步" class="headerlink" title="解密初步"></a>解密初步</h4><h4 id="逆向工程初步"><a href="#逆向工程初步" class="headerlink" title="逆向工程初步"></a>逆向工程初步</h4><h1 id="解密篇"><a href="#解密篇" class="headerlink" title="解密篇"></a>解密篇</h1><h2 id="逆向分析技术-1"><a href="#逆向分析技术-1" class="headerlink" title="逆向分析技术"></a>逆向分析技术</h2><h3 id="32位软件逆向"><a href="#32位软件逆向" class="headerlink" title="32位软件逆向"></a>32位软件逆向</h3><h4 id="启动函数"><a href="#启动函数" class="headerlink" title="启动函数"></a>启动函数</h4><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><h4 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h4><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><h4 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h4><h4 id="文字字符串"><a href="#文字字符串" class="headerlink" title="文字字符串"></a>文字字符串</h4><h4 id="指令修改技巧"><a href="#指令修改技巧" class="headerlink" title="指令修改技巧"></a>指令修改技巧</h4><h3 id="64未软件逆向"><a href="#64未软件逆向" class="headerlink" title="64未软件逆向"></a>64未软件逆向</h3><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><h4 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h4><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><h4 id="循环语句-1"><a href="#循环语句-1" class="headerlink" title="循环语句"></a>循环语句</h4><h4 id="数学运算符-1"><a href="#数学运算符-1" class="headerlink" title="数学运算符"></a>数学运算符</h4><h4 id="虚函数-1"><a href="#虚函数-1" class="headerlink" title="虚函数"></a>虚函数</h4><h2 id="各类保护技术"><a href="#各类保护技术" class="headerlink" title="各类保护技术"></a>各类保护技术</h2><h3 id="序列号保护方式"><a href="#序列号保护方式" class="headerlink" title="序列号保护方式"></a>序列号保护方式</h3><h3 id="警告窗口"><a href="#警告窗口" class="headerlink" title="警告窗口"></a>警告窗口</h3><h3 id="时间限制"><a href="#时间限制" class="headerlink" title="时间限制"></a>时间限制</h3><h3 id="菜单功能限制"><a href="#菜单功能限制" class="headerlink" title="菜单功能限制"></a>菜单功能限制</h3><h3 id="KeyFile保护"><a href="#KeyFile保护" class="headerlink" title="KeyFile保护"></a>KeyFile保护</h3><h3 id="网络验证"><a href="#网络验证" class="headerlink" title="网络验证"></a>网络验证</h3><h3 id="光盘检测"><a href="#光盘检测" class="headerlink" title="光盘检测"></a>光盘检测</h3><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="单向散列算法"><a href="#单向散列算法" class="headerlink" title="单向散列算法"></a>单向散列算法</h3><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><h4 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h4><h4 id="SM3"><a href="#SM3" class="headerlink" title="SM3"></a>SM3</h4><h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><h4 id="RC4流密码"><a href="#RC4流密码" class="headerlink" title="RC4流密码"></a>RC4流密码</h4><h4 id="TEA算法"><a href="#TEA算法" class="headerlink" title="TEA算法"></a>TEA算法</h4><h4 id="IDEA算法"><a href="#IDEA算法" class="headerlink" title="IDEA算法"></a>IDEA算法</h4><h4 id="BlowFish算法"><a href="#BlowFish算法" class="headerlink" title="BlowFish算法"></a>BlowFish算法</h4><h4 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h4><h4 id="SM4分组密码算法"><a href="#SM4分组密码算法" class="headerlink" title="SM4分组密码算法"></a>SM4分组密码算法</h4><h3 id="公开密钥加密算法"><a href="#公开密钥加密算法" class="headerlink" title="公开密钥加密算法"></a>公开密钥加密算法</h3><h4 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h4><h4 id="ElGamal公钥算法"><a href="#ElGamal公钥算法" class="headerlink" title="ElGamal公钥算法"></a>ElGamal公钥算法</h4><h4 id="DSA数字签名算法"><a href="#DSA数字签名算法" class="headerlink" title="DSA数字签名算法"></a>DSA数字签名算法</h4><h4 id="椭圆曲线密码"><a href="#椭圆曲线密码" class="headerlink" title="椭圆曲线密码"></a>椭圆曲线密码</h4><h4 id="SM2算法"><a href="#SM2算法" class="headerlink" title="SM2算法"></a>SM2算法</h4><h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><h4 id="CRC32算法"><a href="#CRC32算法" class="headerlink" title="CRC32算法"></a>CRC32算法</h4><h4 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h4><h3 id="常见加密库与识别"><a href="#常见加密库与识别" class="headerlink" title="常见加密库与识别"></a>常见加密库与识别</h3><h4 id="Miracl大数运算库"><a href="#Miracl大数运算库" class="headerlink" title="Miracl大数运算库"></a>Miracl大数运算库</h4><h4 id="FGInt"><a href="#FGInt" class="headerlink" title="FGInt"></a>FGInt</h4><h1 id="系统篇"><a href="#系统篇" class="headerlink" title="系统篇"></a>系统篇</h1><h2 id="Windows内核基础"><a href="#Windows内核基础" class="headerlink" title="Windows内核基础"></a>Windows内核基础</h2><p>内核一个是系统内核本身, 还有就是第三方软件以内核模块加载的驱动文件 </p>
<p>应用层进程通过系统调用进入内核,由系统底层完成对应功能, 内核执行处于该进程上下文空间种,由硬件发来的中断请求代替硬件完成某些哦功能 </p>
<h3 id="内核理论基础"><a href="#内核理论基础" class="headerlink" title="内核理论基础"></a>内核理论基础</h3><p>内核拥有系统最高权限,由此吸引了无数技术迷</p>
<h4 id="权限级别"><a href="#权限级别" class="headerlink" title="权限级别"></a>权限级别</h4><p><img src="/2020/05/27/encry-decry/image-10.png" width="350px"></p>
<p>R0有用最高执行权限, R3最低执行全新啊 </p>
<p>CPU规定R0运行内核, R1、R2运行设备驱动, R3运行应用程序<br>但是操作系统Windows和Linux并没有使用R1和R2,直接设备驱动运行在内核同一级别的R0</p>
<p>WindowsXp的工作细节 </p>
<p><img src="/2020/05/27/encry-decry/image-11.png" width="450px"></p>
<h4 id="内存空间布局"><a href="#内存空间布局" class="headerlink" title="内存空间布局"></a>内存空间布局</h4><p>x86 32位寻址, 4G虚拟空间地址</p>
<p><img src="/2020/05/27/encry-decry/image-12.png" width="300px"></p>
<p>x64 2的64次方位寻址, Windows支持44位最大寻址空间16TB</p>
<p><img src="/2020/05/27/encry-decry/image-13.png" width="400px"> </p>
<h4 id="Wndows与内核启动过程"><a href="#Wndows与内核启动过程" class="headerlink" title="Wndows与内核启动过程"></a>Wndows与内核启动过程</h4><ul>
<li>开机自检 </li>
<li>初始化启动阶段(CMOS设置,BIOS加载启动盘) </li>
<li>Boot加载阶段 </li>
<li>检测和配置硬件阶段</li>
<li>内核加载阶段 </li>
<li>Windows绘画管理启动(smss.exe)</li>
<li>登录阶段 </li>
</ul>
<p>UEFI新一代的系统引导,用于替换BIOS</p>
<h4 id="Window-R3与R0通信"><a href="#Window-R3与R0通信" class="headerlink" title="Window R3与R0通信"></a>Window R3与R0通信</h4><p>APi封装在应用层的某个Dll库, dll动态库更底层的函数包含在ntdll.dll中</p>
<p><img src="/2020/05/27/encry-decry/image-14.png" width="300px"></p>
<p>在调用ntdll.dll的native API函数是成对出现(Nt和ZW开头)<br>再调用一个中断(Sysenter指令(xp之后)或 int 2Eh(xp之前)),从R3进入R0层<br>在内核ntoskml.exe中有一个SSDT,存放了ntdll中对应的SSDT系统服务处理函数</p>
<p><img src="/2020/05/27/encry-decry/image-15.png" width="750px"></p>
<p>在以上的过程应用层命令和数据被IO管理器封装在IRP结构中<br>之后IRP逐层发送给下层的驱动创建的设备对象进行处理</p>
<p><img src="/2020/05/27/encry-decry/image-16.png" width="750px"></p>
<p>内核主要由各种驱动(磁盘上的.sys文件)组成;由系统自带得到(tcpip.sys,ntfs.sys)<br>也有第三方厂商的</p>
<p>内核驱动一旦执行DriverEntry入口函数,即可接收R3层的通信请求,内核驱动中专门有一组分发派遣函数响应应用层的调用请求 </p>
<h4 id="内核函数"><a href="#内核函数" class="headerlink" title="内核函数"></a>内核函数</h4><p>●Ex:管理层。“Ex”是”Executive” 的开头两个字母。<br>●Ke:核心层。“Ke”是“Kernel” 的开头两个字母。<br>●HAL: 硬件抽象层。“HAL”是“Hardware Abstraction Layer” 的缩写。<br>●<br>Ob:对象管理。“Ob”是“Object” 的开头两个字母。<br>●MM:内存管理。“MM”是“Memory Manager” 的缩写。<br>●Ps:进程(线程)管理。“Ps”表示“Process”。<br>●Se: 安全管理。“Se”是“Security” 的开头两个字母。<br>●lo: I/O管理。<br>●Fs:文件系统。“Fs”是”File System” 的缩写。<br>●Cc:文件缓存管理。“Ce”表示“Cache”。<br>●Cm:系统配置管理。“Cm”是“Configuration Manager” 的缩写。<br>●Pp:即插即用管理。“Pp”表示“PnP”。<br>●Rtl: 运行时程序库。“Rtl” 是“Runtime Library” 的缩写。<br>●Zw/Nt:对应于SSDT中的服务函数，例如与文件或者注册表相关的操作函数。<br>●Flt: Minifilter文件过滤驱动中调用的函数。<br>●Ndis: Ndis网络框架中调用的函数。</p>
<p>IRQL:(中断请求级别) 内核不同情况下会运行在不同IRQL级别上 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define PASSIVE LEVEL	0</span><br><span class="line">#define LOW LEVEL		0</span><br><span class="line">#define APC_ LEVEL		1</span><br><span class="line">#define DISPATCH LEVEL	2</span><br><span class="line">#define PROFILE LEVEL	27</span><br><span class="line">#define CLOCK1_ LEVEL	28</span><br><span class="line">#define CLOCK2_ LEVEL	28</span><br><span class="line">#define IPI_ LEVEL		29</span><br><span class="line">#define POWER LEVEL 	30</span><br><span class="line">#define HIGH LEVEL 		31</span><br></pre></td></tr></table></figure>
<ul>
<li>PASSIVE_ LEVEL: IRQL的最低级别，没有被屏蔽的中断。在这个级别上，线程执行用户模<br>式，可以访问分页内存。线程运行在该中断级别上，对所有中断都作出响应。用户模式代<br>码都是运行在该中断级别上的。</li>
<li><p>APC_ LEVEL:在这个级别上，只有APC级别的中断被屏蔽，可以访问分页内存。当有APC<br>发生时，将处理器提升到APC级别，就能屏蔽其他APC了。为了与APC同步，驱动程序<br>可以手动提升到这个级别。分页调度管理就运行在该级别上。</p>
</li>
<li><p>DISPATCH_ LEVEL:在这个级别上，DPC (延迟过程)和更低的中断被屏蔽，不能访问分页<br>内存，所有被访问的内存不能分页。因为只能处理不可分页的内存，所以在这个级别上能<br>够访问的API大大减少。线程调度和DPC例程运行在该级别上。为了执行多任务，系统必<br>须允许线程调度，而线程调度是由时钟中断来保证的，因此该级别的中断就是调度中断。<br>代码运行的IRQL被提升为DISPATH LEVEL时，就意味着代码不再受线程中断的影响。代<br>码会一直运行到将IRQL设置为低于DISPATH LEVEL时为止。其间如果发生缺页错误之类<br>的IRQL级别在DISPATH LEVEL之下的严重中断，这些中断均不会被处理，这时代码将无<br>法正常运行。所以，DISPATH LEVEL的使用绝对要慎之又慎，只有在使用自旋锁时才考虑<br>选择该IRQL。</p>
</li>
<li>DIRQL ( Device IRQL):处于高层的驱动程序通常不会使用该IRQL级别，在该级别上所有<br>的中断都会被忽略。这是IRQL的最高级别，通常使用它来判断设备的优先级。</li>
</ul>
<h4 id="内核驱动模块"><a href="#内核驱动模块" class="headerlink" title="内核驱动模块"></a>内核驱动模块</h4><p>那么，编译好的驱动是如何在系统中被加载并执行的呢? </p>
<ul>
<li>①创建一个服务(注册表)。在注册表的Services 键下建立-一个与驱动名称相关的服务键(例<br>如SrvName),即HKEY LOCAL MACHINEISYSTEMCurrentControlSetServices\SrvName。这个服务键<br>规定了驱动的一些属性，例如启动GROUP与StarType决定了驱动加载的先后，StartType 为0的比<br>StartType为1的先启动。</li>
<li>②对象管理器生成驱动对象( Driver0bject )并传递给DriverEntry0 函数。执行DriverEntry0丽<br>数(它是驱动执行的人口函数，也就是驱动执行的第1个函数，类似于R3程序中的main0函数)。</li>
<li>③创建控制设备对象。</li>
<li>④创建控制设备符号链接( R3级可见)。</li>
<li>⑤如果是过滤驱动，则创建过滤设备对象并绑定。</li>
<li>⑥注册特定的分发派遣函数。</li>
<li>⑦其他初始化动作，例如Hook、过滤(文件系统过滤、网络防火墙过滤等)、回调框架(注册<br>表回调等)等的注册和初始化。</li>
</ul>
<h3 id="内核重要数据结构"><a href="#内核重要数据结构" class="headerlink" title="内核重要数据结构"></a>内核重要数据结构</h3><h4 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h4><p><img src="/2020/05/27/encry-decry/image-17.png" width="250px"></p>
<p>在Windows内核中有-种很重要的数据结构管理机制，那就是内核对象。应用层的进程、线程、文件、驱动模块、事件、信号量等对象或者打开的句柄在内核中都有与之对应的内核对象。</p>
<p>windows内核对象分对象头和对象提<br>对象头至少一个OBJECT_HEADER和对象额外信息 </p>
<p>Windows内核对象分3种类型</p>
<ul>
<li>Dispatcher对象 </li>
</ul>
<p>这种对象在对象体开始位置放置了一个共享的公共数据结构DISPATCHER HEADER,其结构代码如下。包含DISPATCHER HEADER结构的内核对象的名字都以字母“K”开头</p>
<p>表明这是一一个内核对象，例如KPROCESS、KTHREAD、KEVENT、KSEMAPHORE、KTIMER、KQUEUE、KMUTANT、KMUTEX，但以字母“K”开头的内核对象不一-定 是Dispatcher对象。包含DISPATCHER_ HEADER结构的内核对象都是可以等待的( waitable)</p>
<p>也就是说，这些内核对象可以作为参数传给内核的KeWaitForsSingleObject0和KeW aitForMulipleObjects0函数，以及应用层的WaitForSingleObject0 和W aitForMultiple Objects0函数。</p>
<ul>
<li>IO对象 </li>
</ul>
<p>I/0对象在对象体开始位置并未放置DISPATCHER HEADER结构，但通常会放置一个与type<br>和size有关的整型成员，以表示该内核对象的类型(例如文件内核对象的类型为26)和大小。常见<br>的I/0对象包括DEVICE OBJECT、DRIVER_ OBJECT、 FILE OBJECT、IRP、VPB、KPROFILE 等。</p>
<ul>
<li>其他对象 </li>
</ul>
<p>除了Dispatcher 对象和1I/0对象，剩下的都属于其他内核对象。其中有两个常用的内核对象，分别是程对象( EPROCESS )与线程对象( ETHREAD )。</p>
<p>EPROCESS用于在内核中管理进程的各种信息，每个进程都对应于一一个EPROCESS结构，用于记录进程执行期间的各种数据。尽管EPROCESS结构非常大，但它是一个不透明的结构( Opaque Structure),具体成员并未导出，并随着操作系统版本的变化而变化。因此，要想查看EPROCESS结构中的成员，只能查阅网上资料或者在使用W inDbg调试器加载内核符号后进行。</p>
<p>所有进程的EPROCESS内核结构都被放人-一个双向链表，R3在枚举系统进程的时候，通过遍历这个链表获得了进程的列表。因此，有的Rootkit会试图将自己进程的EPROCESS结构从这个链表中摘掉，从而达到隐藏自己的目的。</p>
<h4 id="SSDT"><a href="#SSDT" class="headerlink" title="SSDT"></a>SSDT</h4><p>SSDT用于处理应用层通过kernel32.dll下发的各个API操作请求。ntdL.dll 中的API是-一个简单的包装函数，当kernel32.dll中的API通过ntdll.dll时，会先完成对参数的检查，再调用-个中断( int2Eh或者SysEnter指令),从而实现从R3层进入RO层<br>并将要调用的服务号(也就是SSDT数组中的索引号index值)存放到寄存器EAX中，最后根据存放在EAX中的索弓|值在SSDT数组中调用指定的服务( Nt系列函数),如图所示。</p>
<p><img src="/2020/05/27/encry-decry/image-18.png" width="500px"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ServiceDescr</span> <span class="title">iptorEntry</span></span></span><br><span class="line"><span class="class">	<span class="title">unsigned</span> <span class="title">int</span>★ <span class="title">ServiceTableBase</span>;</span></span><br><span class="line">	/ /表的基地址</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *Servi ceCounterTableBase;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> NumberOfServices;</span><br><span class="line">	<span class="comment">//表中服务函数的个数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *ParamTableBase;</span><br><span class="line">&#125; ServiceDescriptorTableEntry_ t,</span><br><span class="line"></span><br><span class="line"> ★PServiceDescriptorTableEntry t;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>
<h4 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h4><p>TEB与PEB一样，不在系统内核空间中，而是应用层中的结构。TEB结构比较重要<br>在这里简要介绍一下。TEB ( Thread environment block,线程环境块)结构中包含了系统频繁使用的一些与线程相关的数据。<br>进程中的每个线程(系统线程除外)都有一一个自己的TEB。一个进程的所有TEB都存放在从0x7FFDE000开始的线性内存中，每4KB为一个完整的TEB。</p>
<ul>
<li>TEB访问 </li>
</ul>
<p>NtCurrentTeb函数调用 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">	<span class="title">TEB</span></span></span><br><span class="line"><span class="class">	<span class="title">NT</span> <span class="title">TIB</span> <span class="title">Tib</span>;</span></span><br><span class="line">	PV0ID Envi ronmentPointer ;</span><br><span class="line">	CLIENT ID Cid;</span><br><span class="line">	PVOID ActiveRpcInfo;</span><br><span class="line">	PVOID ThreadLoca lStoragePointer;</span><br><span class="line">	PPEB Peb;</span><br><span class="line">&#125; TEB, ★PTEB;</span><br><span class="line"><span class="keyword">typedef</span> PTEB</span><br><span class="line">(NTAPI* NtCurrentTeb) () ;</span><br><span class="line">NtCurrentTeb</span><br><span class="line">fnNtCurrentTeb = (NtCur rentTeb) GetProcAddress ( GetModuleHandle(_ T (<span class="string">"ntdll.d11"</span>) ) ,<span class="string">"NtCurrentTeb"</span> ) ;</span><br><span class="line">PTEB pTeb = fnNtCurrentTeb() ;</span><br></pre></td></tr></table></figure>
<p>FS段寄存器访问 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, dword ptr fs: [18h] ; 此时eax里为TEB的指针</span><br></pre></td></tr></table></figure>
<h4 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h4><p>PEB ( Process Environment Block, 进程环境块)存在于用户地址空间中，记录了进程的相关信息。每个进程都有自己的PEB信息。</p>
<p>TEB中的ProcessEnvironmentBlock就是PEB结构的地址<br>其结构的0x30偏移处是一-个指向PEB (进程环境块)的指针。PEB的0x2偏移处是一一个UChar成员，名叫”BeingDebugged””<br>进程被调试时值为1,未被调试时值为0。因此，访问PEB的地址有如下两种方法。</p>
<ul>
<li>直接获取 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, dword ptr fs:[30] ; fs[30]里存放的即为PEB地址</span><br></pre></td></tr></table></figure>
<ul>
<li>通过teb获取 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, dword ptr fs:[18h] ; 此时eax位为teb的指针</span><br><span class="line">mov eax, dword ptr [eax+30h] ; 此时eax为peb的指针</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/27/encry-decry/image-19.png" width="500px"></p>
<h2 id="Windows下的异常处理"><a href="#Windows下的异常处理" class="headerlink" title="Windows下的异常处理"></a>Windows下的异常处理</h2><p>Windows的异常处理是操作系统处理程序错误或异常的一系列流程和技术的总称。主要介绍Windows下异常处理的数据结构、原理、流程，以及开发人员主要使用的两种异常处理技术，一种是SEH (结构化异常处理)，另种是VEH (向量化异常处理，在Windows XP以上版本中使用)。</p>
<h3 id="异常处理的基本概念"><a href="#异常处理的基本概念" class="headerlink" title="异常处理的基本概念"></a>异常处理的基本概念</h3><p>CPU引入中断和异常的概念, 中断是外部硬件或异步事件产生、异常由内部事件产生(故障、缺陷、终止三类)</p>
<p><img src="/2020/05/27/encry-decry/image-20.png" width="650px"></p>
<h3 id="SEH的概念及基本知识"><a href="#SEH的概念及基本知识" class="headerlink" title="SEH的概念及基本知识"></a>SEH的概念及基本知识</h3><h3 id="SEH异常处理程序原理及涉及"><a href="#SEH异常处理程序原理及涉及" class="headerlink" title="SEH异常处理程序原理及涉及"></a>SEH异常处理程序原理及涉及</h3><h3 id="向量化异常处理"><a href="#向量化异常处理" class="headerlink" title="向量化异常处理"></a>向量化异常处理</h3><h3 id="x64平台上的异常处理"><a href="#x64平台上的异常处理" class="headerlink" title="x64平台上的异常处理"></a>x64平台上的异常处理</h3><h3 id="异常处理程序涉及中的注意事项"><a href="#异常处理程序涉及中的注意事项" class="headerlink" title="异常处理程序涉及中的注意事项"></a>异常处理程序涉及中的注意事项</h3><h3 id="异常处理的实际应用"><a href="#异常处理的实际应用" class="headerlink" title="异常处理的实际应用"></a>异常处理的实际应用</h3><h2 id="Win32调试Api"><a href="#Win32调试Api" class="headerlink" title="Win32调试Api"></a>Win32调试Api</h2><h3 id="调试相关函数说明"><a href="#调试相关函数说明" class="headerlink" title="调试相关函数说明"></a>调试相关函数说明</h3><h3 id="调试事件"><a href="#调试事件" class="headerlink" title="调试事件"></a>调试事件</h3><h3 id="创建并跟踪进程"><a href="#创建并跟踪进程" class="headerlink" title="创建并跟踪进程"></a>创建并跟踪进程</h3><h3 id="调试循环体"><a href="#调试循环体" class="headerlink" title="调试循环体"></a>调试循环体</h3><h3 id="处理调试事件"><a href="#处理调试事件" class="headerlink" title="处理调试事件"></a>处理调试事件</h3><h3 id="线程环境"><a href="#线程环境" class="headerlink" title="线程环境"></a>线程环境</h3><h3 id="将代码注入进程"><a href="#将代码注入进程" class="headerlink" title="将代码注入进程"></a>将代码注入进程</h3><h2 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h2><p><img src="/2020/05/27/encry-decry/image-21.png" width="1500px"></p>
<p><img src="/2020/05/27/encry-decry/image-22.png" width="1500px"></p>
<h3 id="PE的概念"><a href="#PE的概念" class="headerlink" title="PE的概念"></a>PE的概念</h3><h4 id="基地址"><a href="#基地址" class="headerlink" title="基地址"></a>基地址</h4><h4 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h4><h4 id="相对虚拟地址"><a href="#相对虚拟地址" class="headerlink" title="相对虚拟地址"></a>相对虚拟地址</h4><h4 id="文件偏移地址"><a href="#文件偏移地址" class="headerlink" title="文件偏移地址"></a>文件偏移地址</h4><h3 id="MS-DOS头部"><a href="#MS-DOS头部" class="headerlink" title="MS-DOS头部"></a>MS-DOS头部</h3><h3 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h3><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><h4 id="区块表"><a href="#区块表" class="headerlink" title="区块表"></a>区块表</h4><h4 id="常见区块与区块合并"><a href="#常见区块与区块合并" class="headerlink" title="常见区块与区块合并"></a>常见区块与区块合并</h4><h4 id="区块的对齐值"><a href="#区块的对齐值" class="headerlink" title="区块的对齐值"></a>区块的对齐值</h4><h4 id="文件偏移与虚拟地址转换"><a href="#文件偏移与虚拟地址转换" class="headerlink" title="文件偏移与虚拟地址转换"></a>文件偏移与虚拟地址转换</h4><h3 id="输入表"><a href="#输入表" class="headerlink" title="输入表"></a>输入表</h3><h4 id="输入函数的调用"><a href="#输入函数的调用" class="headerlink" title="输入函数的调用"></a>输入函数的调用</h4><h4 id="输入表的结构"><a href="#输入表的结构" class="headerlink" title="输入表的结构"></a>输入表的结构</h4><h4 id="输入地址表"><a href="#输入地址表" class="headerlink" title="输入地址表"></a>输入地址表</h4><h4 id="输入表实例分析"><a href="#输入表实例分析" class="headerlink" title="输入表实例分析"></a>输入表实例分析</h4><h3 id="绑定输入"><a href="#绑定输入" class="headerlink" title="绑定输入"></a>绑定输入</h3><h3 id="输出表"><a href="#输出表" class="headerlink" title="输出表"></a>输出表</h3><h4 id="输出表的结构"><a href="#输出表的结构" class="headerlink" title="输出表的结构"></a>输出表的结构</h4><h4 id="输出表实例分析"><a href="#输出表实例分析" class="headerlink" title="输出表实例分析"></a>输出表实例分析</h4><h3 id="基址重定位"><a href="#基址重定位" class="headerlink" title="基址重定位"></a>基址重定位</h3><h4 id="基址重定位的概念"><a href="#基址重定位的概念" class="headerlink" title="基址重定位的概念"></a>基址重定位的概念</h4><h4 id="基址重定位表的结构"><a href="#基址重定位表的结构" class="headerlink" title="基址重定位表的结构"></a>基址重定位表的结构</h4><h4 id="基址重定位表实例分析"><a href="#基址重定位表实例分析" class="headerlink" title="基址重定位表实例分析"></a>基址重定位表实例分析</h4><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><h4 id="资源结构"><a href="#资源结构" class="headerlink" title="资源结构"></a>资源结构</h4><h4 id="资源结构实例分析"><a href="#资源结构实例分析" class="headerlink" title="资源结构实例分析"></a>资源结构实例分析</h4><h4 id="资源编辑工具"><a href="#资源编辑工具" class="headerlink" title="资源编辑工具"></a>资源编辑工具</h4><h3 id="TLS初始化"><a href="#TLS初始化" class="headerlink" title="TLS初始化"></a>TLS初始化</h3><h3 id="调试目录"><a href="#调试目录" class="headerlink" title="调试目录"></a>调试目录</h3><h3 id="延迟载入数据"><a href="#延迟载入数据" class="headerlink" title="延迟载入数据"></a>延迟载入数据</h3><h3 id="调试目录-1"><a href="#调试目录-1" class="headerlink" title="调试目录"></a>调试目录</h3><h3 id="延迟载入数据-1"><a href="#延迟载入数据-1" class="headerlink" title="延迟载入数据"></a>延迟载入数据</h3><h3 id="程序异常数据"><a href="#程序异常数据" class="headerlink" title="程序异常数据"></a>程序异常数据</h3><h2 id="注入技术"><a href="#注入技术" class="headerlink" title="注入技术"></a>注入技术</h2><h3 id="Dll注入技术"><a href="#Dll注入技术" class="headerlink" title="Dll注入技术"></a>Dll注入技术</h3><h3 id="Dll注入应用"><a href="#Dll注入应用" class="headerlink" title="Dll注入应用"></a>Dll注入应用</h3><h3 id="Dll注入的防范"><a href="#Dll注入的防范" class="headerlink" title="Dll注入的防范"></a>Dll注入的防范</h3><h4 id="驱动层防范"><a href="#驱动层防范" class="headerlink" title="驱动层防范"></a>驱动层防范</h4><h4 id="应用层防范"><a href="#应用层防范" class="headerlink" title="应用层防范"></a>应用层防范</h4><h2 id="Hook技术"><a href="#Hook技术" class="headerlink" title="Hook技术"></a>Hook技术</h2><h3 id="Hook概述"><a href="#Hook概述" class="headerlink" title="Hook概述"></a>Hook概述</h3><p>一类是通过修改数据(通常是引用的函数地址)进行Hook, 另一类则直接修改函数内的指令进行Hook。</p>
<p>类似于C语言中的指针<br>第1种Hook就是修改指针的值<br>第2种Hook就是修改指针指向的内容的值。</p>
<p>总结起来其实只有两种: AddressHook和InlineHook</p>
<h4 id="Address-Hook"><a href="#Address-Hook" class="headerlink" title="Address Hook"></a>Address Hook</h4><p>Addres Hook指通过修改数据进行Hook, 这里数据指一些函数地址(也称为偏移量) </p>
<h5 id="PE的IAT"><a href="#PE的IAT" class="headerlink" title="PE的IAT"></a>PE的IAT</h5><p>IAT:(Import Address Table输入表)中的函数</p>
<p>作用范围只必须在静态链接的方式调用API时才会被Hook,在使用LoadLibrary或GetProcAddress进行动态调试时不受影响,要相对已加载的所有模块起作用,必须遍历进程内的模块,对目标Api进行Hook </p>
<h5 id="PE的EAT"><a href="#PE的EAT" class="headerlink" title="PE的EAT"></a>PE的EAT</h5><p>EAT ( Export Address Table,输出表)与IAT不同，它存放的不是函数地址，而是函数地址的偏移，使用时需要加上模块基址，所示。所以，在进行Hook时，也要用Detour函数的地址减被Hook模块的基址。<br>在Hook之后，所有试图通过输出表获取函数地址的行为都会受到影响(主程序及其输人表中所有模块的IAT在程序初始化时就已经被填充了，因此之后通过IAT进行调用不受EAT Hook的影响)。</p>
<p>EAT并不直接起作用，它只能影响Hook之后对该函数地址的获取(例如IAT拦截不到的Loadlibrary 或GetProcAddress调用方式)或者后续加载的模块的IAT-看起来就像新加载的模块被安装了IAT Hook,其实是因为受到了EAT Hook的影响。<br>结合IAT Hook,就可以对某进程内部所有已加载和未加载的模块通过静态或动态的方式调用API的行为进行拦截了。</p>
<h5 id="user32-dll的回调函数表"><a href="#user32-dll的回调函数表" class="headerlink" title="user32.dll的回调函数表"></a>user32.dll的回调函数表</h5><p>全局钩子Dll为例,安装全局消息钩子之后,所有消息循环进程都加载了全局钩子Dll </p>
<p>而负责加载这个Dll的就是<code>__ClientLoadLibrary</code>函数(Hook这里可防止全局钩子Dll侵入目标进程) </p>
<h5 id="IDT-系统的中断描述符表"><a href="#IDT-系统的中断描述符表" class="headerlink" title="IDT(系统的中断描述符表)"></a>IDT(系统的中断描述符表)</h5><p>顾名思义，IDT ( Iterrupt Descriptor Table,系统的中断描述符表)是操作系统在处理中断机制(例如调试中断、键盘/鼠标中断、系统调用中断等)时使用的一 张表。当这些中断发生时，操作系统需要知道应该把中断交给谁去处理，因此需要一张 表来存储这些信息以便操作系统使用(这张表就是IDT)。IDT的表基址存放在idtr寄存器中，表内项目数存放在idtl寄存器中</p>
<p>在x86系统中，其大小为8字节，每个中断项的中断处理例程称为ISR ( Interrupt Service Routine )。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/ /<span class="function">Entry of Interrupt Descriptor <span class="title">Table</span> <span class="params">(IDTENTRY)</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> struct_ KIDTENTRY</span></span><br><span class="line"><span class="function">	USHORT Offset</span>;</span><br><span class="line">	USHORT Selector ;</span><br><span class="line">	USHORT Access ;</span><br><span class="line">	USHORT Extendedoffset;</span><br><span class="line">&#125; KIDTENTRY;</span><br><span class="line"><span class="keyword">typedef</span> KIDTENTRY ★ PKIDTENTRY;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Macro to return address of a trap/ interrupt handler in IDT</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KiReturnHandlerAddressFr omIDT (Vector)</span></span><br><span class="line">MAKEULONG (KiPcr()-&gt;IDT [HalVectorToIDTEntry\</span><br><span class="line">(Vector)].ExtendedOffset, KiPcr()-&gt;IDT[HalVectorToIDTEntry(Vector)].Offset)</span><br></pre></td></tr></table></figure>
<h5 id="SSDT和Shadow-SSDT"><a href="#SSDT和Shadow-SSDT" class="headerlink" title="SSDT和Shadow SSDT"></a>SSDT和Shadow SSDT</h5><p>Windows系统的大部分功能都是通过调用系统服务实现的。应用程序调用API后转人操作系统内核进行处理时，首先就要用到SSDT ( System Service Descriptor Table,系统服务描述符表)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"><span class="title">KSERVICE</span> <span class="title">TABLE</span> <span class="title">DESCRIPTOR</span> &#123;</span></span><br><span class="line">	PULONG PTR Base ;</span><br><span class="line">	/ /表基址</span><br><span class="line">	PULONG Count;</span><br><span class="line">	ULONG Limit;</span><br><span class="line">	<span class="comment">//总项数</span></span><br><span class="line">	PUCHAR Number;</span><br><span class="line">	<span class="comment">//参数个数表</span></span><br><span class="line">&#125; KSERVICE TABLE DESCRIPTOR,</span><br><span class="line">★PKSERVICE TABLE DESCRI PTOR;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// KeServiceDescriptorTable - This is a table of descriptors for system </span></span><br><span class="line">service providers. Each entry in the table describes the base</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">address of the dispatch table <span class="keyword">and</span> the number of services provided.</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">tdefine NUMBER SERVICE TABLES <span class="number">2</span></span><br><span class="line">KSERVICE TABLE DESCRIPTOR KeServiceDescriptorTable[NUMBER_ SERVICE TABLES];</span><br><span class="line">KSERVICE TABLE DESCRIPTOR KeServiceDescriptorTableShadow[NUMBER SERVICE TABLES];</span><br></pre></td></tr></table></figure>
<h5 id="C-类的虚函数表"><a href="#C-类的虚函数表" class="headerlink" title="C++类的虚函数表"></a>C++类的虚函数表</h5><p>虚函数和重载是C++非常重要的特性，它可以使子类以相同的接口实现与基类不同的功能。<br>编译器在实现这一功能时，使用了一个地址表来保存虚函数的地址，称为虚函数表( Virtual Function Table, VFT)。</p>
<p>在默认情况下，该地址表中保存了基类的虚函数地址，一旦子类重载了某个函数，编译器就会用子类中该函数的地址替换虚函数表中对应的函数地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PEDIYBase</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span> <span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"PEDIYBase: :fun1"</span>&lt;end1; &#125;;</span><br><span class="line">		<span class="comment">//共3个虚函数</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span> <span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">" PEDIYBase: : fun2"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" PEDIYBase: : fun3"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">fun4</span> <span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"PEDIYBase: : fun4"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PEDIYEX</span> :</span> <span class="keyword">public</span> PEDIYBase</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span> <span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PEDIYEx: : fun1 ()&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"PEDIYEx: : fun1"</span>&lt;&lt;<span class="built_in">endl</span> ; <span class="comment">//重载了funl函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int_ _tmain(<span class="keyword">int</span> argc, TCHAR* argv[]， TCHAR* envp[])</span><br><span class="line">	<span class="keyword">int</span> nRetCode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialize MFC and print and error on failure</span></span><br><span class="line">	<span class="keyword">if</span> (!AfxWinInit(::GetModuleHandle (<span class="literal">NULL</span>), <span class="literal">NULL</span>,::GetCommandLine(), <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> change error code to suit your needs</span></span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; T(<span class="string">"Fatal Error: MFC initialization failed"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		nRetCode = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> code your appl ication's behavior here.</span></span><br><span class="line">		pfun fun-<span class="literal">NULL</span>;</span><br><span class="line">		PEDIYBase *pbase = <span class="keyword">new</span> PEDIYBase;</span><br><span class="line">		PEDIYEx *pDIYEx = <span class="keyword">new</span> PEDIYEX;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"pbase = 0x"</span> &lt;&lt; <span class="built_in">std</span>: :hex &lt;&lt; pbase &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		</span><br><span class="line">		pbase-&gt;funl () ;</span><br><span class="line">		pDIYEx-&gt;fun1 () ;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">delete</span> pDIYEX;</span><br><span class="line">		<span class="keyword">delete</span> pbase;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nRetCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++类种如果有虚函数成员, 第一个元素就是虚函数地址表, 重载就是子类的方法去覆盖父类的方法, 也就是地址替换(实际上Hook也是可以这么做)</p>
<h5 id="COM接口的功能函数列表"><a href="#COM接口的功能函数列表" class="headerlink" title="COM接口的功能函数列表"></a>COM接口的功能函数列表</h5><p>COM技术是在Windows中常用的一种技术。可以用不同的语言编写COM组件，从而在二进制层面暴露统的接口。 而且，同一个COM接口的所有接口函数都放在一个表中，这一点几乎与 C++的虚函数表一模一样。<br>通过一段简单的代码来观察一 操作系统外壳接口IShell的接口函数，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ShellTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HRESULT hr;</span><br><span class="line">	IShellDi spatch *pShellDispatch = <span class="literal">NULL</span> ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (CoInitialize (<span class="literal">NULL</span>) != S_ <span class="number">0</span>K)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">"CoInitialize failed! \n"</span>) ;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hr = CoCreateInstance (CLSID_ Shell, <span class="literal">NULL</span>, CLSCTX_ SERVER, IID_ IShellDispatch, (LPVOID*) &amp;pShellDispatch) ;</span><br><span class="line">	<span class="keyword">if</span> (hr == S_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">"pShellDispatch = 0x8X\n"</span> , pShellDispatch) ;</span><br><span class="line">		pShellDi spatch-&gt;FindFiles () ;</span><br><span class="line">		pShel lDispatch-&gt;Release() ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">"Create Instance failed!\n"</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CoUninitialize() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>printf输出的是接口实例, 地址为154678h, COM接口通用存在vftable,与C++种的vftable完全一样 </p>
<p>替换vftable地址就可以实现对COM接口的Hook<br>开发只会替换表中个别地址来进行Hook<br>如果直接替换这个地址表的基址?这样可以不修改原表内容对全部项目进行Hook<br>流向的内核重载技术实际上就是这样做的(只是一种大规模的AddressHook而已)</p>
<h5 id="DRIVER-OBJECT中的MajorFunction及FastIo派遣例程地址"><a href="#DRIVER-OBJECT中的MajorFunction及FastIo派遣例程地址" class="headerlink" title="DRIVER_OBJECT中的MajorFunction及FastIo派遣例程地址"></a>DRIVER_OBJECT中的MajorFunction及FastIo派遣例程地址</h5><p>以ntfs.sys为例, FSD HOOk其实就是修改FileSystem Driver的派遣例程地址 </p>
<h5 id="StartIo等特殊例程的地址"><a href="#StartIo等特殊例程的地址" class="headerlink" title="StartIo等特殊例程的地址"></a>StartIo等特殊例程的地址</h5><p>用于IRP的串行处理, 在nt!IoStartPacket中被调用 </p>
<h5 id="OBJECT-TYPE中-OBJECT-TYPE-INITIALIZER中包含的各种处理过程"><a href="#OBJECT-TYPE中-OBJECT-TYPE-INITIALIZER中包含的各种处理过程" class="headerlink" title="OBJECT_TYPE中_OBJECT_TYPE_INITIALIZER中包含的各种处理过程"></a>OBJECT_TYPE中_OBJECT_TYPE_INITIALIZER中包含的各种处理过程</h5><p>对象(Ohject)是Windows内核的一个基本元素。系统中有许多不同类型的对象(例如，打开文件生成了一个文件对象，创建进程生成了一个进程对象)。<br>在每种对象的头部都有一个指针表明了该对象的类型。在类型结构中存放了一些处理例程(OBJECT_TYPE JNITIALIZER 结构),用于处理该类型对象的创建、解析、删除等。</p>
<p><img src="/2020/05/27/encry-decry/image-23.png" width="650px"></p>
<p>只要替换_OBJECT_TYPE_INITIALIZER结构中的该例程地址,就可实现对指定文件或目录的重定向 </p>
<h5 id="特殊寄存器中的地址"><a href="#特殊寄存器中的地址" class="headerlink" title="特殊寄存器中的地址"></a>特殊寄存器中的地址</h5><p>Windows使用MSR寄存器组中IA32 SYSENTER EIP 的值作为内核调用的人口，当在ntdll中调用汇编指令sysenter进入内核时，CPU会首先执行到这里。</p>
<p>因此，通过修改MSR寄存器中保存的快速调用人口函数地址，同样可以进行Hook </p>
<h5 id="特殊的函数指针"><a href="#特殊的函数指针" class="headerlink" title="特殊的函数指针"></a>特殊的函数指针</h5><p>特定的函数指针存放在已知的地址中,而不是存放表中 </p>
<p><img src="/2020/05/27/encry-decry/image-24.png" width="550px"> </p>
<p>以上代码实际上调用了lofCompleteRequest 函数来完成IRP请求。类似以指针方式调用的函数还有IoCallDriver IoAllocatelrp、 IoFreeIrp, 它们都是与IRP处理有关的函数。为什么要这么做呢?</p>
<p>事实上，除了在正常情况下调用的这些函数，在内核中还有一-组 函数，包括loAllocateIrpe lovCallDriver 、loypCompleRequest、IoFreelrpPrivate 当需要对驱动进行verily 操作时，系统就会用Iov系列函数的地址来代替当前函数的地址，从而实现对IRP全生命周期的追踪检查。由于这些函数都与IRP处理有关,当需要对IRP进行干预时，就可以用同样的方式替换这些处理过程(著名的ARK工具IceSword就是这么做的)。</p>
<p>另一个比较知名的函数KiDebugRoutine也位于内核中。它是内核调试引擎的异常处理函数，当内核调试引擎活动时它指向KdpTrap函数，不活动时它指向KdpStub函数。所以，Hook 它可以起到反内核调试的作用，它也因此被各类外挂/反外挂程序关注。</p>
<h4 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h4><p>Inline Hook是指直接修改指令的Hook, 与Address Hook相比较更容易理解 </p>
<p>因为关键是转移程序的执行流程, 所以一般使用jmp、call、retn之类的转移指令 </p>
<h5 id="1-jmp-XXxXXXxx-5字节"><a href="#1-jmp-XXxXXXxx-5字节" class="headerlink" title="1. jmp XXxXXXxx (5字节)"></a>1. jmp XXxXXXxx (5字节)</h5><p>直接跳转到某地址</p>
<h5 id="2-push-xxxxxx-rein-6字节"><a href="#2-push-xxxxxx-rein-6字节" class="headerlink" title="2. push xxxxxx/rein ( 6字节)"></a>2. push xxxxxx/rein ( 6字节)</h5><p>通过压栈返回实现跳转</p>
<p><img src="/2020/05/27/encry-decry/image-25.png" width="1000px"></p>
<h5 id="3-mov-eax-xxxxxxxx-jmp-eax-7字节"><a href="#3-mov-eax-xxxxxxxx-jmp-eax-7字节" class="headerlink" title="3. mov eax, xxxxxxxx/jmp eax(7字节)"></a>3. mov eax, xxxxxxxx/jmp eax(7字节)</h5><p>先将转移地址放入寄存器, 再实现跳转 </p>
<p><img src="/2020/05/27/encry-decry/image-26.png" width="1000px"></p>
<h5 id="4-call-Hook-更换指令或输入表"><a href="#4-call-Hook-更换指令或输入表" class="headerlink" title="4. call Hook(更换指令或输入表)"></a>4. call Hook(更换指令或输入表)</h5><p><img src="/2020/05/27/encry-decry/image-27.png" width="1000px"></p>
<p>这类与IAT Hook类似 </p>
<p><img src="/2020/05/27/encry-decry/image-28.png" width="1000px"> </p>
<h5 id="5-HotPatch-Hook"><a href="#5-HotPatch-Hook" class="headerlink" title="5. HotPatch Hook"></a>5. HotPatch Hook</h5><p>一个短跳加一个长跳 </p>
<p><img src="/2020/05/27/encry-decry/image-29.png" width="1000px"></p>
<blockquote>
<p>为何出现这几种形式, WindowsApi开头指令有两种形式<br>主要区别是否使用SEH </p>
</blockquote>
<p>如果是5字节的jmp,那么在未使用SEH时刚好覆盖前3条指令;如果使用了SEH,那么“mov eax, xxxjmp”指令刚好覆盖前2条指令。push/retn 为6字节，不能刚好全部覆盖原来的指令，但是 它和jmp有一个相同的好处是不改变任何寄存器的值。</p>
<p>至于如图13.18所示这种奇怪的“两级跳” ,其实是微软用来实现HotPatch的方式。每个函数的第1条指令一定为2字节，而且从函数位置向上，一般是5个nop或INT3 (这些都是为这种Hook方式准备的)。<br>这样不管API函数有没有使用SEH,其第1条指令的长度都是2字节(这就是“mov edi, edi”这条作用与nop指令相同的指令存在的原因),都可以用这样一种通用的方式 (“短跳”加 “长跳”)来进行Hook。</p>
<h4 id="基于异常处理的Hook"><a href="#基于异常处理的Hook" class="headerlink" title="基于异常处理的Hook"></a>基于异常处理的Hook</h4><p>除了前面两种正规的Hook之外,还有基于异常的处理机制实现的 </p>
<p><img src="/2020/05/27/encry-decry/image-30.png" width="550px"></p>
<p>对Windows异常处理机制有一定了解的读者都知道，当程序执行过程中发生异常时，系统内核的异常处理过程nt!KiDispatchException会开始工作。在没有内核调试器存在且异常程序没有被调试的情况下，系统把异常处理过程转交给用户态的异常处理过程( nll!RtlDispatchException)，以查找系统中是否安装了异常处理程序(例如VEH、SEH、TopLevelExceptionHandler)。<br>如果已经安装，就会调用异常处理过程对其进行处理。详细过程如图13.20所示。</p>
<p>因此如果在程序中自行安装SEH (或VEH)处理过程，然后向被Hook的位置写人一条会引发异常的指令(最简单的就是写人断点指令INT 3),或者通过改变被Hook位置的内存属性引发内存访问异常，抑或中断指令等。<br>接下来只要程序执行到这里，就会触发异常，跳转到事先安装的异常处理过程中。</p>
<p>在实际应用中，因为SEH的使用有较多限制(基于线程、非全局、基于栈)，而VEH优点更多(基于进程、全局，并且优先于SEH处理),所以通过“VEH + INT3”进行Hook更具有实用性。<br>如果读者对Windows的异常处理机制有深人的了解，甚至可以Hook掉ndl!KiUserExceptionDispatchero这里是异常处理过程返回用户层处理的第1站，Hook了这里,就比VEH更早拥有了控制权。</p>
<p>流行的CPU虚拟化技术(简单VT)还能使Host OS在比RO更高的权限下工作，从而捕获由Guest OS执行特权指令引起的异常事件，并对返回结果进行干预(例如，可以干预cpuid指令的返<br>回结果)。 所以也可以认为这是一种基于异常的Hook。</p>
<h4 id="不是Hook的Hook"><a href="#不是Hook的Hook" class="headerlink" title="不是Hook的Hook"></a>不是Hook的Hook</h4><h5 id="PE病毒感染-修改了EntryPoint"><a href="#PE病毒感染-修改了EntryPoint" class="headerlink" title="PE病毒感染,修改了EntryPoint"></a>PE病毒感染,修改了EntryPoint</h5><p>一个“优秀”的病毒，会在执行病毒代码后跳回原始人口，执行程序的正常功能，使用户不太容易察觉程序实际上已经被感染了。正如一个优秀的Hook 程序，除了达到自己的目的，不会对原来的调用产生影响。</p>
<h5 id="系统回调机制与分层模型"><a href="#系统回调机制与分层模型" class="headerlink" title="系统回调机制与分层模型"></a>系统回调机制与分层模型</h5><p>操作系统提供了正规的接口,理解为正规的Hook </p>
<ul>
<li>各类回调机制 </li>
</ul>
<p>典型的有消息钩子及内核中的各类回调(进程、线程创建回调、加载映像回调、 注册表回调等)</p>
<ul>
<li>分层服务和过滤驱动模型 </li>
</ul>
<p>一个典型机制是LSP服务提供者，它是一个位于应用层的分层服务。由于用户进程中所有的网络数据都由LSP服务提供者处理，它当然可以用于网络数据处理的Hook。</p>
<p>另一个非常典型的机制就是微软制定的驱动模型( Class/Port/MiniPort),其中有我们熟悉的文件和磁盘过滤驱动。文件保护、透明加密、磁盘还原就是其典型应用 </p>
<p><img src="/2020/05/27/encry-decry/image-31.png" width="750px"></p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="IAT-Hook篡改MessageBox消息"><a href="#IAT-Hook篡改MessageBox消息" class="headerlink" title="IAT Hook篡改MessageBox消息"></a>IAT Hook篡改MessageBox消息</h5><p>IAT Hook主要工作就是修改你想要Hook的API对应在IAT表中的地址(IAT:全名Import Address Table)</p>
<ul>
<li>以下是被Hook的对象 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Message.cpp : 定义应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Message.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LOADSTRING 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量: </span></span><br><span class="line">HINSTANCE hInst;								<span class="comment">// 当前实例</span></span><br><span class="line">TCHAR szTitle[MAX_LOADSTRING];					<span class="comment">// 标题栏文本</span></span><br><span class="line">TCHAR szWindowClass[MAX_LOADSTRING];			<span class="comment">// 主窗口类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此代码模块中包含的函数的前向声明: </span></span><br><span class="line"><span class="function">ATOM				<span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span>;</span><br><span class="line"><span class="function">BOOL				<span class="title">InitInstance</span><span class="params">(HINSTANCE, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">LRESULT CALLBACK	<span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"><span class="function">INT_PTR CALLBACK	<span class="title">About</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> APIENTRY _tWinMain(_In_ HINSTANCE hInstance,</span><br><span class="line">                     _In_opt_ HINSTANCE hPrevInstance,</span><br><span class="line">                     _In_ LPTSTR    lpCmdLine,</span><br><span class="line">                     _In_ <span class="keyword">int</span>       nCmdShow)</span><br><span class="line">&#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(hPrevInstance);</span><br><span class="line">	UNREFERENCED_PARAMETER(lpCmdLine);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// <span class="doctag">TODO:</span>  在此放置代码。</span></span><br><span class="line">	MSG msg;</span><br><span class="line">	HACCEL hAccelTable;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化全局字符串</span></span><br><span class="line">	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);</span><br><span class="line">	LoadString(hInstance, IDC_MESSAGE, szWindowClass, MAX_LOADSTRING);</span><br><span class="line">	MyRegisterClass(hInstance);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行应用程序初始化: </span></span><br><span class="line">	<span class="keyword">if</span> (!InitInstance (hInstance, nCmdShow))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MESSAGE));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主消息循环: </span></span><br><span class="line">	<span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))</span><br><span class="line">		&#123;</span><br><span class="line">			TranslateMessage(&amp;msg);</span><br><span class="line">			DispatchMessage(&amp;msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>) msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数:  MyRegisterClass()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的:  注册窗口类。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">ATOM <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WNDCLASSEX wcex;</span><br><span class="line"></span><br><span class="line">	wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line"></span><br><span class="line">	wcex.style			= CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">	wcex.lpfnWndProc	= WndProc;</span><br><span class="line">	wcex.cbClsExtra		= <span class="number">0</span>;</span><br><span class="line">	wcex.cbWndExtra		= <span class="number">0</span>;</span><br><span class="line">	wcex.hInstance		= hInstance;</span><br><span class="line">	wcex.hIcon			= LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MESSAGE));</span><br><span class="line">	wcex.hCursor		= LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+<span class="number">1</span>);</span><br><span class="line">	wcex.lpszMenuName	= MAKEINTRESOURCE(IDC_MESSAGE);</span><br><span class="line">	wcex.lpszClassName	= szWindowClass;</span><br><span class="line">	wcex.hIconSm		= LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> RegisterClassEx(&amp;wcex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   函数:  InitInstance(HINSTANCE, int)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   目的:  保存实例句柄并创建主窗口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   注释: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        在此函数中，我们在全局变量中保存实例句柄并</span></span><br><span class="line"><span class="comment">//        创建和显示主程序窗口。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">BOOL <span class="title">InitInstance</span><span class="params">(HINSTANCE hInstance, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   HWND hWnd;</span><br><span class="line"></span><br><span class="line">   hInst = hInstance; <span class="comment">// 将实例句柄存储在全局变量中</span></span><br><span class="line"></span><br><span class="line">   hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,</span><br><span class="line">      CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!hWnd)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ShowWindow(hWnd, nCmdShow);</span><br><span class="line">   UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数:  WndProc(HWND, UINT, WPARAM, LPARAM)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的:    处理主窗口的消息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  WM_COMMAND	- 处理应用程序菜单</span></span><br><span class="line"><span class="comment">//  WM_PAINT	- 绘制主窗口</span></span><br><span class="line"><span class="comment">//  WM_DESTROY	- 发送退出消息并返回</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> wmId, wmEvent;</span><br><span class="line">	PAINTSTRUCT ps;</span><br><span class="line">	HDC hdc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (message)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">		wmId    = LOWORD(wParam);</span><br><span class="line">		wmEvent = HIWORD(wParam);</span><br><span class="line">		<span class="comment">// 分析菜单选择: </span></span><br><span class="line">		<span class="keyword">switch</span> (wmId)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> IDM_ABOUT:</span><br><span class="line">			MessageBoxW(hWnd, <span class="string">L"哈哈,你单击了我，收到你消息了"</span>, <span class="string">L"messagebox"</span>, MB_ICONINFORMATION);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> IDM_EXIT:</span><br><span class="line">			DestroyWindow(hWnd);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_PAINT:</span><br><span class="line">		hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span>  在此添加任意绘图代码...</span></span><br><span class="line">		EndPaint(hWnd, &amp;ps);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">		PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “关于”框的消息处理程序。</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">About</span><span class="params">(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(lParam);</span><br><span class="line">	<span class="keyword">switch</span> (message)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">		<span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">		<span class="keyword">if</span> (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)</span><br><span class="line">		&#123;</span><br><span class="line">			EndDialog(hDlg, LOWORD(wParam));</span><br><span class="line">			<span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (INT_PTR)FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以下是Hook的代码 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"Advapi32.lib"</span>)</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注入到目标PID进程</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InjectDll</span><span class="params">(<span class="keyword">char</span> *DllFullPath,<span class="keyword">const</span> DWORD dwRemoteProcessId)</span></span>&#123;</span><br><span class="line">	HANDLE h_token;</span><br><span class="line">	<span class="keyword">if</span> (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;h_token))</span><br><span class="line">	&#123;</span><br><span class="line">		TOKEN_PRIVILEGES tkp;</span><br><span class="line">		<span class="comment">//修改进程权限</span></span><br><span class="line">		LookupPrivilegeValue(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tkp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line">		tkp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">		tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">		<span class="comment">//通知系统修改进程权限</span></span><br><span class="line">		AdjustTokenPrivileges(h_token, FALSE, &amp;tkp, <span class="keyword">sizeof</span>(tkp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	HANDLE hRemoteProcess;</span><br><span class="line">	<span class="comment">//打开目标进程</span></span><br><span class="line">	<span class="keyword">if</span> ((hRemoteProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwRemoteProcessId)) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"OpenProcess failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"OpenProcess.OK\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在远程进程中申请内存并写入数据  payload部分的地址</span></span><br><span class="line">	DWORD dwSize = lstrlenA(DllFullPath);</span><br><span class="line">	LPVOID pszLibFileRemote;    <span class="comment">//pszLibFileRemote 类型改为LPVOID 就可以注入了  佛学。。。</span></span><br><span class="line">	pszLibFileRemote = VirtualAllocEx(hRemoteProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	<span class="keyword">int</span> er = GetLastError();</span><br><span class="line">	<span class="keyword">if</span> (pszLibFileRemote == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"VirtualAllocEx failed\n"</span>);</span><br><span class="line">		CloseHandle(hRemoteProcess);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"VirtualAllocEx OK\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"DllFullPath:%s\n"</span>, DllFullPath);</span><br><span class="line">	DWORD dwWritten = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!::WriteProcessMemory(hRemoteProcess, pszLibFileRemote, (<span class="keyword">void</span>*)DllFullPath, <span class="built_in">strlen</span>(DllFullPath) + <span class="number">1</span>, &amp;dwWritten))</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"WriteProcessMemory failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dwWritten != <span class="built_in">strlen</span>(DllFullPath) + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"WriteProcessMemery OK\n"</span>);</span><br><span class="line">			VirtualFreeEx(hRemoteProcess, pszLibFileRemote, <span class="built_in">strlen</span>(DllFullPath) + <span class="number">1</span>, MEM_DECOMMIT);</span><br><span class="line">			CloseHandle(hRemoteProcess);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"WriteProcessMemory OK\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建远程线程，执行LoadLibraryA</span></span><br><span class="line">	LPVOID pFunc = LoadLibraryA;</span><br><span class="line">	DWORD dwID;</span><br><span class="line">	HANDLE hThread = CreateRemoteThread(hRemoteProcess,<span class="literal">NULL</span>,<span class="number">0</span>,(LPTHREAD_START_ROUTINE)pFunc,pszLibFileRemote,<span class="number">0</span>,&amp;dwID);</span><br><span class="line">	WaitForSingleObject(hThread,INFINITE);</span><br><span class="line">	VirtualFreeEx(hRemoteProcess,pszLibFileRemote,<span class="built_in">strlen</span>(DllFullPath)+<span class="number">1</span>,MEM_DECOMMIT);</span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line">	CloseHandle(hRemoteProcess);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Remote thread run ok\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过进程名查找进程的ID</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetProcessID</span><span class="params">(WCHAR *ProcessName)</span></span>&#123;</span><br><span class="line">	DWORD ret = <span class="number">0</span>;</span><br><span class="line">	PROCESSENTRY32W pe32;</span><br><span class="line">	pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">	<span class="comment">//将系统当前正在运行的所有进程 拍个快照</span></span><br><span class="line">	HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//从快照中取出第一个进程</span></span><br><span class="line">	BOOL bProcess = Process32FirstW(hProcessSnap,&amp;pe32);</span><br><span class="line">	<span class="keyword">while</span> (bProcess)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//取得快照中每一个进程的名称</span></span><br><span class="line">		wstring sName = pe32.szExeFile;</span><br><span class="line">		<span class="comment">//与传入的参数对比，如果相等，返回进程ID</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">-1</span> != sName.find(ProcessName))</span><br><span class="line">		&#123;</span><br><span class="line">			ret = pe32.th32ProcessID;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//取下一个进程</span></span><br><span class="line">		bProcess = Process32NextW(hProcessSnap,&amp;pe32);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭快照</span></span><br><span class="line">	CloseHandle(hProcessSnap);</span><br><span class="line">	<span class="comment">//返回进程PID   没结果的话，返回默认0</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc,_TCHAR* argv[])&#123;</span><br><span class="line">	<span class="comment">//找到目标进程-----也可以遍历系统内所有进程，给每个进程都加上DLL</span></span><br><span class="line">	DWORD Pid = GetProcessID(<span class="string">L"Message.exe"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!Pid)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"can not find target PID\n"</span>);</span><br><span class="line">		_getch();</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Found target - PID : %d\n"</span>,Pid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始注入</span></span><br><span class="line">	<span class="comment">//构建字符串==》要注入的DLL路径</span></span><br><span class="line">	<span class="comment">//使用了绝对路径</span></span><br><span class="line">	<span class="keyword">char</span> *DllPath = <span class="string">"F:\\vs(c)\\IAPHookPayload\\Debug\\IATHookPayload.dll"</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Start to inject target - %s\n"</span>, DllPath);</span><br><span class="line">	InjectDll(DllPath,Pid);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Inject done\nexiting...."</span>);</span><br><span class="line">	_getch();</span><br><span class="line">	<span class="keyword">return</span> TRUE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以下是DLL模块代码 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE g_hModuleHandle;</span><br><span class="line">HMODULE hModuleInject = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE hInjectThread = <span class="literal">NULL</span>;</span><br><span class="line">IMAGE_DOS_HEADER* pDosHeader = <span class="literal">NULL</span>;</span><br><span class="line">IMAGE_OPTIONAL_HEADER* pOptHeader = <span class="literal">NULL</span>;</span><br><span class="line">IMAGE_IMPORT_DESCRIPTOR* pImportDesc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __declspec(dllexport) test()&#123;</span><br><span class="line">	OutputDebugString(<span class="string">L"__declspec(dllexport) test"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">MyMsgBoxW</span><span class="params">(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		MessageBoxW(hWnd, <span class="string">L"你被黑了"</span>, lpCaption, uType);</span><br><span class="line">		<span class="keyword">return</span> IDYES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">injectThread</span><span class="params">(LPARAM lparam)</span></span>&#123;</span><br><span class="line">	MessageBoxA(<span class="literal">NULL</span>, <span class="string">"进入inject成功"</span>, <span class="string">"if succeed"</span>, MB_OK);</span><br><span class="line">	<span class="comment">//获取模块句柄</span></span><br><span class="line">	hModuleInject = ::GetModuleHandleA(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//最终目标找到输入表 IAT表格</span></span><br><span class="line">	pDosHeader = (IMAGE_DOS_HEADER *)hModuleInject;</span><br><span class="line">	<span class="comment">//找到Image_Optional_Header  </span></span><br><span class="line">	<span class="comment">//24==》在IMAGE_NT_HEADERS中 signature 和 Image_File_Header 分别是4和14个字节 加起来是18个字节  是十六进制的  转换位十进制是24</span></span><br><span class="line">	pOptHeader = (IMAGE_OPTIONAL_HEADER*)((BYTE*)hModuleInject + pDosHeader-&gt;e_lfanew + <span class="number">24</span>);</span><br><span class="line">	<span class="comment">//找到输入表(Image_directory_entry_import)</span></span><br><span class="line">	pImportDesc = (IMAGE_IMPORT_DESCRIPTOR*)((BYTE*)hModuleInject + pOptHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line">	<span class="comment">//遍历每个节点 每一个节点  对应一个目标程序所调用的dll  例如：user32.dll kernel32.dll  msvcr32.dll.....</span></span><br><span class="line">	<span class="keyword">while</span> (pImportDesc-&gt;Name)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> * pazDllName = (<span class="keyword">char</span>*)((BYTE*)hModuleInject + pImportDesc-&gt;Name);</span><br><span class="line">		MessageBoxA(<span class="literal">NULL</span>, pazDllName, <span class="string">"if succeed"</span>, MB_OK);</span><br><span class="line">		<span class="keyword">if</span> (_stricmp(pazDllName, <span class="string">"IATHookPayload.dll"</span>) != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			MessageBoxA(<span class="literal">NULL</span>, pazDllName, <span class="string">"succeed to come in"</span>, MB_OK);</span><br><span class="line">			IMAGE_THUNK_DATA* pThunk = (IMAGE_THUNK_DATA*)((BYTE*)hModuleInject + pImportDesc-&gt;FirstThunk);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span> (pThunk-&gt;u1.Function)</span><br><span class="line">			&#123;</span><br><span class="line">				DWORD oldProtectValue;<span class="comment">//保存原有的内存属性的值		</span></span><br><span class="line">				<span class="keyword">if</span> (pThunk-&gt;u1.Function == (DWORD)MessageBoxW)</span><br><span class="line">				&#123;</span><br><span class="line">					MessageBoxA(<span class="literal">NULL</span>, <span class="string">"succeed to MessageBoxW"</span>, <span class="string">"if succeed to find the MessageBox"</span>, MB_OK);</span><br><span class="line">					<span class="comment">//设置内存的属性   IAT地址默认时不让写入的</span></span><br><span class="line">					VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, <span class="number">8</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtectValue);</span><br><span class="line">					pThunk-&gt;u1.Function = (DWORD)MyMsgBoxW;</span><br><span class="line">					<span class="comment">//改回原有属性</span></span><br><span class="line">					VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, <span class="number">8</span>, oldProtectValue, &amp;oldProtectValue);</span><br><span class="line">				&#125;</span><br><span class="line">				pThunk++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		pImportDesc++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HANDLE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	test();</span><br><span class="line">	g_hModuleHandle = (HMODULE)hModule;</span><br><span class="line">	<span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">		MessageBoxA(<span class="literal">NULL</span>,<span class="string">"DLL_PROCESS_ATTACH"</span>,<span class="string">"process"</span>,MB_OK);</span><br><span class="line">		DisableThreadLibraryCalls((HMODULE)hModule);</span><br><span class="line">		<span class="comment">//加载的时候会创建一个线程</span></span><br><span class="line">		hInjectThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)injectThread, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		CloseHandle(hInjectThread);</span><br><span class="line">	<span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">	<span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/27/encry-decry/image-21.png" width="1500px"></p>
<h5 id="Inline-Hook篡改MessageBox消息"><a href="#Inline-Hook篡改MessageBox消息" class="headerlink" title="Inline Hook篡改MessageBox消息"></a>Inline Hook篡改MessageBox消息</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *lpText1;</span><br><span class="line">ULONG my_esp;</span><br><span class="line">__declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">MyMessageBoxA</span><span class="params">(HWND hWnd,LPCTSTR lpText,LPCTSTR lpCaption,UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//printf("hook");</span></span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//pop hWnd</span></span><br><span class="line">		<span class="comment">//pop lpText</span></span><br><span class="line">		<span class="comment">//pop lpCaption</span></span><br><span class="line">		<span class="comment">//pop uType</span></span><br><span class="line">		mov my_esp,esp; <span class="comment">//先保存下需要用到的参数</span></span><br><span class="line">		pushad<span class="comment">//然后保存整个堆栈</span></span><br><span class="line">		pushfd</span><br><span class="line">		push eax</span><br><span class="line">		mov eax, my_esp</span><br><span class="line">		add eax, <span class="number">8</span></span><br><span class="line">		mov eax,[eax] <span class="comment">//不能直接 mov给变量，编译通不过 ， 需要用eax 中转一下，听说是编译器的问题。</span></span><br><span class="line">		mov lpText1,eax;</span><br><span class="line">		pop eax;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"MyMessageBoxA lpText: %s \r\n"</span>,lpText1); <span class="comment">//lpText1已经是地址了 不需要&amp;度地址赋。</span></span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		popfd</span><br><span class="line">		popad <span class="comment">//把堆栈还原掉。</span></span><br><span class="line">		RETN <span class="number">16</span>; <span class="comment">//把参数废除掉 4*n 屏蔽掉MessageBoxA</span></span><br><span class="line">	&#125;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		PUSH EBP   <span class="comment">//执行以下被HOOK掉的 头5个字节。</span></span><br><span class="line">		MOV EBP,ESP</span><br><span class="line">		JMP newbark;   <span class="comment">//然后调回去</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hook的位置挑选"><a href="#Hook的位置挑选" class="headerlink" title="Hook的位置挑选"></a>Hook的位置挑选</h3><p>先了解执行流 </p>
<p>这个过程就像很多地表径流和支流汇入干流(主河道)的过程，如图13.23 所示。Hook的位置越往上，就可以越早得到控制权，从而优先进行处理，但因为拦截的范围有限，所以也容易被绕过(对小的河流极易进行“改道” );<br>Hook的位置越往下，得到控制权就越晚，但是在该调用真正实施之前，安装Hook的程序有最终的决定权，而且不容易被绕过。<br>另一个显而易见的特点是，Hook 的位置越往下，经过的“流量”就越大(也就是说，调用频率越高),对系统性能的影响也越大。</p>
<ul>
<li>影响最小的Hook: 应用程序中的call Hook,精确到特定位置对特定APi的调用</li>
<li>影响最大的Hook: 系统内核中,大部分Hook的未知都会影响整个系统的调用过程,越往下就越明显 </li>
</ul>
<p><img src="/2020/05/27/encry-decry/image-32.png" width="1000px"></p>
<p>所以，必须选择调用点“下游”的位置进行Hook,在满足拦截范围的情况下，离调用点不要太远，从而使拦截范围尽可能小。同时，要考虑参数处理的难易程度。通常情况下，上层的调用接口比较清楚，参数意义明确，甚至多数已经文档化，而当参数传递到下层的接口时，可能会丧失一部分特性数据，给处理参数带来不便。<br>在应用层上，对API进行IAT Hook和Inline Hook 足以满足这个要求。在内核中，KiFastCallEntry 和KeServiceDescriptorTable (含Shadow )是两个绝佳的Hook位置。</p>
<p>早期的各类安全软件基本上都是通过Hook SSDT和SSDT Shadow达到主动防御和自我保护的目的</p>
<p><img src="/2020/05/27/encry-decry/image-33.png" width="700px"></p>
<p>后来，由于安全软件防护体系的日益完善，需要Hook 的系统服务越来越多，很多安全软件就<br>把Hook的位置移到了KiFastCallEntry 内部。这样，只要Hook一个位置，不仅可以达到Hook多个<br>系统服务的目的，还能兼顾SSDT和SSDT Shadow</p>
<p><img src="/2020/05/27/encry-decry/image-34.png" width="1100px"></p>
<h3 id="Hook的典型过程"><a href="#Hook的典型过程" class="headerlink" title="Hook的典型过程"></a>Hook的典型过程</h3><p>不管哪种Hook,都需要定义一个函数来替代被Hook的函数, 参照微软的Detour的概念,称该函数为Detour函数 </p>
<p>其原型、调用约定、返回值斗鱼原函数一摸一样</p>
<p>如果在Detour函数需要调用原函数来实现功能,就需要通过某种方式来调用原始函数 </p>
<p>Address Hook和Inline Hook处理方式各有所不同  </p>
<h4 id="Address-Hook的实施过程"><a href="#Address-Hook的实施过程" class="headerlink" title="Address Hook的实施过程"></a>Address Hook的实施过程</h4><h4 id="Inline-Hook的实施过程"><a href="#Inline-Hook的实施过程" class="headerlink" title="Inline Hook的实施过程"></a>Inline Hook的实施过程</h4><h4 id="基于异常处理的Hook的实施过程"><a href="#基于异常处理的Hook的实施过程" class="headerlink" title="基于异常处理的Hook的实施过程"></a>基于异常处理的Hook的实施过程</h4><h4 id="二次Hook的注意事项"><a href="#二次Hook的注意事项" class="headerlink" title="二次Hook的注意事项"></a>二次Hook的注意事项</h4><h4 id="通过Hook引擎的实现"><a href="#通过Hook引擎的实现" class="headerlink" title="通过Hook引擎的实现"></a>通过Hook引擎的实现</h4><h3 id="Detour函数的用法"><a href="#Detour函数的用法" class="headerlink" title="Detour函数的用法"></a>Detour函数的用法</h3><h3 id="Hook中的注意事项"><a href="#Hook中的注意事项" class="headerlink" title="Hook中的注意事项"></a>Hook中的注意事项</h3><h3 id="Hook在x64平台上的新问题"><a href="#Hook在x64平台上的新问题" class="headerlink" title="Hook在x64平台上的新问题"></a>Hook在x64平台上的新问题</h3><h3 id="Hook技术的应用"><a href="#Hook技术的应用" class="headerlink" title="Hook技术的应用"></a>Hook技术的应用</h3><h4 id="Hook的检测、恢复"><a href="#Hook的检测、恢复" class="headerlink" title="Hook的检测、恢复"></a>Hook的检测、恢复</h4><h4 id="Hook的对抗"><a href="#Hook的对抗" class="headerlink" title="Hook的对抗"></a>Hook的对抗</h4><h1 id="漏洞篇"><a href="#漏洞篇" class="headerlink" title="漏洞篇"></a>漏洞篇</h1><h2 id="漏洞分析技术"><a href="#漏洞分析技术" class="headerlink" title="漏洞分析技术"></a>漏洞分析技术</h2><h3 id="软件漏洞原理"><a href="#软件漏洞原理" class="headerlink" title="软件漏洞原理"></a>软件漏洞原理</h3><h4 id="缓冲区溢出漏洞"><a href="#缓冲区溢出漏洞" class="headerlink" title="缓冲区溢出漏洞"></a>缓冲区溢出漏洞</h4><h4 id="整型溢出漏洞"><a href="#整型溢出漏洞" class="headerlink" title="整型溢出漏洞"></a>整型溢出漏洞</h4><h4 id="UAF漏洞"><a href="#UAF漏洞" class="headerlink" title="UAF漏洞"></a>UAF漏洞</h4><h3 id="ShellCode"><a href="#ShellCode" class="headerlink" title="ShellCode"></a>ShellCode</h3><h4 id="ShellCode的结构"><a href="#ShellCode的结构" class="headerlink" title="ShellCode的结构"></a>ShellCode的结构</h4><h4 id="ShellCode通用技术"><a href="#ShellCode通用技术" class="headerlink" title="ShellCode通用技术"></a>ShellCode通用技术</h4><h4 id="实战ShellCode的编写"><a href="#实战ShellCode的编写" class="headerlink" title="实战ShellCode的编写"></a>实战ShellCode的编写</h4><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="漏洞利用基本技术"><a href="#漏洞利用基本技术" class="headerlink" title="漏洞利用基本技术"></a>漏洞利用基本技术</h4><h4 id="漏洞利用高级技术"><a href="#漏洞利用高级技术" class="headerlink" title="漏洞利用高级技术"></a>漏洞利用高级技术</h4><h3 id="漏洞样本"><a href="#漏洞样本" class="headerlink" title="漏洞样本"></a>漏洞样本</h3><h3 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><h4 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h4><h4 id="追根溯源"><a href="#追根溯源" class="headerlink" title="追根溯源"></a>追根溯源</h4><h1 id="脱壳篇"><a href="#脱壳篇" class="headerlink" title="脱壳篇"></a>脱壳篇</h1><h2 id="专用加密软件"><a href="#专用加密软件" class="headerlink" title="专用加密软件"></a>专用加密软件</h2><h3 id="认识壳"><a href="#认识壳" class="headerlink" title="认识壳"></a>认识壳</h3><h4 id="壳的引擎"><a href="#壳的引擎" class="headerlink" title="壳的引擎"></a>壳的引擎</h4><h4 id="压缩引擎"><a href="#压缩引擎" class="headerlink" title="压缩引擎"></a>压缩引擎</h4><h3 id="压缩壳"><a href="#压缩壳" class="headerlink" title="压缩壳"></a>压缩壳</h3><h4 id="UPX"><a href="#UPX" class="headerlink" title="UPX"></a>UPX</h4><h4 id="ASPack"><a href="#ASPack" class="headerlink" title="ASPack"></a>ASPack</h4><h3 id="加密壳"><a href="#加密壳" class="headerlink" title="加密壳"></a>加密壳</h3><h4 id="ASProtect"><a href="#ASProtect" class="headerlink" title="ASProtect"></a>ASProtect</h4><h4 id="Armadillo"><a href="#Armadillo" class="headerlink" title="Armadillo"></a>Armadillo</h4><h4 id="EXECryptor"><a href="#EXECryptor" class="headerlink" title="EXECryptor"></a>EXECryptor</h4><h4 id="Themida"><a href="#Themida" class="headerlink" title="Themida"></a>Themida</h4><h3 id="虚拟机保护软件"><a href="#虚拟机保护软件" class="headerlink" title="虚拟机保护软件"></a>虚拟机保护软件</h3><h4 id="虚拟机介绍"><a href="#虚拟机介绍" class="headerlink" title="虚拟机介绍"></a>虚拟机介绍</h4><h4 id="VMProtect简介"><a href="#VMProtect简介" class="headerlink" title="VMProtect简介"></a>VMProtect简介</h4><h2 id="脱壳技术"><a href="#脱壳技术" class="headerlink" title="脱壳技术"></a>脱壳技术</h2><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><h4 id="壳的加载过程"><a href="#壳的加载过程" class="headerlink" title="壳的加载过程"></a>壳的加载过程</h4><h4 id="脱壳机"><a href="#脱壳机" class="headerlink" title="脱壳机"></a>脱壳机</h4><h4 id="手动脱壳"><a href="#手动脱壳" class="headerlink" title="手动脱壳"></a>手动脱壳</h4><h3 id="寻找OEP"><a href="#寻找OEP" class="headerlink" title="寻找OEP"></a>寻找OEP</h3><h4 id="根据跨段指令寻找OEP"><a href="#根据跨段指令寻找OEP" class="headerlink" title="根据跨段指令寻找OEP"></a>根据跨段指令寻找OEP</h4><h4 id="内存访问断点寻找OEP"><a href="#内存访问断点寻找OEP" class="headerlink" title="内存访问断点寻找OEP"></a>内存访问断点寻找OEP</h4><h4 id="根据栈平衡原理寻找OEP"><a href="#根据栈平衡原理寻找OEP" class="headerlink" title="根据栈平衡原理寻找OEP"></a>根据栈平衡原理寻找OEP</h4><h4 id="根据编译语言特点寻找OEP"><a href="#根据编译语言特点寻找OEP" class="headerlink" title="根据编译语言特点寻找OEP"></a>根据编译语言特点寻找OEP</h4><h3 id="抓取内存映像"><a href="#抓取内存映像" class="headerlink" title="抓取内存映像"></a>抓取内存映像</h3><h4 id="Dump原理"><a href="#Dump原理" class="headerlink" title="Dump原理"></a>Dump原理</h4><h4 id="反Dump技术"><a href="#反Dump技术" class="headerlink" title="反Dump技术"></a>反Dump技术</h4><h3 id="重建输入表"><a href="#重建输入表" class="headerlink" title="重建输入表"></a>重建输入表</h3><h4 id="输入表重建的原理"><a href="#输入表重建的原理" class="headerlink" title="输入表重建的原理"></a>输入表重建的原理</h4><h4 id="确定IAT的地址和大小"><a href="#确定IAT的地址和大小" class="headerlink" title="确定IAT的地址和大小"></a>确定IAT的地址和大小</h4><h4 id="根据IAT的地址和大小"><a href="#根据IAT的地址和大小" class="headerlink" title="根据IAT的地址和大小"></a>根据IAT的地址和大小</h4><h4 id="根据IAT重建输入表"><a href="#根据IAT重建输入表" class="headerlink" title="根据IAT重建输入表"></a>根据IAT重建输入表</h4><h4 id="用Import-REC重建输入表"><a href="#用Import-REC重建输入表" class="headerlink" title="用Import REC重建输入表"></a>用Import REC重建输入表</h4><h4 id="输入表加密概括"><a href="#输入表加密概括" class="headerlink" title="输入表加密概括"></a>输入表加密概括</h4><h3 id="Dll文件脱壳"><a href="#Dll文件脱壳" class="headerlink" title="Dll文件脱壳"></a>Dll文件脱壳</h3><h4 id="寻找OEP-1"><a href="#寻找OEP-1" class="headerlink" title="寻找OEP"></a>寻找OEP</h4><h4 id="Dump映像文件"><a href="#Dump映像文件" class="headerlink" title="Dump映像文件"></a>Dump映像文件</h4><h4 id="重建Dll的输入表"><a href="#重建Dll的输入表" class="headerlink" title="重建Dll的输入表"></a>重建Dll的输入表</h4><h4 id="构造重定位表"><a href="#构造重定位表" class="headerlink" title="构造重定位表"></a>构造重定位表</h4><h3 id="附加数据"><a href="#附加数据" class="headerlink" title="附加数据"></a>附加数据</h3><h3 id="PE文件的优化"><a href="#PE文件的优化" class="headerlink" title="PE文件的优化"></a>PE文件的优化</h3><h3 id="压缩壳-1"><a href="#压缩壳-1" class="headerlink" title="压缩壳"></a>压缩壳</h3><h4 id="UPX外壳"><a href="#UPX外壳" class="headerlink" title="UPX外壳"></a>UPX外壳</h4><h4 id="ASPack外壳"><a href="#ASPack外壳" class="headerlink" title="ASPack外壳"></a>ASPack外壳</h4><h3 id="加密壳-1"><a href="#加密壳-1" class="headerlink" title="加密壳"></a>加密壳</h3><h3 id="静态脱壳"><a href="#静态脱壳" class="headerlink" title="静态脱壳"></a>静态脱壳</h3><h4 id="外壳Loader分析"><a href="#外壳Loader分析" class="headerlink" title="外壳Loader分析"></a>外壳Loader分析</h4><h4 id="编写静态脱壳器"><a href="#编写静态脱壳器" class="headerlink" title="编写静态脱壳器"></a>编写静态脱壳器</h4><h1 id="保护篇"><a href="#保护篇" class="headerlink" title="保护篇"></a>保护篇</h1><h2 id="软件保护技术"><a href="#软件保护技术" class="headerlink" title="软件保护技术"></a>软件保护技术</h2><h3 id="防范算法求逆"><a href="#防范算法求逆" class="headerlink" title="防范算法求逆"></a>防范算法求逆</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h4 id="堡垒战术"><a href="#堡垒战术" class="headerlink" title="堡垒战术"></a>堡垒战术</h4><h4 id="游击战术"><a href="#游击战术" class="headerlink" title="游击战术"></a>游击战术</h4><h3 id="抵静态分析"><a href="#抵静态分析" class="headerlink" title="抵静态分析"></a>抵静态分析</h3><h4 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h4><h4 id="SMC技术实现"><a href="#SMC技术实现" class="headerlink" title="SMC技术实现"></a>SMC技术实现</h4><h4 id="信息隐藏"><a href="#信息隐藏" class="headerlink" title="信息隐藏"></a>信息隐藏</h4><h4 id="简单的多态变形技术"><a href="#简单的多态变形技术" class="headerlink" title="简单的多态变形技术"></a>简单的多态变形技术</h4><h3 id="文件完整性校验"><a href="#文件完整性校验" class="headerlink" title="文件完整性校验"></a>文件完整性校验</h3><h4 id="磁盘文件校验的实现"><a href="#磁盘文件校验的实现" class="headerlink" title="磁盘文件校验的实现"></a>磁盘文件校验的实现</h4><h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><h4 id="内存映像校验"><a href="#内存映像校验" class="headerlink" title="内存映像校验"></a>内存映像校验</h4><h3 id="代码和数据结合"><a href="#代码和数据结合" class="headerlink" title="代码和数据结合"></a>代码和数据结合</h3><h4 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h4><h4 id="加密算法的选用"><a href="#加密算法的选用" class="headerlink" title="加密算法的选用"></a>加密算法的选用</h4><h4 id="手动加密代码"><a href="#手动加密代码" class="headerlink" title="手动加密代码"></a>手动加密代码</h4><h4 id="使-txt区块可写"><a href="#使-txt区块可写" class="headerlink" title="使.txt区块可写"></a>使.txt区块可写</h4><h2 id="反跟踪技术"><a href="#反跟踪技术" class="headerlink" title="反跟踪技术"></a>反跟踪技术</h2><h3 id="由BeingDebugged引发的蝴蝶效应"><a href="#由BeingDebugged引发的蝴蝶效应" class="headerlink" title="由BeingDebugged引发的蝴蝶效应"></a>由BeingDebugged引发的蝴蝶效应</h3><h4 id="BeingDebugged"><a href="#BeingDebugged" class="headerlink" title="BeingDebugged"></a>BeingDebugged</h4><h4 id="NtGlobalFlag"><a href="#NtGlobalFlag" class="headerlink" title="NtGlobalFlag"></a>NtGlobalFlag</h4><h4 id="HeapMagic"><a href="#HeapMagic" class="headerlink" title="HeapMagic"></a>HeapMagic</h4><h3 id="回归Native-用户态的梦魇"><a href="#回归Native-用户态的梦魇" class="headerlink" title="回归Native:用户态的梦魇"></a>回归Native:用户态的梦魇</h3><h4 id="CheckRemoteDebuggerPresent"><a href="#CheckRemoteDebuggerPresent" class="headerlink" title="CheckRemoteDebuggerPresent"></a>CheckRemoteDebuggerPresent</h4><h4 id="ProcessDebugPort"><a href="#ProcessDebugPort" class="headerlink" title="ProcessDebugPort"></a>ProcessDebugPort</h4><h4 id="ThreadHideFromDebugger"><a href="#ThreadHideFromDebugger" class="headerlink" title="ThreadHideFromDebugger"></a>ThreadHideFromDebugger</h4><h4 id="DebugObject"><a href="#DebugObject" class="headerlink" title="DebugObject"></a>DebugObject</h4><h4 id="SystemKernelDebuggerInformation"><a href="#SystemKernelDebuggerInformation" class="headerlink" title="SystemKernelDebuggerInformation"></a>SystemKernelDebuggerInformation</h4><h4 id="NativeApi"><a href="#NativeApi" class="headerlink" title="NativeApi"></a>NativeApi</h4><h4 id="Hook和AntiHook"><a href="#Hook和AntiHook" class="headerlink" title="Hook和AntiHook"></a>Hook和AntiHook</h4><h3 id="真正的奥义-小技巧一览"><a href="#真正的奥义-小技巧一览" class="headerlink" title="真正的奥义:小技巧一览"></a>真正的奥义:小技巧一览</h3><h4 id="SoftICE检测方法"><a href="#SoftICE检测方法" class="headerlink" title="SoftICE检测方法"></a>SoftICE检测方法</h4><h4 id="OllyDbg检测方法"><a href="#OllyDbg检测方法" class="headerlink" title="OllyDbg检测方法"></a>OllyDbg检测方法</h4><h4 id="调试器漏洞"><a href="#调试器漏洞" class="headerlink" title="调试器漏洞"></a>调试器漏洞</h4><h4 id="防止调试器附加"><a href="#防止调试器附加" class="headerlink" title="防止调试器附加"></a>防止调试器附加</h4><h4 id="父进程检测"><a href="#父进程检测" class="headerlink" title="父进程检测"></a>父进程检测</h4><h4 id="时间差"><a href="#时间差" class="headerlink" title="时间差"></a>时间差</h4><h4 id="通过Trap-Flag检测"><a href="#通过Trap-Flag检测" class="headerlink" title="通过Trap Flag检测"></a>通过Trap Flag检测</h4><h4 id="双进程保护"><a href="#双进程保护" class="headerlink" title="双进程保护"></a>双进程保护</h4><h2 id="外壳编写基础"><a href="#外壳编写基础" class="headerlink" title="外壳编写基础"></a>外壳编写基础</h2><h3 id="外壳结构"><a href="#外壳结构" class="headerlink" title="外壳结构"></a>外壳结构</h3><h3 id="加壳主程序"><a href="#加壳主程序" class="headerlink" title="加壳主程序"></a>加壳主程序</h3><h4 id="判断文件是否PE格式"><a href="#判断文件是否PE格式" class="headerlink" title="判断文件是否PE格式"></a>判断文件是否PE格式</h4><h4 id="文件基本数据读入"><a href="#文件基本数据读入" class="headerlink" title="文件基本数据读入"></a>文件基本数据读入</h4><h4 id="附加数据读取"><a href="#附加数据读取" class="headerlink" title="附加数据读取"></a>附加数据读取</h4><h4 id="输入表的处理"><a href="#输入表的处理" class="headerlink" title="输入表的处理"></a>输入表的处理</h4><h4 id="重定位表的处理"><a href="#重定位表的处理" class="headerlink" title="重定位表的处理"></a>重定位表的处理</h4><h4 id="文件的压缩"><a href="#文件的压缩" class="headerlink" title="文件的压缩"></a>文件的压缩</h4><h4 id="资源数据的处理"><a href="#资源数据的处理" class="headerlink" title="资源数据的处理"></a>资源数据的处理</h4><h4 id="区块的融合"><a href="#区块的融合" class="headerlink" title="区块的融合"></a>区块的融合</h4><h3 id="用汇编写外壳部分"><a href="#用汇编写外壳部分" class="headerlink" title="用汇编写外壳部分"></a>用汇编写外壳部分</h3><h4 id="外壳的加载过程"><a href="#外壳的加载过程" class="headerlink" title="外壳的加载过程"></a>外壳的加载过程</h4><h4 id="自建输入表"><a href="#自建输入表" class="headerlink" title="自建输入表"></a>自建输入表</h4><h4 id="外壳引导段"><a href="#外壳引导段" class="headerlink" title="外壳引导段"></a>外壳引导段</h4><h4 id="将外壳添加至源程序"><a href="#将外壳添加至源程序" class="headerlink" title="将外壳添加至源程序"></a>将外壳添加至源程序</h4><h3 id="C-编写外壳部分"><a href="#C-编写外壳部分" class="headerlink" title="C++编写外壳部分"></a>C++编写外壳部分</h3><h2 id="虚拟机设计"><a href="#虚拟机设计" class="headerlink" title="虚拟机设计"></a>虚拟机设计</h2><h3 id="虚拟机保护技术原理"><a href="#虚拟机保护技术原理" class="headerlink" title="虚拟机保护技术原理"></a>虚拟机保护技术原理</h3><h4 id="反汇编引擎-1"><a href="#反汇编引擎-1" class="headerlink" title="反汇编引擎"></a>反汇编引擎</h4><h4 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h4><h3 id="启动框架和调用约定"><a href="#启动框架和调用约定" class="headerlink" title="启动框架和调用约定"></a>启动框架和调用约定</h3><h4 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h4><h4 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h4><h4 id="平衡栈vBegin和vCheckESP"><a href="#平衡栈vBegin和vCheckESP" class="headerlink" title="平衡栈vBegin和vCheckESP"></a>平衡栈vBegin和vCheckESP</h4><h3 id="Handler的设计"><a href="#Handler的设计" class="headerlink" title="Handler的设计"></a>Handler的设计</h3><h4 id="辅助的Handler"><a href="#辅助的Handler" class="headerlink" title="辅助的Handler"></a>辅助的Handler</h4><h4 id="普通Handler和指令拆解"><a href="#普通Handler和指令拆解" class="headerlink" title="普通Handler和指令拆解"></a>普通Handler和指令拆解</h4><h4 id="标志位的问题"><a href="#标志位的问题" class="headerlink" title="标志位的问题"></a>标志位的问题</h4><h4 id="相同作用的指令"><a href="#相同作用的指令" class="headerlink" title="相同作用的指令"></a>相同作用的指令</h4><h4 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h4><h4 id="转移跳转指令的另一种实现"><a href="#转移跳转指令的另一种实现" class="headerlink" title="转移跳转指令的另一种实现"></a>转移跳转指令的另一种实现</h4><h4 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h4><h4 id="retn指令"><a href="#retn指令" class="headerlink" title="retn指令"></a>retn指令</h4><h4 id="不可模拟指令"><a href="#不可模拟指令" class="headerlink" title="不可模拟指令"></a>不可模拟指令</h4><h3 id="托管代码的异常处理"><a href="#托管代码的异常处理" class="headerlink" title="托管代码的异常处理"></a>托管代码的异常处理</h3><h4 id="VC-的异常处理"><a href="#VC-的异常处理" class="headerlink" title="VC++的异常处理"></a>VC++的异常处理</h4><h2 id="VMProtect逆向和还原浅析"><a href="#VMProtect逆向和还原浅析" class="headerlink" title="VMProtect逆向和还原浅析"></a>VMProtect逆向和还原浅析</h2><h3 id="VMProtect逆向分析"><a href="#VMProtect逆向分析" class="headerlink" title="VMProtect逆向分析"></a>VMProtect逆向分析</h3><h4 id="VMProtect虚拟执行引擎的全景图"><a href="#VMProtect虚拟执行引擎的全景图" class="headerlink" title="VMProtect虚拟执行引擎的全景图"></a>VMProtect虚拟执行引擎的全景图</h4><h4 id="VMProtect虚拟引擎的基本架构"><a href="#VMProtect虚拟引擎的基本架构" class="headerlink" title="VMProtect虚拟引擎的基本架构"></a>VMProtect虚拟引擎的基本架构</h4><h3 id="VMProtect的还原"><a href="#VMProtect的还原" class="headerlink" title="VMProtect的还原"></a>VMProtect的还原</h3><h4 id="虚拟执行系统"><a href="#虚拟执行系统" class="headerlink" title="虚拟执行系统"></a>虚拟执行系统</h4><h4 id="生成完整的字节码流程图"><a href="#生成完整的字节码流程图" class="headerlink" title="生成完整的字节码流程图"></a>生成完整的字节码流程图</h4><h4 id="Handler命名并添加语义动作"><a href="#Handler命名并添加语义动作" class="headerlink" title="Handler命名并添加语义动作"></a>Handler命名并添加语义动作</h4><h4 id="字节码的低级描述转为中级描述"><a href="#字节码的低级描述转为中级描述" class="headerlink" title="字节码的低级描述转为中级描述"></a>字节码的低级描述转为中级描述</h4><h4 id="清除无用的字节码"><a href="#清除无用的字节码" class="headerlink" title="清除无用的字节码"></a>清除无用的字节码</h4><h4 id="用真值表化简要逻辑指令"><a href="#用真值表化简要逻辑指令" class="headerlink" title="用真值表化简要逻辑指令"></a>用真值表化简要逻辑指令</h4><h4 id="从特征中建立部分寄存器映射信息"><a href="#从特征中建立部分寄存器映射信息" class="headerlink" title="从特征中建立部分寄存器映射信息"></a>从特征中建立部分寄存器映射信息</h4><h4 id="其他无法确定的寄存器图着色算法"><a href="#其他无法确定的寄存器图着色算法" class="headerlink" title="其他无法确定的寄存器图着色算法"></a>其他无法确定的寄存器图着色算法</h4><h4 id="使用DAG匹配生成指令"><a href="#使用DAG匹配生成指令" class="headerlink" title="使用DAG匹配生成指令"></a>使用DAG匹配生成指令</h4><h1 id="软件重构篇"><a href="#软件重构篇" class="headerlink" title="软件重构篇"></a>软件重构篇</h1><h2 id="补丁技术"><a href="#补丁技术" class="headerlink" title="补丁技术"></a>补丁技术</h2><h3 id="文件补丁"><a href="#文件补丁" class="headerlink" title="文件补丁"></a>文件补丁</h3><h3 id="内存补丁"><a href="#内存补丁" class="headerlink" title="内存补丁"></a>内存补丁</h3><h4 id="跨进程内存存取机制"><a href="#跨进程内存存取机制" class="headerlink" title="跨进程内存存取机制"></a>跨进程内存存取机制</h4><h4 id="DebugApi机制"><a href="#DebugApi机制" class="headerlink" title="DebugApi机制"></a>DebugApi机制</h4><h4 id="利用调试器寄存器机制"><a href="#利用调试器寄存器机制" class="headerlink" title="利用调试器寄存器机制"></a>利用调试器寄存器机制</h4><h4 id="利用Dll注入技术"><a href="#利用Dll注入技术" class="headerlink" title="利用Dll注入技术"></a>利用Dll注入技术</h4><h4 id="利用Hook技术"><a href="#利用Hook技术" class="headerlink" title="利用Hook技术"></a>利用Hook技术</h4><h4 id="利用VT技术"><a href="#利用VT技术" class="headerlink" title="利用VT技术"></a>利用VT技术</h4><h3 id="SMC补丁技术"><a href="#SMC补丁技术" class="headerlink" title="SMC补丁技术"></a>SMC补丁技术</h3><h4 id="单层SMC补丁技术"><a href="#单层SMC补丁技术" class="headerlink" title="单层SMC补丁技术"></a>单层SMC补丁技术</h4><h4 id="多层SMC补丁技术"><a href="#多层SMC补丁技术" class="headerlink" title="多层SMC补丁技术"></a>多层SMC补丁技术</h4><h3 id="补丁工具"><a href="#补丁工具" class="headerlink" title="补丁工具"></a>补丁工具</h3><h2 id="代码的二次开发"><a href="#代码的二次开发" class="headerlink" title="代码的二次开发"></a>代码的二次开发</h2><h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><h3 id="增加空间"><a href="#增加空间" class="headerlink" title="增加空间"></a>增加空间</h3><h4 id="区块间隙"><a href="#区块间隙" class="headerlink" title="区块间隙"></a>区块间隙</h4><h4 id="手动构造区块"><a href="#手动构造区块" class="headerlink" title="手动构造区块"></a>手动构造区块</h4><h4 id="工具辅助构造区块"><a href="#工具辅助构造区块" class="headerlink" title="工具辅助构造区块"></a>工具辅助构造区块</h4><h3 id="获得函数的调用信息"><a href="#获得函数的调用信息" class="headerlink" title="获得函数的调用信息"></a>获得函数的调用信息</h3><h4 id="增加输入函数"><a href="#增加输入函数" class="headerlink" title="增加输入函数"></a>增加输入函数</h4><h4 id="显式链接调用Dll"><a href="#显式链接调用Dll" class="headerlink" title="显式链接调用Dll"></a>显式链接调用Dll</h4><h3 id="代码的重定位"><a href="#代码的重定位" class="headerlink" title="代码的重定位"></a>代码的重定位</h3><h4 id="修复重定位表"><a href="#修复重定位表" class="headerlink" title="修复重定位表"></a>修复重定位表</h4><h4 id="代码的自定位技术"><a href="#代码的自定位技术" class="headerlink" title="代码的自定位技术"></a>代码的自定位技术</h4><h3 id="增加输出函数"><a href="#增加输出函数" class="headerlink" title="增加输出函数"></a>增加输出函数</h3><h3 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h3><h4 id="WinProc函数"><a href="#WinProc函数" class="headerlink" title="WinProc函数"></a>WinProc函数</h4><h4 id="寻找消息循环"><a href="#寻找消息循环" class="headerlink" title="寻找消息循环"></a>寻找消息循环</h4><h4 id="WinProc汇编形式"><a href="#WinProc汇编形式" class="headerlink" title="WinProc汇编形式"></a>WinProc汇编形式</h4><h3 id="菜单扩展"><a href="#菜单扩展" class="headerlink" title="菜单扩展"></a>菜单扩展</h3><h4 id="扩充WinProc"><a href="#扩充WinProc" class="headerlink" title="扩充WinProc"></a>扩充WinProc</h4><h4 id="扩充Exit菜单功能"><a href="#扩充Exit菜单功能" class="headerlink" title="扩充Exit菜单功能"></a>扩充Exit菜单功能</h4><h4 id="扩充Open菜单的功能"><a href="#扩充Open菜单的功能" class="headerlink" title="扩充Open菜单的功能"></a>扩充Open菜单的功能</h4><h3 id="Dll扩展"><a href="#Dll扩展" class="headerlink" title="Dll扩展"></a>Dll扩展</h3><h4 id="扩展接口"><a href="#扩展接口" class="headerlink" title="扩展接口"></a>扩展接口</h4><h4 id="扩展消息循环"><a href="#扩展消息循环" class="headerlink" title="扩展消息循环"></a>扩展消息循环</h4>
        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2020/05/27/encry-decry/';
        this.page.title = '加密与解密[笔记篇]';
        this.page.identifier = '2020/05/27/encry-decry/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
