<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Windows&amp;WRK&amp;ReactOS 源码一览 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="Windows 内核技术详解笔记
说明本文结合《Windows 内核情景分析》(毛德操著)、《软件调试》(张银奎著)、《Windows 核心编程》、《寒江独钓-Windows 内核安全编程》、《Windows PE 权威指南》、《C++反汇编与逆向分析揭秘》以及 ReactOS 操作系 统 (V0.3.12)源码,以《Windows 内核情景分析》为蓝本,对 Windows 内核重要框架、函数、结构体进行 解析 
由于工程庞大,我能理解到的只是冰山一角,但本文力求做到让每个读者都能从整体上理解 ">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Go/Rust</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">系统内核</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">威胁追踪</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">数据库</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#说明"><span class="toc-number">1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#本文术语约定"><span class="toc-number">2.</span> <span class="toc-text">本文术语约定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#系统调用"><span class="toc-number">3.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#主动进入内核"><span class="toc-number">3.1.</span> <span class="toc-text">主动进入内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#int2e"><span class="toc-number">3.1.1.</span> <span class="toc-text">int2e</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Int-2e-的内部实现原理"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">Int 2e 的内部实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IDT整体布局"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">IDT整体布局</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#异常"><span class="toc-number">3.1.1.2.1.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#空白"><span class="toc-number">3.1.1.2.2.</span> <span class="toc-text">空白</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-系"><span class="toc-number">3.1.1.2.3.</span> <span class="toc-text">5 系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#硬"><span class="toc-number">3.1.1.2.4.</span> <span class="toc-text">硬</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KiSystemService"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">KiSystemService</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Trap帧"><span class="toc-number">3.1.1.3.1.</span> <span class="toc-text">Trap帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#KPCR-amp-amp-KPRCB"><span class="toc-number">3.1.1.3.2.</span> <span class="toc-text">KPCR&amp;&amp;KPRCB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SSDT-amp-Shadow-SSDT"><span class="toc-number">3.1.1.3.3.</span> <span class="toc-text">SSDT&amp;Shadow SSDT</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过快速调用指令"><span class="toc-number">3.1.2.</span> <span class="toc-text">通过快速调用指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KiFastCallEntry"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">KiFastCallEntry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sysexit"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">Sysexit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PreviousMode"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">PreviousMode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cs-ds-es-fs-gs-ss段寄存器介绍"><span class="toc-number">3.1.3.</span> <span class="toc-text">cs,ds,es,fs,gs,ss段寄存器介绍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存管理篇"><span class="toc-number">4.</span> <span class="toc-text">内存管理篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Cpu-访问物理内存的原理介绍"><span class="toc-number">4.1.</span> <span class="toc-text">Cpu 访问物理内存的原理介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cpu访问内存途径"><span class="toc-number">4.1.1.</span> <span class="toc-text">Cpu访问内存途径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟页面结构"><span class="toc-number">4.2.</span> <span class="toc-text">虚拟页面结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#地址空间"><span class="toc-number">4.2.1.</span> <span class="toc-text">地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区段"><span class="toc-number">4.2.2.</span> <span class="toc-text">区段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区块"><span class="toc-number">4.2.3.</span> <span class="toc-text">区块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存各个Mm函数"><span class="toc-number">4.2.4.</span> <span class="toc-text">内存各个Mm函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#物理页面"><span class="toc-number">4.3.</span> <span class="toc-text">物理页面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#物理页面的状态转换"><span class="toc-number">4.3.1.</span> <span class="toc-text">物理页面的状态转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漫谈页目录、二级页表"><span class="toc-number">4.4.</span> <span class="toc-text">漫谈页目录、二级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PTE"><span class="toc-number">4.4.1.</span> <span class="toc-text">PTE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MmCreateVirtualMapping"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">MmCreateVirtualMapping</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MmDeleteVirtualMapping"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">MmDeleteVirtualMapping</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#物理页面的临时映射-Hyperspace"><span class="toc-number">4.5.</span> <span class="toc-text">物理页面的临时映射(Hyperspace)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MmCreateHyperspaceMapping"><span class="toc-number">4.5.1.</span> <span class="toc-text">MmCreateHyperspaceMapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MmDeleteHyperspaceMapping"><span class="toc-number">4.5.2.</span> <span class="toc-text">MmDeleteHyperspaceMapping</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟页面与物理页面之间的映射"><span class="toc-number">4.6.</span> <span class="toc-text">虚拟页面与物理页面之间的映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#寻找PTE"><span class="toc-number">4.6.1.</span> <span class="toc-text">寻找PTE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存分配"><span class="toc-number">4.7.</span> <span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#页面访问异常"><span class="toc-number">4.8.</span> <span class="toc-text">页面访问异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缺页异常处理"><span class="toc-number">4.8.1.</span> <span class="toc-text">缺页异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#缺页-页换入"><span class="toc-number">4.8.1.1.</span> <span class="toc-text">缺页-页换入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺页-页换出"><span class="toc-number">4.8.1.2.</span> <span class="toc-text">缺页-页换出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存映射文件与共享物理内存"><span class="toc-number">4.9.</span> <span class="toc-text">内存映射文件与共享物理内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#相关结构"><span class="toc-number">4.9.1.</span> <span class="toc-text">相关结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Api流程"><span class="toc-number">4.9.2.</span> <span class="toc-text">Api流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建section"><span class="toc-number">4.9.2.1.</span> <span class="toc-text">创建section</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#映射section"><span class="toc-number">4.9.2.2.</span> <span class="toc-text">映射section</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺页异常处理-视图型区段"><span class="toc-number">4.9.2.3.</span> <span class="toc-text">缺页异常处理-视图型区段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#驱动程序分配内存"><span class="toc-number">4.10.</span> <span class="toc-text">驱动程序分配内存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内核对象"><span class="toc-number">5.</span> <span class="toc-text">内核对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#常见的内核对象"><span class="toc-number">5.1.</span> <span class="toc-text">常见的内核对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象头"><span class="toc-number">5.2.</span> <span class="toc-text">对象头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象目录"><span class="toc-number">5.3.</span> <span class="toc-text">对象目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象类型"><span class="toc-number">5.4.</span> <span class="toc-text">对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自注册对象类型"><span class="toc-number">5.4.1.</span> <span class="toc-text">自注册对象类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#句柄"><span class="toc-number">5.5.</span> <span class="toc-text">句柄</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#句柄结构"><span class="toc-number">5.5.1.</span> <span class="toc-text">句柄结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用内核函数"><span class="toc-number">5.6.</span> <span class="toc-text">常用内核函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ObReferenceObjectByHandle"><span class="toc-number">5.6.1.</span> <span class="toc-text">ObReferenceObjectByHandle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObReferenceObjectByPointer"><span class="toc-number">5.6.2.</span> <span class="toc-text">ObReferenceObjectByPointer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象目录中的查找过程"><span class="toc-number">5.7.</span> <span class="toc-text">对象目录中的查找过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ObReferenceObjectByName"><span class="toc-number">5.7.1.</span> <span class="toc-text">ObReferenceObjectByName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObOpenObjectByPointer"><span class="toc-number">5.7.2.</span> <span class="toc-text">ObOpenObjectByPointer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObOpenObjectByName"><span class="toc-number">5.7.3.</span> <span class="toc-text">ObOpenObjectByName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObDereferenceObject"><span class="toc-number">5.7.4.</span> <span class="toc-text">ObDereferenceObject</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#句柄的遗传和复制"><span class="toc-number">5.8.</span> <span class="toc-text">句柄的遗传和复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CreateProcess"><span class="toc-number">5.8.1.</span> <span class="toc-text">CreateProcess</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExDupHandleTable"><span class="toc-number">5.8.2.</span> <span class="toc-text">ExDupHandleTable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#句柄的关闭"><span class="toc-number">5.9.</span> <span class="toc-text">句柄的关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ObpCloseHandle"><span class="toc-number">5.9.1.</span> <span class="toc-text">ObpCloseHandle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObpCloseHandleTableEntry"><span class="toc-number">5.9.2.</span> <span class="toc-text">ObpCloseHandleTableEntry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IopCloseFile"><span class="toc-number">5.9.3.</span> <span class="toc-text">IopCloseFile</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程线程"><span class="toc-number">6.</span> <span class="toc-text">进程线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程的启动过程"><span class="toc-number">6.1.</span> <span class="toc-text">进程的启动过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用户空间"><span class="toc-number">6.2.</span> <span class="toc-text">用户空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MmInitializeProcessAddressSpace"><span class="toc-number">6.2.1.</span> <span class="toc-text">MmInitializeProcessAddressSpace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PspMapSystemDll"><span class="toc-number">6.2.2.</span> <span class="toc-text">PspMapSystemDll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MmCreatePeb"><span class="toc-number">6.2.3.</span> <span class="toc-text">MmCreatePeb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BasepInitializeEnvironment"><span class="toc-number">6.2.4.</span> <span class="toc-text">BasepInitializeEnvironment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BasepCreateFirstThread"><span class="toc-number">6.2.5.</span> <span class="toc-text">BasepCreateFirstThread</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BasepCreateStack"><span class="toc-number">6.2.5.1.</span> <span class="toc-text">BasepCreateStack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BasepInitializeContext"><span class="toc-number">6.2.5.2.</span> <span class="toc-text">BasepInitializeContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MmCreateTeb"><span class="toc-number">6.2.5.3.</span> <span class="toc-text">MmCreateTeb</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程-amp-线程的创建"><span class="toc-number">6.3.</span> <span class="toc-text">进程&amp;线程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CreateProcessInternalW"><span class="toc-number">6.3.1.</span> <span class="toc-text">CreateProcessInternalW</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NtCreateProcess"><span class="toc-number">6.3.2.</span> <span class="toc-text">NtCreateProcess</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PspCreateProcess"><span class="toc-number">6.3.3.</span> <span class="toc-text">PspCreateProcess</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KeInitThread"><span class="toc-number">6.3.4.</span> <span class="toc-text">KeInitThread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiInitializeContextThread"><span class="toc-number">6.3.5.</span> <span class="toc-text">KiInitializeContextThread</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KUINIT-FRAME"><span class="toc-number">6.3.5.1.</span> <span class="toc-text">_KUINIT_FRAME</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KSTART-FRAME"><span class="toc-number">6.3.5.2.</span> <span class="toc-text">_KSTART_FRAME</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KSWITCHFRAME"><span class="toc-number">6.3.5.3.</span> <span class="toc-text">_KSWITCHFRAME</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiThreadStartup"><span class="toc-number">6.3.6.</span> <span class="toc-text">KiThreadStartup</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PspUserThreadStartup"><span class="toc-number">6.3.6.1.</span> <span class="toc-text">PspUserThreadStartup</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LdrInitializeThunk"><span class="toc-number">6.3.7.</span> <span class="toc-text">LdrInitializeThunk</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LdrPEStartup"><span class="toc-number">6.3.7.1.</span> <span class="toc-text">LdrPEStartup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LdrFixupImports"><span class="toc-number">6.3.7.2.</span> <span class="toc-text">LdrFixupImports</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LdrpLoadModule"><span class="toc-number">6.3.7.3.</span> <span class="toc-text">LdrpLoadModule</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BaseProcessStartThunk"><span class="toc-number">6.3.8.</span> <span class="toc-text">BaseProcessStartThunk</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主线程的用户空间总入口"><span class="toc-number">6.3.8.1.</span> <span class="toc-text">主线程的用户空间总入口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#普通线程的用户空间总入口"><span class="toc-number">6.3.8.2.</span> <span class="toc-text">普通线程的用户空间总入口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LoadLibraryW"><span class="toc-number">6.3.9.</span> <span class="toc-text">LoadLibraryW</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GetDllLoadPath"><span class="toc-number">6.3.9.1.</span> <span class="toc-text">GetDllLoadPath</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LdrpAttachThread"><span class="toc-number">6.3.9.2.</span> <span class="toc-text">LdrpAttachThread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LdrpAttachProcess"><span class="toc-number">6.3.9.3.</span> <span class="toc-text">LdrpAttachProcess</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程调度与切换"><span class="toc-number">6.4.</span> <span class="toc-text">线程调度与切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程切换相关数据结构"><span class="toc-number">6.4.1.</span> <span class="toc-text">线程切换相关数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KPCR"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">KPCR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KPCR-TIB"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">KPCR_TIB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KPRCB"><span class="toc-number">6.4.1.3.</span> <span class="toc-text">KPRCB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KSWITCHFRAME-1"><span class="toc-number">6.4.1.4.</span> <span class="toc-text">_KSWITCHFRAME</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Trap现场帧"><span class="toc-number">6.4.1.5.</span> <span class="toc-text">Trap现场帧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiSwapContex切换线程核心"><span class="toc-number">6.4.2.</span> <span class="toc-text">KiSwapContex切换线程核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiSwapContextInternal"><span class="toc-number">6.4.3.</span> <span class="toc-text">KiSwapContextInternal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的调度策略与切换时机"><span class="toc-number">6.5.</span> <span class="toc-text">线程的调度策略与切换时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主动放弃cpu-NtYieldExecution"><span class="toc-number">6.5.1.</span> <span class="toc-text">主动放弃cpu(NtYieldExecution)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调度策略-KiSelectReadyThread"><span class="toc-number">6.5.2.</span> <span class="toc-text">调度策略(KiSelectReadyThread)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KiComputeNewPriority"><span class="toc-number">6.5.2.1.</span> <span class="toc-text">KiComputeNewPriority</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#被动切换"><span class="toc-number">6.5.3.</span> <span class="toc-text">被动切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#时间片切换"><span class="toc-number">6.5.3.1.</span> <span class="toc-text">时间片切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优先级切换"><span class="toc-number">6.5.3.2.</span> <span class="toc-text">优先级切换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ResumeThread"><span class="toc-number">6.5.3.2.1.</span> <span class="toc-text">ResumeThread</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IRQL降低"><span class="toc-number">6.5.3.3.</span> <span class="toc-text">IRQL降低</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#KiExitDispatcher"><span class="toc-number">6.5.3.3.1.</span> <span class="toc-text">KiExitDispatcher</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#KiUnwaitThread"><span class="toc-number">6.5.3.3.1.1.</span> <span class="toc-text">KiUnwaitThread</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#KiReadyThread"><span class="toc-number">6.5.3.3.1.2.</span> <span class="toc-text">KiReadyThread</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#KiDeferredReadyThread"><span class="toc-number">6.5.3.3.1.3.</span> <span class="toc-text">KiDeferredReadyThread</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程、线程的优先级"><span class="toc-number">6.6.</span> <span class="toc-text">进程、线程的优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#修改优先级"><span class="toc-number">6.6.1.</span> <span class="toc-text">修改优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SetPriorityClass"><span class="toc-number">6.6.1.1.</span> <span class="toc-text">SetPriorityClass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KiSetPriorityThread"><span class="toc-number">6.6.1.2.</span> <span class="toc-text">KiSetPriorityThread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KeSetPriorityThread"><span class="toc-number">6.6.1.3.</span> <span class="toc-text">KeSetPriorityThread</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程局部存储-TLS"><span class="toc-number">6.7.</span> <span class="toc-text">线程局部存储:TLS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#相关结构-1"><span class="toc-number">6.7.1.</span> <span class="toc-text">相关结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PEB"><span class="toc-number">6.7.1.1.</span> <span class="toc-text">PEB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RTL-BITMAP"><span class="toc-number">6.7.1.2.</span> <span class="toc-text">RTL_BITMAP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TEB"><span class="toc-number">6.7.1.3.</span> <span class="toc-text">TEB</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态Tls相关函数"><span class="toc-number">6.7.2.</span> <span class="toc-text">动态Tls相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TlsAlloc"><span class="toc-number">6.7.2.1.</span> <span class="toc-text">TlsAlloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TlsSetValue"><span class="toc-number">6.7.2.2.</span> <span class="toc-text">TlsSetValue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TlsGetValue"><span class="toc-number">6.7.2.3.</span> <span class="toc-text">TlsGetValue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TlsFree"><span class="toc-number">6.7.2.4.</span> <span class="toc-text">TlsFree</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态Tls"><span class="toc-number">6.7.3.</span> <span class="toc-text">静态Tls</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化流程"><span class="toc-number">6.7.3.1.</span> <span class="toc-text">初始化流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LdrPEStartup-1"><span class="toc-number">6.7.3.1.1.</span> <span class="toc-text">LdrPEStartup</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#LdrpAcquireTlsSlot"><span class="toc-number">6.7.3.1.1.1.</span> <span class="toc-text">LdrpAcquireTlsSlot</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#LdrpInitializeTlsForProccess"><span class="toc-number">6.7.3.1.1.2.</span> <span class="toc-text">LdrpInitializeTlsForProccess</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LdrpAttachThread-1"><span class="toc-number">6.7.3.1.2.</span> <span class="toc-text">LdrpAttachThread</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程挂靠与跨进程操作"><span class="toc-number">6.8.</span> <span class="toc-text">进程挂靠与跨进程操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KeAttachProcess"><span class="toc-number">6.8.1.</span> <span class="toc-text">KeAttachProcess</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KiSwapProcess"><span class="toc-number">6.8.1.1.</span> <span class="toc-text">KiSwapProcess</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打开目标进程"><span class="toc-number">6.8.2.</span> <span class="toc-text">打开目标进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跨进程读写数据"><span class="toc-number">6.8.3.</span> <span class="toc-text">跨进程读写数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的挂起与恢复"><span class="toc-number">6.9.</span> <span class="toc-text">线程的挂起与恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KeSuspendThread"><span class="toc-number">6.9.1.</span> <span class="toc-text">KeSuspendThread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KeResumeThread"><span class="toc-number">6.9.2.</span> <span class="toc-text">KeResumeThread</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DLL注入"><span class="toc-number">6.10.</span> <span class="toc-text">DLL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DllMain"><span class="toc-number">6.10.1.</span> <span class="toc-text">DllMain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LoadAppInitDlls"><span class="toc-number">6.10.2.</span> <span class="toc-text">LoadAppInitDlls</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetDllList"><span class="toc-number">6.10.3.</span> <span class="toc-text">GetDllList</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#APC"><span class="toc-number">7.</span> <span class="toc-text">APC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ReadFileEx异步读写Apc实现"><span class="toc-number">7.1.</span> <span class="toc-text">ReadFileEx异步读写Apc实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础结构"><span class="toc-number">7.2.</span> <span class="toc-text">基础结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KAPC-STATE"><span class="toc-number">7.2.1.</span> <span class="toc-text">_KAPC_STATE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KAPC-ENVIRONMENT"><span class="toc-number">7.2.2.</span> <span class="toc-text">_KAPC_ENVIRONMENT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KAPC"><span class="toc-number">7.2.3.</span> <span class="toc-text">_KAPC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Api流程-1"><span class="toc-number">7.3.</span> <span class="toc-text">Api流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QueueUserAPC"><span class="toc-number">7.3.1.</span> <span class="toc-text">QueueUserAPC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NtQueueApcThread"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">NtQueueApcThread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KeInitializeApc"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">KeInitializeApc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KeInsertQueueApc"><span class="toc-number">7.3.1.3.</span> <span class="toc-text">KeInsertQueueApc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KiInsertQueueApc"><span class="toc-number">7.3.1.4.</span> <span class="toc-text">KiInsertQueueApc</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用户态APC的执行时机"><span class="toc-number">7.4.</span> <span class="toc-text">用户态APC的执行时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cli后面处理"><span class="toc-number">7.4.1.</span> <span class="toc-text">Cli后面处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiDeliverApc"><span class="toc-number">7.4.2.</span> <span class="toc-text">KiDeliverApc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiInitializeUserApc"><span class="toc-number">7.4.3.</span> <span class="toc-text">KiInitializeUserApc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiUserApcDisatcher"><span class="toc-number">7.4.4.</span> <span class="toc-text">KiUserApcDisatcher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntCallUserApc"><span class="toc-number">7.4.5.</span> <span class="toc-text">IntCallUserApc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZwContinue"><span class="toc-number">7.4.6.</span> <span class="toc-text">ZwContinue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核态APC的执行时机"><span class="toc-number">7.5.</span> <span class="toc-text">内核态APC的执行时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KeLowerIrql"><span class="toc-number">7.5.1.</span> <span class="toc-text">KeLowerIrql</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HalRequestSoftwareInterrupt"><span class="toc-number">7.5.2.</span> <span class="toc-text">HalRequestSoftwareInterrupt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HalpApcInterruptHandler"><span class="toc-number">7.5.3.</span> <span class="toc-text">HalpApcInterruptHandler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程同步"><span class="toc-number">8.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#直接间接等待对象"><span class="toc-number">8.1.</span> <span class="toc-text">直接间接等待对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WaitForSingleObject"><span class="toc-number">8.2.</span> <span class="toc-text">WaitForSingleObject</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KeWaitForSingleObject"><span class="toc-number">8.2.1.</span> <span class="toc-text">KeWaitForSingleObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KWAIT-BLOCK"><span class="toc-number">8.2.2.</span> <span class="toc-text">_KWAIT_BLOCK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiCheckAlertability"><span class="toc-number">8.2.3.</span> <span class="toc-text">KiCheckAlertability</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程等待唤醒"><span class="toc-number">8.3.</span> <span class="toc-text">线程等待唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KiWaitTest"><span class="toc-number">8.3.1.</span> <span class="toc-text">KiWaitTest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiSatisfyObjectWait-分配唤醒信号"><span class="toc-number">8.3.2.</span> <span class="toc-text">KiSatisfyObjectWait(分配唤醒信号)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiUnwaitThread-唤醒指定线程"><span class="toc-number">8.3.3.</span> <span class="toc-text">KiUnwaitThread(唤醒指定线程)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiSwapThread"><span class="toc-number">8.3.4.</span> <span class="toc-text">KiSwapThread</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KeWaitForMultipleObjects"><span class="toc-number">8.4.</span> <span class="toc-text">KeWaitForMultipleObjects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步对象"><span class="toc-number">8.5.</span> <span class="toc-text">同步对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量"><span class="toc-number">8.5.1.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NtCreateSemaphore"><span class="toc-number">8.5.1.1.</span> <span class="toc-text">NtCreateSemaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KeInitializeSemaphore"><span class="toc-number">8.5.1.2.</span> <span class="toc-text">KeInitializeSemaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NtReleaseSemaphore"><span class="toc-number">8.5.1.3.</span> <span class="toc-text">NtReleaseSemaphore</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥对象"><span class="toc-number">8.5.2.</span> <span class="toc-text">互斥对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KeInitializeMutant"><span class="toc-number">8.5.2.1.</span> <span class="toc-text">KeInitializeMutant</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NtReleaseMutant"><span class="toc-number">8.5.2.2.</span> <span class="toc-text">NtReleaseMutant</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件对象"><span class="toc-number">8.5.3.</span> <span class="toc-text">事件对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KeSetEvent"><span class="toc-number">8.5.3.1.</span> <span class="toc-text">KeSetEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KeResetEvent"><span class="toc-number">8.5.3.2.</span> <span class="toc-text">KeResetEvent</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自旋锁"><span class="toc-number">8.5.4.</span> <span class="toc-text">自旋锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#消息与钩子"><span class="toc-number">9.</span> <span class="toc-text">消息与钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#转变GUI线程"><span class="toc-number">9.1.</span> <span class="toc-text">转变GUI线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Win32kProcessCallback"><span class="toc-number">9.1.1.</span> <span class="toc-text">Win32kProcessCallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Win32kThreadCallback"><span class="toc-number">9.1.2.</span> <span class="toc-text">Win32kThreadCallback</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息循环机制重点函数"><span class="toc-number">9.2.</span> <span class="toc-text">消息循环机制重点函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GetMessageW"><span class="toc-number">9.2.1.</span> <span class="toc-text">GetMessageW</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NtUserGetMessage"><span class="toc-number">9.2.1.1.</span> <span class="toc-text">NtUserGetMessage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UserGetWindowObject-找窗口对象"><span class="toc-number">9.2.1.2.</span> <span class="toc-text">UserGetWindowObject(找窗口对象)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FindMsgMemory-查找指定类型消息的L附件包"><span class="toc-number">9.2.1.3.</span> <span class="toc-text">FindMsgMemory(查找指定类型消息的L附件包)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#co-IntPeekMessage"><span class="toc-number">9.2.1.4.</span> <span class="toc-text">co_IntPeekMessage</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#USER-SENT-MESSAGE"><span class="toc-number">9.2.1.4.1.</span> <span class="toc-text">_USER_SENT_MESSAGE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#send队列处理"><span class="toc-number">9.2.1.4.2.</span> <span class="toc-text">send队列处理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#co-MsqDispatchOneSentMessage"><span class="toc-number">9.2.1.4.2.1.</span> <span class="toc-text">co_MsqDispatchOneSentMessage</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#post消息队列处理"><span class="toc-number">9.2.1.4.3.</span> <span class="toc-text">post消息队列处理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#co-MsqFindMessage"><span class="toc-number">9.2.1.4.3.1.</span> <span class="toc-text">co_MsqFindMessage</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#co-IntWaitMessage"><span class="toc-number">9.2.1.5.</span> <span class="toc-text">co_IntWaitMessage</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#co-MsqTranslateMouseMessage"><span class="toc-number">9.2.2.</span> <span class="toc-text">co_MsqTranslateMouseMessage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DispatchMessageW"><span class="toc-number">9.2.3.</span> <span class="toc-text">DispatchMessageW</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IntCallWindowProcW"><span class="toc-number">9.2.3.1.</span> <span class="toc-text">IntCallWindowProcW</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PostMessageW"><span class="toc-number">9.2.4.</span> <span class="toc-text">PostMessageW</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PostMessageWorker"><span class="toc-number">9.2.4.1.</span> <span class="toc-text">PostMessageWorker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UserPostMessage"><span class="toc-number">9.2.4.2.</span> <span class="toc-text">UserPostMessage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MsqPostMessage"><span class="toc-number">9.2.4.3.</span> <span class="toc-text">MsqPostMessage</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SendMessage"><span class="toc-number">9.2.5.</span> <span class="toc-text">SendMessage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NtUserSendMessage"><span class="toc-number">9.2.5.1.</span> <span class="toc-text">NtUserSendMessage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#co-IntDoSendMessage"><span class="toc-number">9.2.5.2.</span> <span class="toc-text">co_IntDoSendMessage</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#co-IntSendMessage"><span class="toc-number">9.2.5.2.1.</span> <span class="toc-text">co_IntSendMessage</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#co-IntSendMessageTimeoutSingle"><span class="toc-number">9.2.5.2.2.</span> <span class="toc-text">co_IntSendMessageTimeoutSingle</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#co-MsqSendMessage"><span class="toc-number">9.2.5.2.3.</span> <span class="toc-text">co_MsqSendMessage</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息钩子"><span class="toc-number">9.3.</span> <span class="toc-text">消息钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SetWindowsHookExW"><span class="toc-number">9.3.1.</span> <span class="toc-text">SetWindowsHookExW</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NtUserSetWindowsHookEx"><span class="toc-number">9.3.1.1.</span> <span class="toc-text">NtUserSetWindowsHookEx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IntAddHook"><span class="toc-number">9.3.1.2.</span> <span class="toc-text">IntAddHook</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#co-HOOK-CallHooks"><span class="toc-number">9.3.2.</span> <span class="toc-text">co_HOOK_CallHooks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#键盘消息的产生、处理"><span class="toc-number">9.4.</span> <span class="toc-text">键盘消息的产生、处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InitInputImpl"><span class="toc-number">9.4.1.</span> <span class="toc-text">InitInputImpl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KeyboardThreadMain"><span class="toc-number">9.4.2.</span> <span class="toc-text">KeyboardThreadMain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntKeyboardGetModifiers"><span class="toc-number">9.4.3.</span> <span class="toc-text">IntKeyboardGetModifiers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MsqPostHotKeyMessage"><span class="toc-number">9.4.4.</span> <span class="toc-text">MsqPostHotKeyMessage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#co-MsqPostKeyboardMessage"><span class="toc-number">9.4.5.</span> <span class="toc-text">co_MsqPostKeyboardMessage</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#鼠标消息的产生、处理"><span class="toc-number">9.5.</span> <span class="toc-text">鼠标消息的产生、处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MouseThreadMain"><span class="toc-number">9.5.1.</span> <span class="toc-text">MouseThreadMain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntMouseInput"><span class="toc-number">9.5.2.</span> <span class="toc-text">IntMouseInput</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MsqInsertSystemMessage"><span class="toc-number">9.5.3.</span> <span class="toc-text">MsqInsertSystemMessage</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟键盘鼠标动作"><span class="toc-number">9.6.</span> <span class="toc-text">模拟键盘鼠标动作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#keybd-event-amp-mouse-event"><span class="toc-number">9.6.1.</span> <span class="toc-text">keybd_event&amp;mouse_event</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SendInput"><span class="toc-number">9.6.2.</span> <span class="toc-text">SendInput</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DPC"><span class="toc-number">10.</span> <span class="toc-text">DPC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本结构"><span class="toc-number">10.1.</span> <span class="toc-text">基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键函数"><span class="toc-number">10.2.</span> <span class="toc-text">关键函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KeInitializeDpc"><span class="toc-number">10.2.1.</span> <span class="toc-text">KeInitializeDpc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HalRequestSoftwareInterrupt-1"><span class="toc-number">10.2.2.</span> <span class="toc-text">HalRequestSoftwareInterrupt</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DPC-函数的执行时机"><span class="toc-number">10.3.</span> <span class="toc-text">DPC 函数的执行时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KfLowerIrql"><span class="toc-number">10.3.1.</span> <span class="toc-text">KfLowerIrql</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HalpDispatchInterrupt2"><span class="toc-number">10.3.2.</span> <span class="toc-text">HalpDispatchInterrupt2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiDispatchInterrupt"><span class="toc-number">10.3.3.</span> <span class="toc-text">KiDispatchInterrupt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiRetireDpcList"><span class="toc-number">10.3.4.</span> <span class="toc-text">KiRetireDpcList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DPC切目标CPU"><span class="toc-number">10.4.</span> <span class="toc-text">DPC切目标CPU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KeSetTargetProcessorDpc"><span class="toc-number">10.4.1.</span> <span class="toc-text">KeSetTargetProcessorDpc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统工作者线程"><span class="toc-number">10.5.</span> <span class="toc-text">系统工作者线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ExInitializeWorkItem"><span class="toc-number">10.5.1.</span> <span class="toc-text">ExInitializeWorkItem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExQueueWorkItem"><span class="toc-number">10.5.2.</span> <span class="toc-text">ExQueueWorkItem</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#中断处理"><span class="toc-number">11.</span> <span class="toc-text">中断处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IoConnectInterrupt"><span class="toc-number">11.1.</span> <span class="toc-text">IoConnectInterrupt</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KeInitializeInterrupt"><span class="toc-number">11.1.1.</span> <span class="toc-text">KeInitializeInterrupt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KeConnectInterrupt"><span class="toc-number">11.1.2.</span> <span class="toc-text">KeConnectInterrupt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiGetVectorDispatch"><span class="toc-number">11.1.3.</span> <span class="toc-text">KiGetVectorDispatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KeQueryInterruptHandler"><span class="toc-number">11.1.4.</span> <span class="toc-text">KeQueryInterruptHandler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KiInterruptTemplateHandler"><span class="toc-number">11.2.</span> <span class="toc-text">KiInterruptTemplateHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KiChainedDispatch"><span class="toc-number">11.2.1.</span> <span class="toc-text">KiChainedDispatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiInterruptDispatch"><span class="toc-number">11.2.2.</span> <span class="toc-text">KiInterruptDispatch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IoDisconnectInterrupt"><span class="toc-number">11.3.</span> <span class="toc-text">IoDisconnectInterrupt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HalpClockInterruptHandler"><span class="toc-number">11.4.</span> <span class="toc-text">HalpClockInterruptHandler</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#设备驱动"><span class="toc-number">12.</span> <span class="toc-text">设备驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#相关结构定义"><span class="toc-number">12.1.</span> <span class="toc-text">相关结构定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IRP"><span class="toc-number">12.1.1.</span> <span class="toc-text">IRP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本函数"><span class="toc-number">12.2.</span> <span class="toc-text">基本函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IoCreateDevice"><span class="toc-number">12.2.1.</span> <span class="toc-text">IoCreateDevice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IofCallDriver"><span class="toc-number">12.2.2.</span> <span class="toc-text">IofCallDriver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NtDeviceIoControlFile"><span class="toc-number">12.2.3.</span> <span class="toc-text">NtDeviceIoControlFile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IopDeviceFsIoControl"><span class="toc-number">12.2.3.1.</span> <span class="toc-text">IopDeviceFsIoControl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IoGetAttachedDevice"><span class="toc-number">12.2.3.2.</span> <span class="toc-text">IoGetAttachedDevice</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IoAllocateIrp"><span class="toc-number">12.2.4.</span> <span class="toc-text">IoAllocateIrp</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IoInitializeIrp"><span class="toc-number">12.2.4.1.</span> <span class="toc-text">IoInitializeIrp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IopQueueIrpToThread"><span class="toc-number">12.2.4.2.</span> <span class="toc-text">IopQueueIrpToThread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IoCancelIrp"><span class="toc-number">12.2.4.3.</span> <span class="toc-text">IoCancelIrp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IoAttachDevice-设备的绑定"><span class="toc-number">12.2.5.</span> <span class="toc-text">IoAttachDevice(设备的绑定)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IoAttachDeviceToDeviceStackSafe"><span class="toc-number">12.2.5.1.</span> <span class="toc-text">IoAttachDeviceToDeviceStackSafe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IoAttachDeviceByPointer"><span class="toc-number">12.2.5.2.</span> <span class="toc-text">IoAttachDeviceByPointer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IoAttachDeviceToDeviceStack"><span class="toc-number">12.2.5.3.</span> <span class="toc-text">IoAttachDeviceToDeviceStack</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IoCompleteRequest"><span class="toc-number">12.2.6.</span> <span class="toc-text">IoCompleteRequest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IopCompleteRequest"><span class="toc-number">12.2.7.</span> <span class="toc-text">IopCompleteRequest</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#驱动的加载过程"><span class="toc-number">12.3.</span> <span class="toc-text">驱动的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NtLoadDriver"><span class="toc-number">12.3.1.</span> <span class="toc-text">NtLoadDriver</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IopLoadUnloadDriver"><span class="toc-number">12.3.1.1.</span> <span class="toc-text">IopLoadUnloadDriver</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IopGetDriverObject"><span class="toc-number">12.3.1.1.1.</span> <span class="toc-text">IopGetDriverObject</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IopInitializeDriverModule"><span class="toc-number">12.3.1.2.</span> <span class="toc-text">IopInitializeDriverModule</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IopCreateDriver"><span class="toc-number">12.3.1.3.</span> <span class="toc-text">IopCreateDriver</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IopReinitializeDrivers"><span class="toc-number">12.3.1.3.1.</span> <span class="toc-text">IopReinitializeDrivers</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IoRegisterDriverReinitialization"><span class="toc-number">12.3.1.3.2.</span> <span class="toc-text">IoRegisterDriverReinitialization</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#驱动加载过程-非NtLoadDriver"><span class="toc-number">12.3.2.</span> <span class="toc-text">驱动加载过程(非NtLoadDriver)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本结构-1"><span class="toc-number">12.3.2.1.</span> <span class="toc-text">基本结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IopCreateDeviceNode"><span class="toc-number">12.3.2.2.</span> <span class="toc-text">IopCreateDeviceNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PnpRootCreateDevice"><span class="toc-number">12.3.2.3.</span> <span class="toc-text">PnpRootCreateDevice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pnp-驱动的加载过程"><span class="toc-number">12.3.2.4.</span> <span class="toc-text">Pnp 驱动的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IoInitSystem"><span class="toc-number">12.3.2.4.1.</span> <span class="toc-text">IoInitSystem</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IopInitializePnpServices"><span class="toc-number">12.3.2.4.2.</span> <span class="toc-text">IopInitializePnpServices</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IopStartDevice"><span class="toc-number">12.3.2.4.3.</span> <span class="toc-text">IopStartDevice</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IoInvalidateDeviceRelations"><span class="toc-number">12.3.2.4.4.</span> <span class="toc-text">IoInvalidateDeviceRelations</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PnpRootQueryDeviceRelations"><span class="toc-number">12.3.2.4.5.</span> <span class="toc-text">PnpRootQueryDeviceRelations</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mdl"><span class="toc-number">13.</span> <span class="toc-text">Mdl</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#核心Api"><span class="toc-number">13.1.</span> <span class="toc-text">核心Api</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IoAllocateMdl"><span class="toc-number">13.1.1.</span> <span class="toc-text">IoAllocateMdl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IoFreeMdl"><span class="toc-number">13.1.2.</span> <span class="toc-text">IoFreeMdl</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#网络通信篇"><span class="toc-number">14.</span> <span class="toc-text">网络通信篇</span></a></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            Windows&amp;WRK&amp;ReactOS 源码一览
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2020/11/03/windows-kernel-summary/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2020-11-03T03:11:30.000Z" itemprop="datePublished">2020-11-03</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>Windows 内核技术详解笔记<br><a id="more"></a></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文结合《Windows 内核情景分析》(毛德操著)、《软件调试》(张银奎著)、《Windows 核心编程》、《寒江独钓-Windows 内核安全编程》、《Windows PE 权威指南》、《C++反汇编与逆向分析揭秘》以及 ReactOS 操作系 统 (V0.3.12)源码,以《Windows 内核情景分析》为蓝本,对 Windows 内核重要框架、函数、结构体进行 解析 </p>
<p>由于工程庞大,我能理解到的只是冰山一角,但本文力求做到让每个读者都能从整体上理解 Windows 内核 的架构,并大量解释一些关键细节。 </p>
<p>本文适合读者:熟悉 C 语言、汇编,PE 文件格式,有一定驱动/内核程序开发经历的读者 本文阅读顺序:基础较弱的读者请遵循篇章序号,否则可能会吃力。 本文解读方式:</p>
<ul>
<li>1、源码、伪码结合,展示主流程,很多时候忽略权限、错误检查,多线程互斥等旁枝末节 </li>
<li>2、函数的参数没有严格排序,很多不重要的参数也省略了,要注意 </li>
<li>3、结构体内的成员没有严格排序,成员名称也不严格对应,并只列出一些重要成员 </li>
<li>4、一些清理工作,如关闭句柄、释放内存、释放互斥对象等工作省略 </li>
<li>5、很多时候,函数体开头声明的那些没有初始值的局部变量我都略去了 </li>
</ul>
<blockquote>
<p>(我所做的修改基本不影响从代码层次理解 Windows 内核的原理) </p>
</blockquote>
<ul>
<li>写作初衷 1: 我一直对 Rootkit 感兴趣,但是以前在不熟悉内核的情况下,总是不知道要在哪个位置挂钩, 要 Hook 哪些函数才能达到我的目的。 </li>
<li>写作初衷 2:以前在写文件系统过滤驱动、Ndis 过滤驱动以及其他驱动时遇到的种种疑惑,因此,总想看 一下 ddk 提供的内核函数到底是怎么实现的。 </li>
</ul>
<p>于是翻看了毛老师的大作,受益匪浅,在基本理清了原理与细节后,特此做了一番总结<br>希望这篇文章 能够为安全界的朋友尽一点绵薄之力。<br>由于工作原因我接触到的知识面有限,不可能逐一摸透 Windows 的方方面面,再说ReactOS 本来就与 Windows 有一些小差别<br>因此希望各位朋友带着批判的态度去阅读本文。(当然我是尽我所能,认真写完逐篇的) </p>
<p><br></p>
<h1 id="本文术语约定"><a href="#本文术语约定" class="headerlink" title="本文术语约定"></a>本文术语约定</h1><ul>
<li>描述符:指用来描述一件事物的“结构体”。如缓冲描述符,描述了一个缓冲的基址、长度等信息。</li>
<li>中断描述符,描述了那个中断向量对应的分配状态、isr 等信息 </li>
<li>Entry:指表中的表项、条目,有时也指函数入口 </li>
<li>SSDT:基本系统服务表(其实全称应叫系统服务派遣表)  </li>
<li>Shadow - SSDT:GUI/GDI 系统服务函数表,这是第二张 SSDT </li>
<li>SSDTDT:系统服务表描述符表,表中每个元素是一个 SSDT 描述符(注意内核中有两张 SSDT 和两张 SSDTDT) </li>
<li>IDT:中断描述符表,每个 cpu 一个。(每个表项是一个描述符,可以简单视为 isr) </li>
<li>ISR:中断服务例程,IDT 表中的中断描述符所描述的中断处理函数 </li>
<li>EPR:异常处理例程,IDT 表中的异常描述符所描述的异常处理函数 </li>
<li>VA:虚拟地址, </li>
<li>PA:物理地址, </li>
<li>LA:线性地址, </li>
<li>RVA:相对虚拟地址 </li>
<li>foa:文件偏移 </li>
<li>PDE:页目录中的表项,保存着对应二级页表的物理地址,又叫“二级页表描述符” </li>
<li>PTE:二级页表中的表项,真正记录着每个虚拟页面的映射情况以及其他信息,又叫“映射描述符” 页目录:(又叫一级页表、总页表),一个 PDE 数组,这个数组的大小刚好占据一个页面 </li>
<li>二级页表:一个 PTE 数组,这个数组的大小也刚好占据一个页面(进程有一个总页表+1024 个二级页表) </li>
<li>AREA:地址空间中的一块连续的区段,VirtualAlloc 分配内存都是以区段为单位 </li>
<li>内存分配:表示从地址空间中用 VirtualAlloc 预定或者提交映射一块内存,不是指 malloc、new、HeapAlloc </li>
<li>PID:进程 ID、进程号。(其实也是个句柄) </li>
<li>TID:线程 ID、线程号。(其实也是个句柄) </li>
<li>PDO:物理设备对象,相对于 fdo 而言。Pdo 并不一定是最底层的那个硬件 pdo  </li>
<li>FDO:功能设备对象,相对于 pdo 而言。Fdo 也可能直接访问硬件芯片。fdo 与 pdo 只是一种相对概念。 </li>
<li>栈底 pdo:又叫”基石 pdo’,”硬件 pdo’,指用作堆栈基石的那个 pdo,它是由相应的总线驱动内部创建的 。 </li>
<li>端口设备对象:端口驱动或者小端口驱动中创建的设备对象(他下面是硬件 pdo) </li>
<li>总线驱动:用来驱动总线的驱动(总线本身也是一种特殊的设备),如 pci.sys 总线驱动 </li>
<li>端口驱动:由厂家提供的真正用来直接访问硬件芯片的驱动,位于总线驱动上层 </li>
<li>功能驱动:指类驱动。如鼠标类驱动 mouseclass.sys,磁盘类驱动 disk.sys </li>
<li>上层过滤驱动:位于功能类驱动上面的驱动 </li>
<li>下层过滤驱动:位于功能驱动下面,端口驱动上面的驱动 </li>
<li>顶层驱动:指位于栈顶的驱动 </li>
<li>中间驱动:intermediate drivers,凡是夹在顶层驱动与端口驱动之间的那些驱动都叫中间驱动 </li>
<li>设备树:由 PnP 管理器构造的一颗用来反映物理总线布局的”硬件设备树’。 </li>
<li>设备节点:设备树中的节点。每个节点都表示一个真正的”硬件 pdo”</li>
<li>老式驱动:即 NT 式驱动,指不提供 AddDevice 或通过 NtLoadDriver 加载的驱动 </li>
<li>WDM 驱动:指提供了 AddDevice 并且不是通过 NtLoadDriver 加载的驱动 </li>
<li>IRP 派遣例程:又叫分发例程、派遣函数。驱动程序中用来响应处理 irp 的函数。(Dispatch) </li>
<li>设备绑定:指将设备”堆栈’到原栈顶设备上面,成为新的栈顶设备。 </li>
<li>文件:指物理介质上的文件(磁盘、光盘、U 盘) </li>
<li>文件对象:每次打开设备时生成一个文件对象(文件对象不是文件,仅仅表示对设备的一次打开上下文,因此文件对象又叫打开者) </li>
<li>套接字驱动:afd.sys 套接字设备:\Device\Afd\Endpoint </li>
<li>套接字文件对象:每打开一次套接字设备生成一个套接字文件对象 </li>
<li>套接字FCB:每个套接字文件对象关联的FCB,用来描述套接字的其他信息 </li>
<li>地址文件对象:每次打开传输层的tdi设备时生成的一个文件对象,用于套接字绑定 </li>
<li>地址对象:传输层中为每个地址文件对象创建一个地址对象,用来描述一个地址(IP、端口号、协议等) </li>
<li>Socket irp:发往 afd 套接字设备(即\Device\Afd\Endpoint)的 irp </li>
<li>Tdi irp:发往传输层设备(即\Device\Tcp,\Device\Udp,\Device\RawIp)的 irp </li>
<li>物理卷设备:指磁盘卷、光盘卷、磁带卷等物理卷设备,由相应类型的硬件驱动创建 磁盘卷设备:指磁盘分区,设备对象名为\Device\HarddiskN\PartitionN 形式(N 从 0 开始) </li>
<li>文件卷设备:由文件系统内部创建的挂载(即绑定)在物理卷上的匿名设备 </li>
<li>Cdo:控制设备对象。一个驱动通常创建有一个 cdo,用来与外界通信。 </li>
<li>FSD:文件系统驱动,File System Driver 缩写。 </li>
<li>簇:文件以簇为分配单位。一个文件包含 N 个簇,簇之间不必物理连续,一个簇一般为 4KB </li>
<li>扇区:系统以扇区为单位进行磁盘 IO。一个簇包含 N 个扇区,一个扇区一般为 512B </li>
<li>文件块:磁盘文件中的文件块,对应于内核中的文件缓冲段 </li>
<li>缓冲段:文件块在内核中的缓冲 </li>
<li>ACL:访问控制表。每个 Ntfs 文件、内核对象都有一份 ACL,记录了各用户、组的访问权限 </li>
<li>Token:访问令牌。每个线程、进程都有一个 Token,记录了包含的特权、用户、组等信息 </li>
<li>SID:指用户 ID、组 ID、机器 ID,用来唯一标识。 </li>
<li>主令牌:进程自己的令牌 </li>
<li>客户令牌:也即模拟令牌。每个线程默认使用进程的令牌,但也可模式使用其他进程的令牌 </li>
</ul>
<p><br><br><br></p>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>Windows 的地址空间分用户模式与内核模式,低2GB 的部分叫用户模式,高2G 的部分叫内核模式,位于用户空间的代码不能访问内核空间,位于内核空间的代码却可以访问用户空间<br>一个线程的运行状态分内核态与用户态,当指令位于用户空间时,就表示当前处于内核态,当指令位于内核空间时,就处于内核态.<br>一个线程由用户态进入内核态的途径有3 种典型的方式:</p>
<ul>
<li>1、 主动通过int 2e(软中断自陷方式)或sysenter 指令(快速系统调用方式)调用系统服务函数,主动进入内核</li>
<li>2、 发生异常,被迫进入内核</li>
<li>3、 发生硬件中断,被迫进入内核</li>
</ul>
<h2 id="主动进入内核"><a href="#主动进入内核" class="headerlink" title="主动进入内核"></a>主动进入内核</h2><p>现在讨论第一种进入内核的方式:(又分为两种方式)</p>
<h3 id="int2e"><a href="#int2e" class="headerlink" title="int2e"></a>int2e</h3><p>通过老式的int 2e 指令方式调用系统服务(因为老式cpu 没提供sysenter 指令)</p>
<p>如ReadFile 函数调用系统服务函数NtReadFile</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Kernel32.ReadFile() <span class="comment">//点号前面表示该函数的所在模块</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//所有Win32 API 通过NTDLL 中的系统服务存根函数调用系统服务进入内核</span></span><br><span class="line">	NTDLL.NtReadFile();</span><br><span class="line">&#125;</span><br><span class="line">NTDLL.NtReadFile()</span><br><span class="line">&#123;</span><br><span class="line">	Mov eax,<span class="number">152</span> <span class="comment">//我们要调用的系统服务函数号,也即SSDT 表中的索引,记录在eax 中</span></span><br><span class="line">	If(cpu 不支持sysenter 指令)</span><br><span class="line">	&#123;</span><br><span class="line">		Lea edx,[esp+<span class="number">4</span>] <span class="comment">//用户空间中的参数区基地址,记录在edx 中</span></span><br><span class="line">		Int <span class="number">2</span>e <span class="comment">//通过该自陷指令方式进入KiSystemService,"调用’对应的系统服务</span></span><br><span class="line">	&#125;</span><br><span class="line">	Else</span><br><span class="line">	&#123;</span><br><span class="line">		Lea edx,[esp +<span class="number">4</span>] <span class="comment">//用户空间中的参数区基地址,记录在edx 中</span></span><br><span class="line">		Sysenter <span class="comment">//通过sysenter 方式进入KiFastCallEntry,"调用’对应的系统服务</span></span><br><span class="line">	&#125;</span><br><span class="line">	Ret <span class="number">36</span> <span class="comment">//不管是从int 2e 方式还是sysenter 方式,系统调用都会返回到此条指令处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Int-2e-的内部实现原理"><a href="#Int-2e-的内部实现原理" class="headerlink" title="Int 2e 的内部实现原理"></a>Int 2e 的内部实现原理</h4><p>该指令是一条自陷指令,执行该条指令后,cpu 会自动将当前线程的当前栈切换为本线程的内核栈(栈分<br>用户栈、内核栈),保存中断现场,也即那5 个寄存器。<br>然后从该cpu 的中断描述符表(简称IDT)中找到这个2e 中断号对应的函数(也即中断服务例程,简称ISR),jmp 到对应的isr 处继续执行,此时这个ISR<br>本身就处于内核空间了,当前线程就进入内核空间了</p>
<p>Int 2e 指令可以把它理解为intel 提供的一个内部函数,它内部所做的工作如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Int <span class="number">2</span>e</span><br><span class="line">&#123;</span><br><span class="line">	Cli <span class="comment">//cpu 一中断,立马自动关中断</span></span><br><span class="line">	Mov esp, TSS.内核栈地址 <span class="comment">//切换为内核栈,TSS 中记录了当前线程的内核栈地址</span></span><br><span class="line">	Push SS</span><br><span class="line">	Push esp</span><br><span class="line">	Push eflags</span><br><span class="line">	Push cs</span><br><span class="line">	Push eip <span class="comment">//这5 项工作保存了中断现场【标志、ip、esp】</span></span><br><span class="line">	Jmp IDT[中断号] <span class="comment">//跳转到对应本中断号的isr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

<h4 id="IDT整体布局"><a href="#IDT整体布局" class="headerlink" title="IDT整体布局"></a>IDT整体布局</h4><p>IDT 的整体布局:【异常-&gt;空白-&gt;5 系-&gt;硬】(推荐采用7 字口诀的方式重点记忆)</p>
<h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><p>前20 个表项存放着各个异常的描述符(IDT 表不仅可以放中断描述符,还放置了所有异常的异常处理描述符,0x00-0x13)保留:0x14-0x1F,忽略这块号段</p>
<h5 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h5><p>接下来存放一组空闲的保留项(0x20-0x29),供系统和程序员自己分配注册使用</p>
<h5 id="5-系"><a href="#5-系" class="headerlink" title="5 系"></a>5 系</h5><p>然后是系统自己注册的5 个预定义的软中断向量(软中断指手动的INT 指令)</p>
<blockquote>
<p>(0x2A-0x2E 5 个系统预注册的中断向量</p>
<ul>
<li>0x2A:KiGetTickCount</li>
<li>0x2B:KiCallbaclReturn</li>
<li>0x2C:KiRaiseAssertion</li>
<li>0x2D:KiDebugService</li>
<li>0x2E:KiSystemService</li>
</ul>
</blockquote>
<h5 id="硬"><a href="#硬" class="headerlink" title="硬"></a>硬</h5><p>最后的表项供驱动程序注册硬件中断使用和自定义注册其他软中断使用(0x30-0xFF)</p>
<blockquote>
<p>下面是中断号的具体的分配情况<br>0x00-0x13 固定分配给异常:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0x00: Divide error(故障)</span><br><span class="line">0x01: Debug (故障或陷阱)</span><br><span class="line">0x02: 保留未用(为非屏蔽中断保留的,NMI)</span><br><span class="line">0x03: breakpoint(陷阱)</span><br><span class="line">0x04: Overflow(陷阱)</span><br><span class="line">0x05: Bounds check(故障)</span><br><span class="line">0x06: Invalid Opcode(故障)</span><br><span class="line">0x07: Device not available(故障)</span><br><span class="line">0x08: Double fault(异常中止)</span><br><span class="line">0x09: Coprocessor segment overrun(异常中止)</span><br><span class="line">0x0A: Invalid TSS(故障)</span><br><span class="line">0x0B: Segment not present(故障)</span><br><span class="line">0x0C: Stack segment(故障)</span><br><span class="line">0x0D: General protection(故障)</span><br><span class="line">0x0E: Page fault(故障)</span><br><span class="line">0x0F: Intel 保留</span><br><span class="line">0x10: Floating point error(故障)</span><br><span class="line">0x11: Alignment check(故障)</span><br><span class="line">0x12: Machine check(异常中止)</span><br><span class="line">0x13: SIMD floating point(故障)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>0x14-0x1f:Intel 保留给他公司将来自己使用(OS 和用户都不要试图去使用这个号段,不安全)<br>———————-以下的号段可用于自由分配给OS、硬件、用户使用———————–</p>
<blockquote>
<p>linux 等其他系统是怎么划分这块号段的,不管,我们只看Windows 的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x20-0x29:Windows 没占用,因此这块号段我们也可以自由使用</span><br><span class="line">0x2A-0x2E:Windows 自己本身使用的5 个中断号</span><br><span class="line">0x30-0xFF:Windows 决定把这块剩余的号段让给硬件和用户使用</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>参见《寒江独钓》一书P93 页注册键盘中断时,搜索空闲未用表项是从0x20 开始,到0x29 结束的<br>就知道为什么寒江独钓是在这段范围内搜索空白表项了(其实我们也完全可以从0x14 开始搜索)</p>
</blockquote>
<p>Windows 系统中,0x30-0xFF 这块号段让给了硬件和用户自己使用。<br>事实上,这块号段的开头部分默认都是让给硬件IRQ 使用的,也即是分配给硬件IRQ 的。<br>IRQ N 默认映射到中断号0x30+N,如IRQ0 用于系统时钟,<br>系统时钟中断号默认对应就是0x30。当然程序员也可以修改APIC(可编程中断控制器)将IRQ 映射到自定义的中断号。</p>
<p>IRQ 对外部设备分配,但IRQ0,IRQ2,IRQ13 必须如下分配:</p>
<ul>
<li>IRQ0 —-&gt;间隔定时设备</li>
<li>IRQ2 —-&gt;8259A 芯片</li>
<li>IRQ13 —-&gt;外部数学协处理器<br>其余的IRQ 可以任意分配给外部设备。<br>虽然一个IRQ 只对应一个中断号,但是由于IRQ 数量有限,而设备种类成千上万,因此多个设备可以使用<br>同一个IRQ,进而,多个设备可以分配同一个中断号。因此,一个中断号可以共享给多个设备同时使用。</li>
</ul>
<p>明白了IDT,就可以看到0x2e 号中断的isr 为KiSystemService,顾名思义这个中断号专用于提供系统服务。</p>
<hr>

<h4 id="KiSystemService"><a href="#KiSystemService" class="headerlink" title="KiSystemService"></a>KiSystemService</h4><p>在正式分析KiSystemService,前,先看下几个辅助函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">SaveTrap() <span class="comment">//这个函数用来保存寄存器现场和其他状态信息</span></span><br><span class="line">&#123;</span><br><span class="line">	Push <span class="number">0</span> <span class="comment">//LastError</span></span><br><span class="line">	Push ebp</span><br><span class="line">	Push ebx</span><br><span class="line">	Push esi</span><br><span class="line">	Push edi</span><br><span class="line">	Push fs <span class="comment">//此时的fs 若是从用户空间自陷进来的就指着TEB,反之指着kpcr</span></span><br><span class="line">	Push kpcr.ExceptionList</span><br><span class="line">	Push kthread.PreviousMode</span><br><span class="line">	Sub esp,<span class="number">0x48</span> <span class="comment">//腾给调式寄存器保存用</span></span><br><span class="line">	-----------至此,上面的这些语句连同<span class="keyword">int</span> <span class="number">2</span>e 中的语句在栈上构造了一个trap 帧-----------------</span><br><span class="line">	Mov CurTrapFrame,esp <span class="comment">//当前Trap 帧的地址</span></span><br><span class="line">	Mov CurTrapFrame.edx, kthread.TrapFrame <span class="comment">//将上次的trap 帧地址记录到edx 成员中</span></span><br><span class="line">	Mov kthread.TrapFrame, CurTrapFrame, <span class="comment">//修改本线程当前trap 帧的地址</span></span><br><span class="line">	Mov kthread.PreviousMode,GetMode(进入内核前的CS) <span class="comment">//根据CS 自动确定上次模式</span></span><br><span class="line">	Mov kpcr.ExceptionList,<span class="number">-1</span> <span class="comment">//表示刚进入内核时,尚未安装seh</span></span><br><span class="line">	Mov fs,kpcr <span class="comment">//一进入内核就让fs 改指向当前cpu 的描述符kpcr,不再指向TEB</span></span><br><span class="line">	If(当前线程处于调试状态) </span><br><span class="line">   		保存 DR0-DR7 到 trap 帧中 </span><br><span class="line">&#125; </span><br><span class="line">FindTableCall() <span class="comment">//这个函数用来查表,拷贝参数,调用系统服务 </span></span><br><span class="line">&#123; </span><br><span class="line">	Mov edi,eax <span class="comment">//系统函数号,低 12 位为索引,第 13 为表示是哪张系统服务表中的索引 </span></span><br><span class="line">	Mov eax, edi.低 <span class="number">12</span> 位 <span class="comment">//eax=真正的服务号 </span></span><br><span class="line">	If(edi.第 <span class="number">13</span> 位=<span class="number">1</span>) <span class="comment">//if 这是 shadow SSDT 中的系统函数号 </span></span><br><span class="line">	&#123; </span><br><span class="line">	   If(当前线程.服务描述符表!=shadow) </span><br><span class="line">	      当前线程.服务描述符表=shadow <span class="comment">//换用另外一张描述符表 </span></span><br><span class="line">	&#125; </span><br><span class="line">	服务表描述符=当前线程.服务描述符表[edi.第 <span class="number">13</span> 位] Mod edi=服务表描述符.base <span class="comment">//这个系统服务表的地址 Mov ebx,[edi+eax*4] //查表获得这个函数的地址 </span></span><br><span class="line">	Mov ecx=服务表描述符.Number[eax] <span class="comment">//查表获得的这个系统函数的参数大小 </span></span><br><span class="line">	 </span><br><span class="line">	Mov esi,edx <span class="comment">//esi=用户空间中的参数地址 Mov edi,esp  //esp 已经为内核栈的栈顶地址 </span></span><br><span class="line">	Rep movsb <span class="comment">//将所有参数从用户空间复制到内核空间,相当于 N 个连续 push 压参 </span></span><br><span class="line">	Call  ebx <span class="comment">//调用对应的系统服务函数 </span></span><br><span class="line">&#125; </span><br><span class="line">KiSystemService()<span class="comment">//int 2e 的 isr,内核服务函数总入口,注意这个函数可以嵌套、递归！！！ </span></span><br><span class="line">&#123; </span><br><span class="line">    SaveTrap(); </span><br><span class="line">    Sti <span class="comment">//开中断 </span></span><br><span class="line">	<span class="comment">//---------------上面保存完寄存器等现场后,开始查 SSDT 表调用系统服务------------------ </span></span><br><span class="line">	FindTableCall(); </span><br><span class="line">	<span class="comment">//---------------------------------调用完系统服务函数后------------------------------ </span></span><br><span class="line">	Move esp,kthread.TrapFrame; <span class="comment">//将栈顶回到 trap 帧结构体处 </span></span><br><span class="line">	Cli <span class="comment">//关中断 </span></span><br><span class="line">	<span class="keyword">if</span>(上次模式==UserMode) </span><br><span class="line">	&#123; </span><br><span class="line">		Call KiDeliverApc <span class="comment">//遍历执行本线程的内核 APC 和用户 APC 队列中的所有 APC 函数 清理 Trap 帧,恢复寄存器现场 </span></span><br><span class="line">		Iret  <span class="comment">//返回用户空间 </span></span><br><span class="line">	&#125; </span><br><span class="line">	Else </span><br><span class="line">	&#123; </span><br><span class="line">	   返回到原 call 处后面的那条指令处 </span><br><span class="line">	&#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面所说的 Trap 帧(TrapFrame)是指一个结构体,用来保存系统调用、中断、异常发生时的寄存器现场, 方便以后回到用户空间/回到中断处时,恢复那些寄存器的值,继续执行 </p>
<p>Trap帧中除了保存了所有寄存器现场外,还附带保存了一些其他信息,如 seh 链表的地址等 </p>
<h5 id="Trap帧"><a href="#Trap帧" class="headerlink" title="Trap帧"></a>Trap帧</h5><p>必须说一下 trap 帧的结构体布局定义: <code>typedef struct _KTRAP_FRAME</code> //Trap现场帧 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KTRAP_FRAME</span> //<span class="title">Trap</span>现场帧 </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="comment">// ------------------这些是KiSystemService保存的--------------------------- </span></span><br><span class="line">    ULONG DbgEbp; </span><br><span class="line">    ULONG DbgEip; </span><br><span class="line">    ULONG DbgArgMark; </span><br><span class="line">    ULONG DbgArgPointer; </span><br><span class="line">    ULONG TempSegCs; </span><br><span class="line">    ULONG TempEsp; </span><br><span class="line">    ULONG Dr0; </span><br><span class="line">    ULONG Dr1; </span><br><span class="line">    ULONG Dr2; </span><br><span class="line">    ULONG Dr3; </span><br><span class="line">    ULONG Dr6; </span><br><span class="line">    ULONG Dr7; </span><br><span class="line">    ULONG SegGs; </span><br><span class="line">    ULONG SegEs; </span><br><span class="line">    ULONG SegDs; </span><br><span class="line">    ULONG Edx;<span class="comment">//xy 这个位置不是用来保存edx的,而是用来保存上个Trap帧,因为Trap帧是可以嵌套的 </span></span><br><span class="line">    ULONG Ecx; <span class="comment">//中断和异常引起的自陷要保存eax,系统调用则不需保存ecx </span></span><br><span class="line">    ULONG Eax;<span class="comment">//中断和异常引起的自陷要保存eax,系统调用则不需保存eax </span></span><br><span class="line">    ULONG PreviousPreviousMode; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> <span class="title">FAR</span> *<span class="title">ExceptionList</span>;</span><span class="comment">//上次seh链表的开头地址 </span></span><br><span class="line">    ULONG SegFs; </span><br><span class="line">    ULONG Edi; </span><br><span class="line">    ULONG Esi; </span><br><span class="line">    ULONG Ebx; ULONG Ebp; </span><br><span class="line">	<span class="comment">//---------------------------------------------------------------------------------------- </span></span><br><span class="line">	ULONG ErrCode;<span class="comment">//发生的不是中断,而是异常时,cpu还会自动在栈中压入对应的具体异常码在这儿 </span></span><br><span class="line">	<span class="comment">//-----------下面5个寄存器是由int 2e内部本身保存的或KiFastCallEntry模拟保存的现场--------- </span></span><br><span class="line">    ULONG Eip; </span><br><span class="line">    ULONG SegCs; </span><br><span class="line">    ULONG EFlags; </span><br><span class="line">    ULONG HardwareEsp; ULONG HardwareSegSs; </span><br><span class="line">	<span class="comment">//---------------以下用于用于保存V86模式的4个寄存器也是cpu自动压入的------------------- </span></span><br><span class="line">    ULONG V86Es; </span><br><span class="line"> </span><br><span class="line">    ULONG V86Ds; </span><br><span class="line">    ULONG V86Fs; ULONG V86Gs; </span><br><span class="line">&#125; KTRAP_FRAME, *PKTRAP_FRAME;</span><br></pre></td></tr></table></figure>
<h5 id="KPCR-amp-amp-KPRCB"><a href="#KPCR-amp-amp-KPRCB" class="headerlink" title="KPCR&amp;&amp;KPRCB"></a>KPCR&amp;&amp;KPRCB</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Struct KPCR </span><br><span class="line">&#123; </span><br><span class="line">   KPCR_TIB Tib;<span class="comment">//类似于 TEB.TIB,内部第一个字段都是 ExceptionList </span></span><br><span class="line">   KPCR* self;<span class="comment">//自身结构体的地址,方便直接寻址 </span></span><br><span class="line">   KPRCB* kprcb;<span class="comment">//处理器控制块的地址、 </span></span><br><span class="line">   KIRQL irql;<span class="comment">//当前 cpu 的 irql </span></span><br><span class="line">   USHORT* IDT;<span class="comment">//本 cpu 的 IDT 地址,一有中断/异常就去这个表找 isr、epr </span></span><br><span class="line">   USHORT* GDT;<span class="comment">//全局描述符表地址 </span></span><br><span class="line">   KTSS* TSS;<span class="comment">//记录了本 cpu 上当前运行线程的状态信息,重要字段有内核栈地址,IO 权限位图 </span></span><br><span class="line">   „„ </span><br><span class="line">&#125; </span><br><span class="line">Struct KPRCB </span><br><span class="line">&#123; </span><br><span class="line">   KTHREAD* CurrentThread;<span class="comment">//本 cpu 上当前运行的线程 </span></span><br><span class="line">   KTHREAD* NextThread;<span class="comment">//本 cpu 上将抢占当前线程的下个线程(抢占式调度核心) </span></span><br><span class="line">   BYTE CpuID;<span class="comment">//不多说 </span></span><br><span class="line">   ULONG KernelTime,UserTime;<span class="comment">//本 cpu 的累计运行时间统计信息 </span></span><br><span class="line">   „„ </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="SSDT-amp-Shadow-SSDT"><a href="#SSDT-amp-Shadow-SSDT" class="headerlink" title="SSDT&amp;Shadow SSDT"></a>SSDT&amp;Shadow SSDT</h5><p>系统中有两张“系统服务表”,即 SSDT 和 shadow SSDT。<br>同样系统中也有两张“系统服务表描述符表”, 每个表都包含两个描述符。<br>两张表中第一个描述符都是 SSDT 的描述符,第二个描述符都是 shadow SSDT 的 描述符。<br>但是第一个表的第二个描述符是空白的,因此第一张表实际上只能描述 SSDT 表,第二张表可以 描述 SSDT 表和 shadow SSDT 表。</p>
<p>所以一旦调用的是 shadow SSDT 表中系统服务函数,<br>这个线程就会自动换 用第二张服务表描述符表,具体为: <code>Mov kthread.ServiceTable</code>, 第二张服务表描述符表<br>这样这个线程就变为一个 GUI 线程,以后都使用 第二张“系统服务表描述符表”了 </p>
<p>“系统服务表描述符”是一个结构体,用来描述一张系统服务表的各种信息,如下定义: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Struct KSERVICE_TABLE_DESCRIPTOR </span><br><span class="line">&#123; </span><br><span class="line">   ULONG* base;<span class="comment">//系统服务表的地址 </span></span><br><span class="line">   ULONG* CountTable;<span class="comment">//该系统服务表中每个函数的历史调用次数统计表 </span></span><br><span class="line">   ULONG limit;<span class="comment">//该系统服务表的大小,也即容量 </span></span><br><span class="line">   BYTE* ArgSizeTable;<span class="comment">//记录该系统服务表中每个函数参数大小的表    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="通过快速调用指令"><a href="#通过快速调用指令" class="headerlink" title="通过快速调用指令"></a>通过快速调用指令</h3><p>通过快速调用指令(Intel 的是 sysenter,AMD 的是 syscall)调用系统服务 </p>
<p>老式的 cpu 不支持、不提供 sysenter 指令,只能由 int 2e 模拟中断方式进入内核调用系统服务<br>但是那种方式有一个明显的缺点,就是速度慢！(如 int 2e 内部本身要保存 5 个寄存器的现场,然后还 要去 IDT 中查找 isr,这个过程消耗的时间太多)<br>因此 x86 系列从奔腾 2 代开始为系统调用专门增设了 一条 sysenter 指令以及相应的寄存器 msr。<br>同样sysenter 指令也可看做 intel 提供的一个内部函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sysenter() </span><br><span class="line">&#123; </span><br><span class="line">   Mov ss,msr_ss </span><br><span class="line">   Mov esp,msr_esp <span class="comment">//关键 </span></span><br><span class="line">   Mov cs,msr_cs </span><br><span class="line">   Mov eip,msr_eip <span class="comment">//关键 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统在启动初始化过程中,会将上面四个 msr 寄存器设为固定的值,其中 msr_esp 为 DPC 函数专用堆栈, Msr_eip 则固定为<code>KiFastCallEntry</code></p>
<p><hr></p>
<h4 id="KiFastCallEntry"><a href="#KiFastCallEntry" class="headerlink" title="KiFastCallEntry"></a>KiFastCallEntry</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">KiFastCallEntry() <span class="comment">//快速系统调用总入口 </span></span><br><span class="line">&#123; </span><br><span class="line">	Mov fs,kpcr <span class="comment">//一进入内核,就将 fs 改指向处理器描述符 kpcr </span></span><br><span class="line">	Mov esp,TSS.ESP <span class="comment">//一进入内核,就换用内核栈(每个线程的内核栈地址保存在 TSS 中) </span></span><br><span class="line">	Push ds </span><br><span class="line">	Push edx  <span class="comment">//edx 为用户空间栈的栈顶地址,保存在这儿,方便以后回到用户空间时恢复 </span></span><br><span class="line">	Push eflags </span><br><span class="line">	Push cs </span><br><span class="line">	Push sysenter 指令的后面那条指令的地址 <span class="comment">//将用户空间中的返回地址保存在这儿 </span></span><br><span class="line">	<span class="comment">//--------上面的 5 条 push 指令模拟中断、异常发生时 cpu 自动保存的那 5 个寄存器的现场------------ </span></span><br><span class="line">	Cli <span class="comment">//关中断,构造 Trap 现场帧的过程中需要暂时关中断 </span></span><br><span class="line">	Mov eflags,<span class="number">0x2</span> SaveTrap();  </span><br><span class="line">	Sti <span class="comment">//开中断 </span></span><br><span class="line">	<span class="comment">// ---------------上面保存完寄存器等现场后,查 SSDT 表调用对应系统服务----------------------</span></span><br><span class="line">	FindTableCall(); </span><br><span class="line">	<span class="comment">// ------------------------------------调用完系统服务函数后-------------------------------- </span></span><br><span class="line">	Move esp,kthread.TrapFrame; <span class="comment">//将栈顶回到 trap 帧结构体处 Cli //关中断 </span></span><br><span class="line">	</span><br><span class="line">	Call KiDeliverApc <span class="comment">//遍历执行本线程的内核 APC 和用户 APC 队列中的所有 APC 函数 </span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 清理 Trap 帧,恢复寄存器现场 </span></span><br><span class="line">	Sti <span class="comment">//开中断 </span></span><br><span class="line">	<span class="comment">// -----------------------------------下面返回用户空间------------------------------------- </span></span><br><span class="line">	Mov ecx,保存的用户空间栈顶地址 </span><br><span class="line">	Mov edx,保存的返回地址,也即 sysenter 指令的后面那条指令的地址 </span><br><span class="line">	sysexit <span class="comment">//可以把这条指令理解为一个 fastcall 调用约定函数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

<h4 id="Sysexit"><a href="#Sysexit" class="headerlink" title="Sysexit"></a>Sysexit</h4><p>Sysexit 指令也可理解为一个函数,它做的工作如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sysexit </span><br><span class="line">&#123; </span><br><span class="line">	Mov cs,msr_cs </span><br><span class="line">	Mov ss,msr_ss </span><br><span class="line">	Mov esp,ecx <span class="comment">//换用用户空间中的栈 </span></span><br><span class="line">	Mov eip,edx <span class="comment">//这样就返回用户空间中了,所有系统调用总是先返回到 NTDLL.dll 中的某个固定位置</span></span><br><span class="line">	<span class="comment">// 最后一路返回到 NTDLL 中发起系统调用的那个存根函数体内 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><hr></p>
<h4 id="PreviousMode"><a href="#PreviousMode" class="headerlink" title="PreviousMode"></a>PreviousMode</h4><p>前面讲过,线程的内核结构 KTHREAD 中,有一个字段记录了 PreviousMode<br>这个“上一模式”指的就是,进入本次系统调用前的模式,也即指进入 SSDT 表中的服务函数前的模式是在用户空间还是内核空间。<br>Windows 不仅支持由用户空间发起系统调用,也支持由内核空间发起系统调用,为此Windows 专门配备了 Zw 系列的内核服务封装函数,如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Ntoskrnl.ZwCreateFile() <span class="comment">//模拟构造一个 Trap 现场,然后调用系统服务 </span></span><br><span class="line">&#123; </span><br><span class="line">	Mov eax,系统服务号 </span><br><span class="line">	Lea edx,[esp+<span class="number">4</span>] </span><br><span class="line">	Push eflags  </span><br><span class="line">	Push cs <span class="comment">//关键。根据 cs 的值设置 KTHREAD.PreviousMode 字段 </span></span><br><span class="line">	<span class="comment">//注意在调用本函数前,此处不再模拟中断、异常时自动保存的 ss、esp、eip 寄存器 </span></span><br><span class="line">	Call KiSystemService  </span><br><span class="line">	Ret <span class="comment">//这样,调用完系统服务后,就返回到这儿了,不再返回到 NTDLL 中的 sysenter 指令后面了 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">NtReadFile</span><span class="params">(„)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   „ </span><br><span class="line">   KPROCESSOR_MODE PreviousMode = KeGetPreviousMode(); </span><br><span class="line">   „ </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">KeGetPreviosMode() </span><br><span class="line">&#123; </span><br><span class="line">	Return kthread.PreviousMode; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样内核 API KeGetPreviosMode 的返回值就是内核模式了 </p>
<p>上面这个 NtReadFile 系统服务函数需要获得<code>上次模式</code>,而这个<code>上次模式</code>是在构造 TrapFrame 中的 过程中根据 cs 的值设置的。<br>因此凡是需要读取<code>上次模式</code>的系统服务函数,都必须有一个“正确的 TrapFrame”。<br>因此 ZwXXX 系列的系统服务封装函数会在内部<code>Push eflags</code>,<code>Push cs</code>,<code>Call KiSystemService</code><br>这三条指令就恰好伪造了一个“正确的 TrapFrame”,使得系统服务能够正确运行。<br>换言之:凡是需要读取“正确TrapFrame”的系统服务函数都不能直接手工调用,必须调用他们的 ZwXXX 封装函数。反之就可以直接调用。 </p>
<p><br></p>
<h3 id="cs-ds-es-fs-gs-ss段寄存器介绍"><a href="#cs-ds-es-fs-gs-ss段寄存器介绍" class="headerlink" title="cs,ds,es,fs,gs,ss段寄存器介绍"></a>cs,ds,es,fs,gs,ss段寄存器介绍</h3><p>fs 在用户态间接指向 TEB,在内核态间接指向 kpcr<br>其他 5 个段寄存器都可以理解为一个描述符 如cs段寄存器描述符<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs</span>&#123;</span> </span><br><span class="line">   BOOL bInGDT;<span class="comment">//指示下面的 idx 是在 GDT 表中还是 LDT 表中的索引,一般为 TRUE </span></span><br><span class="line">   Int idx;<span class="comment">// GDT/LDT 描述符表中,本 cs 段描述符的索引位置 </span></span><br><span class="line">   Int rpl:<span class="comment">//本段的特权级别:0 或者 3 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单的讲可以将他们视为 GDT 或 LDT 中的段描述符索引 更多基础信息参考:张银奎 -《软件调试》 </p>
<p><br><br><br></p>
<h1 id="内存管理篇"><a href="#内存管理篇" class="headerlink" title="内存管理篇"></a>内存管理篇</h1><p>32 位系统中有 4GB 的虚拟地址空间<br>每个进程有一个地址空间,共 4GB,(具体分为低 2GB 的用户地址空间+高 2GB 的内核地址空间) 各个进程的用户地址空间不同,属于各进程专有,内核地址空间部分则几乎完全相同<br>虚拟地址如<code>0x11111111</code>, 看似这 8 个数字是一个整体,其实是由三部分组成的,是一个三维地址<br>将这 个 32 位的值拆开,高 10 位表示二级页表号,中间 10 位表示二级页表中的页号,最后 12 位表示页内偏移(2^12=4kb)<br>因此一个虚拟地址实际上是一个三维地址,指明了本虚拟地址在哪个二级页表,又在哪个 页以及页内偏移是多少 这三样信息！<br>即10-10-12的分页模式, 当然也有2-9-9-12的分页模式, 理论上这样的PAE分页模式可以突破32g的内存, 达到64g的物理地址空间</p>
<blockquote>
<p>【虚拟地址 = 二级页表号.页号.页内偏移】:口诀【页表、页号、页偏移】 </p>
</blockquote>
<h2 id="Cpu-访问物理内存的原理介绍"><a href="#Cpu-访问物理内存的原理介绍" class="headerlink" title="Cpu 访问物理内存的原理介绍"></a>Cpu 访问物理内存的原理介绍</h2><h3 id="Cpu访问内存途径"><a href="#Cpu访问内存途径" class="headerlink" title="Cpu访问内存途径"></a>Cpu访问内存途径</h3><p>如高级语言<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DWORD g_var; <span class="comment">//假设这个全局变量被编译器编译为 0x00000004 </span></span><br><span class="line">g_var=<span class="number">100</span>;</span><br></pre></td></tr></table></figure></p>
<p>那么这条赋值语句编译后对应的汇编语句为:<code>mov DWORD PTR[0x00000004],100</code></p>
<p>这里<code>0x00000004</code>就是一个虚拟地址,简称 VA</p>
<blockquote>
<p>那么这条 mov 指令究竟是如何寻址的呢？<br>寻址过程为:CPU 中的虚拟地址转换器也即 MMU,将虚拟地址 0x00000004 转换为物理地址 具体转换过程为: </p>
</blockquote>
<p>根据 CR3 寄存器中记录的当前进程页表的物理地址,找到总页表也即页目录,再根据虚拟地址中的页表号,以页表号为索引,找到总页表中对应的 PDE<br>再根据 PDE 找到对应的二级页表, 再以虚拟地址中的页号部x分为索引,找到二级页表中的对应 PTE<br>再根据这个 PTE 记录的映射关系,找到这个虚拟页面对应的物理页面<br>最后加上虚拟地址中的页内偏移部分,加上这个偏移值,就得出最后的物理地址。</p>
<blockquote>
<p>具体用下面的函数可以形象表达寻址转换过程</p>
</blockquote>
<p><code>mov DWORD PTR[0x00000004],100 //这条指令的内部原理(没考虑二级缓冲情况)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">	va=<span class="number">0x00000004</span>;<span class="comment">//页表号=0,页号=0,页内偏移=4 </span></span><br><span class="line"></span><br><span class="line">	总页表=CR3; <span class="comment">//本进程的总页表的物理地址固定保存在 cr3 寄存器中 </span></span><br><span class="line">	PDE=总页表[va.页表号];  <span class="comment">//PDE 为对应的二级页表描述符 </span></span><br><span class="line">	</span><br><span class="line">	二级页表=PDE.PageAddr; <span class="comment">//得出本二级页表的地址 </span></span><br><span class="line">	PTE=二级页表[va.页号];  <span class="comment">//得出到该虚拟地址所在页面的 PTE 映射描述符 </span></span><br><span class="line">	</span><br><span class="line">	If(PTE 空白) <span class="comment">//PTE 为空表示该虚拟页面尚未建立映射 </span></span><br><span class="line">		触发 <span class="number">0x0e</span> 号页面访问异常(具体为缺页异常) </span><br><span class="line">	Else </span><br><span class="line">	</span><br><span class="line">	If(PTE.bPresent==<span class="literal">false</span>) <span class="comment">//PTE 的这个字段表示该虚拟页面当前是否映射到了物理内存 </span></span><br><span class="line">		触发 <span class="number">0x0e</span> 号页面访问异常(具体为缺页异常) </span><br><span class="line">	Else </span><br><span class="line">	</span><br><span class="line">	If(CR0.wp==<span class="number">1</span>  &amp;&amp;  PTE.Writable==<span class="literal">false</span>) <span class="comment">//已开启页面写保护功能,就检查这个页面是否可写 </span></span><br><span class="line">		触发 <span class="number">0x0e</span> 号页面访问异常(具体为页面访问保护越权异常) </span><br><span class="line">	Else </span><br><span class="line">		物理地址 pa =cs.base + PTE.PageAddr + va.页内偏移 <span class="comment">//得出对应的物理地址 </span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	将得到的 pa 放到地址总线上,<span class="number">100</span> 放在数据总线上,经由 FSB-&gt;北桥-&gt;内存总线-&gt;内存条 写入内存 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的讲,可以将他们视为 GDT 或 LDT 中的段描述符索引 更多基础信息参考:张银奎 -《软件调试》 </p>
<blockquote>
<p>注:在做 SSDT hook、IDT hook 时,由于 SSDT 与 IDT 这两张表各自所在的页面都是只读的,也即他们的 PTE 中标志位标示了该页面不可写。<br>因此一修改 SSDT、IDT 就会报异常,一个简单的处理方法是是关闭 CRO 中的 wp 即写保护位,这样就可以修改了 </p>
</blockquote>
<p><br><br><br></p>
<h2 id="虚拟页面结构"><a href="#虚拟页面结构" class="headerlink" title="虚拟页面结构"></a>虚拟页面结构</h2><blockquote>
<p>进程,地址空间,区段,区块,页面的逻辑层次关系<br>一个虚拟页面实际上有五级限定:<br><code>【进程.地址空间.区段.区块.虚拟页面】</code> 意为:哪个进程的哪个地址空间中的哪个区段中的哪个区块中的哪个虚拟页面 </p>
</blockquote>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>前文说了,每个进程有两个地址空间,一个用户地址空间,一个内核地址空间,该地址空间的内核结构体定义为:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Struct  MADDRESS_SPACE <span class="comment">//地址空间描述符 </span></span><br><span class="line">&#123; </span><br><span class="line">	MEMORY_AREA* MemoryRoot;<span class="comment">//本地址空间的已分配区段表(一个 AVL 树的根) </span></span><br><span class="line">	VOID* LowestAddress;<span class="comment">//本地址空间的最低地址(用户空间是 0,内核空间是 0x80000000) </span></span><br><span class="line">	EPROCESS* Process;<span class="comment">//本地址空间的所属进程 </span></span><br><span class="line">	<span class="comment">/*一个表,表中每个元素记录了本地址空间中各个二级页表中的 PTE 个数,一旦某个二级页表中的 PTE 个数减到了 0,就自动释放该二级页面表本身,体现为稀疏数组特征*/</span> </span><br><span class="line">	USHORT* PageTableRefCountTable;  </span><br><span class="line">	ULONG PageTableRefCountTableSize;<span class="comment">//上面那个表的大小 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>地址空间中所有已分配的区段都记录在一张表中,这个表不是简单的数组,而是一个 AVL 树,用来提高查 找效率。<br>每个区段的基址都对齐 64KB 或 4KB(指 64KB 整倍数),各个区段之间可以有空隙, 区段的分布是很零散的！各个区段之间,夹杂的空隙就是尚未分配的虚拟内存。</p>
<hr>

<h3 id="区段"><a href="#区段" class="headerlink" title="区段"></a>区段</h3><blockquote>
<p>注:所谓已分配区段,是指已经过 VirtualAlloc 预订(reserve)或提交(commit)后的虚拟内存 区段的描述符如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Struct  MEMORY_AREA   <span class="comment">//区段描述符 </span></span><br><span class="line">&#123; </span><br><span class="line">	Void* StartingAddress; <span class="comment">//开始地址,普通区段对齐 64KB,其它类型区段对齐 4KB </span></span><br><span class="line">	Void* EndAddress;<span class="comment">//结尾地址,EndAddress – StartingAddress 就是该区段的大小 </span></span><br><span class="line">	MEMORY_AREA*  Parent;<span class="comment">//AVL 树中的父节点 </span></span><br><span class="line">	MEMORY_AREA* LeftChild;<span class="comment">//左边的子节点 </span></span><br><span class="line">	MEMORY_AREA* RightChild;<span class="comment">//右边的子节点 </span></span><br><span class="line">	<span class="comment">//常见的区段类型有:普通型区段、视图型区段、缓冲型区段(后面文件系统中会讲到)等 </span></span><br><span class="line">	ULONG type;<span class="comment">//本区段的类型 </span></span><br><span class="line">	ULONG protect;<span class="comment">//本区段的保护权限,可读、可写、可执行的组合 </span></span><br><span class="line">	ULONG flags;<span class="comment">//当初分配本区段时的分配标志 </span></span><br><span class="line">	BOOLEAN DeleteInProgress;<span class="comment">//本区段是否标记为了"已删除"</span></span><br><span class="line"></span><br><span class="line">	ULONG PageOpCount; </span><br><span class="line"> </span><br><span class="line">	Union&#123; </span><br><span class="line">		Struct <span class="comment">//这个 Struct 专用于视图型区段 </span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">//凡是含有 ROS 字样的函数与结构体都表示是 ReactOS 与 Windows 中不同的实现细节 </span></span><br><span class="line">			ROS_SECTION_OBJECT* section;  </span><br><span class="line">			ULONG ViewOffest;<span class="comment">//指本视图型区段在所在 Segment 内部的偏移 </span></span><br><span class="line">			MM_SECTION_SEGMENT* Segment;<span class="comment">//所属 Segment </span></span><br><span class="line">			BOOLEAN WriteCopyView;<span class="comment">//本视图区段是不是一个写复制区段      </span></span><br><span class="line">		&#125;SectionData; </span><br><span class="line">		LIST_ENTRY RegionListHead;<span class="comment">//本区段内部的所有 Region 区块,放在一个链表中 </span></span><br><span class="line">	&#125;Data; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>浅谈区段类型: </p>
<ul>
<li>MEMORY_AREA_VIRTUAL_MEMORY://普通型区段,由 VirtuAlloc 应用层用户分配的区段都是普通区段 </li>
<li>MEMORY_AREA_SECTION_VIEW://视图型区段,用于文件映射、共享内存 </li>
<li>MEMORY_AREA_CACHE_SEGMENT://用于文件缓冲的区段(一个簇大小) </li>
<li>MEMORY_AREA_PAGED_POOL://内核分页池中的区段 MEMORY_AREA_KERNEL_STACK://用于内核栈中的区段 </li>
<li>MEMORY_AREA_PEB_OR_TEB://用于 PEB、TEB 的区段 </li>
<li>MEMORY_AREA_MDL_MAPPING://内核中专用于建立 MDL 映射的区段 </li>
<li>MEMORY_AREA_CONTINUOUS_MEMORY://对应的物理页面也连续的区段 </li>
<li>MEMORY_AREA_IO_MAPPING://内核空间中用于映射外设内存(如显存)的区段 </li>
<li>MEMORY_AREA_SHARED_DATA://内核空间中用于与用户空间共享的区段 </li>
</ul>
<hr>


<h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Struct  MM_REGION <span class="comment">//区块描述符 </span></span><br><span class="line">&#123; </span><br><span class="line">	ULONG type;<span class="comment">//指本区块的分配类型(预定型分配、提交型分配),又叫映射状态(已映射、尚未映射) </span></span><br><span class="line">	ULONG protect;<span class="comment">//本区块的访问保护权限,可读、可写、可执行的组合 </span></span><br><span class="line">	ULONG length;<span class="comment">//区块长度,对齐页面大小(4KB) </span></span><br><span class="line">	LIST_ENTRY RegionListEntry;<span class="comment">//用来挂入所在区段的区块链表 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存以区段为分配单位,一个区段内部,又按分配类型、保护属性划分区块。<br>一个区块包含一到多个内存页面,分配类型相同并且保护权限相同的区域组成一个个的区块,因此,称为“同属性区块”。<br>一个区段内部,相邻区块之间的属性肯定是不相同的(分配类型或保护权限不同)<br>若两个相邻区块的属性相同了,会自动合并成一个新的区块。 </p>
<p><br></p>
<h3 id="内存各个Mm函数"><a href="#内存各个Mm函数" class="headerlink" title="内存各个Mm函数"></a>内存各个Mm函数</h3><p><code>MEMORY_AREA* MmLocateMemoryAreaByAddress(MADDRESS_SPACE* as, void* addr);</code><br>这个内核函数用于在指定地址空间中查找指定地址所属的已分配区段,如果返回 NULL,表示该地址尚不处 于任何已分配区段中,也即表示该地址尚未分配。 </p>
<p><code>Void* MmFindGap(MADDRESS_SPACE* as, ULONG len, ULONG AlignGranularity, BOOL TopDown)</code><br>这个函数在指定地址空间中 查找一块符合 len 长度的空闲(也即未分配)区域,返回找到的空闲区的地址,<br>AlignGranularity 表示该空白区必须的对齐粒度,TopDown 表示是否从高地址端向低地址端搜索 </p>
<p><code>MEMORY_AREA*  MmLocateMemoryAreaByRegion(MADDRESS_SPACE* as, void* addr, ULONG len)</code><br>这个函数从指定地址空间的低地址端向高地址段搜索,返回第一个与给点区间(addr,len)有交集的已分 配区段 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MmCreateMemoryArea</span><span class="params">(MADDRESS_SPACE* as, type, <span class="keyword">void</span>** BaseAddr, Len, protect, bFixedAddr, AllocFlags,   MEMORY_AREA** Result)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	Len=Align(Len,<span class="number">4</span>kb);<span class="comment">//区段长度都要对齐 4kb </span></span><br><span class="line">	UINT BaseAlign;<span class="comment">//区段的基址对齐粒度 </span></span><br><span class="line"></span><br><span class="line">	If(type==普通区段) </span><br><span class="line">		BaseAlign=<span class="number">64</span>KB; </span><br><span class="line">	Else </span><br><span class="line">		BaseAlign =<span class="number">4</span>KB;  </span><br><span class="line">	</span><br><span class="line">	If(*BaseAddr ==<span class="literal">NULL</span>  &amp;&amp;  !bFixedAddr)<span class="comment">//if 用户不要求从固定地址处开始分配 </span></span><br><span class="line">	&#123; </span><br><span class="line">		*BaseAddr=MmFindGap(as,Len, BaseAlign, AllocFlags 要求 TopDown?); </span><br><span class="line">	&#125; </span><br><span class="line">	Else<span class="comment">//else 只要用户给定了基址,就必须从那儿开始分配 </span></span><br><span class="line">	&#123; </span><br><span class="line">		*BaseAddr=Align(*BaseAddr, BaseAlign); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	If(要分配的区域没有完全落在指定地址空间内部) </span><br><span class="line">		Return fail; </span><br><span class="line">	</span><br><span class="line">	If(MmLocateMemoryAreaByRegion(as,*BaseAddr,Len)!=<span class="number">0</span>)<span class="comment">//if 这段范围已分配过 </span></span><br><span class="line">		Return fail;     </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//找到了一个空闲区域后/指定的地址满足分配要求,就把这块区域分配出去 </span></span><br><span class="line"></span><br><span class="line">	Memory_Area* Area=ExAllocatePool(NonPagePool, <span class="keyword">sizeof</span>(*Area),tag); </span><br><span class="line">	ZeroMemory(Area); </span><br><span class="line">	Area.type=type;<span class="comment">//本区段的初始分配类型(初始时,一个区段内部就一个区块) </span></span><br><span class="line">	Area.StartAddr=*BaseAddr; </span><br><span class="line">	Area.EndAddr=*BaseAddr+Len; </span><br><span class="line">	Area.protect=protect;<span class="comment">//本区段的初始保护属性 </span></span><br><span class="line">	Area.flags=Allocflags; </span><br><span class="line">	</span><br><span class="line">	MmInsertMemoryArea(as,Area);<span class="comment">//分配后插入地址空间中的已分配区段表中(AVL 树) </span></span><br><span class="line">	*Result=Area; </span><br><span class="line">	Return succ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数用来从指定地址或者让系统自动寻找一块空闲的区域,分配一块指定长度、类型的区段。</p>
<blockquote>
<p>所谓分配:包含 reserve 型分配(即预定型分配)和 commit 型分配(即提交型分配)<br>预定:只占用分配一块区段,不建立映射<br>提交:分配一块区段并建立映射(映射到磁盘页文件/物理内存页面/普通文件)</p>
</blockquote>
<p><code>MM_REGION* MmFindRegion(void* AreaBaseAddr, LIST_ENTRY* RegionListHead, void* TgtAddr, Void** RegionBaseAddr)</code><br>这个函数从指定区段的区块链表中,查找给定目标地址 TgtAddr 落在哪一个区块内 第一个参数表示区段的基址。函数返回找到的区段并顺便将该区段的基址也存入最后一个参数中返回给调 用者 </p>
<p><code>MM_REGION* MmSplitRegion(MM_REGION* rgn, BaseAddr, StartAddr,Len, NewType,NewProtect AlterFunc)</code><br>这个函数将指定区块内部的指定区域(StartAddr,Len)修改为新的分配类型、保护属性,使原区块分裂, 一分为三(特殊情况一分为二)<br>然后调用 AlterFunc 跟着修改二级页表中,新区块的那些 PTE,最后再跟 着修改物理页面分配情况。函数返回新分出来的那个中间区块。这是一个内部辅助函数。 </p>
<p><code>NTSTATUS  MmAlterRegion(AreaBaseAddr, RegionListHead, TgtAddr,Len, NewType,NewProtect, AlterFunc)</code><br>这个函数是个通用函数,用来修改指定区段内部的指定区域的分配类型、保护属性,然后调用<br>调用 AlterFunc 跟着修改二级页表中,目标区域对应的那些 PTE,最后再跟着修改物理 页面的分配情况。 </p>
<p><br></p>
<h2 id="物理页面"><a href="#物理页面" class="headerlink" title="物理页面"></a>物理页面</h2><p>内核中有一个全局的物理页面数组,和<code>7</code>个物理页面链表。<br>分别是:</p>
<ul>
<li>PHYSICAL_PAGE MmPageArray[];//物理内存有多大,该数组就有多大 </li>
<li>LIST_ENTRY  FreeZeroedPageListHead;//空闲物理页面链表(且物理页面已清 0) </li>
<li>LIST_ENTRY  FreeUnzeroedPageListHead;//空闲物理页面链表(但物理页面尚未清 0) </li>
<li>LIST_ENTRY  UsedPageListHeads[4];//细分为 4 大消费用途的忙碌物理页面链表,各链表中按 LRU 顺序 </li>
<li>LIST_ENTRY  BiosPageListHead;//用于 Bios 的物理页面链表 </li>
</ul>
<p>物理页面数组是一个物理页面描述符数组,每个元素描述对应的物理页面(数组索引号即 物理页号,又叫 pfn)<br>每个描述符是一个<code>PHYSICAL_PAGE</code>结构体 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Struct  PHYSICAL_PAGE <span class="comment">//物理页面描述 </span></span><br><span class="line">&#123; </span><br><span class="line">	Type ;<span class="comment">//该物理页面的空闲占用状态(1 表示空闲,2 表示已占用,3 表示分给了 BIOS) </span></span><br><span class="line">	Consumer;<span class="comment">//该物理页面的消费用途(用户/内核分页池/内核非分页池/文件缓冲 四种) </span></span><br><span class="line">	Zero;<span class="comment">//标志本页面是否已清 0 </span></span><br><span class="line">	ListEntry;<span class="comment">//用来挂入那 7 个链表之一 </span></span><br><span class="line">	ReferenceCount;<span class="comment">//引用计数,一旦减到 0,页面就变为空闲状态,进入空闲链表 </span></span><br><span class="line">	SWAPENTRY SavedSwapEntry;<span class="comment">//对应的来源页文件,用于置换,一般为空  </span></span><br><span class="line">	LockCount;<span class="comment">//本物理页面的锁定计数(物理页面可锁定在内存中,不许置换到外存) MapCount;//同一个物理页面可以映射到 N 个进程的 N 个虚拟页面 </span></span><br><span class="line">	MM_RMAP_ENTRY* RmapListHead;<span class="comment">//本物理页面映射给的那些虚拟页面,组成的链表   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="物理页面的状态转换"><a href="#物理页面的状态转换" class="headerlink" title="物理页面的状态转换"></a>物理页面的状态转换</h3><blockquote>
<p>一个物理页面的典型状态转换过程为</p>
</blockquote>
<ul>
<li>起初处于空闲并清 0 的状态,然后应内存分配要求分配给 4 个消费者之一, 同时将该物理页面记录到对应消费者的 UsedPageListHead 链表中</li>
<li>最后用户用完后主动释放,或者因为物理内存紧张,被迫释放换到外存,而重新进入空闲状态,但此时尚未清0,将进入 FreeUnzeroedPageList 链表。</li>
<li>然后内核中有一个守护线程会定时、周期扫描这个空闲链表,将物理内存清0,转入 FreeZeroedPageList 链表,等候下次被分配。</li>
</ul>
<p>如此周而复返</p>
<blockquote>
<p>这段函数为指定消费者分配一个物理页面, 并第一时间将物理页面清 0, 然后返回分得的物理页号<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PFN_NUMBER  <span class="title">MmAllocPage</span><span class="params">(ULONG ConsumerType)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PFN_NUMBER Pfn;<span class="comment">//物理页号 </span></span><br><span class="line">	PPHYSICAL_PAGE PageDescriptor; </span><br><span class="line">	BOOLEAN NeedClear = FALSE;<span class="comment">//是否需要清零 </span></span><br><span class="line">	<span class="keyword">if</span> (FreeZeroedPageList链表 为空) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (FreeUnzeroedPageList 为空) </span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果两个空闲链表都为空就失败 </span></span><br><span class="line">		PageDescriptor = MiRemoveHeadList(&amp;MmFreePageListHead); </span><br><span class="line">		NeedClear = TRUE; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		PageDescriptor = MiRemoveHeadList(&amp;MmZeroedPageListHead); </span><br><span class="line">		<span class="comment">//从空闲链表中摘下来一个空闲页面后,初始化 </span></span><br><span class="line">	</span><br><span class="line">	MmAvailablePages--;<span class="comment">//总的可用物理页数-- </span></span><br><span class="line"></span><br><span class="line">	PageDescriptor-&gt;ReferenceCount = <span class="number">1</span>;<span class="comment">//刚分配的物理页面的引用计数为1 </span></span><br><span class="line">	PageDescriptor-&gt;LockCount=<span class="number">0</span>;<span class="comment">//表示可被置换到外存 </span></span><br><span class="line">	PageDescriptor-&gt;MapCount=<span class="number">0</span>;<span class="comment">//表示刚分配的物理页面尚未映射到任何虚拟页面 </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//记录到分配链表中 </span></span><br><span class="line">	InserTailList(&amp;UsedPageListHeads[ConsumerType], PageDescriptor); </span><br><span class="line">	<span class="keyword">if</span> (NeedClear) </span><br><span class="line">		MiZeroPage(PfnOffset);<span class="comment">//清0 </span></span><br><span class="line">	Pfn = PageDescriptor-MmPageArray;<span class="comment">//pfn=数组的索引,就是物理页号 </span></span><br><span class="line">	<span class="keyword">return</span> Pfn; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>这个函数先检查配额,再检查空闲页面阀值,做好准备工作后,再才分配物理页面<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS  <span class="title">MmRequestPageMemoryConsumer</span><span class="params">(consumer, PFN* pfn)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//先检查物理页面配额,超出配额,就自我修剪 </span></span><br><span class="line">	If(本消费者的分得的物理页面数量 = 本消费者的最大配额) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//换出那个消费者的某个物理页面到外存,腾出一个物理页面出来 </span></span><br><span class="line">		Call 对应消费者的自我页面修剪函数    </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	If(当前系统总的空闲页面总量 &lt; 储备阀值) </span><br><span class="line">	&#123; </span><br><span class="line">		If(consumer==非分页池消费者) </span><br><span class="line">		&#123; </span><br><span class="line">			*pfn = MmAllocPage(consumer); </span><br><span class="line">			<span class="comment">//分完后唤醒系统中的平衡线程去平衡物理页面,填补空白 </span></span><br><span class="line">			KeSetEvent(&amp;MiBalancerEvent);  </span><br><span class="line">			Return succ; </span><br><span class="line">		&#125; </span><br><span class="line">		Else </span><br><span class="line">		&#123; </span><br><span class="line">			*pfn = 请求平衡线程赶紧从其他消费者手中退出一个物理页面; </span><br><span class="line">			Return succ; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	Else </span><br><span class="line">		*pfn = MmAllocPage(consumer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>这个函数释放指定消费者占用的指定物理页面,实际上是递减引用计数,引用计数减到 0 后就挂入系统空闲链表 </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS  <span class="title">MmReleasePageMemory</span><span class="params">(consumer, pfn)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	Consumer.UsedPageCount--;<span class="comment">//递减本消费者持有的页面计数; </span></span><br><span class="line">	pfn.ReferenceCount--;<span class="comment">//递减本页面的引用计数</span></span><br><span class="line">	If(pfn.ReferenceCount==<span class="number">0</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		If(有其他分配请求正在等待退让物理页面) </span><br><span class="line">	 		将这个 pfn 分给那个 Pending 中的分配请求 </span><br><span class="line">		Else </span><br><span class="line">	 		将这个页面挂入系统 FreeUnzeroedPageList 链表； </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="漫谈页目录、二级页表"><a href="#漫谈页目录、二级页表" class="headerlink" title="漫谈页目录、二级页表"></a>漫谈页目录、二级页表</h2><p>前面讲到每个虚拟地址看似是一个整形值,实际上由三部分组成:<code>页表号.页号.页内偏移</code>;</p>
<blockquote>
<p>为什么不是直接的页号.页内偏移呢,直接采用一个简单的一维数组,记录所有虚拟页面的这样多直观！</p>
</blockquote>
<p>原因是:一个进 程的虚拟地址空间太大,如果为每个虚拟页面都分配一个 PTE,那么将占用大量内存<br>不信我们算一下:一个进程中总共有<code>4GB/4KB=2^20</code>个虚拟页面,也即 1MB 个虚拟页面<br>如果直接采用一维数组, 描述这个 1MB 页面的映射情况,那么整个数组大小=<code>1MB*sizeof(PTE)=4MB</code><br>这样光页表部分就占据了 4MB 的内存。<br>注意页表部分本身占用的内存是非分页内存,也即真金白银地占据着 4MB 物理内存,这 4MB 在现在的机器看来并不算多<br>但在早期只有 256MB 物理内存的老爷机上(最多只能同时支持 <code>256MB/4MB</code> 个=64 个进程),已经算够多了！ </p>
<p>相反如果采用页目录+二级页表的方式就会节省很多内存！<br>一个二级页表本身有一个页面大小, 可以容纳<code>4KB/sizeof(PTE)</code>=1024个 PTE<br>换句话说一个二级页表可以描述 1024 个页面的映射情况(换算成字节数,一个二级页面能描述<code>1024*4kb</code> 的地址空间)<br>一个进程总共有 4GB 地址空间,那么整个地址空间就有<code>4GB/(1024*4kb)</code>=1024个二级页表<br>那些暂时未映射的一大片虚拟地址,一般是高端的地址,就对应这 1024个二级页表中靠后的那些二级页表,就可以暂时不用为他们分配物理内存了<br>只有在确实要访问那些虚拟页面时,才分配他们对应的二级页表,这样按需分配就节省了物理内存。 </p>
<p>另外, 32 位系统中每个进程有 1024 个二级页表外加一个页目录。 咋一看似乎系统中有 1025 个页表维持着映射关系<br>其实不然, 因为页目录本身是一个特殊的二级页表,也是那 1024 个二级页表中的一个。<br>概念上,我们把第一个二级页表理解为页目录。这样系统中实际上共有 1024 个二级页表</p>
<blockquote>
<p>包括页目录本身在内,但要注意页目录并不在二级页表区的中的第一个位置,而是在中间的某个位置,后面我会推算页目录本身的虚拟地址在什么地方。<br>明白了这个道理, 就可以由任意一个虚拟地址推算出他所在的二级页表在页目录中的索引位置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ADDR_TO_PDE_OFFSET(addr)(  v/(1024*4kb) ) </span><br><span class="line">#define ADDR_TO_PAGE_TABLE(addr) ADDR_TO_PDE_OFFSET(addr)</span><br></pre></td></tr></table></figure>
<p>这样每个进程的页表不再是个简单的数组,而变成了一个稀疏数组。<br>页目录中的每个 PDE 描述了每个二级页表本身的物理地址。如果 PDE=0,就表示那个二级页表尚未分配,体现为<code>稀疏数组</code>特征。<br>实际上一个进程很少使用到整个 4GB 地址空间, 因此页目录中的绝大多数 PDE 都是空的, 实际的二级页面个数往往很少。 </p>
<h3 id="PTE"><a href="#PTE" class="headerlink" title="PTE"></a>PTE</h3><p>每个虚拟页面的映射描述符(即 PTE)的位置是固定的,根据虚拟页号可以自然算出那个虚拟页面的映射 描述符位置,找到映射描述符的位置后,就可以获得该虚拟页面的当前映射情况(是否已映射,若已映射, 是映射到了物理内存还是页文件,又具体映射到了哪个具体的物理页面,这些信息都一一获悉)<br>因此 PTE 映射描述符是页表的核心,现在看一下 PTE 它的结构。 </p>
<p>PTE 的结构,PTE 是二级页表中的表项,用来描述一个虚拟页面的映射情况以及其他信息<br>注意 PTE 本身长度为 4B,但我们可以把它当做一个描述符结构体,并不妨碍理解  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Struct PTE </span><br><span class="line">&#123; </span><br><span class="line">	Union </span><br><span class="line">	&#123; </span><br><span class="line">		Struct </span><br><span class="line">		&#123; </span><br><span class="line">			Bool bPresent;<span class="comment">//重点字段,表示该虚拟页面是否映射到了物理内存 </span></span><br><span class="line">			Bool bWritable;<span class="comment">//表示这个虚拟页面是否可写 </span></span><br><span class="line">			Bool bUser;<span class="comment">//表示是否是用户地址空间中的虚拟页面 </span></span><br><span class="line"></span><br><span class="line">			Bool bReaded;<span class="comment">//表示本虚拟页面自从上次置换到内存后是否曾被读过 </span></span><br><span class="line">			Bool bDirty;<span class="comment">//表示本虚拟页面自从上次置换到内存后是否曾被写过 </span></span><br><span class="line">			Bool bGlobal;<span class="comment">//表示本 PTE 表项是全局页面的映射描述符,切换进程时不用刷新本 PTE </span></span><br><span class="line">			UINT pfn;<span class="comment">//关键字段,表示本虚拟页面对应的物理页号  </span></span><br><span class="line">		&#125;Mem; </span><br><span class="line">		Struct </span><br><span class="line">		&#123; </span><br><span class="line">			文件中的页面号； </span><br><span class="line">			页文件号；<span class="comment">//系统中可以支持多个 Pagefile.sys 页文件 </span></span><br><span class="line">		&#125;File; </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样,这个 PTE 如果映射到了内存,就解释为 Mem 结构体,如果映射到了页文件,就解释为 File 结构体。  </p>
<h4 id="MmCreateVirtualMapping"><a href="#MmCreateVirtualMapping" class="headerlink" title="MmCreateVirtualMapping"></a>MmCreateVirtualMapping</h4><p>以下这个函数用来为指定的一段连续虚拟页面,批量创建 PTE,建立到各个物理页面的映射。</p>
<blockquote>
<p>注意虚拟页面一定是连续的, 物理页面数组中的物理页面是可以零散分布的。 </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS  <span class="title">MmCreateVirtualMapping</span><span class="params">(process,  FirstVirtualPageAddr, VirtualPageCount, PfnArray,</span></span></span><br><span class="line"><span class="function"><span class="params">					PfnCount,  PteFlags)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	If(VirtualPageCount != PfnCount ) </span><br><span class="line">		Return fail; </span><br><span class="line">	</span><br><span class="line">	DWORD NewPTE=ConstructPte(PteFlags);<span class="comment">//拷贝 PTE 中的那些 Bool 标志位 </span></span><br><span class="line">	Void* CurPageAddr = FirstVirtualPageAddr;<span class="comment">//当前虚拟页面的地址 </span></span><br><span class="line">	PTE* Pt;<span class="comment">//当前虚拟页面的 PTE 在二级页表中对应的位置 </span></span><br><span class="line">	</span><br><span class="line">	For(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; VirtualPageCount;i++)<span class="comment">//遍历每个要创建映射的虚拟页面 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//这个函数下文有解析 </span></span><br><span class="line">		Pt = MmGetPageTableForProcess(process, CurPageAddr);<span class="comment">//找到这个页面的 pte 位置  </span></span><br><span class="line">		OldPte = *Pt;<span class="comment">//记录这个虚拟页面原来的 PTE </span></span><br><span class="line">		If(OldPte 映射到了页文件) </span><br><span class="line">			<span class="keyword">return</span> fail; </span><br><span class="line">		</span><br><span class="line">		If(OldPte 映射到了物理内存)  </span><br><span class="line">			<span class="comment">// 撤销原来的映射; </span></span><br><span class="line">			NewPTE.pfn = PfnArray[i];<span class="comment">//关键,将这个虚拟页面映射到指定的物理页面 </span></span><br><span class="line">		</span><br><span class="line">		*pt = NewPTE;<span class="comment">//修改原 PTE 表项 </span></span><br><span class="line">		<span class="comment">//递增对应二级页表中的 PTE 个数,这个函数其实是创建 PTE,不是修改 PTE </span></span><br><span class="line">		</span><br><span class="line">		Process.地址空间.PageTableRefCountTable[ ADDR_TO_PAGE_TABLE(CurPageAddr) ]++; </span><br><span class="line">		</span><br><span class="line">		If(OldPte 映射到了某物理内存页面) </span><br><span class="line">			MiFlushTlb(pt, CurPageAddr);<span class="comment">//同步更新 cpu 二级缓冲中的 PTE </span></span><br><span class="line"></span><br><span class="line">		CurPageAddr+=<span class="number">4</span>KB；<span class="comment">//下一个虚拟页面 </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MmDeleteVirtualMapping"><a href="#MmDeleteVirtualMapping" class="headerlink" title="MmDeleteVirtualMapping"></a>MmDeleteVirtualMapping</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MmDeleteVirtualMapping</span><span class="params">(process, PageAddr,  bFreePhysicalPage,  BOOL* bDirty, PFN* pfn)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PTE* pt= MmGetPageTableForProcess(process, CurPageAddr);<span class="comment">//找到这个页面的 pte 位置  </span></span><br><span class="line">	PTE OldPte=*pt; </span><br><span class="line">	*pt=<span class="number">0</span>;<span class="comment">//全 0 就表示删除 PTE </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//*注意,一个物理页面可能还可能被其他虚拟页面映射着,应该等到该物理页面的 MapCount 减到 0 时 才释放这个物理页面*/ </span></span><br><span class="line">	If(bFreePhysicalPage) </span><br><span class="line">		MmReleasePageMemoryConsumer(pfn);  </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//递减对应二级页表中的 PTE 个数 </span></span><br><span class="line">	Process.地址空间.PageTableRefCountTable[ ADDR_TO_PAGE_TABLE(CurPageAddr) ] --; </span><br><span class="line"></span><br><span class="line">	If(Process.地址空间.PageTableRefCountTable[ ADDR_TO_PAGE_TABLE(CurPageAddr) ]  = <span class="number">0</span>) </span><br><span class="line">		MmReleasePageTable(process,PageAddr);<span class="comment">//释放对应的整个二级页表,体现稀疏数组特征 </span></span><br><span class="line">	</span><br><span class="line">	*bDirty=OldPte.bDirty; </span><br><span class="line">	*pfn=OldPte.pfn;<span class="comment">//返回原来映射的物理页面号 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="物理页面的临时映射-Hyperspace"><a href="#物理页面的临时映射-Hyperspace" class="headerlink" title="物理页面的临时映射(Hyperspace)"></a>物理页面的临时映射(Hyperspace)</h2><p>Windows 中,不管是应用程序还是内核程序,都不能直接访问物理内存</p>
<blockquote>
<p>如 <code>Mov eax,DWORD PTR[物理地址]</code>是不允许的,不支持的。</p>
</blockquote>
<p>所有非 IO 指令都只能访问虚拟内存地址</p>
<blockquote>
<p>如 <code>Mov eax, DWORD PTR[虚拟地址]</code>形式</p>
</blockquote>
<p>但是有时候我们明明已经知道了某个东西固定在物理内存条某处<br>假如系统时间的值永远固定存放在物理内存条的物理地址<code>0x80000000</code>处</p>
<blockquote>
<p>我们已经知道了物理地址,如何访问获得系统时间值呢？这是个问题！<br>Windows 为了解决这样的直接访问物理内存操作提供了手段！<br>其中之一便是:<code>为物理页面建立临时映射</code>, 也即可以将某个物理页面映射到系统地址空间中的那段专用于临时页面映射的保留区域。<br>具体的系统地址空间中专用于临时映射的那段保留区的起始虚拟地址为<code>#define  HYPERSPACE  0xC0400000</code></p>
</blockquote>
<p>保留区的大小为:1024 个虚拟页面,也即<code>1024*4KB=4MB</code>大小<br>下面这个函数用来将指定物理页面临时映射到保留区中的某个虚拟页面,返回得到的虚拟页面地址 </p>
<h3 id="MmCreateHyperspaceMapping"><a href="#MmCreateHyperspaceMapping" class="headerlink" title="MmCreateHyperspaceMapping"></a>MmCreateHyperspaceMapping</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void* <span class="title">MmCreateHyperspaceMapping</span><span class="params">(pfn)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PTE* Pte=临时映射保留区的映射描述符们所在的二级页表;<span class="comment">//也即第一个临时页面的映射描述符 </span></span><br><span class="line">	Pte+=pfn%<span class="number">1024</span>;<span class="comment">//从这个虚拟页面的映射描述符开始,向后搜索第一个尚未映射的虚拟页面 </span></span><br><span class="line">	For(i=pfn%<span class="number">1024</span>; i&lt;<span class="number">1024</span>; i++,Pte++)<span class="comment">//先遍历后面的那些 PTE </span></span><br><span class="line">	&#123; </span><br><span class="line">		If(*pte == 空白) </span><br><span class="line">		&#123; </span><br><span class="line">			*pte.pfn=pfn; </span><br><span class="line">			Break; </span><br><span class="line">		&#125;   </span><br><span class="line">	&#125; </span><br><span class="line">	If(i==<span class="number">1024</span>)<span class="comment">//如果后面部分未找到一个空闲 PTE,又从前面部分开始查找 </span></span><br><span class="line">	&#123; </span><br><span class="line"></span><br><span class="line">		PTE* Pte=临时映射保留区的映射描述符们所在的二级页表;<span class="comment">//回到开头 </span></span><br><span class="line">		For(i=<span class="number">0</span>; i&lt;pfn%<span class="number">1024</span>;i++,Pte++) </span><br><span class="line">		&#123; </span><br><span class="line">			If(*pte == 空白) </span><br><span class="line">			&#123; </span><br><span class="line">				*pte.pfn=pfn; </span><br><span class="line">				Break; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;<span class="comment">//end for </span></span><br><span class="line">	&#125;<span class="comment">//end if(i==1024) </span></span><br><span class="line">	<span class="comment">//上面是一个简单的闭式 hash 表的查找过程,找到一个尚未映射的临时保留虚拟页面后,就返回 </span></span><br><span class="line">	Return HYPERSPACE + i*<span class="number">4</span>kb; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然叫临时映射,那用完后就得撤销映射 </p>
<h3 id="MmDeleteHyperspaceMapping"><a href="#MmDeleteHyperspaceMapping" class="headerlink" title="MmDeleteHyperspaceMapping"></a>MmDeleteHyperspaceMapping</h3><p>MmDeleteHyperspaceMapping(pfn);//这个函数就是用来删除以前建立的临时映射,省略 </p>
<p><br></p>
<h2 id="虚拟页面与物理页面之间的映射"><a href="#虚拟页面与物理页面之间的映射" class="headerlink" title="虚拟页面与物理页面之间的映射"></a>虚拟页面与物理页面之间的映射</h2><p>一个物理页面可以映射到 N 个进程的 N 个虚拟页面中,但一个虚拟页面同一时刻只能映射到一个物理页面。<br>可以这么理解:<code>&quot;一个物理页面当前可能被 N 个虚拟页面映射着&quot;</code>, <code>&quot;本虚拟页面当前映射着一个物理页面&quot;</code>。 </p>
<p>每个虚拟页面又分四种映射状态: </p>
<ul>
<li>1、 映射着某个物理页面(已分配且已映射) </li>
<li>2、 映射着某个磁盘页文件中的某个页面(已分配且已映射) </li>
<li>3、 没映射到任何物理存储介质(对应的 PTE=0),但是可能被预定了(已分配,但尚未映射) </li>
<li>4、 裸奔(尚未分配,以上情况都不满足) </li>
</ul>
<p>一个进程的用户地址空间高达 2GB,分成很多虚拟页面,如果时时刻刻都让这些虚拟页面映射着物理内存, 那么物理内存恐怕很快就分完了。<br>所以同一时刻,只有最频繁访问的那些虚拟页面映射着物理页面(最 频繁访问的那些虚拟页面就构成了一个进程的工作集)<br>工作集中的所有虚拟页面都映射着物理页面,一旦访问工作集外面的虚拟页面,势必引发缺页异常<br>系统的缺页异常处理函数会自动帮我们处理这种异常(自动分配一个物理页面,将那个引发缺页异常的虚拟页面映射着的外存页面以分页读 irp 的形式读入到新 分配的物理页面中,然后修改那个虚拟页面的映射关系,指向那个新分配的物理页面)<br>这就是系统的缺页异常处理函数的工作原理,应用程序毫不知情。 </p>
<h3 id="寻找PTE"><a href="#寻找PTE" class="headerlink" title="寻找PTE"></a>寻找PTE</h3><p>要想查询一个虚拟页面的映射情况(有没有映射,有的话,又映射到了什么地方 这些信息)<br>唯一的办法就是要找到这个虚拟页面的 PTE 映射描述符,那么如何查找呢？ </p>
<p><code>#define PAGETABLE_MAP 0xC0000000</code><br>如前文所述每个进程的页表区都真枪实弹的占据着对应的物理内存</p>
<p>系统为了方便,把每个进程的页表区都事先固定映射到了虚拟地址<code>0xC0000000</code>处,长度为<code>1024</code>个页表 * 每个页表本身的大小(即 4KB)=4MB。<br>因此各个进程的页表区也都是被系统映射到了同一段虚拟空间<code>(0xC0000000---0xC0000000+4MB)</code>处。<br>这段区域用来映射二级页表们 </p>
<p><img src="/2020/11/03/windows-kernel-summary/image-01.png" width="800px"></p>
<p><code>#define PAGEDIR_MAP  (PAGETABLE_MAP + PAGETABLE_MAP/1024)</code></p>
<p><code>PAGEDIR_MAP</code>表示页目录本身所在的虚拟页面的地址, 这是怎么得来的呢？</p>
<p>是经过下面这样推算出来的<code>PAGEDIR_MAP= PAGETABLE_MAP + idx*</code>每个二级页面的大小<br>           = <code>PAGETABLE_MAP + idx*4kb</code><br>           = <code>PAGETABLE_MAP + (PAGETABLE_MAP 偏移/每个二级页表描述的长度范围) * 4kb</code><br>           = <code>PAGETABLE_MAP + (PAGETABLE_MAP/(1024*4kb)) * 4kb</code><br>           = <code>PAGETABLE_MAP + PAGETABLE_MAP/1024</code><br>因此只要知道了页表区中第一个二级页面的虚拟地址,就可以推算出页目录本身的虚拟地址 </p>
<p>进一步: </p>
<p><code>#define ADDR_TO_PDE(PageAddr) PAGEDIR_MAP + PageAddr/(1024*1024)</code> //直接推算 PDE 的地址<br><code>#define ADDR_TO_PTE(PageAddr) PAGETABLE_MAP + PageAddr/1024</code> //直接推算 PTE 的地址 </p>
<p>这两个宏我就不想多说了<br>下面这个函数用来找到指定进程中的指定虚拟页面的映射描述符位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PTE* <span class="title">MmGetPageTableForProcess</span><span class="params">(process, PageAddr)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	ULONG PDE_IDX = ADDR_TO_PDE_OFFSET(PageAddr);<span class="comment">//计算该虚拟页面的映射描述符在哪个二级页表中 PDE* PageDir;//页目录的虚拟地址 </span></span><br><span class="line">	If(process!=当前进程 &amp;&amp; PageAddr&lt;<span class="number">2</span>GB)<span class="comment">//if PageAddr 是其他进程的用户空间中的某个虚拟页面 </span></span><br><span class="line">	&#123; </span><br><span class="line">		PFN pfn=process.pcb.DirectoryTableBase;<span class="comment">//获得那个进程的页目录所在的物理页面号 </span></span><br><span class="line">		PageDir=MmCreateHyperspaceMapping(pfn);<span class="comment">//临时映射那个物理页面,以便访问它的页表 </span></span><br><span class="line">		</span><br><span class="line">		If(PageDir[PDE_IDX]==空白) </span><br><span class="line">			Return <span class="literal">NULL</span>;<span class="comment">//若整个二级页面尚未分配,返回 NULL </span></span><br><span class="line">		</span><br><span class="line">		Pfn= PageDir[PDE_IDX].pfn;<span class="comment">//获得二级页表所在的物理页号 </span></span><br><span class="line">		MmDeleteHyperspaceMapping(PageDir);<span class="comment">//不用在访问页目录了,撤销临时映射 </span></span><br><span class="line">		PTE* pte= MmCreateHyperspaceMapping(Pfn);<span class="comment">//再临时映射二级页表本身,以便访问它 </span></span><br><span class="line">		Return pte+ADDR_TO_PTE_OFFSET(PageAddr);<span class="comment">//OK,返回那个页面的映射描述符 </span></span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	Else<span class="comment">//反之,若那个虚拟页面就在本进程的用户地址空间或公共的系统地址空间中,就直接推算页目 录的虚拟地址,免得为其创建临时映射,以提高效率 </span></span><br><span class="line">	&#123; </span><br><span class="line">		PageDir=ADDR_TO_PDE(PageAddr);<span class="comment">//直接推算的页目录的虚拟地址 </span></span><br><span class="line">		If(PageDir[PDE_IDX]==空白) </span><br><span class="line">			Return <span class="literal">NULL</span>;<span class="comment">//若整个二级页面尚未分配,返回 NULL </span></span><br><span class="line">		<span class="function">Return <span class="title">ADDR_TO_PTE</span><span class="params">(PageAddr)</span></span>;<span class="comment">//直接推算得到这个虚拟页面的映射描述符地址     </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面说过各个进程的用户地址空间是私有的,各不相同的; 内核地址空间部分则几乎完全相同</p>
<blockquote>
<p>为什么是几乎呢, 而不是全部呢？<br>那就是因为内核地址空间中,每个进程的二级页表区和临时映射区,没有映射到相同的物理页面。 </p>
</blockquote>
<p><code>MmUpdatePageDir(process, KernePagelAddr,PageCount)</code></p>
<p>每当内核地址空间中的某组页面的映射发生变化,系统就会调用这个函数将内核地址空间中从<code>KernePagelAddr</code> 开始的一组内核虚拟页面<br>从系统的公共内核页表中同步复制这些页面的 <code>PTE</code>到各个进程的对应页表中<br>这样就使得每个进程的内核页面映射都相同,落到同一个物理页面或者文件页面中。 </p>
<p>但是系统绝不会同步修改各个进程的二级页表区和临时映射区中那些虚拟页面的映射描述符<br>因为那部分虚拟页面由每个进程自己单独维护映射,各不相同。<br>也即每个进程的内核页表部分都 copy 自系统,用户页表部分各不相同。 </p>
<blockquote>
<p>综上:<code>【各个进程的用户地址空间各不相同,内核地址空间相同,但页表区、临时映射区除外】</code></p>
</blockquote>
<p><br> </p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>下面看一下普通的内存分配流程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Void*  Kernel32.VirtualAlloc(<span class="keyword">void</span>* BaseAddr, Len, AllocType, protect) </span><br><span class="line">&#123; </span><br><span class="line">	Void* addr=BaseAddr; </span><br><span class="line">	NTDLL.NtVirtualAlloc(&amp;addr, Len, AllocType, protect) </span><br><span class="line">	&#123; </span><br><span class="line">		Mov eax,服务号 </span><br><span class="line">		Lea edx,[esp+<span class="number">4</span>] <span class="comment">//记录用户区参数地址 </span></span><br><span class="line">		Sysenter </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//--------------------用户模式与内核模式分界线----------------------- </span></span><br><span class="line">		KiFastCallEntry() </span><br><span class="line">		&#123; </span><br><span class="line">		 </span><br><span class="line">			NtAllocateVirtualMemory(hCurProcess,&amp;BaseAddr, &amp;Len, AllocType, protect); </span><br><span class="line">		 </span><br><span class="line">			Sysexit </span><br><span class="line">		&#125; </span><br><span class="line">		Return status; </span><br><span class="line">	&#125; </span><br><span class="line">	Return addr; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上,应用层的这个 API 调用内核服务函数,从指定进程的用户空间中分配一块指定特征的区段,最后返回区段的地址。 </p>
<p>内核中的服务函数如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS  <span class="title">NtAllocateVirtualMemory</span><span class="params">(hProcess, <span class="keyword">void</span>** BaseAddr, <span class="keyword">int</span>* Len, AllocType, protect)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	If(参数不合法)<span class="comment">//一般 SST 中的内核服务函数入口处都会对用户空间传下来的参数进行合法性检查 </span></span><br><span class="line">		Return fail; </span><br><span class="line">	</span><br><span class="line">	*BaseAddr=Align(*BaseAddr,<span class="number">64</span>kb); </span><br><span class="line">	*Len=Align(*Len,<span class="number">4</span>kb); </span><br><span class="line">	</span><br><span class="line">	EPROCESS* process;<span class="comment">//该进程对象的内核结构 </span></span><br><span class="line">	ObReferenceObjectByHandle(hProcess,PROCESS_VM_OPERATION,UserMode,&amp;process,„)<span class="comment">//获得对象 </span></span><br><span class="line">	</span><br><span class="line">	Type=(AllocType &amp; MEM_COMMIT)?MEM_COMMIT:MEM_RESERVE;<span class="comment">//提交型分配或预定型分配 </span></span><br><span class="line">	MADDRESS_SPACE* As = process-&gt;VadRoot;<span class="comment">//VadRoot 表示该进程的用户地址空间 </span></span><br><span class="line">	</span><br><span class="line">	If(*BaseAddr!=<span class="literal">NULL</span>)<span class="comment">//if 用户给定了分配的起始地址,必须从那儿分配 </span></span><br><span class="line">	&#123; </span><br><span class="line">		MEMORY_AREA* Area=MmLocateMemoryAreaByAddress(As,*BaseAddr); </span><br><span class="line">		</span><br><span class="line">		If(Area!=<span class="literal">NULL</span>)<span class="comment">//如果该地址落在事先已经分配的某个区段中 </span></span><br><span class="line">		&#123; </span><br><span class="line">			AreaLen=Area-&gt;EndAddress – Area-&gt;StartingAddress; </span><br><span class="line">			<span class="comment">//如果用户要求分配的这块区域完全落在那个已分配区段中,就修改分配类型、保护属性 </span></span><br><span class="line">			<span class="comment">//然后调用 AlterFunc 执行合并、拆分、修改页面映射等相关工作 </span></span><br><span class="line">			If(AreaLen &gt;= *Len)  </span><br><span class="line">			&#123; </span><br><span class="line">				MmAlterRegion(As,Area-&gt;StratingAddr, Area-&gt;区块链表, *BaseAddr,*Len,Type,protect AlterFunc=MmModifyAttributes); </span><br><span class="line">				Return succ; </span><br><span class="line">			&#125; </span><br><span class="line">			Else </span><br><span class="line">				Return fail; </span><br><span class="line">		&#125;<span class="comment">//end If(Area!=NULL) </span></span><br><span class="line">	&#125;<span class="comment">//end if(*BaseAddr!=NULL) </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//若用户没指定地址,或者即使指定了地址,但那个地址尚未落入任何已分配区段中,就分配区段 </span></span><br><span class="line">	MmCreateMemoryArea(As,普通型区段,BaseAddr,Len,protect,„); </span><br><span class="line">	MmInitializeRegion(Area);<span class="comment">//每个区段初始分配时,内部就初始化为:包含一个区块。 </span></span><br><span class="line">	Return succ;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意上面函数分配的区段尚未建立映射,既没有映射到物理内存,也没有映射到页文件<br>但是该区段已经分配,会被记录到地址空间的已分配区段表中(AVL树)<br>由于尚未映射,此时该区段中各个页面的 PTE 映射描述符是空的,cpu一访问这个页面就会引发缺页异常 </p>
<p><br></p>
<h2 id="页面访问异常"><a href="#页面访问异常" class="headerlink" title="页面访问异常"></a>页面访问异常</h2><p>当 cpu 访问一个虚拟页面时,如果</p>
<ul>
<li>1、 该虚拟页面尚未映射到物理页面,触发典型的<code>0x0e</code>号缺页异常 </li>
<li>2、 该虚拟页面映射着了某个物理页面,但是读写访问权限不匹配,触发<code>0x0e</code>越权异常 不管是缺页异常还是越权异常,都叫页面访问异常。</li>
</ul>
<p>一旦发生异常,cpu 自动从当前 cpu 的<code>IDT[异常号]</code>位置找到对应的异常处理函数(简称 epr<br>epr 最终将调用<code>MmAccessFault</code>函数处理该异常<br>注意发生异常时,cpu还会自动把具体的异常原因号(非异常号)压入内核栈帧中,然后跳转到对应的epr<br>该epr是<code>_KiTrap14</code>函数,该epr在内部构造好异常Trap帧后(也即保存寄存器现场)<br>Jmp到<code>KiTrap0EHandler</code>异常处理函数,这个函数从CR2寄存器读取发生异常的内存单元地址,然后调用下面的函数 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">	… </span><br><span class="line">	<span class="comment">//异常码的最低位表示是因缺页引起的异常还是写保护引起的异常 </span></span><br><span class="line">	Status = MmAccessFault(TrapFrame-&gt;ErrCode &amp; <span class="number">1</span>, Cr2,TrapFrame-&gt;SegCs &amp; MODE_MASK, TrapFrame); </span><br><span class="line">	… </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS  <span class="title">MmAccessFault</span><span class="params">(<span class="keyword">bool</span> bProtect, MemoryAddr, Mode, <span class="keyword">void</span>* TrapInfo)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	If(bProtect) </span><br><span class="line">		<span class="function">Return <span class="title">MmpAccessFault</span><span class="params">(Mode, MemoryAddr, TrapInfo?TRUE:FALSE)</span></span>; </span><br><span class="line">	Else </span><br><span class="line">		<span class="function">Return <span class="title">MmNotPresentFault</span><span class="params">(Mode, MemoryAddr, TrapInfo?TRUE:FALSE)</span></span>;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bProtect</code>表示是越权引起的异常还是缺页引起的异常, <code>MemoryAddr</code>表示访问的内存单元地址, <code>Mode</code>表示该指令位于哪个模式空间 </p>
<h3 id="缺页异常处理"><a href="#缺页异常处理" class="headerlink" title="缺页异常处理"></a>缺页异常处理</h3><p>看缺页异常是怎么处理的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MmNotPresentFault</span><span class="params">(Mode, Address)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	MADDRESS_SPACE AddressSpace; </span><br><span class="line">	If(Mode==KernelMode) </span><br><span class="line">		AddressSpace =MmGetKernelAddressSpace(); </span><br><span class="line">	Else </span><br><span class="line">		AddressSpace =当前进程的用户地址空间; </span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">	&#123; </span><br><span class="line">		MemoryArea = MmLocateMemoryAreaByAddress(AddressSpace, Address); </span><br><span class="line">		<span class="comment">//如果一个页面尚未映射,那么它的PTE==0,这种情况引发缺页异常</span></span><br><span class="line">		<span class="comment">// 如果该地址落在了一个已经分配的区段中,那么MemoryArea不会为NULL,否则MemoryArea为NULL。</span></span><br><span class="line">		<span class="comment">// 如果既未建立映射也未分配, 就不会进行缺页置换处理,而是直接返回失败,抛出Win32异常,通知上层应用程序去处理 。</span></span><br><span class="line">		<span class="comment">// 相反如果已经分配过了,并且分配类型是commit,就由系统自己进行缺页处理,调入页面。 </span></span><br><span class="line">		<span class="keyword">if</span> (MemoryArea == <span class="literal">NULL</span> || MemoryArea-&gt;DeleteInProgress) </span><br><span class="line">		<span class="keyword">return</span> (STATUS_ACCESS_VIOLATION); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (MemoryArea-&gt;Type) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">case</span> MEMORY_AREA_PAGED_POOL:<span class="comment">//分页池中的区段 </span></span><br><span class="line">				Status = MmCommitPagedPoolAddress(Address); </span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">case</span> MEMORY_AREA_SECTION_VIEW:<span class="comment">//视图型区段 </span></span><br><span class="line">				Status = MmNotPresentFaultSectionView(AddressSpace,MemoryArea,Address); </span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> MEMORY_AREA_VIRTUAL_MEMORY:<span class="comment">//普通型区段 </span></span><br><span class="line">				Status = MmNotPresentFaultVirtualMemory(AddressSpace,MemoryArea,Address); </span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;<span class="keyword">while</span> (Status == STATUS_MM_RESTART_OPERATION); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上只有这几种区段中的页面才有可能被置换到外存去,各种类型的区段的缺页处理都不同,我们看典型的普通型区段的缺页处理;</p>
<h4 id="缺页-页换入"><a href="#缺页-页换入" class="headerlink" title="缺页-页换入"></a>缺页-页换入</h4><blockquote>
<p>以下是普通型区段的换入</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   NTSTATUS  </span><br><span class="line">MmNotPresentFaultVirtualMemory(AddressSpace,MemoryArea,Address) </span><br><span class="line">&#123; </span><br><span class="line">	NTSTATUS win32ExcepCode;<span class="comment">//由 cpu 异常码转换后的 win32 异常码 </span></span><br><span class="line">	Region=MmFindRegion(MemoryArea-&gt;StratinngAddress, MemoryArea-&gt;区块链表,Address); </span><br><span class="line">	If(Region-&gt;Type==MEM_RESERVE || Region-&gt;Protect == PAGE_NO_ACCESS) </span><br><span class="line">	&#123; </span><br><span class="line">		win32ExcepCode==STATUS_ACCESS_VIOLATION; </span><br><span class="line">		<span class="keyword">return</span> win32ExcepCode; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	If(当前正有其他线程在处理这个页面异常,正在做置换工作) </span><br><span class="line">		等待那个线程处理完缺页异常,<span class="keyword">return</span> succ; </span><br><span class="line">	MmRequestPageMemoryConsumer(USER,&amp;pfn);<span class="comment">//分配一个空闲物理页面 </span></span><br><span class="line">	If(MmIsPageSwapEntry(Address))<span class="comment">//if 这个虚拟地址所在的虚拟页面映射到了外存 </span></span><br><span class="line">	&#123; </span><br><span class="line">	MmDeletePageFileMapping(Address,&amp;SwapEntry);<span class="comment">//返回原映射的那个外存页面,然后删除原映射 </span></span><br><span class="line">	MmReadFromSwapPage();<span class="comment">//将外存页面读入新分配的物理页面中 </span></span><br><span class="line">	Pfn.SavedSwapEntry=SwapEntry;<span class="comment">//记录本物理页面,当初是从这个页文件调入的 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//创建映射,将该虚拟页面改映射到新分配的物理页面 </span></span><br><span class="line">	MmCreateVirtualMapping(AddressSpace-&gt;process, Address, Region-&gt;Protect, &amp;pfn 数组,<span class="number">1</span> 个元素) </span><br><span class="line">	<span class="comment">//将这个虚拟页面插入那个物理页面的映射链表中(多个虚拟页面可映射到同一物理页面) </span></span><br><span class="line">	MmInsertRmap(pfn, AddressSpace-&gt;process,Align(Address,<span class="number">4</span>kb)); Return succ; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">NTSTATUS <span class="title">MmReadFromSwapEntry</span><span class="params">(SwapEntry,pfn)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   MDL mdl; </span><br><span class="line">   … </span><br><span class="line">   MmBuildMdlFromPages(mdl,pfn);<span class="comment">//将物理页面 pfn 映射到系统的 mdl 映射区中 </span></span><br><span class="line">   FileNo=SwapEntry.FileNo; </span><br><span class="line">   FileOffset=SwapEntry.PageNo * <span class="number">4</span>kb; </span><br><span class="line">   <span class="comment">//这个函数内部会构造一个分页读 irp 发往文件系统,最后发给磁盘驱动,读入页文件中对应的页面 </span></span><br><span class="line">   Status=IoPageRead(PagingFileList[FileNo]-&gt;FileObject, FileOffset,mdl,…);<span class="comment">//读入到物理页面 </span></span><br><span class="line">   <span class="keyword">if</span> (Status == STATUS_PENDING) </span><br><span class="line">   &#123; </span><br><span class="line">      KeWaitForSingleObject(&amp;Event, Executive, KernelMode, FALSE, </span><br><span class="line">      	<span class="literal">NULL</span> <span class="comment">//看到没,Timeout参数=NULL,表示一直等到磁盘页面读入完成 </span></span><br><span class="line">      	); </span><br><span class="line">      Status = Iosb.Status; </span><br><span class="line">   &#125; </span><br><span class="line">   … </span><br><span class="line">   Return status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于涉及到磁盘 I/O,因此置换过程有点耗时！<br>频繁的缺页异常往往会造成系统性能瓶颈,这就是时间换空间带来的副作用。 </p>
<p>另外:由于<code>MmReadFromSwapEntry</code>这个函数会在内部调用<code>KeWaitForSingleObject</code>一直等到页面读入到内存后才返回原处继续执行。<br>但是<code>KeWaitForSingleObject</code>这个函数,如果是要等待的话,只能运行在<code>DISPATCH_LEVEL</code> irql以下,否则蓝屏。</p>
<p>这就是为什么在<code>DISPATCH_LEVEL</code>及其以上 irql 时,千万不能访问分页内存。<br>因为分页内存可能在磁盘中,这样一触发缺页中断<br>在这个 irql 尝试去读取磁盘页面时,就会因为 KeWaitForSingleObject 的问题而崩溃。 </p>
<p><code>【换言之根源是 DISPATCH 中断级的代码不能调用 KeWaitForSingleObject 等待任意对象】</code></p>
<p>下面引自 DDK 原话:<code>“Callers of KeWaitForSingleObject must be running at IRQL &lt;= DISPATCH_LEVEL. However, if Timeout = NULL or *Timeout != 0, the caller must be running at IRQL &lt;= APC_LEVEL and in a nonarbitrary thread context.”</code><br>看到没只有在<code>Timeout ！= NULL &amp;&amp; *Timeout==0</code>的情况下,才可以在<code>DISPATCH_LEVEL</code>等待 </p>
<hr>

<h4 id="缺页-页换出"><a href="#缺页-页换出" class="headerlink" title="缺页-页换出"></a>缺页-页换出</h4><p>每当一个消费者持有的物理页面数量超过自身配额,消费者会主动自我修剪一部分物理页面,置换到外存。</p>
<p>每当系统总体空闲物理内存紧张时(即小于最低空闲页数阀值也即 64 个页面时)<br>内核中的那个平衡线程也会强制修剪某些物理页面,置换到外存,以腾出一个物理页面出来。<br>注意并不是物理内存完全耗尽后才开始发生置换操作,而是物理内存快要用完(小于 64 个页面)时,系统就开始着手置换操作了。 </p>
<p>下面是置换函数原理<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS  <span class="title">MmPageOutVirtualMemory</span><span class="params">(MADDRESS_SPACE* as,  MEMORY_AREA* Area, PageAddr)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PTE* pt= MmGetPageTableForProcess(process, CurPageAddr);<span class="comment">//找到这个页面的 pte 位置 </span></span><br><span class="line">	PTE pte=*pt; </span><br><span class="line"></span><br><span class="line">	PFN pfn=pte.pfn; </span><br><span class="line">	SavedSwapEntry = pfn.SavedSwapEntry; </span><br><span class="line">	If(pte.bDirty == <span class="literal">false</span>)<span class="comment">//如果该页面未脏,那好办 </span></span><br><span class="line">	&#123; </span><br><span class="line">		MmDeleteVirtualMapping(as.process, PageAddr, „);<span class="comment">//删除该虚拟页面对应的原 PTE </span></span><br><span class="line">		If(SavedSwapEntry != <span class="number">0</span> )<span class="comment">//if 该物理页面是从页文件调入的,就直接使用那个页文件 </span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">//将该虚拟页面对应的 PTE 重定向映射到原先的页文件中的那个页面 </span></span><br><span class="line">			MmCreatePageFileMapping(as.process, PageAddr, SavedSwapEntry); </span><br><span class="line">			Pfn.SavedSwapEntry = <span class="number">0</span>; </span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">		MmReleasePageMemoryConsumer(USER, pfn);<span class="comment">//既然换到外存了,那就释放物理页面变成空闲状态 </span></span><br><span class="line">		Return succ; </span><br><span class="line">	&#125; </span><br><span class="line">	Else<span class="comment">//如果已经脏了,工作有点多 </span></span><br><span class="line">	&#123; </span><br><span class="line">		If(SavedSwapEntry == <span class="number">0</span> )<span class="comment">//if 该物理页面是从页文件调入的,就直接使用那个页文件 </span></span><br><span class="line">			NewSwapEntry= MmAllocSwapPage();<span class="comment">//从磁盘上的页文件中分配一个文件页面 </span></span><br><span class="line">		Else </span><br><span class="line">			NewSwapEntry= SavedSwapEntry;<span class="comment">//沿用原来的页文件页面 </span></span><br><span class="line">		</span><br><span class="line">		MmWriteToSwapPage(pfn ---&gt; NewSwapEntry);<span class="comment">//以分页写 irp 的形式将物理页面内容写入外存页面 </span></span><br><span class="line">		MmDeleteVirtualMapping(as.process, PageAddr, „);<span class="comment">//删除该虚拟页面对应的原 PTE </span></span><br><span class="line">		MmCreatePageFileMapping(as.process, PageAddr, NewSwapEntry);<span class="comment">//重定向 </span></span><br><span class="line">		Pfn.SavedSwapEntry = <span class="number">0</span>; </span><br><span class="line">		MmReleasePageMemoryConsumer(USER, pfn);<span class="comment">//既然换到外存了,那就释放物理页面变成空闲状态 </span></span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>平衡线程进行的换出操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MiBalancerThread</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	WaitObjects[<span class="number">0</span>]=&amp;MiBalanceEvent; </span><br><span class="line">	WaitObjects[<span class="number">1</span>]=&amp;MiBalancerTimer; </span><br><span class="line">	Whilr(<span class="literal">true</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		Status=KeWaitForMultipleObjects(<span class="number">2</span>,WaitObjects,WaitAny,Executive,KernelMode,„); </span><br><span class="line">		If(status==STATUS_SUCCESS)<span class="comment">//如果收到了内核发来的一个平衡请求 </span></span><br><span class="line">		&#123; </span><br><span class="line">			While(系统总空闲页数 &lt; 阀值+<span class="number">5</span>) </span><br><span class="line">			调用各个消费者的修剪函数; </span><br><span class="line">		&#125; </span><br><span class="line">		Else<span class="comment">//定时醒来 </span></span><br><span class="line">		&#123; </span><br><span class="line"></span><br><span class="line">			For(遍历每个消费者) </span><br><span class="line">			&#123; </span><br><span class="line">				If(该消费者占有的物理页数是否超过了自己的配额 || 系统空闲物理页数小于了阀值) 调用它的修剪函数;  </span><br><span class="line">			&#125;   </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统中整个分四大消费者:文件缓冲,用户空间,内核分页池,内核非分页池 </p>
<p>看下典型的 User 消费者是如何修剪自己的物理页面的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS  <span class="title">MmTrimUserMemory</span><span class="params">(ToTrimPageCount, ULONG* ActualTrimPageCount)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	*ActualTrimPageCount=<span class="number">0</span>; </span><br><span class="line">	Pfn=MmGetLRUFirstUserPage();<span class="comment">//根据 LRU 算法找到要换出去的物理页面 </span></span><br><span class="line"></span><br><span class="line">	While(pfn!=<span class="number">0</span> &amp;&amp; ToTrimPageCount&gt;<span class="number">0</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		MmPageOutPhysicalAddress(pfn);<span class="comment">//换出去 </span></span><br><span class="line">		*ActualTrimPageCount++; </span><br><span class="line">		Pfn=MmGetLRUNextUserPage(pfn);<span class="comment">//获得下一个要换出去的物理页面 </span></span><br><span class="line">	&#125; </span><br><span class="line">	Return succ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>置换算法是 LRU,最近以来最少被访问到的物理页面优先换出去。讲述操作系统原理的书籍一般都有介绍,在此不解释。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MmPageOutPhysicalAddress</span><span class="params">(pfn)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//获得第一个映射到本物理页面的虚拟页面 </span></span><br><span class="line">	FirstEntry=MmGetRmapListHeadPage(pfn); </span><br><span class="line">	Process=FirstEntry-&gt;process; </span><br><span class="line">	PageAddr=FirstEntry-&gt;address; </span><br><span class="line">	</span><br><span class="line">	If(PageAddr&gt;<span class="number">2</span>GB) </span><br><span class="line">		AddressSpace=内核地址空间; </span><br><span class="line">	Else </span><br><span class="line">		AddressSpace=process-&gt;VadRoot;<span class="comment">//目标进程的用户空间 </span></span><br><span class="line">	</span><br><span class="line">	MemoryArea = MmLocateMemoryAreaByAddress(AddressSpace, PageAddr); </span><br><span class="line">	If(MemoryArea-&gt;Type == 视图型区段)<span class="comment">//表示 if 这个物理页面是一个共享页面,被多个进程映射共享 </span></span><br><span class="line">	&#123; </span><br><span class="line">		遍历 pfn.映射链表,一一处理;<span class="comment">//特别处理</span></span><br><span class="line">		Return succ;  </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function">Else <span class="title">if</span><span class="params">(MemoryArea-&gt;Type == 普通型区段)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		MmPageOutVirtualMemory(„); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="内存映射文件与共享物理内存"><a href="#内存映射文件与共享物理内存" class="headerlink" title="内存映射文件与共享物理内存"></a>内存映射文件与共享物理内存</h2><p>相信编写过应用程序的朋友都知道“内存映射文件”一说。<br>简单地讲内存映射文件就是把磁盘上的文件当做物理内存使用。</p>
<p>这样要读写文件时, 不用再原始地调用<code>ReadFile</code>,<code>WriteFile</code>函数读写文件。<br>可以直接把文件映射到虚拟内存,然后直接读写虚拟内存即可对文件进行读写。</p>
<p>当一个文件映射到虚拟内存后,一读写对应的虚拟内存,势必引发缺页异常<br>系统的缺页异常处理函数自动处理,把文件页面调入读入物理内存。<br>这样就间接地对文件进行了 IO。 </p>
<p>除了普通的纯数据文件可以映射到内存外,exe、dll 等可执行文件和磁盘中的页文件也是以内存映射文件的方式进行访问的。<br>应用层的<code>CreateFileMapping</code>这个 API 就是专用来创建文件映射用的。</p>
<blockquote>
<p>除此之外,两个进程也可以共享物理内存,只要把同一个物理页面映射到这两个进程的地址空间即可<br>物理内存共享也是靠内存映射文件机制实现的,只不过映射的不是普通磁盘文件,而是页文件。</p>
</blockquote>
<h3 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h3><p>内核相关结构定义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Struct ROS_SECTION_OBJECT</span><br><span class="line">&#123;</span><br><span class="line">	CSHORT    type;<span class="comment">//本结构体的类型</span></span><br><span class="line">	CSHORT    size;<span class="comment">//本结构体的实际长度(结构体后面经常可以衔接其他数据,size 包含了那部分的长度)</span></span><br><span class="line">	ULONG    protect;<span class="comment">//本 section 的保护权限</span></span><br><span class="line">	ULONGLONG   MaxSize;<span class="comment">//本 section 的最大长度</span></span><br><span class="line">	ULONG   AllocationAttributes;<span class="comment">//包含了本 section 的文件类型</span></span><br><span class="line">	FILE_OBJECT*    FileObject;<span class="comment">//创建本 section 的那个文件对象(文件句柄)</span></span><br><span class="line">	Union</span><br><span class="line">	&#123;</span><br><span class="line">		MM_SECTION_SEGMENT* Segment;<span class="comment">//数据文件 section 中的唯一 segment </span></span><br><span class="line">		MM_IMAGE_SECTION_OBJECT*   ImageSegments;<span class="comment">//镜像文件中的 Segment 数组</span></span><br><span class="line">	&#125; section;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如上普通数据文件<code>section</code>内部就包含一个<code>segment</code><br>可执行镜像文件(统称 PE 文件)<code>section</code>中一般包含多个<code>segment</code><br>对应 PE 文件中的每个<code>“节”</code>, 如<code>.TEXT</code>节, <code>.DATA</code>节,<code>.RSRC</code>节</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MM_IMAGE_SECTION_OBJECT</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    ULONG_PTR ImageBase; </span><br><span class="line">    ULONG_PTR StackReserve; </span><br><span class="line">    ULONG_PTR StackCommit; </span><br><span class="line">    ULONG_PTR EntryPoint; </span><br><span class="line">    USHORT Subsystem; </span><br><span class="line">    USHORT ImageCharacteristics; </span><br><span class="line">    USHORT MinorSubsystemVersion; </span><br><span class="line">    USHORT MajorSubsystemVersion; </span><br><span class="line">    USHORT Machine; </span><br><span class="line"> </span><br><span class="line">    BOOLEAN Executable; </span><br><span class="line">    ULONG NrSegments;<span class="comment">// 本ImageSection中的segment个数,也即"节’个数 </span></span><br><span class="line">    ULONG ImageSize; </span><br><span class="line">    PMM_SECTION_SEGMENT Segments;<span class="comment">//本ImageSection中的segment数组 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考《Windows    PE 权威指南》一书<br>PE 文件头的节表区中每个节的格式定义为</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Struct    PE_SEGMENT</span><br><span class="line">&#123;</span><br><span class="line">	BYTE    Name[IMAGE_SIZEOF_SHORT_NAME=<span class="number">8</span>]; <span class="comment">//8 个字节的节名 如".text"	".rdata"	".data" </span></span><br><span class="line">	DWORD VirtualSize;<span class="comment">//该节未对齐前的原始数据大小  </span></span><br><span class="line">	DWORD VirtualAddress; <span class="comment">//该节的 RVA DWORD    </span></span><br><span class="line">	SizeOfRawData;    <span class="comment">//该节的 FAS 也即文件对齐大小,一般指对齐 512B 后的大小</span></span><br><span class="line">	DWORD 	PointerToRawData; <span class="comment">//该节的 FOA,即文件偏移 DWORD    </span></span><br><span class="line">	PointerToRelocations; <span class="comment">//专用于 obj 文件 DWORD    </span></span><br><span class="line">	PointerToLinenumbers; <span class="comment">//用于调试</span></span><br><span class="line">	WORD	NumberOfRelocations;	<span class="comment">//专用于 obj 文件</span></span><br><span class="line">	WORD	NumberOfLinenumbers;	<span class="comment">//用于调试</span></span><br><span class="line">	DWORD   Characteristics;    <span class="comment">//该节的属性(可读、可写、可执行、可共享、可丢弃、可分页等属性)</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>
<p>每个节的 Characteristics 的特征属性包括下面几个:</p>
<ul>
<li>IMAGE_SCN_CNT_CODE    该节中包含有代码 如.text </li>
<li>IMAGE_SCN_CNT_INITIALIZED_DATA    该节中包含有已初始化的数据 如.data </li>
<li>IMAGE_SCN_CNT_UNINITIALIZED_DATA   该节中包含有尚未初始化的数据,如.bss .data?</li>
<li>IMAGE_SCN_MEM_DISCARDABLE 该节加载到内存后是可抛弃的,如 dll 中的.reloc 重定位节就是可以抛弃的</li>
<li>IMAGE_SCN_MEM_NOT_CACHED    节中数据不会经过缓冲</li>
<li>IMAGE_SCN_MEM_NOT_PAGED    该节不准交换到页文件中,sys 文件中的节(除.page)都不可换出</li>
<li>IMAGE_SCN_MEM_SHARED 这个节可以被多个进程共享,如 dll 中的共享节。也即表示本节是否允许写复 制。(默认允许)</li>
<li>IMAGE_SCN_MEM_EXECUTE 本节可执行 IMAGE_SCN_MEM_READ 本节可读 IMAGE_SCN_MEM_WRITE  本节可写</li>
</ul>
<p>在内核中,每个节的结构体定义则如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Struct    MM_SECTION_SEGMENT</span><br><span class="line">&#123;</span><br><span class="line">	LONG	FileOffset;<span class="comment">//foa</span></span><br><span class="line">	ULONG 	VirtualAddress;<span class="comment">//其实是相对虚拟地址偏移 rva,不是 va </span></span><br><span class="line">	ULONG   RawLength;<span class="comment">//本节在文件中的原始实际长度</span></span><br><span class="line">	ULONG 	Length;<span class="comment">//本节对齐后的长度(一般指对齐 4KB) </span></span><br><span class="line">	ULONG 	protect;<span class="comment">//可读、可写、可执行这些保护属性 </span></span><br><span class="line">	ULONG   ReferenceCount;</span><br><span class="line">	SECTION_PAGE_DIRECTORY PageDir;<span class="comment">//本节内部的页表,后文有详说 ULONG    Flags;</span></span><br><span class="line">	 </span><br><span class="line">	ULONG   Characteristics;</span><br><span class="line">	BOOL	WriteCopy;<span class="comment">//本节是否写复制,pe 文件中一般为 TRUE,数据文件中一般为 FALSE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Api流程"><a href="#Api流程" class="headerlink" title="Api流程"></a>Api流程</h3><h4 id="创建section"><a href="#创建section" class="headerlink" title="创建section"></a>创建section</h4><blockquote>
<p>要使用内存映射文件, 首先需要创建一个公共的<code>“文件 section”</code>(section 是一种内核对象)<br>以后谁要访问这个文件,映射这个文件 section 就可以了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">NtCreateSection</span><span class="params">(hFile, HANDLE*    hSection,    DesiredAccess, ObjectAttribute,    MaxSize,    protect,    AllocAttr,)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	If(ExGetPreviousMode() == UserMode)</span><br><span class="line">	基本参数检查;</span><br><span class="line">	</span><br><span class="line">	ROS_SECTION_OBJEC*    SectionObject;</span><br><span class="line">	<span class="comment">//ReactOS 中 SECTION 对象结构体的定义,与 Windows 中有差别</span></span><br><span class="line">	<span class="comment">//为指定文件创建一个 section 对象</span></span><br><span class="line">	</span><br><span class="line">	MmCreateSection(hFile, &amp;SectionObject , DesiredAccess, ObjectAttribute, MaxSize, protect, AllocAttr); </span><br><span class="line">	ObInsertObject(SectionObject, …, hSection);<span class="comment">//将对象插入对象目录和句柄表,返回它的句柄在 hSection 中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MmCreateSection</span><span class="params">(hFile,   ROS_SECTION_OBJEC**   SectionObject  ,	DesiredAccess,  ObjectAttribute,	MaxSize, protect,    AllocAttr,)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	If(AllocAttr    &amp;    SEC_IMAGE)</span><br><span class="line">		<span class="comment">//if    用户给定的 hFile 是一个可执行镜像文件</span></span><br><span class="line">		<span class="function">Return <span class="title">MmCreateImageSection</span><span class="params">(hFile,SectionObject, DesiredAccess, ObjectAttribute, MaxSize, … )</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	<span class="title">If</span><span class="params">(hFile!=<span class="literal">NULL</span>)</span><span class="comment">//创建普通数据文件 section</span></span></span><br><span class="line"><span class="function">		Return <span class="title">MmCreateDataFileSection</span><span class="params">(hFile,SectionObject, DesiredAccess, ObjectAttribute, MaxSize, … )</span></span>; </span><br><span class="line">	Else<span class="comment">//用户没给给定文件,说明是要创建一段多进程共享的物理内存</span></span><br><span class="line">		<span class="function">Return <span class="title">MmCreatePageFileSection</span><span class="params">(hFile,SectionObject, DesiredAccess, ObjectAttribute, MaxSize, … )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上这个函数可以创建三种文件 section<br>其中若是要创建共享物理内存,就创建页文件 section, 共享物理内存起初是在页文件中的。</p>
<p>可执行文件的 section 创建过程比较繁琐,涉及逐个逐个字段解析文件头,虽然繁杂但是过程简单<br>在此不详述,更多内容参考《Windows PE 权威指南》<br>看一下普通数据文件 section 的创建过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MmCreateDataFileSection</span><span class="params">(hFile,SectionObject, DesiredAccess, ObjectAttribute, MaxSize, protect, AllocAttr )</span></span>;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">	FILE_OBJECT* FileObject; MM_SECTION_SEGMENT * Segment; ROS_SECTION_OBJECT* Section;</span><br><span class="line">	<span class="comment">//创建一个 section 内核对象,返回指针在 Section 中</span></span><br><span class="line">	ObCreateObject(MmSectionObjectType, ObjectAttribute,    <span class="keyword">sizeof</span>(ROS_SECTION_OBJECT),    &amp;Section,   …);</span><br><span class="line">	</span><br><span class="line">	*SectionObject = Section; Section-&gt;protect=protect;</span><br><span class="line">	Section-&gt;AllocateAttribute=AllocAttr;</span><br><span class="line">	ObreferenceObjectByHandle(hFile, IoFileObjecType, &amp;FileObject);<span class="comment">//从文件句柄得到对应的文件对象 </span></span><br><span class="line">	</span><br><span class="line">	If(MaxSize==<span class="number">0</span>)</span><br><span class="line">		MaxSize=GeFileLen(FileObject);<span class="comment">//0 就表示采用默认的文件大小,使用整个文件</span></span><br><span class="line">	</span><br><span class="line">	If(MaxSize&gt; GeFileLen(FileObject))</span><br><span class="line">		<span class="comment">//增长磁盘文件的大小</span></span><br><span class="line">		Segment = ExAllocatePool(NonPagePool, <span class="keyword">sizeof</span>(MM_SECTION_SEGMENT)); </span><br><span class="line">		Segment-&gt;ReferenceCount=<span class="number">1</span>;</span><br><span class="line">		Segment-&gt;FileOffset=<span class="number">0</span>; </span><br><span class="line">		Segment-&gt;protect=protect;</span><br><span class="line">		Segment-&gt;Flags=MM_DATAFILE_SEGMENT;<span class="comment">//标志这是普通数据文件中的一个 segment</span></span><br><span class="line">		Segment-&gt;WriteCopy=FALSE;<span class="comment">//数据文件的 segment 默认不是写复制的,这点与 pe 文件不同</span></span><br><span class="line">		Segment-&gt;RawLength=MaxSize;</span><br><span class="line">		Segment-&gt;Length=Align4kb(MaxSize); </span><br><span class="line">		Segment-&gt;VirtualAddress=<span class="number">0</span>;<span class="comment">//指 rva=0</span></span><br><span class="line">		Section-&gt;segment=segment;<span class="comment">//普通数据文件就一个 segment,而且整个文件就是一个 segment </span></span><br><span class="line">		Section-&gt;MaxSize=MaxSize;<span class="comment">//记录本 section 对象的长度</span></span><br><span class="line">		Section-&gt;Fileobject=Fileobject;<span class="comment">//记录本 section 是由哪个文件对象创建的</span></span><br><span class="line">		FileObject-&gt;SectionObjectPointer-&gt;DataSectionObject = segment; </span><br><span class="line">	Return	succ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="映射section"><a href="#映射section" class="headerlink" title="映射section"></a>映射section</h4><p>创建好了 section 对象后,就可以让任意进程拿去映射了,不过映射是以视图为单位进行的 </p>
<blockquote>
<p>【section, segment, 视图, 页面】,这是这四者之间的层级关系请牢记</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtMapViewOfSection</span><span class="params">(hSection, ViewOffset, ViewSize,	AllocType, protect,    hProcess, <span class="keyword">void</span>** BaseAddr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PreviousMode=ExGetPreviousMode(); </span><br><span class="line">	If(PreviousMode == UserMode)</span><br><span class="line">		参数检查；</span><br><span class="line">	ViewOffset=Align4kb(ViewOffset); </span><br><span class="line">	ViewSize=Align4kb(ViewSize);</span><br><span class="line">	ObReferenceObjectByHandle(hSection---&gt; Section);<span class="comment">//获得对应的对象</span></span><br><span class="line">	MmMapViewOfSection(Section, ViewOffset,ViewSize, AllocType, protect, hProcess, <span class="keyword">void</span>** BaseAddr );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function">NTSTATUS <span class="title">NtMapViewOfSection</span><span class="params">(Section, ViewOffset, ViewSize,	AllocType, protect,    hProcess, <span class="keyword">void</span>** BaseAddr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	AddressSpace=process-&gt;VadRoot;<span class="comment">//那个进程的用户地址空间</span></span><br><span class="line">	<span class="comment">// 若是 PE 文件的 section,则加载映射文件中的每个 segment</span></span><br><span class="line">	<span class="comment">// 注意此时的 ViewOffset 和 ViewSize 参数不 起作用,将自动把每个完整 segment 当做一个视图来映射。</span></span><br><span class="line">	If(Section-&gt;AllocationAttribute    &amp;    SEC_IMAGE)</span><br><span class="line">	&#123;</span><br><span class="line">		ULONG i; </span><br><span class="line">		ULONG NrSegments; </span><br><span class="line">		ULONG_PTR ImageBase; </span><br><span class="line">		ULONG ImageSize; </span><br><span class="line">		PMM_IMAGE_SECTION_OBJECT ImageSectionObject; </span><br><span class="line">		PMM_SECTION_SEGMENT SectionSegments; </span><br><span class="line"></span><br><span class="line">		ImageSectionObject = Section-&gt;ImageSection; </span><br><span class="line">		SectionSegments = ImageSectionObject-&gt;Segments;<span class="comment">//节数组 </span></span><br><span class="line">		NrSegments = ImageSectionObject-&gt;NrSegments;<span class="comment">//该pe文件中的节数 </span></span><br><span class="line">		ImageBase = (ULONG_PTR)*BaseAddress; </span><br><span class="line">		<span class="keyword">if</span> (ImageBase == <span class="number">0</span>) </span><br><span class="line">			ImageBase = ImageSectionObject-&gt;ImageBase; </span><br><span class="line">		ImageSize = <span class="number">0</span>; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//下面的循环遍历该pe文件中所有需要加载的节,计算所有节的大小总和 </span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NrSegments; i++) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> (!(SectionSegments[i].Characteristics &amp; IMAGE_SCN_TYPE_NOLOAD))<span class="comment">//所需要加载这个节 </span></span><br><span class="line">			&#123; </span><br><span class="line">				ULONG_PTR MaxExtent; </span><br><span class="line">				<span class="comment">//该节的rva+该节的对齐4KB长度 </span></span><br><span class="line">				MaxExtent=SectionSegments[i].VirtualAddress + SectionSegments[i].Length; </span><br><span class="line">				ImageSize = max(ImageSize, MaxExtent); </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">		ImageSectionObject-&gt;ImageSize = ImageSize; </span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果该pe文件期望加载的区域中有任何一个地方被占用了,重定位,dll文件一般都会重定位 </span></span><br><span class="line">		<span class="keyword">if</span> (MmLocateMemoryAreaByRegion(AddressSpace, ImageBase,PAGE_ROUND_UP(ImageSize))) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> ((*BaseAddress) != <span class="literal">NULL</span>)<span class="comment">//如果用户的要求是必须加载到预期地址处,返回失败！ </span></span><br><span class="line">			<span class="keyword">return</span>(STATUS_UNSUCCESSFUL); </span><br><span class="line">			ImageBase = MmFindGap(AddressSpace, ImageSize, PAGE_SIZE, FALSE);<span class="comment">//重定位,找空闲区 </span></span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//一次性加载映射该pe文件中的所有节 </span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NrSegments; i++) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">//注意pe文件中有的节是不用加载的 </span></span><br><span class="line">			<span class="keyword">if</span> (!(SectionSegments[i].Characteristics &amp; IMAGE_SCN_TYPE_NOLOAD)) </span><br><span class="line">			&#123; </span><br><span class="line">				PVOID SBaseAddress =  ((<span class="keyword">char</span>*)ImageBase + (SectionSegments[i].VirtualAddress); </span><br><span class="line">				<span class="comment">//把该节整体当做一个view进行映射。由此可见,pe文件中的每个节也是一个视图型区段 </span></span><br><span class="line">				MmMapViewOfSegment(AddressSpace, </span><br><span class="line">							Section, </span><br><span class="line">							&amp;SectionSegments[i],<span class="comment">//该视图所在的第一个节 </span></span><br><span class="line">							&amp;SBaseAddress,<span class="comment">//该节的预期映射地址 </span></span><br><span class="line">							SectionSegments[i].Length,<span class="comment">//ViewSize=整个节的长度 </span></span><br><span class="line">							SectionSegments[i].Protection, </span><br><span class="line">							<span class="number">0</span>,<span class="comment">//ViewOffset=0 </span></span><br><span class="line">							<span class="number">0</span>); </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">		*BaseAddress = (PVOID)ImageBase;<span class="comment">//返回该 PE 文件实际加载映射的地址</span></span><br><span class="line">	&#125;</span><br><span class="line">	Else<span class="comment">//普通数据文件和页文件的 section,都只有一个 segment</span></span><br><span class="line">	&#123;</span><br><span class="line">		MmMapViewOfSegment(AddressSpace,	section, section-&gt;segmen, ViewOffSet, ViewSize ,</span><br><span class="line">					AllocType &amp; MEM_TOPDOWN,    protect,    hProcess,    <span class="keyword">void</span>** BaseAddr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">NTSTATUS MmMapViewOfSegment(AddressSpace, section , segment, ViewOffset, ViewSize, AllocType, protect, hProcess,<span class="keyword">void</span>** BaseAddr)</span><br><span class="line">&#123;</span><br><span class="line">	MEMORY_AREA*   Area;</span><br><span class="line">	MmCreateMemoryArea(AddressSpace, 视图型区段, BaseAddr,ViewSize, protect, AllocType, &amp;Area);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录本视图区段映射的是哪个 section 的哪个 segment 中的哪个位置</span></span><br><span class="line">	Area-&gt;Data.SectionData.Section=Section; </span><br><span class="line">	Area-&gt;Data.SectionData.Segment=segment;</span><br><span class="line">	Area-&gt;Data.SectionData.ViewOffset=ViewOffset;</span><br><span class="line">	Area-&gt;Data.SectionData..WriteCopyView=FALSE;<span class="comment">//视图型区段默认是不"写复制’的 初始化 Area 区段中的区块链表;</span></span><br><span class="line">	<span class="comment">//初始时,整个区段中就一个区块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上将文件中的的某个 segment 中的某部分视图映射到虚拟内存后<br>视图中的这些虚拟页面的初始时的 PTE 尚是空白的,Cpu 一访问视图区段中的虚拟页面,立马引发缺页异常。<br>系统的缺页异常处理函数此时就会自动将对应的那些文件页面读入内存中。</p>
<p>之前我们看过了普通型区段的缺页异常处理流程,现在是时候看一下视图型区段的缺页处理流程了</p>
<p><br></p>
<h4 id="缺页异常处理-视图型区段"><a href="#缺页异常处理-视图型区段" class="headerlink" title="缺页异常处理-视图型区段"></a>缺页异常处理-视图型区段</h4><blockquote>
<p>回顾一下</p>
</blockquote>
<p>当发生缺页异常时,将进入缺页异常处理函数,再进入<code>MmAccessFault()</code>函数,再进入<code>MmNotPresentFault</code> 函数<br>这个函数根据发生缺页的虚拟页面所在的区段类型进入现在的<code>“视图区段页面异常处理函数”</code></p>
<p>即下面的函数, 看看是怎么处理这种异常的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MmNotPresentFaultSectionView</span><span class="params">(AddressSpace,    MemoryArea,    Addr, …)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PageAddr=Align4kb(Addr);<span class="comment">//缺页内存单元所在的虚拟页面</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算这个页面在所属 segment 内的偏移</span></span><br><span class="line">	Offset = PageAddr - MemoryArea-&gt;StartingAddress + MemoryArea-&gt;Data.SectionData.ViewOffset; </span><br><span class="line">	Segment=MemoryArea-&gt;Data.SectionData.Segment;<span class="comment">//该页面所在 segment</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	If(该页面的 PTE 映射到了 页文件)<span class="comment">//还记得有一种 section 是页文件 section 吧？ </span></span><br><span class="line">		按普通页文件异常处理方式处理;<span class="comment">//前文已讲,不再赘述</span></span><br><span class="line">	Else</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//在这个 segment 内部维护的那个页面映射表中找到这个虚拟页面的映射描述符</span></span><br><span class="line">		Entry = MmGetPageEntrySectionSegment(Segment, Offset);</span><br><span class="line">		PFN    Pfn;</span><br><span class="line">		If(*Entry==<span class="number">0</span>)<span class="comment">//空白,表示既未映射到物理页面,也未映射到文件中的页面</span></span><br><span class="line">		&#123;</span><br><span class="line">			FileOffset=ConvertTo(Segment, Offset);<span class="comment">//将 segment 内的偏移转换成文件中的偏移</span></span><br><span class="line">			Pfn =  分配一个空闲物理页面;</span><br><span class="line">			MiReadPage(MemoryArea, FileOffset, pfn);<span class="comment">//读入文件中对应的页面到内存中</span></span><br><span class="line">			*Entry=Pfn;<span class="comment">//将分得的物理页面保存到这个映射描述符中,方便其他线程使用</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">Else  <span class="title">if</span><span class="params">( Entry 是一个文件页面)</span> <span class="comment">//最典型的情况</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			Entry=ConvertToSwapEntry(Entry);<span class="comment">//转换格式 </span></span><br><span class="line">			Pfn=分配一个空闲物理页面; </span><br><span class="line">			MmReadFromSwapEntry(Entry, Pfn);<span class="comment">//读入到内存</span></span><br><span class="line">			*Entry=Pfn;<span class="comment">//将分得的物理页面保存到这个映射描述符中,方便其他线程使用</span></span><br><span class="line">		&#125;</span><br><span class="line">		Else </span><br><span class="line">			<span class="comment">//刚好是一个物理页面 </span></span><br><span class="line">			Pfn=*Entry;</span><br><span class="line">		MmCreateVirtualMapping(PageAddr &lt;------&gt;Pfn);<span class="comment">//建立映射</span></span><br><span class="line">		MmInsertRmap(pfn, CurProcess,PageAddr);<span class="comment">//将这个虚拟页面添加到那个物理页面的映射链表中</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个<code>segment</code>内部也有一个页面映射表,描述了本<code>segment</code>内部各个虚拟页面的映射情况。 表中的每个映射描述符,要么映射到物理页面,要么映射到普通文件页面(注意不是页文件),要么为空<br>其工作原理与进程的页表是相同的。</p>
<blockquote>
<p>为什么多出来一个 segment 页表呢？<br>根本原因就是普通页表中的 PTE, 无法映射到普通数据文件, 映射描述符的格式不一样。</p>
</blockquote>
<p><br></p>
<h2 id="驱动程序分配内存"><a href="#驱动程序分配内存" class="headerlink" title="驱动程序分配内存"></a>驱动程序分配内存</h2><p>最后看一个非常常见的内核函数(供驱动程序用来分配内存的日常函数) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void*   <span class="title">ExAllocatePool</span><span class="params">(PoolType,  NumberOfBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Return  ExAllocatePoolWithTag(PoolType, NumberOfBytes, 'NONE');</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Void*   <span class="title">ExAllocatePoolWithTag</span><span class="params">(PoolType, NumberOfByte, tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (NumberOfBytes &gt; PageSize-BlockHeadSize)<span class="comment">//超出一个页面 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//大于一个页面大小的分配特殊处理; </span></span><br><span class="line">		<span class="function">Retun  <span class="title">MiAllocatePoolPages</span><span class="params">(PoolType, NumberOfBytes)</span></span>;; </span><br><span class="line">	&#125; </span><br><span class="line">	For(遍历空闲块表) </span><br><span class="line">	&#123; </span><br><span class="line">		If(找到了一个合乎大小的空闲块) </span><br><span class="line">		&#123; </span><br><span class="line">			从空闲块链表中摘下一个合乎大小的块； </span><br><span class="line">			前后合并相邻块；<span class="comment">//是在一个页面内分隔、合并 </span></span><br><span class="line">			Return 找到的块地址; </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//如果已有的空闲链表找不到这样一个大小的块 </span></span><br><span class="line">	在池中分配一个新的页面; </span><br><span class="line">	在新页面中把前面的部分割出来,后面剩余的部分挂入池中的空闲块表中; </span><br><span class="line">	Return 分得的块地址   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内核中池的分配原理同用户空间中的堆一样,都是先用<code>VirtuAllocate</code>去分配一个页面,然后在这个页面中寻找空闲块,分给用户。</p>
<p>每个池块的块头含有一些附加信息,如这个池块的大小,池类型,该池块的 tag 标记等信息。<br>用户空间中的<code>malloc</code>,<code>new</code>堆块分配函数,都是调用<code>HeapAlloc API</code>函数从堆管理器维护的 N 个 虚拟页面中分出一些零散的块出来, 每个堆块的块头、块尾也含有一些附加信息<br>如堆块大小,防止堆块溢出的<code>cookie</code>等信息。</p>
<p>堆管理器则在底层调用<code>VirtualAlloc</code>API分配,增长虚拟页面,提供底层服务。 </p>
<blockquote>
<p>详细的用户空间中的堆分配原理请参考: 张银奎-《软件调试》一书</p>
</blockquote>
<p><br><br><br></p>
<h1 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h1><p>写过Windows 应用程序的朋友都常常听说“内核对象”、“句柄”等术语却无从得知他们的内核实现到底是怎样的, 本篇文章就揭开这些技术的神秘面纱。</p>
<h2 id="常见的内核对象"><a href="#常见的内核对象" class="headerlink" title="常见的内核对象"></a>常见的内核对象</h2><p>常见的内核对象有</p>
<ul>
<li>Job、Directory(对象目录中的目录)</li>
<li>SymbolLink(符号链接)</li>
<li>Section(内存映射文件)</li>
<li>Port(LPC 端口)、</li>
<li>IoCompletion(Io 完成端口)</li>
<li>File(并非专指磁盘文件)</li>
<li>同步对象(Mutex、Event、Semaphore、Timer)、</li>
<li>Key(注册表中的键)</li>
<li>Token(用户/组令牌)<br>= Process、Thread、Pipe、Mailslot、Debug(调试端口)等</li>
</ul>
<p>内核对象就是一个数据结构,就是一个struct 结构体<br>各种不同类型的对象有不同的定义,本片文章不专门介绍各个具体对象类型的结构体定义,只讲述一些公共的对象管理机制。</p>
<blockquote>
<p>所有内核对象都遵循统一的使用模式</p>
<ul>
<li>第一步:先创建对象；</li>
<li>第二步:打开对象,得到句柄(可与第一步合并在一起,表示创建时就打开) </li>
<li>第三步:通过 API 访问对象；</li>
<li>第四步:关闭句柄,递减引用计数；</li>
<li>第五步:句柄全部关完并且引用计数降到 0 后,销毁对象。</li>
</ul>
</blockquote>
<p>句柄就是用来维系对象的把柄,就好比 N 名纤夫各拿一条绳,同拉一艘船。<br>每打开一次对象就可拿到一个句柄,表示拿到该对象的一次访问权。<br>内核对象是全局的,各个进程都可以访问</p>
<p>比如两个进程想要共享某块内存来进行通信,就可以约定一个对象名<br>例如一个进程可以用<code>CreatFileMapping(&quot;SectionName&quot;)</code>创建一个 section, 而另一个进程可以用 <code>OpenFileMapping(&quot;SectionName&quot;)</code>打开这个 section,这样这个 section 就被两个进程共享了。</p>
<blockquote>
<p>(注意:本篇说的都是内核对象的句柄。像什么 hWnd、hDC、hFont、hModule、hHeap、hHook 等等其他 句柄,并不是指内核对象,因为这些句柄值不是指向进程句柄表中的索引,而是另外一种机制)</p>
</blockquote>
<p><hr><br><br></p>
<h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>各个对象的结构体虽然不同,但有一些通用信息记录在对象头中,看下面的结构体定义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_HEADER</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	LONG PointerCount;<span class="comment">//引用计数 </span></span><br><span class="line">	<span class="keyword">union</span> </span><br><span class="line">	&#123; </span><br><span class="line">		LONG HandleCount;<span class="comment">//本对象的打开句柄计数(每个句柄本身也占用一个对象引用计数) </span></span><br><span class="line">		<span class="keyword">volatile</span> VOID* NextToFree;<span class="comment">//下一个要延迟删除的对象 </span></span><br><span class="line">	&#125;; </span><br><span class="line"></span><br><span class="line">	OBJECT_TYPE* Type;<span class="comment">//本对象的类型,类型本身也是一种内核对象,因此我习惯叫"类型对象"</span></span><br><span class="line">	UCHAR NameInfoOffset;<span class="comment">//对象名的偏移(无名对象没有Name) </span></span><br><span class="line">	UCHAR HandleInfoOffset;<span class="comment">//各进程的打开句柄统计信息数组 </span></span><br><span class="line">	UCHAR QuotaInfoOffset;<span class="comment">//对象本身实际占用内存配额(当不等于该类对象的默认大小时要用到这个) </span></span><br><span class="line">	UCHAR Flags;<span class="comment">//对象的一些属性标志 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">union</span> </span><br><span class="line">	&#123; </span><br><span class="line">		OBJECT_CREATE_INFORMATION* ObjectCreateInfo;<span class="comment">//来源于创建对象时的OBJECT_ATTRIBUTES </span></span><br><span class="line">		PVOID QuotaBlockCharged; </span><br><span class="line">	&#125;; </span><br><span class="line"></span><br><span class="line">	PSECURITY_DESCRIPTOR SecurityDescriptor;<span class="comment">//安全描述符(对象的拥有者、ACL等信息) </span></span><br><span class="line">	QUAD Body;<span class="comment">//通用对象头后面紧跟着真正的结构体(这个字段是后面真正结构体中的第一个成员) </span></span><br><span class="line">&#125; OBJECT_HEADER, *POBJECT_HEADER;</span><br></pre></td></tr></table></figure></p>
<p>如上Body 就是对象体中的第一个字段,头部后面紧跟具体对象类型的结构体定义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_HEADER_NAME_INFO</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	POBJECT_DIRECTORY Directory;<span class="comment">//对象目录中的父目录(不一定是文件系统中的目录) </span></span><br><span class="line">	UNICODE_STRING Name;<span class="comment">//相对于Directory的路径或者全路径 </span></span><br><span class="line">	ULONG QueryReferences;<span class="comment">//对象名查询操作计数 </span></span><br><span class="line">	… </span><br><span class="line">&#125; OBJECT_HEADER_NAME_INFO, *POBJECT_HEADER_NAME_INFO; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_HEADER_CREATOR_INFO</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	LIST_ENTRY TypeList;<span class="comment">//用来挂入所属"对象类型’中的链表(也即类型对象内部的对象链表) </span></span><br><span class="line">	PVOID CreatorUniqueProcess;<span class="comment">//表示本对象是由哪个进程创建的 </span></span><br><span class="line">	… </span><br><span class="line">&#125; OBJECT_HEADER_CREATOR_INFO, *POBJECT_HEADER_CREATOR_INFO;</span><br></pre></td></tr></table></figure></p>
<p>对象头中记录了<code>NameInfo</code>、<code>HandleInfo</code>、<code>QuotaInfo</code>、<code>CreatorInfo</code> 这 4 种可选信息。<br>如果这 4 种可选信息全部都有的话,整个对象的布局从低地址到高地址的内存布局为: </p>
<p><code>QuotaInfo-&gt; HandleInfo-&gt;NameInfo-&gt;CreatorInfo-&gt;对象头-&gt;对象体</code></p>
<p>这 4 种可选信息的相对位置倒不重要,但是必须记住,他们都是在对象头中的上方(也即对象头上面的低地址端)。<br>以下为了方便不妨叫做“对象头中的可选信息”、“头部中的可选信息”。 </p>
<p>于是有宏定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由对象体的地址得到对象头的地址 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJECT_TO_OBJECT_HEADER(pBody)   CONTAINING(pBody,OBJECT_HEADER,Body) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得到对象的名字 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJECT_HEADER_TO_NAME_INFO(h) </span></span><br><span class="line">	h-&gt;NameInfoOffset?(h - h-&gt;NameInfoOffset):<span class="literal">NULL</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//得到对象的创建者信息 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJECT_HEADER_TO_CREATOR_INFO(h) </span></span><br><span class="line">	h-&gt;Flags &amp; OB_FLAG_CREATOR_INFO?h-<span class="keyword">sizeof</span>(OBJECT_HEADER_CREATOR_INFO):<span class="literal">NULL</span></span><br></pre></td></tr></table></figure></p>
<p>所有有名字的对象都会进入内核中的<code>对象目录</code>中,对象目录就是一棵树。<br>内核中有一个全局指针变量<code>ObpRootDirectoryObject</code>,就指向对象目录树的根节点,根节点是一个根目录。</p>
<p>对象目录的作用就是用来将对象路径解析为对象地址。<br>给定一个对象路径,就可以直接在对象目录中找到对应的对象。<br>就好比给定一个文件的全路径,一定能从磁盘的根目录中向下一直搜索找到对应的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如某个设备对象的对象名(全路径)是`&quot;\Device\MyCdo&quot;`</span><br><span class="line">那么从根目录到这个对象的路径中:`Device 是根目录中的子目录,MyDevice 则是 Device 目录中的子节点。`</span><br><span class="line">对象有了名字,应用程序就可以直接调用 CreateFile 打开这个对象,获得句柄,没有名字的对象无法记录到</span><br></pre></td></tr></table></figure>
<p>对象目录中,应用层看不到,只能由内核自己使用。</p>
<p><hr><br><br></p>
<h2 id="对象目录"><a href="#对象目录" class="headerlink" title="对象目录"></a>对象目录</h2><p>内核中各种类型的对象在对象目录中的位置: </p>
<ul>
<li>目录对象: 最常见就是对象目录中的目录节点(可以作为叶节点) </li>
<li>普通对象: 只能作为叶节点</li>
<li>符号链接对象: 只能作为叶节点 </li>
</ul>
<blockquote>
<p>注意文件对象和注册表中的键对象看似有文件名、键名,但此名非对象名。因此文件对象与键对象是无名的,无法进入对象目录中</p>
</blockquote>
<p>根目录也是一种目录对象,符号链接对象可以链接到对象目录中的任何节点,包括又链向另一个符号链接对象。<br>对象目录中,每个目录节点下面的子节点可以是</p>
<ul>
<li>1、 普通对象节点</li>
<li>2、 子目录</li>
<li>3、 符号链接 </li>
</ul>
<p>该目录中的所有子节点对象都保存在该目录内部的目录项列表中。不过这个列表不是一个简单的数组,而是一个开式<code>hash</code> 表用来方便查找。<br>根据该目录中各个子对象名的<code>hash</code>值,将对应的子对象挂入对应的<code>hash</code>链表中,用<code>hash</code>方式存储这些子对象以提高查找效率<br>目录本身也是一种内核对象,其类型就叫<code>&quot;目录类型&quot;</code><br>现在就可以看一下这种对象的结构体定义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_DIRECTORY</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_DIRECTORY_ENTRY</span>* <span class="title">HashBuckets</span>[37];</span><span class="comment">//37条hash链 </span></span><br><span class="line">	EX_PUSH_LOCK Lock; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_MAP</span> *<span class="title">DeviceMap</span>;</span> </span><br><span class="line">	… </span><br><span class="line">&#125; OBJECT_DIRECTORY, *POBJECT_DIRECTORY;</span><br></pre></td></tr></table></figure></p>
<p>如上目录对象中的所有子对象按<code>hash</code>值分门别类的安放在该目录内部不同的<code>hash</code>链中 其中每个目录项的结构体定义为: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_DIRECTORY_ENTRY</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_DIRECTORY_ENTRY</span> * <span class="title">ChainLink</span>;</span><span class="comment">//下一个目录项(即下一个子节点) </span></span><br><span class="line">PVOID Object;<span class="comment">//对象体的地址 </span></span><br><span class="line">ULONG HashValue;<span class="comment">//所在hash链 </span></span><br><span class="line">&#125; OBJECT_DIRECTORY_ENTRY, *POBJECT_DIRECTORY_ENTRY;</span><br></pre></td></tr></table></figure>
<p>看到没每个目录项记录了指向的对象的地址,同时间接记录了对象名信息<br>下面这个函数用来在指定的目录中查找指定名称的子对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID* <span class="title">ObpLookupEntryDirectory</span><span class="params">(IN POBJECT_DIRECTORY Directory, </span></span></span><br><span class="line"><span class="function"><span class="params">	IN PUNICODE_STRING Name, </span></span></span><br><span class="line"><span class="function"><span class="params">	IN ULONG Attributes, </span></span></span><br><span class="line"><span class="function"><span class="params">	IN POBP_LOOKUP_CONTEXT Context)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"></span><br><span class="line">	BOOLEAN CaseInsensitive = FALSE; </span><br><span class="line">	PVOID FoundObject = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//表示对象名是否严格大小写匹配查找 </span></span><br><span class="line">	<span class="keyword">if</span> (Attributes &amp; OBJ_CASE_INSENSITIVE) CaseInsensitive = TRUE; </span><br><span class="line"></span><br><span class="line">	HashValue=CalcHash(Name-&gt;Buffer);<span class="comment">//计算对象名的hash值 </span></span><br><span class="line">	HashIndex = HashValue % <span class="number">37</span>;<span class="comment">//获得对应的hash链索引 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录本次是在那条hash中查找 </span></span><br><span class="line">	Context-&gt;HashValue = HashValue; </span><br><span class="line">	Context-&gt;HashIndex = (USHORT)HashIndex; </span><br><span class="line">	<span class="keyword">if</span> (!Context-&gt;DirectoryLocked) </span><br><span class="line">		ObpAcquireDirectoryLockShared(Directory, Context);<span class="comment">//锁定目录,以便在其中进行查找操作 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历对应hash链中的所有对象 </span></span><br><span class="line">	AllocatedEntry = &amp;Directory-&gt;HashBuckets[HashIndex]; </span><br><span class="line">	LookupBucket = AllocatedEntry; </span><br><span class="line">	<span class="keyword">while</span> ((CurrentEntry = *AllocatedEntry)) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (CurrentEntry-&gt;HashValue == HashValue) </span><br><span class="line">		&#123; </span><br><span class="line">			ObjectHeader = OBJECT_TO_OBJECT_HEADER(CurrentEntry-&gt;Object); </span><br><span class="line">			HeaderNameInfo = OBJECT_HEADER_TO_NAME_INFO(ObjectHeader); </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> ((Name-&gt;Length == HeaderNameInfo-&gt;Name.Length) &amp;&amp; </span><br><span class="line">				(RtlEqualUnicodeString(Name, &amp;HeaderNameInfo-&gt;Name, CaseInsensitive))) </span><br><span class="line">			&#123; </span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//找到对应的子对象 </span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">		AllocatedEntry = &amp;CurrentEntry-&gt;ChainLink; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CurrentEntry)<span class="comment">//如果找到了子对象 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (AllocatedEntry != LookupBucket) </span><br><span class="line">			<span class="comment">// 将找到的子对象挂入链表的开头,方便下次再次查找同一对象时直接找到； </span></span><br><span class="line">			FoundObject = CurrentEntry-&gt;Object; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FoundObject) <span class="comment">//如果找到了子对象 </span></span><br><span class="line">	&#123; </span><br><span class="line">		ObjectHeader = OBJECT_TO_OBJECT_HEADER(FoundObject); </span><br><span class="line">		ObpReferenceNameInfo(ObjectHeader);<span class="comment">//递增对象名字的引用计数 </span></span><br><span class="line">		ObReferenceObject(FoundObject);<span class="comment">//注意递增了对象本身的引用计数 </span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!Context-&gt;DirectoryLocked) </span><br><span class="line">			ObpReleaseDirectoryLock(Directory, Context);      </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查本次函数调用前,查找上下文中是否已有一个先前的中间节点对象,若有就释放 </span></span><br><span class="line">	<span class="keyword">if</span> (Context-&gt;Object) </span><br><span class="line">	&#123; </span><br><span class="line">		ObjectHeader = OBJECT_TO_OBJECT_HEADER(Context-&gt;Object); </span><br><span class="line">		HeaderNameInfo = OBJECT_HEADER_TO_NAME_INFO(ObjectHeader); </span><br><span class="line">		ObpDereferenceNameInfo(HeaderNameInfo); </span><br><span class="line">		ObDereferenceObject(Context-&gt;Object); </span><br><span class="line">	&#125; </span><br><span class="line">	Context-&gt;Object = FoundObject; </span><br><span class="line">	<span class="keyword">return</span> FoundObject;<span class="comment">//返回找到的子对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上<code>hash</code>查找子对象,找不到就返回 NULL。<br>注意由于这个函数是在遍历路径的过程中逐节逐节的调用的,所以会临时查找中间的目录节点,记录到<code>Context</code>中。</p>
<p><br></p>
<h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	ERESOURCE Mutex; </span><br><span class="line">	LIST_ENTRY TypeList;<span class="comment">//本类对象的链表,记录所有同类对象 </span></span><br><span class="line">	UNICODE_STRING Name;<span class="comment">//类型名 </span></span><br><span class="line">	PVOID DefaultObject;<span class="comment">//指本类对象默认使用的同步事件对象 </span></span><br><span class="line">	ULONG Index;<span class="comment">//本类型的索引,也即表示这是系统中第几个注册的对象类型 </span></span><br><span class="line">	ULONG TotalNumberOfObjects;<span class="comment">//对象链表中总的对象个数 </span></span><br><span class="line">	ULONG TotalNumberOfHandles;<span class="comment">//所有同类对象的打开句柄总数 </span></span><br><span class="line">	ULONG HighWaterNumberOfObjects;<span class="comment">//历史本类对象个数峰值 </span></span><br><span class="line">	ULONG HighWaterNumberOfHandles; <span class="comment">//历史本类对象的句柄个数峰值 </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关键字段。创建类型对象时,会将类型信息拷贝到下面这个字段中 </span></span><br><span class="line">	OBJECT_TYPE_INITIALIZER TypeInfo;  </span><br><span class="line">	ULONG Key;<span class="comment">//事实上用作内存分配的tag,同类对象占用的内存块都标记为同一个tag </span></span><br><span class="line">	ERESOURCE ObjectLocks[<span class="number">4</span>]; </span><br><span class="line">&#125; OBJECT_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE_INITIALIZER</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    USHORT Length;<span class="comment">//本结构体本身的长度 </span></span><br><span class="line">    BOOLEAN UseDefaultObject;<span class="comment">//是否使用全局默认的同步事件对象 </span></span><br><span class="line">    BOOLEAN CaseInsensitive;<span class="comment">//指本类对象的对象名是否大小写不敏感 </span></span><br><span class="line"> </span><br><span class="line">	ULONG InvalidAttributes;<span class="comment">//本类对象不支持的属性集合 </span></span><br><span class="line">	GENERIC_MAPPING GenericMapping;<span class="comment">//一直懒得去分析这个字段 </span></span><br><span class="line">	ULONG ValidAccessMask;<span class="comment">// 本类对象支持的属性集合 </span></span><br><span class="line">	BOOLEAN SecurityRequired;<span class="comment">//本类对象是否需要安全控制(另外:凡是有名字的对象都需要安全控制) </span></span><br><span class="line">	BOOLEAN MaintainHandleCount;<span class="comment">//对象头中是否维护句柄统计信息 </span></span><br><span class="line">	BOOLEAN MaintainTypeList;<span class="comment">//是否维护创建者信息(也即是否需要挂入到所属对象类型的链表中) </span></span><br><span class="line">	</span><br><span class="line">	POOL_TYPE PoolType;<span class="comment">//本类对象位于分页池还是非分页池(一般内核对象都分配在非分页池中) </span></span><br><span class="line">	ULONG DefaultPagedPoolCharge; <span class="comment">//对象占用的分页池总体大小 </span></span><br><span class="line">	ULONG DefaultNonPagedPoolCharge;<span class="comment">//对象占用的非分页池总体大小 </span></span><br><span class="line"></span><br><span class="line">	OB_DUMP_METHOD DumpProcedure;<span class="comment">//? </span></span><br><span class="line">	OB_OPEN_METHOD OpenProcedure;<span class="comment">//打开对象时调用,非常重要 </span></span><br><span class="line">	OB_CLOSE_METHOD CloseProcedure;<span class="comment">//关闭句柄时调用,非常重要 </span></span><br><span class="line">	OB_DELETE_METHOD DeleteProcedure;<span class="comment">//销毁对象时调用,非常重要 </span></span><br><span class="line">	OB_PARSE _METHOD ParseProcedure;<span class="comment">//自定义的路径解析函数(设备、文件、键都提供了此函数)  </span></span><br><span class="line">	OB_SECURITY_METHOD SecurityProcedure;<span class="comment">//查询、设置对象安全描述符的函数 </span></span><br><span class="line">	OB_QUERYNAME_METHOD QueryNameProcedure;<span class="comment">//文件对象提供了自定义的QueryNameString函数 </span></span><br><span class="line">	OB_OKAYTOCLOSE_METHOD OkayToCloseProcedure;<span class="comment">//每次关闭句柄前都会调用这个函数检查可否关闭 </span></span><br><span class="line">&#125; OBJECT_TYPE_INITIALIZER, *POBJECT_TYPE_INITIALIZER;</span><br></pre></td></tr></table></figure>
<p>Windows 内核中有许多预定义的对象类型,程序员也可以自己注册一些自定义的对象类型,就像自注册”窗口类”一样。<br>下面这个函数用来注册一种对象类型(注意对象类型本身也是一种内核对象,因此”对象类型”即是”类型对象”, “类型对象”即是”对象类型”)</p>
<h3 id="自注册对象类型"><a href="#自注册对象类型" class="headerlink" title="自注册对象类型"></a>自注册对象类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ObCreateObjectType</span><span class="params">(IN PUNICODE_STRING TypeName, </span></span></span><br><span class="line"><span class="function"><span class="params">                   IN POBJECT_TYPE_INITIALIZER ObjectTypeInitializer, </span></span></span><br><span class="line"><span class="function"><span class="params">                   OUT POBJECT_TYPE *ObjectType)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	ObpInitializeLookupContext(&amp;Context); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//若 \ObjectTypes 目录下已经创建过了这种对象类型。返回失败 </span></span><br><span class="line">	ObpAcquireDirectoryLockExclusive(ObpTypeDirectoryObject, &amp;Context); </span><br><span class="line">	<span class="keyword">if</span> (ObpLookupEntryDirectory(ObpTypeDirectoryObject, </span><br><span class="line">	            TypeName, </span><br><span class="line">	            OBJ_CASE_INSENSITIVE, </span><br><span class="line">	            FALSE, </span><br><span class="line">	            &amp;Context)) </span><br><span class="line">	&#123; </span><br><span class="line">		ObpReleaseLookupContext(&amp;Context); </span><br><span class="line">		<span class="keyword">return</span> STATUS_OBJECT_NAME_COLLISION;<span class="comment">//不能重复创建同一种对象类型 </span></span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ObjectName.Buffer = ExAllocatePoolWithTag(PagedPool,TypeName-&gt;MaximumLength,tag); </span><br><span class="line">	ObjectName.MaximumLength = TypeName-&gt;MaximumLength; </span><br><span class="line">	RtlCopyUnicodeString(&amp;ObjectName, TypeName); </span><br><span class="line"></span><br><span class="line">	<span class="comment">//分配一块内存,创建类型对象 </span></span><br><span class="line">	Status = ObpAllocateObject(<span class="literal">NULL</span>, <span class="comment">//CreateInfo=NULL </span></span><br><span class="line">	           &amp;ObjectName,<span class="comment">//对象的名字 </span></span><br><span class="line">	           ObpTypeObjectType,<span class="comment">//类型对象本身的类型 </span></span><br><span class="line">	           <span class="keyword">sizeof</span>(OBJECT_TYPE),<span class="comment">//对象的大小 </span></span><br><span class="line">	           KernelMode, </span><br><span class="line">	           (POBJECT_HEADER*)&amp;Header); </span><br><span class="line">	LocalObjectType = (POBJECT_TYPE)&amp;Header-&gt;Body; </span><br><span class="line">	LocalObjectType-&gt;Name = ObjectName;<span class="comment">//类型对象的自身的名称 </span></span><br><span class="line">	Header-&gt;Flags |= OB_FLAG_KERNEL_MODE | OB_FLAG_PERMANENT;<span class="comment">//类型对象全由内核创建并有永久 性 </span></span><br><span class="line"></span><br><span class="line">	LocalObjectType-&gt;TotalNumberOfObjects =<span class="number">0</span>;  </span><br><span class="line">	LocalObjectType-&gt;TotalNumberOfHandles =<span class="number">0</span>; <span class="comment">//本类对象的个数与句柄个数=0 </span></span><br><span class="line">	<span class="comment">//拷贝类型信息(这个TypeInfo就是类型描述符) </span></span><br><span class="line">	LocalObjectType-&gt;TypeInfo = *ObjectTypeInitializer; </span><br><span class="line">	LocalObjectType-&gt;TypeInfo.PoolType = ObjectTypeInitializer-&gt;PoolType; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//类型对象的对象体上面的所有头部大小 </span></span><br><span class="line">	HeaderSize = <span class="keyword">sizeof</span>(OBJECT_HEADER) + </span><br><span class="line">		<span class="keyword">sizeof</span>(OBJECT_HEADER_NAME_INFO)+(ObjectTypeInitializer-&gt;MaintainHandleCount</span><br><span class="line">		?<span class="keyword">sizeof</span>(OBJECT_HEADER_HANDLE_INFO) : <span class="number">0</span>); </span><br><span class="line">	<span class="keyword">if</span> (ObjectTypeInitializer-&gt;PoolType == NonPagedPool) </span><br><span class="line">		LocalObjectType-&gt;TypeInfo.DefaultNonPagedPoolCharge += HeaderSize; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		LocalObjectType-&gt;TypeInfo.DefaultPagedPoolCharge += HeaderSize; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询、设置对象安全描述符的函数 </span></span><br><span class="line">	<span class="keyword">if</span> (!ObjectTypeInitializer-&gt;SecurityProcedure) </span><br><span class="line">		LocalObjectType-&gt;TypeInfo.SecurityProcedure = SeDefaultObjectMethod;   </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (LocalObjectType-&gt;TypeInfo.UseDefaultObject) </span><br><span class="line">	&#123; </span><br><span class="line">		LocalObjectType-&gt;TypeInfo.ValidAccessMask |= SYNCHRONIZE;<span class="comment">//本对象可用于同步操作 </span></span><br><span class="line">		LocalObjectType-&gt;DefaultObject = &amp;ObpDefaultObject;<span class="comment">//其实是个全局的Event对象 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//文件对象的结构体中可自带一个事件对象,WaitForSingleObject(FileObject)等待的就是那个事件 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((TypeName-&gt;Length == <span class="number">8</span>) &amp;&amp; !(wcscmp(TypeName-&gt;Buffer, <span class="string">L"File"</span>))) </span><br><span class="line">		LocalObjectType-&gt;DefaultObject =FIELD_OFFSET(FILE_OBJECT,Event);<span class="comment">//偏移 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((TypeName-&gt;Length == <span class="number">24</span>) &amp;&amp; !(wcscmp(TypeName-&gt;Buffer, <span class="string">L"WaitablePort"</span>))) </span><br><span class="line">		LocalObjectType-&gt;DefaultObject = FIELD_OFFSET(LPCP_PORT_OBJECT,WaitEvent);<span class="comment">//偏移 </span></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		LocalObjectType-&gt;DefaultObject = <span class="literal">NULL</span>; </span><br><span class="line">	</span><br><span class="line">	InitializeListHead(&amp;LocalObjectType-&gt;TypeList); </span><br><span class="line">	CreatorInfo = OBJECT_HEADER_TO_CREATOR_INFO(Header); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CreatorInfo) <span class="comment">//将这个类型对象注册、加入全局链表中,注意这两个TypeList的含义是不一样的 </span></span><br><span class="line">		InsertTailList(&amp;ObpTypeObjectType-&gt;TypeList,&amp;CreatorInfo-&gt;TypeList); LocalObjectType-&gt;Index = ObpTypeObjectType-&gt;TotalNumberOfObjects; </span><br><span class="line">	<span class="comment">//将这个类型对象加入全局数组中 </span></span><br><span class="line">	<span class="keyword">if</span> (LocalObjectType-&gt;Index &lt; <span class="number">32</span>)<span class="comment">//对象类型较少,一般够用 </span></span><br><span class="line">		ObpObjectTypes[LocalObjectType-&gt;Index - <span class="number">1</span>] = LocalObjectType; </span><br><span class="line">		</span><br><span class="line">	<span class="comment">//将类型对象插入 \ObjectTypes 目录中(目录内部的指定hash链中) </span></span><br><span class="line">	bSucc=ObpInsertEntryDirectory(ObpTypeDirectoryObject, &amp;Context, Header); </span><br><span class="line">	<span class="keyword">if</span> (bSucc) </span><br><span class="line">	&#123; </span><br><span class="line">		ObpReleaseLookupContext(&amp;Context); </span><br><span class="line">		*ObjectType = LocalObjectType; </span><br><span class="line">		<span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">	&#125; Else </span><br><span class="line">	&#123; </span><br><span class="line">		ObpReleaseLookupContext(&amp;Context); </span><br><span class="line">		<span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上大致的流程就是创建一个对象类型,然后加入对象目录中的<code>\ObjectTypes</code>目录中。 </p>
<blockquote>
<p>内核中的对象管理器在初始化的时候</p>
</blockquote>
<p>会初始化对象目录。先注册创建名为<code>&quot;Directory&quot;</code>、<code>&quot;SymbolicLink&quot;</code>的对象类型, 然后在对象目录中创建根目录<code>&quot;\&quot;</code>,<code>&quot;\ObjectTypes&quot;</code>目录,<code>&quot;\DosDevices&quot;</code>目录等预定义目录。</p>
<blockquote>
<p>内核中的IO管理器在初始化的时候</p>
</blockquote>
<p>先会注册创建名为<code>&quot;Device&quot;</code>、<code>&quot;File&quot;</code>、<code>&quot;Driver&quot;</code>等对象类型<br>由于对象类型本身也是一种有名字的对象,所以也会挂入对象目录中<br>位置分别为:<code>&quot;\ObjectTypes\Device&quot;</code>, “<code>\ObjectTypes\File&quot;</code>,<code>&quot;\ObjectTypes\Driver&quot;</code>于是,我们的驱动就可以创建对应类型的对象了。 </p>
<blockquote>
<p>下面我们具体看几个重点对象类型的创建过程</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">OBJECT_TYPE_INITIALIZER  Oti = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">Oti.Length=<span class="keyword">sizeof</span>(OBJECT_TYPE_INITIALIZER); </span><br><span class="line">Oti.UseDefaultObject=TRUE; </span><br><span class="line">Oti.MaintainTypeList=TRUE;<span class="comment">//一般都会维持类型信息,加入到所属类型的链表中 </span></span><br><span class="line">Oti.PoolType=NonPagePool;<span class="comment">//所有内核对象,都默认分配在非分页池中 </span></span><br><span class="line">Oti.InvalidAttributes=OBJ_OPENLINK;<span class="comment">//一般都不许打开符号链接 </span></span><br><span class="line">Oti.DefaultNonPagePoolCharge=<span class="keyword">sizeof</span>(OBJECT_DIRECTORY); </span><br><span class="line">Oti.UseDefaultObject=FALSE; </span><br><span class="line">… ObCreateObjectType(<span class="string">"Directory"</span>, &amp;oti, &amp;ObpDirectoryType);<span class="comment">//创建普通的目录对象类型 </span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">Oti.DefaultNonPagePoolCharge=<span class="keyword">sizeof</span>(OBJECT_SYMBOLIC_LINK); </span><br><span class="line">Oti.ValidAccessMask=SYMBOLIC_LINK_ALL_ACCESS; </span><br><span class="line">Oti.ParseProcedure=ObpParseSymbolicLink;<span class="comment">//关键字段。自定义解析后面的路径名 </span></span><br><span class="line">Oti.DeleteProcedure=ObpDeleteSymbolicLink; </span><br><span class="line">… ObCreateObjectType(<span class="string">"SymbolicLink"</span>,&amp;oti,&amp;ObSymbolicLinkType);<span class="comment">//创建符号链接对象类型 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Oti.DefaultNonPagePoolCharge=<span class="keyword">sizeof</span>(DEVICE_OBJECT); </span><br><span class="line">Oti.ParseProcedure=IopParseDevice; <span class="comment">//关键字段。自定义解析后面的路径名 </span></span><br><span class="line">Oti.SecurityProcedure=IopSecurityFile; </span><br><span class="line">… ObCreateObjectType(<span class="string">"Device"</span>, &amp;oti, &amp;IoDeviceObjectType);<span class="comment">//创建设备对象类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Oti.DefaultNonPagePoolCharge=<span class="keyword">sizeof</span>(FILE_OBJECT); </span><br><span class="line">Oti.UseDefaultObject=FALSE;<span class="comment">//每个文件对象内部有一个自己的事件对象 </span></span><br><span class="line">Oti.ParseProcedure=IopParseFile; <span class="comment">//关键字段。自定义解析后面的路径名 </span></span><br><span class="line">Oti.SecurityProcedure=IopSecurityFile; </span><br><span class="line">Oti.QueryNameProcedure=IopQueryNameFile;<span class="comment">//文件对象自己负责 </span></span><br><span class="line">ObQueryNameString Oti.CloseProcedure=IopCloseFile;<span class="comment">//关闭文件句柄时调用的函数(句柄关完后生成 MJ_Cleanup irp) Oti.DeleteProcedure=IopDeleteFile;//销毁文件对象时调用的函数(对象销毁前生成 MJ_Close irp) </span></span><br><span class="line">… ObCreateObjectType(<span class="string">"File"</span>, &amp;oti, &amp;IoFileObjectType);<span class="comment">//创建文件对象类型</span></span><br></pre></td></tr></table></figure>
<p>我们看到,<code>符号链接</code>、<code>设备</code>、<code>文件</code>这三类对象都提供了自定义的路径解析函数。<br>(后文中,这册表键对象也会提供一个自定义解析函数)因为这几种对象,对象后面的剩余路径并不在对象目录中,对象目录中的 叶节点到这几种对象就是终点了。</p>
<blockquote>
<p>比如物理磁盘卷设备对象上的某一文件路径<code>&quot;\Device\Harddisk0\Partition0\Dir1\Dir2\File.txt&quot;</code>的解析过程是</p>
</blockquote>
<ul>
<li>先顺着对象目录中的根目录,按<code>\Device\Harddisk0\Partition0</code>这个路径解析到这一层,找到对应的卷设备对象</li>
<li>再后面剩余的路径<code>Dir1\Dir2\File.txt</code>就由具体的文件系统去解析了,最终找到对应的文件对象 </li>
</ul>
<p>另外注意一下,文件对象在句柄关完后,将产生一个<code>IRP_MJ_CLEANUP</code>; 文件对象在引用减到 0 后,销毁前将产生<code>IRP_MJ_CLOSE</code>。<br>这就是这两个 irp 的产生时机。</p>
<blockquote>
<p>简单记忆【柄完清理,引完关闭】 </p>
</blockquote>
<p><br></p>
<h2 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h2><p>任意进程,只要每打开一个对象就会获得一个句柄,这个句柄用来标志对某个对象的一次打开,通过句 柄,可以直接找到对应的内核对象。<br>句柄本身是进程的句柄表中的一个结构体,用来描述一次打开操作。<br>句柄值则可以简单看做句柄表中的索引,并不影响理解。<br><code>HANDLE</code>的值可以简单的看做一个整形索引值。 每个进程都有一个句柄表,用来记录本进程打开的所有内核对象。<br>句柄表可以简单看做为一个一维数组, 每个表项就是一个句柄,一个结构体,一个句柄描述符</p>
<blockquote>
<p>其结构体定义如下</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">HANDLE_TABLE_ENTRY</span> //句柄描述符 </span></span><br><span class="line"><span class="class"> &#123;</span> </span><br><span class="line">	<span class="keyword">union</span> </span><br><span class="line">	&#123; </span><br><span class="line">		PVOID Object;<span class="comment">//关键字段。该句柄指向的内核对象(注意是其头部) </span></span><br><span class="line">		ULONG_PTR ObAttributes;<span class="comment">//关键字段。该句柄的属性 </span></span><br><span class="line">		PHANDLE_TABLE_ENTRY_INFO InfoTable; </span><br><span class="line">		ULONG_PTR Value;<span class="comment">//值(可见值本身是一个复合体),最低3位表示该句柄的属性(Value= Obje ct | ObAttributes) </span></span><br><span class="line">	&#125;; </span><br><span class="line">	<span class="keyword">union</span> </span><br><span class="line">	&#123; </span><br><span class="line">		ULONG GrantedAccess;<span class="comment">//关键字段。该句柄的访问权限 </span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">		&#123;</span> </span><br><span class="line">			USHORT GrantedAccessIndex; </span><br><span class="line">			USHORT CreatorBackTraceIndex; </span><br><span class="line">		&#125;; </span><br><span class="line">		LONG NextFreeTableEntry;<span class="comment">//当本句柄是一个空闲表项时,用来链接到句柄表中下一个空闲表项 </span></span><br><span class="line">	&#125;; </span><br><span class="line">&#125; HANDLE_TABLE_ENTRY, *PHANDLE_TABLE_ENTRY;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>句柄表则定义如下</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">HANDLE_TABLE</span>   //句柄表描述符 </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	ULONG TableCode; <span class="comment">//表的地址|表的层数(该字段的最后两位表示表的层数) </span></span><br><span class="line">	PHANDLE_TABLE_ENTRY **Table;  </span><br><span class="line">	PEPROCESS QuotaProcess;<span class="comment">//所属进程 </span></span><br><span class="line">	PVOID UniqueProcessId; <span class="comment">//所属进程的PID </span></span><br><span class="line">	EX_PUSH_LOCK HandleTableLock[<span class="number">4</span>]; </span><br><span class="line">	LIST_ENTRY HandleTableList;<span class="comment">//用来挂入全局的句柄表链表(间接给出了系统中的进程列表) </span></span><br><span class="line">	EX_PUSH_LOCK HandleContentionEvent; </span><br><span class="line">	ERESOURCE HandleLock; </span><br><span class="line">	LIST_ENTRY HandleTableList; </span><br><span class="line">	KEVENT HandleContentionEvent; </span><br><span class="line">	PHANDLE_TRACE_DEBUG_INFO DebugInfo; </span><br><span class="line">	LONG ExtraInfoPages; </span><br><span class="line">	ULONG FirstFree;<span class="comment">//第一个空闲表项的索引位置 </span></span><br><span class="line">	ULONG LastFree;<span class="comment">//最后一个空闲表项的索引位置 </span></span><br><span class="line">	ULONG NextHandleNeedingPool;<span class="comment">//本句柄表本身占用的内存页数 </span></span><br><span class="line">	LONG HandleCount;<span class="comment">//表中的有效句柄总数 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> </span><br><span class="line">	&#123; </span><br><span class="line">		ULONG Flags; </span><br><span class="line">		UCHAR StrictFIFO:<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">	&#125;; </span><br><span class="line">&#125; HANDLE_TABLE, *PHANDLE_TABLE;</span><br></pre></td></tr></table></figure>
<p>进程的<code>EPROCESS</code>结构体中有一个字段<code>HANDLE_TABLE* ObjectTable;</code>指的就是该进程的句柄表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">ExCreateHandle</span><span class="params">(PHANDLE_TABLE HandleTable,   PHANDLE_TABLE_ENTRY HandleTableEntry)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	EXHANDLE Handle; </span><br><span class="line">	NewEntry = ExpAllocateHandleTableEntry(HandleTable,&amp;Handle);<span class="comment">//在句柄表中找到一个空闲表项 </span></span><br><span class="line">	*NewEntry = *HandleTableEntry;<span class="comment">//复制句柄表项 </span></span><br><span class="line">	<span class="keyword">return</span> Handle.GenericHandleOverlay;<span class="comment">//返回句柄值(也即空闲表项的索引位置) </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数与其说是创建一个句柄,不如说是插入一个句柄。<br>在指定句柄表中找到一个空闲未用的表项,然后将句柄插入到那个位置,最后返回句柄的<code>&quot;索引&quot;</code>。</p>
<blockquote>
<p>下面这个函数用来打开对象,获得句柄<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ObpCreateHandle</span><span class="params">(IN OB_OPEN_REASON OpenReason,<span class="comment">//4种打开时机 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN PVOID Object, <span class="comment">//要打开的对象 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN PACCESS_STATE AccessState, <span class="comment">//句柄的访问权限 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN ULONG HandleAttributes, <span class="comment">//句柄的属性 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN KPROCESSOR_MODE AccessMode, </span></span></span><br><span class="line"><span class="function"><span class="params">                OUT PHANDLE ReturnedHandle)</span> <span class="comment">//返回的句柄值 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BOOLEAN AttachedToProcess = FALSE, KernelHandle = FALSE; </span><br><span class="line">	NewEntry.Object = ObjectHeader;<span class="comment">//关键。将该句柄指向对应的对象头 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (HandleAttributes &amp; OBJ_KERNEL_HANDLE)<span class="comment">//如果用户要求创建一个全局型的内核句柄 </span></span><br><span class="line">	&#123; </span><br><span class="line">		HandleTable = ObpKernelHandleTable;<span class="comment">//改用内核句柄表 </span></span><br><span class="line">		KernelHandle = TRUE; </span><br><span class="line"></span><br><span class="line">		<span class="comment">//将当前线程挂靠到system进程,也即修改当前的CR3,将页表换成system进程的页表 </span></span><br><span class="line">		<span class="keyword">if</span> (PsGetCurrentProcess() != PsInitialSystemProcess) </span><br><span class="line">		&#123; </span><br><span class="line">			KeStackAttachProcess(&amp;PsInitialSystemProcess-&gt;Pcb, &amp;ApcState); </span><br><span class="line">			AttachedToProcess = TRUE; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		HandleTable = PsGetCurrentProcess()-&gt;ObjectTable;<span class="comment">//使用当前进程的句柄表 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查是否可以独占打开,检查权限,若各项检查通过才打开对象,递增句柄计数,调用对象的OpenP rocedure等等工作 </span></span><br><span class="line">	Status = ObpIncrementHandleCount(Object, </span><br><span class="line">	                        AccessState, </span><br><span class="line">	                        AccessMode, </span><br><span class="line">	                        HandleAttributes, </span><br><span class="line">	                        PsGetCurrentProcess(), </span><br><span class="line">	                        OpenReason); </span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(Status)) </span><br><span class="line">		<span class="keyword">return</span> Status; </span><br><span class="line"></span><br><span class="line">	NewEntry.ObAttributes |= (HandleAttributes &amp; OBJ_HANDLE_ATTRIBUTES);<span class="comment">//填上句柄的属性 </span></span><br><span class="line"></span><br><span class="line">	DesiredAccess =AccessState-&gt;RemainingDesiredAccess|AccessState-&gt;PreviouslyGrantedAccess; </span><br><span class="line">	GrantedAccess = DesiredAccess &amp;(ObjectType-&gt;TypeInfo.ValidAccessMask); </span><br><span class="line">	NewEntry.GrantedAccess = GrantedAccess;<span class="comment">//填上句柄的属性 </span></span><br><span class="line">	Handle = ExCreateHandle(HandleTable, &amp;NewEntry);<span class="comment">//将句柄插入到句柄表中 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Handle)<span class="comment">//if 插入成功 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (KernelHandle) </span><br><span class="line">		Handle = ObMarkHandleAsKernelHandle(Handle);<span class="comment">//将句柄值的最高位设为1,标记为内核句柄 </span></span><br><span class="line"></span><br><span class="line">		*ReturnedHandle = Handle; </span><br><span class="line">		<span class="keyword">if</span> (AttachedToProcess) </span><br><span class="line">		KeUnstackDetachProcess(&amp;ApcState);<span class="comment">//撤销挂靠 </span></span><br><span class="line">		<span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">	&#125; Else </span><br><span class="line">	&#123; </span><br><span class="line">		… </span><br><span class="line">		<span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>打开对象,以得到一个访问句柄。有四种打开时机:</p>
<ul>
<li>1、 创建对象时就打开,如 CreateFile 在创建一个新文件时,就同时打开了那个文件对象 </li>
<li>2、 显式打开,如 OpenFile,OpenMutex,OpenProcess 显式打开某个对象</li>
<li>3、 DuplicateHandle 这个 API 间接打开对象,获得句柄</li>
<li>4、 子进程继承父进程句柄表中的句柄,也可看做是一种打开<br>  在这四种情况下,都会调用这个函数来打开对象,得到一个句柄。<br>  OpenReason 参数就是指打开原因、时机 注意句柄值的最高位为 1,就表示这是一个内核全局句柄,可以在各个进程中通用。<br>  否则一般的句柄只能在对应的进程中有意义。  </li>
</ul>
<p>另外有两个特殊的伪句柄,他们并不表示<code>索引</code>而是一个简单的代号值 </p>
<ul>
<li><code>GetCurrentProcessHandle</code> 返回的句柄值是-1 </li>
<li><code>GetCurrentThreadHandle</code>  返回的句柄值是-2<br>对这两个句柄要特殊处理。《Windows 核心编程》一书专门强调了这两个句柄的使用误区 </li>
</ul>
<h3 id="句柄结构"><a href="#句柄结构" class="headerlink" title="句柄结构"></a>句柄结构</h3><p>句柄不光含有指向对象的指针,每个句柄都还有自己的访问权限与属性,这也是非常重要的。<br>访问权限表示本次打开操作要求的、申请的并且最终得到的权限。<br>句柄属性则表示本句柄是否可以继承,是否是独占打开的,是否是一个内核句柄等属性。 </p>
<p>在驱动程序开发中,经常遇到的下面这个结构<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_ATTRIBUTES</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	ULONG Length;<span class="comment">//本结构体的长度 </span></span><br><span class="line">	HANDLE RootDirectory;<span class="comment">//相对目录(不一定是父目录) </span></span><br><span class="line">	PUNICODE_STRING ObjectName;<span class="comment">//相对RootDirectory这个目录的剩余路径 或者 全路径 </span></span><br><span class="line">	<span class="comment">//上面两个字段一起间接构成对象的全路径 </span></span><br><span class="line">	ULONG Attributes;<span class="comment">//对象属性与句柄属性的混合 </span></span><br><span class="line">	PVOID SecurityDescriptor;<span class="comment">// SD安全描述符 </span></span><br><span class="line">	PVOID SecurityQualityOfService; </span><br><span class="line">&#125; OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES; </span><br><span class="line"><span class="keyword">typedef</span> CONST OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;</span><br></pre></td></tr></table></figure></p>
<p>创建对象、打开对象时都会用到这个结构。 </p>
<p>下面这个函数用来创建一个指定类型的内核对象<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ObCreateObject</span><span class="params">(IN POBJECT_TYPE Type, </span></span></span><br><span class="line"><span class="function"><span class="params">               IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">               IN KPROCESSOR_MODE AccessMode, </span></span></span><br><span class="line"><span class="function"><span class="params">               IN ULONG ObjectSize, </span></span></span><br><span class="line"><span class="function"><span class="params">               IN ULONG PagedPoolCharge OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">               IN ULONG NonPagedPoolCharge OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">               OUT PVOID *Object)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	ObjectCreateInfo = ObpAllocateObjectCreateInfoBuffer(LookasideCreateInfoList); </span><br><span class="line">	Status = ObpCaptureObjectCreateInformation(ObjectAttributes,FALSE,ObjectCreateInfo, &amp;ObjectName);<span class="comment">//提取ObjectAttributes中的字段 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!PagedPoolCharge) </span><br><span class="line">		PagedPoolCharge = Type-&gt;TypeInfo.DefaultPagedPoolCharge; </span><br><span class="line">	<span class="keyword">if</span> (!NonPagedPoolCharge) </span><br><span class="line">		NonPagedPoolCharge = Type-&gt;TypeInfo.DefaultNonPagedPoolCharge; </span><br><span class="line">	</span><br><span class="line">	ObjectCreateInfo-&gt;PagedPoolCharge = PagedPoolCharge; </span><br><span class="line">	ObjectCreateInfo-&gt;NonPagedPoolCharge = NonPagedPoolCharge; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//从对应池中分配内存,创建对应的对象 </span></span><br><span class="line">	Status = ObpAllocateObject(ObjectCreateInfo,&amp;ObjectName,Type,ObjectSize,AccessMode, &amp;Header); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实真正的工作函数是<code>ObpAllocateObject</code><br>它内部调用<code>ExAllocatePoolWithTag(ObjectType-&gt;PoolType, 可选头总大小+ ObjectSize, Tag)</code>分配对象内存<br>然后初始化设置头部中的<code>Flags</code>等其他工作。(绝大多数内核对象都分配在非分页池中) </p>
<p><code>OBJECT_ATTRIBUTES</code>结构体中的<code>Attributes</code>字段是个混合成员,由句柄属性、对象属性、打开属性复合而成<br>可以取下面的组合 </p>
<ul>
<li>OBJ_INHERIT://句柄属性,表示句柄是否可继承给子进程 </li>
<li>OBJ_PERMANENT://指该对象是否永久存在于对象目录中直到对象销毁.(目录\符号链接\设备\文件 都是) </li>
<li>OBJ_EXLUSIVE://对象属性,指该对象同一时刻只能被一个进程独占打开 </li>
<li>OBJ_CASE_INSENSITIVE://打开属性,表示本次打开操作查找比较对象名时大小写不敏感 </li>
<li>OBJ_OPENIF://打开属性,表示 if 对象存在就打开 </li>
<li>OBJ_OPENLINK://打开属性,表示本次打开是否可以直接打开符号链接 </li>
<li>OBJ_KERNEL_HANDLE://句柄属性,表示要求得到一个内核句柄 </li>
</ul>
<p>而对象头中的 Flags 字段则完全表示对象的一些属性标志 </p>
<ul>
<li>OB_FLAG_CREATE_INFO;//表示头部中含有创建时的属性信息 </li>
<li>OB_FLAG_CREATOR_INFO;//表示含有创建者进程信息 </li>
<li>OB_FLAG_KERNEL_MODE://表示 PreviousMode 是内核模式的代码创建的本对象 </li>
<li>OB_FLAG_EXCLUSIVE://表示同一时刻只能被一个进程独占打开 </li>
<li>OB_FLAG_PERMANET://永久性对象,直到对象完全销毁时才脱离对象目录 </li>
<li>OB_FLAG_SINGLE_PROCESS://表示含有每进程的句柄统计信息 </li>
<li>OB_FLAG_DEFER_DELETE;//标记本对象被延迟删除了 </li>
</ul>
<p>创建的对象,如果有名字就需要插入到对象目录和句柄表中。即使没有名字也需要插入到句柄表中<br>这样才能让应用程序得以找到该对象以进行访问。<br>下面这个函数就是做这个的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ObInsertObject</span><span class="params">(IN PVOID Object, </span></span></span><br><span class="line"><span class="function"><span class="params">               IN PACCESS_STATE AccessState OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">               IN ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="function"><span class="params">               OUT PHANDLE Handle)</span><span class="comment">//返回得到的句柄 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object); </span><br><span class="line">	ObjectCreateInfo = ObjectHeader-&gt;ObjectCreateInfo; </span><br><span class="line">	ObjectNameInfo = ObpReferenceNameInfo(ObjectHeader); </span><br><span class="line">	ObjectType = ObjectHeader-&gt;Type; </span><br><span class="line">	ObjectName = <span class="literal">NULL</span>; </span><br><span class="line">	<span class="keyword">if</span> ((ObjectNameInfo) &amp;&amp; (ObjectNameInfo-&gt;Name.Buffer)) </span><br><span class="line">		ObjectName = &amp;ObjectNameInfo-&gt;Name; PreviousMode = KeGetPreviousMode(); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//无名对象(并且不需要安全控制)就不挂入对象目录,仅仅插入句柄表中 </span></span><br><span class="line">	<span class="keyword">if</span> ( (ObjectName==<span class="literal">NULL</span>) &amp;&amp; !(ObjectType-&gt;TypeInfo.SecurityRequired)) </span><br><span class="line">	&#123; </span><br><span class="line">		ObjectHeader-&gt;ObjectCreateInfo = <span class="literal">NULL</span>; </span><br><span class="line">		Status = ObpCreateUnnamedHandle(Object,DesiredAccess,ObjectCreateInfo-&gt;Attributes, </span><br><span class="line">		PreviousMode,Handle); </span><br><span class="line">		<span class="keyword">return</span> Status; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	InsertObject = Object; </span><br><span class="line">	<span class="keyword">if</span> (ObjectName)<span class="comment">//若是一个有名对象 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//这个函数有两种用途。 </span></span><br><span class="line">		<span class="comment">//当Object不为NULL表示将Object插入到对象目录中的指定位置 </span></span><br><span class="line">		<span class="comment">//当Object为NULL表示查找指定的对象目录位置处的对象 </span></span><br><span class="line">		<span class="comment">//两种用途都将指定目录位置处的对象返回到InsertObject中 </span></span><br><span class="line">		Status = ObpLookupObjectName(ObjectCreateInfo-&gt;RootDirectory, </span><br><span class="line">				ObjectName, </span><br><span class="line">				ObjectCreateInfo-&gt;Attributes, </span><br><span class="line">				ObjectType, </span><br><span class="line">				ObjectCreateInfo-&gt;ParseContext, </span><br><span class="line">				Object,<span class="comment">//要插入的对象 </span></span><br><span class="line">				&amp;InsertObject);<span class="comment">//返回最终那个位置处的对象 </span></span><br><span class="line">		<span class="comment">//如果原位置处已有同名对象,插入失败 </span></span><br><span class="line">		<span class="keyword">if</span> ((NT_SUCCESS(Status)) &amp;&amp; (InsertObject) &amp;&amp; (Object != InsertObject)) </span><br><span class="line">		&#123; </span><br><span class="line">			OpenReason = ObOpenHandle;<span class="comment">//既然插入失败了,那就是要打开对象,获得句柄 </span></span><br><span class="line">			<span class="keyword">if</span> (ObjectCreateInfo-&gt;Attributes &amp; OBJ_OPENIF)<span class="comment">//检查本次打开操作的要求 </span></span><br><span class="line">			&#123; </span><br><span class="line">				<span class="keyword">if</span> (ObjectType != OBJECT_TO_OBJECT_HEADER(InsertObject)-&gt;Type) </span><br><span class="line">					Status = STATUS_OBJECT_TYPE_MISMATCH; </span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					Status = STATUS_OBJECT_NAME_EXISTS;<span class="comment">//看到没,应用层经常返回这个出错值         </span></span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123; </span><br><span class="line">				Status = STATUS_OBJECT_NAME_COLLISION; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">return</span> Status; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (InsertObject == Object)<span class="comment">//if 插入成功 </span></span><br><span class="line">		OpenReason = ObCreateHandle;<span class="comment">//只有第一次创建对象的时候才会插入对象目录中 </span></span><br><span class="line">	</span><br><span class="line">	ObjectHeader-&gt;ObjectCreateInfo = <span class="literal">NULL</span>;<span class="comment">//不再需要了 </span></span><br><span class="line">	<span class="keyword">if</span> (Handle)<span class="comment">//如果用户要求插入句柄表,就插入句柄表,得到一个句柄 </span></span><br><span class="line">	&#123; </span><br><span class="line">		Status = ObpCreateHandle(OpenReason,InsertObject,AccessState, </span><br><span class="line">		ObjectCreateInfo-&gt;Attributes, PreviousMode,Handle); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用内核函数"><a href="#常用内核函数" class="headerlink" title="常用内核函数"></a>常用内核函数</h2><h3 id="ObReferenceObjectByHandle"><a href="#ObReferenceObjectByHandle" class="headerlink" title="ObReferenceObjectByHandle"></a>ObReferenceObjectByHandle</h3><p>下面看一下驱动程序经常调用的那些内核函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ObReferenceObjectByHandle</span><span class="params">(IN HANDLE Handle,IN ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="function"><span class="params">                          IN POBJECT_TYPE ObjectType,IN KPROCESSOR_MODE AccessMode, </span></span></span><br><span class="line"><span class="function"><span class="params">                          OUT PVOID* Object,OUT POBJECT_HANDLE_INFORMATION HandleInformation)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	*Object = <span class="literal">NULL</span>; </span><br><span class="line">	<span class="comment">//若句柄是一个内核句柄或当前进程、线程的句柄 </span></span><br><span class="line">	<span class="keyword">if</span> (HandleToLong(Handle) &lt; <span class="number">0</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (Handle == NtCurrentProcess())<span class="comment">//若句柄值是当前进程的句柄(-1),特殊处理 </span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> ((ObjectType == PsProcessType) || !(ObjectType)) </span><br><span class="line">			&#123; </span><br><span class="line">				CurrentProcess = PsGetCurrentProcess(); </span><br><span class="line">				GrantedAccess = CurrentProcess-&gt;GrantedAccess; </span><br><span class="line">				<span class="comment">//if内核模式/要求的权限&lt;=进程对象支持的权限(权限检查) </span></span><br><span class="line">				<span class="keyword">if</span> ((AccessMode == KernelMode) ||!(~GrantedAccess &amp; DesiredAccess)) </span><br><span class="line">				&#123; </span><br><span class="line">					<span class="keyword">if</span> (HandleInformation) </span><br><span class="line">					&#123; </span><br><span class="line">						HandleInformation-&gt;HandleAttributes = <span class="number">0</span>; </span><br><span class="line">						HandleInformation-&gt;GrantedAccess = GrantedAccess; </span><br><span class="line">					&#125; </span><br><span class="line"></span><br><span class="line">					ObjectHeader = OBJECT_TO_OBJECT_HEADER(CurrentProcess); </span><br><span class="line">					InterlockedExchangeAdd(&amp;ObjectHeader-&gt;PointerCount, <span class="number">1</span>);<span class="comment">//递增引用计数 </span></span><br><span class="line">					*Object = CurrentProcess;<span class="comment">//返回得到的对象指针 </span></span><br><span class="line">					Status = STATUS_SUCCESS; </span><br><span class="line">				&#125; </span><br><span class="line">				Else <span class="comment">//权限检查不通过 </span></span><br><span class="line">					Status = STATUS_ACCESS_DENIED;     </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				Status = STATUS_OBJECT_TYPE_MISMATCH; </span><br><span class="line">			<span class="keyword">return</span> Status; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Handle == NtCurrentThread())<span class="comment">//若句柄值是当前线程的句柄(-2),特殊处理 </span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> ((ObjectType == PsThreadType) || !(ObjectType)) </span><br><span class="line">			&#123; </span><br><span class="line">				CurrentThread = PsGetCurrentThread(); </span><br><span class="line">				GrantedAccess = CurrentThread-&gt;GrantedAccess; </span><br><span class="line">				<span class="keyword">if</span> ((AccessMode == KernelMode) ||!(~GrantedAccess &amp; DesiredAccess)) </span><br><span class="line">				&#123; </span><br><span class="line">					<span class="keyword">if</span> (HandleInformation) </span><br><span class="line">					&#123; </span><br><span class="line">						HandleInformation-&gt;HandleAttributes = <span class="number">0</span>; </span><br><span class="line">						HandleInformation-&gt;GrantedAccess = GrantedAccess; </span><br><span class="line">					&#125; </span><br><span class="line">					</span><br><span class="line">					ObjectHeader = OBJECT_TO_OBJECT_HEADER(CurrentThread); </span><br><span class="line">					InterlockedExchangeAdd(&amp;ObjectHeader-&gt;PointerCount, <span class="number">1</span>); </span><br><span class="line">					*Object = CurrentThread; </span><br><span class="line">					Status = STATUS_SUCCESS; </span><br><span class="line">				&#125; </span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					Status = STATUS_ACCESS_DENIED; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				Status = STATUS_OBJECT_TYPE_MISMATCH; </span><br><span class="line">			<span class="keyword">return</span> Status; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (AccessMode == KernelMode)<span class="comment">//若句柄是一个内核句柄 </span></span><br><span class="line">		&#123; </span><br><span class="line">			Handle = ObKernelHandleToHandle(Handle);<span class="comment">//去掉最高位的1,转为普通句柄 </span></span><br><span class="line">			HandleTable = ObpKernelHandleTable;<span class="comment">//采用内核句柄表 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	Else <span class="comment">//最典型的情况,普通句柄,就使用当前进程的句柄表 </span></span><br><span class="line">		HandleTable = PsGetCurrentProcess()-&gt;ObjectTable; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//以该句柄的值为“索引”,找到句柄表中对应的句柄表项 </span></span><br><span class="line">	HandleEntry = ExMapHandleToPointer(HandleTable, Handle) </span><br><span class="line">	<span class="keyword">if</span> (HandleEntry)<span class="comment">//如果找到了,这就是一个有效句柄 </span></span><br><span class="line">	&#123; </span><br><span class="line">		ObjectHeader = ObpGetHandleObject(HandleEntry);<span class="comment">//关键。获得该句柄指向的对应对象 </span></span><br><span class="line">		<span class="keyword">if</span> (!(ObjectType) || (ObjectType == ObjectHeader-&gt;Type)) </span><br><span class="line">		&#123; </span><br><span class="line">			GrantedAccess = HandleEntry-&gt;GrantedAccess; </span><br><span class="line">			<span class="keyword">if</span> ((AccessMode == KernelMode) ||!(~GrantedAccess &amp; DesiredAccess))<span class="comment">//通过权限检查 </span></span><br><span class="line">			&#123; </span><br><span class="line">				InterlockedIncrement(&amp;ObjectHeader-&gt;PointerCount); </span><br><span class="line">				Attributes = HandleEntry-&gt;ObAttributes &amp; OBJ_HANDLE_ATTRIBUTES; </span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (HandleInformation) </span><br><span class="line">				&#123; </span><br><span class="line">					HandleInformation-&gt;HandleAttributes = Attributes; </span><br><span class="line">					HandleInformation-&gt;GrantedAccess = GrantedAccess; </span><br><span class="line">				&#125; </span><br><span class="line">				*Object = &amp;ObjectHeader-&gt;Body;<span class="comment">//返回的是对象体的地址 </span></span><br><span class="line">				<span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">			&#125; </span><br><span class="line">			Else <span class="comment">//权限检查没通过 </span></span><br><span class="line">				Status = STATUS_ACCESS_DENIED; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			Status = STATUS_OBJECT_TYPE_MISMATCH;       </span><br><span class="line">	&#125; </span><br><span class="line">	Else <span class="comment">//有可能用户给定的句柄值是一个无效句柄,在句柄表中找不到 </span></span><br><span class="line">	Status = STATUS_INVALID_HANDLE; </span><br><span class="line">	</span><br><span class="line">	*Object = <span class="literal">NULL</span>; </span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上这个函数从句柄得到对应的内核对象,并递增其引用计数。                               </p>
<blockquote>
<p>两个特殊情况<br><code>#define NtCurrentProcess() (HANDLE)-1</code><br><code>#define NtCurrentThread() (HANDLE)-2</code><br>这是两个伪句柄值,永远获得的是当前进程、线程的内核对象。</p>
</blockquote>
<p>另外若句柄值的最高位是 1,则是一个内核句柄各进程通用。<br>内核型句柄是<code>&quot;System&quot;</code>进程的句柄表中的句柄。<br>因此要获得内核句柄对应的对象,系统会挂靠到<code>&quot;System&quot;</code>进程的地址空间中,去查询句柄表。 </p>
<p>根据句柄值在句柄表中找到对应的表项是靠<code>ExMamHandleToPointer</code>这个函数实现的,这个函数又在内部调用<code>ExpLookupHandleTableEntry</code> 来真正查找。<br>句柄表组织为一个稀疏数组(目的用来节省内存),但可以简单的看做一个一维数组,不影响理解,句柄值本身也可简单理解为一个索引。 </p>
<h3 id="ObReferenceObjectByPointer"><a href="#ObReferenceObjectByPointer" class="headerlink" title="ObReferenceObjectByPointer"></a>ObReferenceObjectByPointer</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ObReferenceObjectByPointer</span><span class="params">(IN PVOID Object,IN ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="function"><span class="params">                           IN POBJECT_TYPE ObjectType,IN KPROCESSOR_MODE AccessMode)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    POBJECT_HEADER Header; </span><br><span class="line">    Header = OBJECT_TO_OBJECT_HEADER(Object); </span><br><span class="line">    <span class="keyword">if</span> ((Header-&gt;Type != ObjectType) &amp;&amp; ((AccessMode != KernelMode) || (ObjectType == ObSymbolicLinkType))) </span><br><span class="line">        <span class="keyword">return</span> STATUS_OBJECT_TYPE_MISMATCH; </span><br><span class="line">    InterlockedIncrement(&amp;Header-&gt;PointerCount);<span class="comment">//递增对象的引用计数 </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数其实是递增对象的引用计数而已</p>
<blockquote>
<p>手握一个引用计数后,就可以防止对象被析构释放,因为对象只有在引用计数减到 0 后才会释放,从而防止因对象析构引起的莫名其妙的崩溃</p>
</blockquote>
<p><br></p>
<h2 id="对象目录中的查找过程"><a href="#对象目录中的查找过程" class="headerlink" title="对象目录中的查找过程"></a>对象目录中的查找过程</h2><blockquote>
<p>给定一个对象名,如<code>&quot;\Device\Harddisk0\Partition0\Dir1\Dir2\File.txt&quot;</code>,如何查找到对应的对象呢？ </p>
</blockquote>
<p>这个路径先在对象目录中一路找到<code>\Device\Harddisk0\Partition0</code> 表示的磁盘卷设备对象,然后再沿着剩余路径<code>&quot;Dir1\Dir2\File.txt&quot;</code>找到对应的文件对象,不过后半部的查找过程是文件系统的事了,后面我将详细讲解。</p>
<p>这里看前半部的查找,是如何找到对应的卷设备的。<br>前文我们讲过了一个函数:<code>ObpLookupEntryDirectory</code>,那个函数用来在指定的目录中找到指定名称的子对 象,现在就需要沿着路径,反复调用这个函数找到我们的卷设备。</p>
<p>下面的函数就是用来这个目的的。可以给定任意一个起点目录,以及相对那个起点目录的任意长的路径,找到指定的对象。<br>这个函数的代码有点 长…(请做好心理准备),<br>原函数差不多有 800 行长,我做了粗略压缩,在我的详尽解释下,相信您可以看明白的。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ObpLookupObjectName</span><span class="params">(IN HANDLE RootHandle OPTIONAL,<span class="comment">//搜索的起点对象,如果为NULL,则表示根节点 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    IN PUNICODE_STRING ObjectName,<span class="comment">//相对RootHandle的路径或者全路径 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    IN ULONG Attributes,<span class="comment">//本次查找操作的属性(如是否忽略大小写) </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    IN POBJECT_TYPE ObjectType,<span class="comment">//要查的目标对象的类型 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    IN OUT PVOID ParseContext,<span class="comment">//其它 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    IN PVOID InsertObject OPTIONAL,<span class="comment">//如果不为NULL,则表示找不到就插入这个对象 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    IN OUT PACCESS_STATE AccessState,<span class="comment">//传入当前线程的令牌以及申请的访问权限 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    OUT POBP_LOOKUP_CONTEXT LookupContext,<span class="comment">//用来返回查找结果细节信息 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    OUT PVOID *FoundObject)</span><span class="comment">//返回最终找到的对象 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	*FoundObject = <span class="literal">NULL</span>;<span class="comment">//初始为未找到 PVOID Object=NULL;  </span></span><br><span class="line">	<span class="comment">//分别指相对当前起点对象的剩余路径、剩余路径中的第一个节点名 </span></span><br><span class="line">    UNICODE_STRING RemainingName, ComponentName; </span><br><span class="line">	BOOLEAN Reparse = FALSE, SymLink = FALSE;<span class="comment">//分别表示是否需要重新解析、是否为符号链接的标志 </span></span><br><span class="line">	<span class="comment">//表示搜索路径中当前的目录,父目录,以及起点目录 </span></span><br><span class="line">	POBJECT_DIRECTORY Directory = <span class="literal">NULL</span>, ParentDirectory = <span class="literal">NULL</span>, RootDirectory; </span><br><span class="line">	<span class="comment">//表示最终要插入到那个位置的叶目录及父目录 </span></span><br><span class="line">	POBJECT_DIRECTORY ReferencedDirectory = <span class="literal">NULL</span>, ReferencedParentDirectory = <span class="literal">NULL</span>; </span><br><span class="line">	OB_PARSE_METHOD ParseRoutine;<span class="comment">//对象自带的解析函数 </span></span><br><span class="line">	ULONG MaxReparse = <span class="number">30</span>;<span class="comment">//符号链接等,总的重新解析次数最大不能超过30次 </span></span><br><span class="line"></span><br><span class="line">	NTSTATUS  Status = STATUS_SUCCESS;<span class="comment">//预期找到成功 </span></span><br><span class="line">	ObpInitializeLookupContext(LookupContext); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(ObjectType) || (ObjectType-&gt;TypeInfo.CaseInsensitive)) </span><br><span class="line">		Attributes |= OBJ_CASE_INSENSITIVE;<span class="comment">//检查本类对象是否支持对象名可以忽略大小写 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (RootHandle)<span class="comment">//如果给定了搜索起点 </span></span><br><span class="line">	&#123; </span><br><span class="line">		Status = ObReferenceObjectByHandle(RootHandle,AccessMode, &amp;RootDirectory,…); </span><br><span class="line">		ObjectHeader = OBJECT_TO_OBJECT_HEADER(RootDirectory);<span class="comment">//得到起点对象 </span></span><br><span class="line">		<span class="keyword">if</span> (ObjectHeader-&gt;Type != ObDirectoryType)<span class="comment">//if给定的起点对象不是目录 </span></span><br><span class="line">		&#123; </span><br><span class="line">			ParseRoutine = ObjectHeader-&gt;Type-&gt;TypeInfo.ParseProcedure; </span><br><span class="line">			<span class="keyword">if</span> (!ParseRoutine)  <span class="keyword">return</span> STATUS_INVALID_HANDLE;<span class="comment">//非目录对象必须自带解析函数 </span></span><br><span class="line">			MaxReparse = <span class="number">30</span>; </span><br><span class="line">			<span class="keyword">while</span> (TRUE) </span><br><span class="line">			&#123; </span><br><span class="line">				RemainingName = *ObjectName;<span class="comment">//当前的剩余路径=初始路径 </span></span><br><span class="line">				Status = ParseRoutine(RootDirectory,<span class="comment">//起点 </span></span><br><span class="line">					ObjectType, </span><br><span class="line">					AccessState, </span><br><span class="line">					AccessCheckMode, </span><br><span class="line">					Attributes, </span><br><span class="line">					IN、OUT   ObjectName,<span class="comment">//传入初始全路径,可能传出新的初始路径 </span></span><br><span class="line">					IN、OUT   &amp;RemainingName,<span class="comment">//传入当前剩余路径,返回最终的剩余路径 </span></span><br><span class="line">					ParseContext, </span><br><span class="line">					&amp;Object);<span class="comment">//返回找到的对象</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// if自带解析函数解析完毕了,不要求重新解析 </span></span><br><span class="line">				<span class="keyword">if</span> ((Status != STATUS_REPARSE) &amp;&amp; (Status != STATUS_REPARSE_OBJECT)) </span><br><span class="line">				&#123; </span><br><span class="line">					<span class="keyword">if</span> (!NT_SUCCESS(Status))<span class="comment">//如果未能解析 </span></span><br><span class="line">						Object = <span class="literal">NULL</span>; </span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (!Object)<span class="comment">//如果未能找到目标对象 </span></span><br><span class="line">						Status = STATUS_OBJECT_NAME_NOT_FOUND; </span><br><span class="line">					</span><br><span class="line">					*FoundObject = Object;<span class="comment">//有可能找到的不是最终的目标对象 </span></span><br><span class="line">					<span class="keyword">return</span> Status;<span class="comment">//不管查找成功还是失败都从这儿返回了 </span></span><br><span class="line">				&#125; </span><br><span class="line">				<span class="comment">//if自带解析函数要求从根目录开始按新的初始路径重新解析 </span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> ( (ObjectName-&gt;Buffer[<span class="number">0</span>] == L”\\”) ) </span><br><span class="line">				&#123; </span><br><span class="line">					RootDirectory = ObpRootDirectoryObject; </span><br><span class="line">					RootHandle = <span class="literal">NULL</span>; </span><br><span class="line">					<span class="keyword">goto</span> ParseFromRoot;<span class="comment">//从根目录开始解析 </span></span><br><span class="line">				&#125; </span><br><span class="line">				<span class="comment">//if自带解析函数要求从指定对象开始重新解析剩余路径(很少见)                 </span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (--MaxReparse)<span class="comment">//如果未能超出最大重解析次数,就重定向解析 </span></span><br><span class="line">					<span class="keyword">continue</span>; </span><br><span class="line">				<span class="keyword">else</span><span class="comment">//如果超出了最大重解析次数,失败返回 </span></span><br><span class="line">				&#123; </span><br><span class="line"></span><br><span class="line">					*FoundObject = Object; </span><br><span class="line">					<span class="keyword">if</span> (!Object) Status = STATUS_OBJECT_NAME_NOT_FOUND; </span><br><span class="line">						<span class="keyword">return</span> Status; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	Else <span class="comment">//如果没有给定搜索起点,就从根目录开始搜索,把ObjectName参数当绝对路径使 </span></span><br><span class="line">	&#123; </span><br><span class="line">		RootDirectory = ObpRootDirectoryObject;<span class="comment">//搜素起点=根目录 </span></span><br><span class="line">		<span class="keyword">if</span> ( (ObjectName-&gt;Buffer[<span class="number">0</span>] != L”\\”))<span class="comment">//绝对路径必须以“\”开头 </span></span><br><span class="line">			<span class="keyword">return</span> STATUS_OBJECT_PATH_SYNTAX_BAD; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">ParseFromRoot: </span><br><span class="line">	<span class="keyword">if</span> (!SymLink) </span><br><span class="line">	&#123; </span><br><span class="line">		Reparse = TRUE;<span class="comment">//表示是否需要继续重新解析的标志,初始为真 </span></span><br><span class="line">		MaxReparse = <span class="number">30</span>;<span class="comment">//最多30次 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">while</span> (Reparse)<span class="comment">//这层循环表示处理每一轮从根目录开始的重新解析操作 </span></span><br><span class="line">	&#123; </span><br><span class="line">		RemainingName = *ObjectName;<span class="comment">//该轮重解析的新的初始剩余路径 </span></span><br><span class="line">		Reparse = FALSE;<span class="comment">//预期本次解析操作一次解析成功,不需要重定向解析 </span></span><br><span class="line">		<span class="keyword">while</span> (TRUE)<span class="comment">//遍历该轮重解析的路径中的各个节点 </span></span><br><span class="line">		&#123; </span><br><span class="line">			Object = <span class="literal">NULL</span>; </span><br><span class="line">			<span class="keyword">if</span> ((RemainingName.Length) &amp;&amp; (RemainingName.Buffer[<span class="number">0</span>] == L”\\”)) </span><br><span class="line">			&#123; </span><br><span class="line">				RemainingName.Buffer++; </span><br><span class="line">				RemainingName.Length -=<span class="number">2</span>; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//上面的操作跳过剩余路径中开头的\字符 </span></span><br><span class="line">			ComponentName = RemainingName;  </span><br><span class="line">			<span class="keyword">while</span> (RemainingName.Length) </span><br><span class="line">			&#123; </span><br><span class="line">				<span class="keyword">if</span> (RemainingName.Buffer[<span class="number">0</span>] == L”\\”) <span class="keyword">break</span>; </span><br><span class="line">				RemainingName.Buffer++; </span><br><span class="line">				RemainingName.Length -=<span class="number">2</span>; </span><br><span class="line">			&#125; </span><br><span class="line">			ComponentName.Length -= RemainingName.Length; </span><br><span class="line">			<span class="comment">//上面的操作获得当前剩余路径中的第一个节点名,即ComponentName </span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!Directory) Directory = RootDirectory;<span class="comment">//当前目录 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="comment">//检查当前线程的令牌是否含有遍历当前目录的权限(先检查令牌特权,再检查用户/组权) </span></span><br><span class="line">			<span class="keyword">if</span> (!(AccessState-&gt;Flags &amp; TOKEN_HAS_TRAVERSE_PRIVILEGE)) </span><br><span class="line">			&#123; </span><br><span class="line">				ReferencedDirectory = Directory; </span><br><span class="line">				<span class="keyword">if</span> (ParentDirectory) </span><br><span class="line">				&#123; </span><br><span class="line">					<span class="keyword">if</span> (!ObpCheckTraverseAccess(ParentDirectory, </span><br><span class="line">					        DIRECTORY_TRAVERSE,<span class="comment">//检查目录遍历权限 </span></span><br><span class="line">					        AccessState,AccessCheckMode,)) </span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//权限检查失败,退出整个函数 </span></span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">if</span> (RemainingName.Length==<span class="number">0</span>)<span class="comment">//if ComponentName是路径中的最后一个节点了 </span></span><br><span class="line">			&#123; </span><br><span class="line">				<span class="keyword">if</span> (!ReferencedDirectory) </span><br><span class="line">					ReferencedDirectory = Directory;<span class="comment">//记录叶目录是哪一个 </span></span><br><span class="line">				<span class="keyword">if</span> (InsertObject)<span class="comment">//要在叶目录中插入对象,必须锁定整个目录 </span></span><br><span class="line">					ObpAcquireDirectoryLockExclusive(Directory, LookupContext); </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//关键。查找剩余路径中的第一个节点(这个函数前面已分析过) </span></span><br><span class="line">			Object = ObpLookupEntryDirectory(Directory,&amp;ComponentName,Attributes, </span><br><span class="line">			     InsertObject ? FALSE : TRUE,LookupContext); </span><br><span class="line">			<span class="keyword">if</span> (!Object) </span><br><span class="line">			&#123; </span><br><span class="line">				<span class="keyword">if</span> (RemainingName.Length&gt;<span class="number">0</span>) </span><br><span class="line">				&#123; </span><br><span class="line">					Status = STATUS_OBJECT_PATH_NOT_FOUND; </span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//如果路径中间的某个目录不存在,失败退出整个函数 </span></span><br><span class="line">				&#125; </span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (InsertObject==<span class="literal">NULL</span>)<span class="comment">//if遍历完整个路径了 </span></span><br><span class="line">				&#123; </span><br><span class="line">					Status = STATUS_OBJECT_NAME_NOT_FOUND; </span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//如果找不到目标对象,又不要求插入新对象,失败返回整个函数(很常见) </span></span><br><span class="line">				&#125; </span><br><span class="line">				</span><br><span class="line"></span><br><span class="line">				<span class="comment">//if用户要求:找不到目标对象就插入一个(这就体现了该函数的另一功能) </span></span><br><span class="line">				<span class="comment">//先检查当前线程的令牌是否具有在这个目录中插入对象的权限 </span></span><br><span class="line">				<span class="keyword">if</span> (!ObCheckCreateObjectAccess(Directory, </span><br><span class="line">				       ObjectType == ObDirectoryType ? </span><br><span class="line">				       DIRECTORY_CREATE_SUBDIRECTORY : </span><br><span class="line">				       DIRECTORY_CREATE_OBJECT, </span><br><span class="line">				       AccessState, </span><br><span class="line">				       &amp;ComponentName)) <span class="comment">//子对象名 </span></span><br><span class="line">				&#123; </span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//没有插入权限,失败返回整个函数 </span></span><br><span class="line"></span><br><span class="line">				&#125; </span><br><span class="line">				ObpInsertEntryDirectory(Directory,LookupContext,ObjectHeader);<span class="comment">//插入目录中 ObjectHeader = OBJECT_TO_OBJECT_HEADER(InsertObject);</span></span><br><span class="line"></span><br><span class="line">				NewName = ExAllocatePoolWithTag(PagedPool,ComponentName.Length,tag); </span><br><span class="line">				ObjectNameInfo = OBJECT_HEADER_TO_NAME_INFO(ObjectHeader); </span><br><span class="line">				RtlCopyMemory(NewName,ComponentName.Buffer,ComponentName.Length); </span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (ObjectNameInfo-&gt;Name.Buffer)<span class="comment">//释放该对象原来的名字 </span></span><br><span class="line">					ExFreePoolWithTag(ObjectNameInfo-&gt;Name.Buffer, OB_NAME_TAG ); </span><br><span class="line">				ObjectNameInfo-&gt;Name.Buffer = NewName;<span class="comment">//设置新插入对象的名字 </span></span><br><span class="line">				ObjectNameInfo-&gt;Name.Length = ComponentName.Length; </span><br><span class="line">				ObjectNameInfo-&gt;Name.MaximumLength = ComponentName.Length; </span><br><span class="line">				</span><br><span class="line">				Status = STATUS_SUCCESS; </span><br><span class="line">				Object = InsertObject;<span class="comment">//成功返回 </span></span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			&#125; </span><br><span class="line"></span><br><span class="line">ReparseObject:<span class="comment">//如果找到了剩余路径中的第一个子节点(那个节点在对象目录中存在) </span></span><br><span class="line">			ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object); </span><br><span class="line">			ParseRoutine = ObjectHeader-&gt;Type-&gt;TypeInfo.ParseProcedure; </span><br><span class="line">			<span class="comment">//if这个节点自带有一个解析函数(那肯定不是目录) </span></span><br><span class="line">			<span class="keyword">if</span> ((ParseRoutine) &amp;&amp; (!(InsertObject) || (ParseRoutine == ObpParseSymbolicLink))) </span><br><span class="line">			&#123;    </span><br><span class="line">				Directory = <span class="literal">NULL</span>;<span class="comment">//不再有当前目录 </span></span><br><span class="line">				InterlockedExchangeAdd(&amp;ObjectHeader-&gt;PointerCount, <span class="number">1</span>); </span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (ReferencedDirectory) </span><br><span class="line">					ReferencedDirectory = <span class="literal">NULL</span>; </span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (ReferencedParentDirectory) </span><br><span class="line">					ReferencedParentDirectory = <span class="literal">NULL</span>; </span><br><span class="line">				<span class="comment">//调用这个对象自带的解析函数 </span></span><br><span class="line">				Status = ParseRoutine(Object,ObjectType,AccessState,AccessCheckMode, </span><br><span class="line">						Attributes, </span><br><span class="line">						IN、OUT ObjectName,<span class="comment">//初始的全路径,可能传出新的初始路径 </span></span><br><span class="line">						IN、OUT &amp;RemainingName,<span class="comment">//传入初始的剩余路径,传出最终的剩余路径 </span></span><br><span class="line">						ParseContext, </span><br><span class="line">						&amp;Object); </span><br><span class="line">				<span class="keyword">if</span> ((Status == STATUS_REPARSE) || <span class="comment">//要求从重根目录开始重新按新的初始路径解析 </span></span><br><span class="line">						(Status == STATUS_REPARSE_OBJECT))<span class="comment">//要求从指定对象开始重新解析剩余路径 </span></span><br><span class="line">				&#123; </span><br><span class="line">					<span class="keyword">if</span> ((Status == STATUS_REPARSE_OBJECT) || (ObjectName-&gt;Buffer[<span class="number">0</span>] == L”\\”)) </span><br><span class="line">					&#123; </span><br><span class="line">						RootHandle = <span class="literal">NULL</span>; </span><br><span class="line">						ParentDirectory = <span class="literal">NULL</span>; </span><br><span class="line">						RootDirectory = ObpRootDirectoryObject; </span><br><span class="line">						<span class="keyword">if</span> (Status == STATUS_REPARSE_OBJECT) </span><br><span class="line">						&#123; </span><br><span class="line">							Reparse = FALSE;<span class="comment">//不用回到最外层的循环,直接从内层位置重新解析 </span></span><br><span class="line">							<span class="keyword">goto</span> ReparseObject; </span><br><span class="line">						&#125; </span><br><span class="line">						<span class="keyword">else</span> </span><br><span class="line">						&#123; </span><br><span class="line">						 	Reparse = TRUE;<span class="comment">//重新回到外层循环从根目录开始解析 </span></span><br><span class="line">							SymLink = TRUE; </span><br><span class="line">							<span class="keyword">goto</span> ParseFromRoot; </span><br><span class="line">						&#125; </span><br><span class="line">					&#125; </span><br><span class="line">				&#125; </span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (!NT_SUCCESS(Status)) </span><br><span class="line">					Object = <span class="literal">NULL</span>; </span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (Object==<span class="literal">NULL</span>) </span><br><span class="line">					Status = STATUS_OBJECT_NAME_NOT_FOUND; </span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//失败返回整个函数 </span></span><br><span class="line">			&#125; </span><br><span class="line">			Else <span class="comment">//剩余路径中的第一个节点是个普通的目录或者是路径中的最后一个节点 </span></span><br><span class="line">			&#123; </span><br><span class="line">				<span class="keyword">if</span> (RemainingName.Length==<span class="number">0</span>)<span class="comment">//若找到的是最后一个节点 </span></span><br><span class="line">				&#123; </span><br><span class="line">					Status = ObReferenceObjectByPointer(Object,ObjectType,AccessMode); </span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//哈哈,终于舒口气了。成功返回找到的这个对象(最典型的情形) </span></span><br><span class="line">				&#125; </span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">				&#123; </span><br><span class="line">					<span class="comment">//若找到的是中间的某个普通目录,修改状态后,回到内层循环继续向后查找 </span></span><br><span class="line">					<span class="keyword">if</span> (ObjectHeader-&gt;Type == ObDirectoryType)  </span><br><span class="line">					&#123; </span><br><span class="line">						ReferencedParentDirectory = ReferencedDirectory; </span><br><span class="line">						ParentDirectory = Directory; </span><br><span class="line">						Directory = Object;<span class="comment">//修改当前目录为新的目录 </span></span><br><span class="line">						ReferencedDirectory = <span class="literal">NULL</span>; </span><br><span class="line">					&#125; </span><br><span class="line">					Else<span class="comment">//很少见 </span></span><br><span class="line">					&#123; </span><br><span class="line">						… </span><br><span class="line">					&#125; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面返回找到的对象 </span></span><br><span class="line"></span><br><span class="line">	*FoundObject = Object; </span><br><span class="line">	<span class="keyword">if</span> (Object==<span class="literal">NULL</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> ((Status == STATUS_REPARSE) || (NT_SUCCESS(Status))) </span><br><span class="line">			Status = STATUS_OBJECT_NAME_NOT_FOUND;<span class="comment">//强制转为查找失败 </span></span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此对象目录的查找过程也详尽分析结束了。<br>这个函数根据路径在对象目录中查找对象。</p>
<ul>
<li>如果找到了,就返回找到点额对象;</li>
<li>如果找不到,并且用户不要求插入新对象在那儿,就返回失败,否则插入用户指定的对象。</li>
</ul>
<blockquote>
<p>一个函数两种用途,后一个用途用于在创建对象时,把新创的有名对象插入对象目录<br>注意: 物理的磁盘卷设备对象、文件对象、注册表键对象以及符号链接对象都提供了自定义的名字解析函 数。关于具体对象类型的解析,以后的篇章会逐渐讲到。 </p>
</blockquote>
<h3 id="ObReferenceObjectByName"><a href="#ObReferenceObjectByName" class="headerlink" title="ObReferenceObjectByName"></a>ObReferenceObjectByName</h3><p>下面这个函数经常使用,但有诀窍<code>DDK</code>文档中并未公开这个函数,但是这个函数实际上是导出的,声明一下 就可以使用了<br>这个函数可以直接根据对象名,找到对应的对象(是不是很方便?)<br>其内部原理就是调用上面的函数在对象目录中查找对象(这个函数实际上是导出的,虽然 DDK 中并未有这个函数) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ObReferenceObjectByName</span><span class="params">(IN PUNICODE_STRING ObjectPath,<span class="comment">//对象的全路径(以\开头) </span></span></span></span><br><span class="line"><span class="function"><span class="params">                        IN ULONG Attributes,<span class="comment">//查找属性 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                        IN PACCESS_STATE PassedAccessState,<span class="comment">//传入的令牌和申请的权限,可选 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                        IN ACCESS_MASK DesiredAccess,<span class="comment">//申请的访问权限,与上面那个参数任选其一 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                        IN POBJECT_TYPE ObjectType,<span class="comment">//当AccessMode传KernelMode时,可忽略此参数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                        IN KPROCESSOR_MODE AccessMode,<span class="comment">//驱动程序中一般传KernelMode </span></span></span></span><br><span class="line"><span class="function"><span class="params">                        IN OUT PVOID ParseContext,<span class="comment">//其它 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                        OUT PVOID* ObjectPtr)</span><span class="comment">//返回找到的对象 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PVOID Object = <span class="literal">NULL</span>; </span><br><span class="line">	Status = ObpCaptureObjectName(&amp;ObjectName, ObjectPath, AccessMode, TRUE); </span><br><span class="line">	<span class="keyword">if</span> (!PassedAccessState)<span class="comment">//如果用户没传这个参数,就创建 </span></span><br><span class="line">	&#123; </span><br><span class="line">		PassedAccessState = &amp;AccessState; </span><br><span class="line">		<span class="comment">//将当前线程的令牌以及申请的访问权限记录到AccessState中 </span></span><br><span class="line">		Status = SeCreateAccessState(&amp;AccessState,&amp;AuxData,DesiredAccess, </span><br><span class="line">		&amp;ObjectType-&gt;TypeInfo.GenericMapping); </span><br><span class="line">	&#125; </span><br><span class="line">	*ObjectPtr = <span class="literal">NULL</span>; </span><br><span class="line">	Status = ObpLookupObjectName(<span class="literal">NULL</span>, <span class="comment">//看到没,NULL表示根目录 </span></span><br><span class="line">			&amp;ObjectName,<span class="comment">//绝对路径 </span></span><br><span class="line">			Attributes,<span class="comment">//查找属性 </span></span><br><span class="line">			ObjectType, </span><br><span class="line">			AccessMode, </span><br><span class="line"></span><br><span class="line">			ParseContext, </span><br><span class="line">			PassedAccessState,<span class="comment">//传入当前线程的令牌 </span></span><br><span class="line">			&amp;Context, </span><br><span class="line">			&amp;Object); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (ObpCheckObjectReference(Object, </span><br><span class="line">				PassedAccessState, <span class="comment">//传入当前线程的令牌 </span></span><br><span class="line">				AccessMode,&amp;Status)) </span><br><span class="line">			*ObjectPtr = Object; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如要找到名为即<code>DeviceName</code>等于<code>&quot;\Device\MyCdo&quot;</code>的设备对象这个函数典型的调用方法示例为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObReferenceObjectByName( </span><br><span class="line">			&amp;DeviceName, </span><br><span class="line">			OBJ_CASE_INSENSITIVE,<span class="comment">//大小写木敏感 NULL, //PassedAccessState FILE_ALL_ACCESS, //DesiredAccess IoDeviceObjectType,//也可以直接传NULL </span></span><br><span class="line">			KernelMode, </span><br><span class="line">			<span class="literal">NULL</span>, <span class="comment">//ParseContext (PVOID*)&amp;DeviceObject);//返回找到的设备对象</span></span><br></pre></td></tr></table></figure>
<h3 id="ObOpenObjectByPointer"><a href="#ObOpenObjectByPointer" class="headerlink" title="ObOpenObjectByPointer"></a>ObOpenObjectByPointer</h3><p>调用上面的那个函数后,可以根据对象名直接得到它的指针,得到指针后我们还可以趁此打开该对象以得到一个访问句柄</p>
<blockquote>
<p>因为有的场合我们不能使用对象指针,只能使用句柄。</p>
</blockquote>
<p>下面的函数就是这个用途<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ObOpenObjectByPointer</span><span class="params">(IN PVOID Object, </span></span></span><br><span class="line"><span class="function"><span class="params">                      IN ULONG HandleAttributes, </span></span></span><br><span class="line"><span class="function"><span class="params">                      IN PACCESS_STATE PassedAccessState, </span></span></span><br><span class="line"><span class="function"><span class="params">                      IN ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="function"><span class="params">                      IN POBJECT_TYPE ObjectType, </span></span></span><br><span class="line"><span class="function"><span class="params">                      IN KPROCESSOR_MODE AccessMode, </span></span></span><br><span class="line"><span class="function"><span class="params">                      OUT PHANDLE Handle)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	*Handle = <span class="literal">NULL</span>; </span><br><span class="line">	Status = ObReferenceObjectByPointer(Object,ObjectType,AccessMode);<span class="comment">//递增引用计数 </span></span><br><span class="line">	Header = OBJECT_TO_OBJECT_HEADER(Object); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!PassedAccessState)<span class="comment">//如果用户没传入一个令牌,就创建一个 </span></span><br><span class="line">	&#123; </span><br><span class="line">		PassedAccessState = &amp;AccessState; </span><br><span class="line">		Status = SeCreateAccessState(&amp;AccessState,&amp;AuxData,DesiredAccess, &amp;Header-&gt;Type-&gt;TypeInfo.GenericMapping); </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (Header-&gt;Type-&gt;TypeInfo.InvalidAttributes &amp; HandleAttributes)<span class="comment">//检查句柄属性是否支持 </span></span><br><span class="line">		<span class="keyword">return</span> STATUS_INVALID_PARAMETER; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//在句柄表中创建一个相应对象的句柄 </span></span><br><span class="line">	Status = ObpCreateHandle(ObOpenHandle,<span class="comment">//OpenReason </span></span><br><span class="line">		Object, </span><br><span class="line">		ObjectType, </span><br><span class="line">		PassedAccessState, </span><br><span class="line">		<span class="number">0</span>, </span><br><span class="line">		HandleAttributes, </span><br><span class="line">		<span class="literal">NULL</span>, </span><br><span class="line">		AccessMode, </span><br><span class="line">		<span class="literal">NULL</span>, </span><br><span class="line">		Handle);<span class="comment">//返回得到的句柄 </span></span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ObOpenObjectByName"><a href="#ObOpenObjectByName" class="headerlink" title="ObOpenObjectByName"></a>ObOpenObjectByName</h3><p>事实上更多的场合是,我们有一个对象的名称,想要打开那个对象,一步得到它的访问句柄(比如<code>OpenMutex</code>)。<br>因此下面的函数就是用于这个常用目的。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ObOpenObjectByName</span><span class="params">(IN POBJECT_ATTRIBUTES ObjectAttributes,<span class="comment">//对象的路径 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   IN POBJECT_TYPE ObjectType, </span></span></span><br><span class="line"><span class="function"><span class="params">                   IN KPROCESSOR_MODE AccessMode, </span></span></span><br><span class="line"><span class="function"><span class="params">                   IN PACCESS_STATE PassedAccessState,<span class="comment">//传入的令牌 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   IN ACCESS_MASK DesiredAccess,<span class="comment">//要求的访问权限 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   IN OUT PVOID ParseContext, </span></span></span><br><span class="line"><span class="function"><span class="params">                   OUT PHANDLE Handle)</span><span class="comment">//返回得到的句柄 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PVOID Object = <span class="literal">NULL</span>; </span><br><span class="line">	*Handle = <span class="literal">NULL</span>; </span><br><span class="line">	TempBuffer = ExAllocatePoolWithTag(NonPagedPool,<span class="keyword">sizeof</span>(OB_TEMP_BUFFER),tag); </span><br><span class="line">	Status = ObpCaptureObjectCreateInformation(ObjectAttributes, </span><br><span class="line">	                                       AccessMode, </span><br><span class="line">	                                       &amp;TempBuffer-&gt;ObjectCreateInfo, </span><br><span class="line">	                                       &amp;ObjectName); </span><br><span class="line">	<span class="keyword">if</span> (!PassedAccessState) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (ObjectType) GenericMapping = &amp;ObjectType-&gt;TypeInfo.GenericMapping; </span><br><span class="line">		PassedAccessState = &amp;TempBuffer-&gt;LocalAccessState; </span><br><span class="line">		Status = SeCreateAccessState(&amp;TempBuffer-&gt;LocalAccessState,&amp;TempBuffer-&gt;AuxData, </span><br><span class="line">		                             DesiredAccess,GenericMapping); </span><br><span class="line">	&#125; 	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用这个函数完成真正的查找工作 </span></span><br><span class="line">	Status = ObpLookupObjectName(TempBuffer-&gt;ObjectCreateInfo.RootDirectory, </span><br><span class="line">	                         &amp;ObjectName, </span><br><span class="line">	                         TempBuffer-&gt;ObjectCreateInfo.Attributes, </span><br><span class="line">	                         ObjectType, </span><br><span class="line">	                         AccessMode, </span><br><span class="line">	                         ParseContext, </span><br><span class="line">	                         <span class="literal">NULL</span>, </span><br><span class="line">	                         PassedAccessState, </span><br><span class="line">	                         &amp;TempBuffer-&gt;LookupContext, </span><br><span class="line">	                         &amp;Object); </span><br><span class="line">	ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object); </span><br><span class="line">	<span class="keyword">if</span> (ObjectHeader-&gt;Flags &amp; OB_FLAG_CREATE_INFO) </span><br><span class="line">	&#123; </span><br><span class="line">		OpenReason = ObCreateHandle;<span class="comment">//说明对象正在创建过程中(也即创建对象时就打开一个句柄) </span></span><br><span class="line">		<span class="keyword">if</span> (ObjectHeader-&gt;ObjectCreateInfo) </span><br><span class="line">		&#123; </span><br><span class="line">			ObpFreeObjectCreateInformation(ObjectHeader-&gt;ObjectCreateInfo);  </span><br><span class="line">			ObjectHeader-&gt;ObjectCreateInfo = <span class="literal">NULL</span>; <span class="comment">//对象打开得到句柄后就不再需要保留创建信息 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	Else <span class="comment">//典型情况:说明是对象创建完后的普通显式打开操作(非创建时打开) </span></span><br><span class="line">		OpenReason = ObOpenHandle; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ObjectHeader-&gt;Type-&gt;TypeInfo.InvalidAttributes &amp; TempBuffer-&gt;ObjectCreateInfo.Attributes) </span><br><span class="line">	&#123; </span><br><span class="line">		Status = STATUS_INVALID_PARAMETER; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//在句柄表中创建句柄 </span></span><br><span class="line">		Status = ObpCreateHandle(OpenReason, </span><br><span class="line">		                         Object, </span><br><span class="line">		                         ObjectType, </span><br><span class="line">		                         PassedAccessState, </span><br><span class="line">		                         <span class="number">0</span>, </span><br><span class="line">		                         TempBuffer-&gt;ObjectCreateInfo.Attributes, </span><br><span class="line">		                         &amp;TempBuffer-&gt;LookupContext, </span><br><span class="line">		                         AccessMode, </span><br><span class="line">		                         <span class="literal">NULL</span>, </span><br><span class="line">		                         Handle); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ObDereferenceObject"><a href="#ObDereferenceObject" class="headerlink" title="ObDereferenceObject"></a>ObDereferenceObject</h3><p>下面是递减对象引用计数的函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG  <span class="title">ObDereferenceObject</span><span class="params">(IN PVOID Object)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	Header = OBJECT_TO_OBJECT_HEADER(Object); </span><br><span class="line">	<span class="keyword">if</span> (Header-&gt;PointerCount &lt; Header-&gt;HandleCount) </span><br><span class="line">		<span class="keyword">return</span> Header-&gt;PointerCount;<span class="comment">//引用计数必须&gt;=句柄计数(因为句柄也是一种引用) </span></span><br><span class="line">	NewCount = InterlockedDecrement(&amp;Header-&gt;PointerCount);<span class="comment">//递减 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (NewCount==<span class="number">0</span>)<span class="comment">//引用计数递减到0后才删除对象 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (!KeAreAllApcsDisabled()) </span><br><span class="line">		    ObpDeleteObject(Object, FALSE);<span class="comment">//立即删除该对象 </span></span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		    ObpDeferObjectDeletion(Header);<span class="comment">//让后台的系统工作线程延迟删除这个对象 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> NewCount;<span class="comment">//返回递减后的值 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function">VOID  <span class="title">ObpDeleteObject</span><span class="params">(IN PVOID Object, IN BOOLEAN CalledFromWorkerThread)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	Header = OBJECT_TO_OBJECT_HEADER(Object); </span><br><span class="line">	ObjectType = Header-&gt;Type; </span><br><span class="line">	NameInfo = OBJECT_HEADER_TO_NAME_INFO(Header); </span><br><span class="line">	CreatorInfo = OBJECT_HEADER_TO_CREATOR_INFO(Header); </span><br><span class="line">	<span class="keyword">if</span> ((CreatorInfo) &amp;&amp; !(IsListEmpty(&amp;CreatorInfo-&gt;TypeList))) </span><br><span class="line">		RemoveEntryList(&amp;CreatorInfo-&gt;TypeList);<span class="comment">//从对象类型的对象链表中移除该对象 </span></span><br><span class="line">	<span class="keyword">if</span> ((NameInfo) &amp;&amp; (NameInfo-&gt;Name.Buffer)) </span><br><span class="line">		ExFreePool(NameInfo-&gt;Name.Buffer);  <span class="keyword">if</span> (Header-&gt;SecurityDescriptor)  。。。 </span><br><span class="line">	<span class="keyword">if</span> (ObjectType-&gt;TypeInfo.DeleteProcedure)<span class="comment">//调用对象类型自身提供的删除函数 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (!CalledFromWorkerThread) </span><br><span class="line">			Header-&gt;Flags |= OB_FLAG_DEFER_DELETE; </span><br><span class="line">		ObjectType-&gt;TypeInfo.DeleteProcedure(Object); </span><br><span class="line">	&#125; </span><br><span class="line">	ObpDeallocateObject(Object);<span class="comment">//内部调用ExFreePool最终释放对象结构体本身 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上两个函数说明:对象的引用计数一旦减到0,就释放对象及其相关其它结构从系统中消失 </p>
<p><br></p>
<h2 id="句柄的遗传和复制"><a href="#句柄的遗传和复制" class="headerlink" title="句柄的遗传和复制"></a>句柄的遗传和复制</h2><p>说到句柄请自觉建立起这样一个完整概念:<code>&quot;具有指定权限和属性的访问句柄&quot;</code>。<br>一个句柄代表一次对对象的打开操作(句柄最终的目的是用来访问对象的,因此叫<code>&quot;访问句柄&quot;</code>)<br>句柄的权限指本次打开指定对象时,当初申请得到的访问权限,以后凡是使用基于这个句柄的操作都不能超出当初打开时申请得到的访问权限(如打开文件时申请的权限是读)<br>那么使用那个<code>hFile</code>调用<code>WriteFile</code>,将拒绝访问,即使当前用户拥有对那个文件的写权限。 </p>
<p>句柄的属性则有重要的一条:是否可继承给子进程。(句柄在打开时通过<code>OBJ_INHERIT</code>标志指示可否继承)</p>
<h3 id="CreateProcess"><a href="#CreateProcess" class="headerlink" title="CreateProcess"></a>CreateProcess</h3><p>Win32 API<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcess</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">	LPCTSTR lpApplicationName,                 </span></span></span><br><span class="line"><span class="function"><span class="params">	LPTSTR lpCommandLine,                       </span></span></span><br><span class="line"><span class="function"><span class="params">	LPSECURITY_ATTRIBUTES  lpProcessAttributes,  </span></span></span><br><span class="line"><span class="function"><span class="params">	LPSECURITY_ATTRIBUTES  lpThreadAttributes,   </span></span></span><br><span class="line"><span class="function"><span class="params">	BOOL bInheritHandles, <span class="comment">//指是否继承父进程的句柄表中那些可继承的句柄 </span></span></span></span><br><span class="line"><span class="function"><span class="params">	......</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>父进程句柄表中的每个可继承句柄<code>继承</code>到子进程句柄表中的对应索引位置<br>这样父子进程就可以使用同一个句柄值,找到同一个内核对象。</p>
<p>这就是<code>&quot;继承&quot;</code>一词的由来。<br>我们知道各个句柄(除开内核型句柄)在各个进程中不能通用,但一旦继承给子进程后,就可以通用了。</p>
<h3 id="ExDupHandleTable"><a href="#ExDupHandleTable" class="headerlink" title="ExDupHandleTable"></a>ExDupHandleTable</h3><p>下面这个函数用来给子进程创建一个句柄表,并从父进程中复制句柄表项达到继承。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PHANDLE_TABLE <span class="title">ExDupHandleTable</span><span class="params">(IN PEPROCESS Process,<span class="comment">//子进程 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 IN PHANDLE_TABLE HandleTable,<span class="comment">//父进程的句柄表 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 IN PEX_DUPLICATE_HANDLE_CALLBACK DupHandleProcedure)</span><span class="comment">//辅助回调函数 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BOOLEAN Failed = FALSE; </span><br><span class="line">	NewTable = ExpAllocateHandleTable(Process, FALSE);<span class="comment">//句柄表描述符结构体 </span></span><br><span class="line">	<span class="keyword">while</span> (NewTable-&gt;NextHandleNeedingPool &lt; HandleTable-&gt;NextHandleNeedingPool) </span><br><span class="line">		ExpAllocateHandleTableEntrySlow(NewTable, FALSE);<span class="comment">//分配与父句柄表对应大小的内存 </span></span><br><span class="line">	</span><br><span class="line">	NewTable-&gt;HandleCount = <span class="number">0</span>;<span class="comment">//有效句柄个数 </span></span><br><span class="line">	NewTable-&gt;FirstFree = <span class="number">0</span>;<span class="comment">//第一个空闲表项的位置 </span></span><br><span class="line"></span><br><span class="line">	Handle.Value = SizeOfHandle(<span class="number">1</span>);<span class="comment">//索引位置 </span></span><br><span class="line">	<span class="comment">//遍历父句柄表中的每个表项,复制到子句柄表 </span></span><br><span class="line">	<span class="keyword">while</span> ((NewEntry = ExpLookupHandleTableEntry(NewTable, Handle))) </span><br><span class="line">	&#123; </span><br><span class="line">		HandleTableEntry = ExpLookupHandleTableEntry(HandleTable, Handle);<span class="comment">//得到父表项 </span></span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123; </span><br><span class="line">		    <span class="keyword">if</span> (!(HandleTableEntry-&gt;Value &amp; OBJ_INHERIT))<span class="comment">//if 该父句柄不可继承 </span></span><br><span class="line">		        Failed = TRUE; </span><br><span class="line">		    <span class="keyword">else</span><span class="comment">//if 该父句柄可继承 </span></span><br><span class="line">		    &#123; </span><br><span class="line">		        <span class="keyword">if</span> (!ExpLockHandleTableEntry(HandleTable, HandleTableEntry)) </span><br><span class="line">		            Failed = TRUE;<span class="comment">//句柄表锁定失败,不管他 </span></span><br><span class="line">		        <span class="keyword">else</span> </span><br><span class="line">		        &#123; </span><br><span class="line">		            <span class="comment">//检查是否可复制,若可以,就递增对象的句柄计数、引用计数,然后复制句柄项 </span></span><br><span class="line">		            <span class="keyword">if</span> (DupHandleProcedure(Process,HandleTable,HandleTableEntry,NewEntry)) </span><br><span class="line">		            &#123; </span><br><span class="line">		                *NewEntry = *HandleTableEntry;<span class="comment">//关键。完完全全复制句柄表项 </span></span><br><span class="line">		                Failed = FALSE; </span><br><span class="line">		                NewEntry-&gt;Value |= EXHANDLE_TABLE_ENTRY_LOCK_BIT; </span><br><span class="line">		                NewTable-&gt;HandleCount++; </span><br><span class="line">		            &#125; </span><br><span class="line">		            <span class="keyword">else</span> </span><br><span class="line">		                Failed = TRUE; </span><br><span class="line">		        &#125; </span><br><span class="line">		    &#125; </span><br><span class="line">		    <span class="keyword">if</span> (Failed)<span class="comment">//若不可复制 </span></span><br><span class="line">		    &#123; </span><br><span class="line">		        NewEntry-&gt;Object = <span class="literal">NULL</span>;<span class="comment">//标记为一个无效的句柄 </span></span><br><span class="line">		        NewEntry-&gt;NextFreeTableEntry = NewTable-&gt;FirstFree; </span><br><span class="line">		        NewTable-&gt;FirstFree = Handle.Value; </span><br><span class="line">		    &#125; </span><br><span class="line">		    Handle.Value += SizeOfHandle(<span class="number">1</span>); </span><br><span class="line">		    NewEntry++;<span class="comment">//下一个句柄 </span></span><br><span class="line">		    HandleTableEntry++;<span class="comment">//下一个句柄 </span></span><br><span class="line">		&#125; <span class="keyword">while</span> (Handle.Value % SizeOfHandle(LOW_LEVEL_ENTRIES)); </span><br><span class="line">		Handle.Value += SizeOfHandle(<span class="number">1</span>);  </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//将句柄表插入到全局链表中(这也是一个检测隐藏的方法) </span></span><br><span class="line">	InsertTailList(&amp;HandleTableListHead, &amp;NewTable-&gt;HandleTableList);  </span><br><span class="line">	<span class="keyword">return</span> NewTable;<span class="comment">//返回给子进程创建的句柄表 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="句柄的关闭"><a href="#句柄的关闭" class="headerlink" title="句柄的关闭"></a>句柄的关闭</h2><p>Win32 API <code>CloseHandle</code>、<code>closesocket</code>会在内部调用<code>NtClose</code>,最终会调用到下面的内核函数来关闭句柄。 </p>
<h3 id="ObpCloseHandle"><a href="#ObpCloseHandle" class="headerlink" title="ObpCloseHandle"></a>ObpCloseHandle</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS  <span class="title">ObpCloseHandle</span><span class="params">(IN HANDLE Handle,IN KPROCESSOR_MODE AccessMode)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BOOLEAN AttachedToProcess = FALSE; </span><br><span class="line">	PEPROCESS Process = PsGetCurrentProcess(); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ObIsKernelHandle(Handle, AccessMode))<span class="comment">//内核句柄(即“system”进程中的句柄) </span></span><br><span class="line">	&#123; </span><br><span class="line">		HandleTable = ObpKernelHandleTable; </span><br><span class="line">		Handle = ObKernelHandleToHandle(Handle); </span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Process != PsInitialSystemProcess) </span><br><span class="line">		&#123; </span><br><span class="line">			KeStackAttachProcess(&amp;PsInitialSystemProcess-&gt;Pcb, &amp;ApcState);<span class="comment">//挂靠到system进程 </span></span><br><span class="line">			AttachedToProcess = TRUE; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	    HandleTable = Process-&gt;ObjectTable;<span class="comment">//典型,使用当前进程的句柄 </span></span><br><span class="line">	</span><br><span class="line">	HandleTableEntry = ExMapHandleToPointer(HandleTable, Handle);<span class="comment">//得到对应的句柄表项 </span></span><br><span class="line">	<span class="keyword">if</span> (HandleTableEntry) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//调用下面的这个函数真正完成句柄关闭工作 </span></span><br><span class="line">	    Status = ObpCloseHandleTableEntry(HandleTable,HandleTableEntry,Handle,AccessMode); </span><br><span class="line">	    <span class="keyword">if</span> (AttachedToProcess) KeUnstackDetachProcess(&amp;ApcState); </span><br><span class="line">	    Status = STATUS_SUCCESS; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (AttachedToProcess) KeUnstackDetachProcess(&amp;ApcState); </span><br><span class="line">		Status = STATUS_INVALID_HANDLE;<span class="comment">//返回无效句柄错误 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ObpCloseHandleTableEntry"><a href="#ObpCloseHandleTableEntry" class="headerlink" title="ObpCloseHandleTableEntry"></a>ObpCloseHandleTableEntry</h3><p>实际的句柄关闭工作是下面这个函数<code>ObpCloseHandleTableEntry</code>,请详细看     </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ObpCloseHandleTableEntry</span><span class="params">(IN PHANDLE_TABLE HandleTable, </span></span></span><br><span class="line"><span class="function"><span class="params">                         IN PHANDLE_TABLE_ENTRY HandleEntry, </span></span></span><br><span class="line"><span class="function"><span class="params">                         IN HANDLE Handle, </span></span></span><br><span class="line"><span class="function"><span class="params">                         IN KPROCESSOR_MODE AccessMode)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	ObjectHeader = ObpGetHandleObject(HandleEntry); </span><br><span class="line">	ObjectType = ObjectHeader-&gt;Type; </span><br><span class="line">	Body = &amp;ObjectHeader-&gt;Body; </span><br><span class="line">	GrantedAccess = HandleEntry-&gt;GrantedAccess; </span><br><span class="line">	<span class="comment">//关闭句柄前,检查对象的当前状态是否可以关闭一个句柄 </span></span><br><span class="line">	<span class="keyword">if</span> (ObjectType-&gt;TypeInfo.OkayToCloseProcedure) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (!ObjectType-&gt;TypeInfo.OkayToCloseProcedure(CurProcess,Body,Handle,AccessMode)) </span><br><span class="line">			<span class="keyword">return</span> STATUS_HANDLE_NOT_CLOSABLE; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//再检查句柄本身是否可以关闭 </span></span><br><span class="line">	<span class="keyword">if</span> ( HandleEntry-&gt;ObAttributes &amp; OBJ_PROTECT_CLOSE ) </span><br><span class="line">		<span class="keyword">return</span> STATUS_HANDLE_NOT_CLOSABLE; </span><br><span class="line">	ExDestroyHandle(HandleTable, Handle, HandleEntry);<span class="comment">//关键,将对应位置处的句柄标记为空闲 </span></span><br><span class="line">	ObpDecrementHandleCount(Body,CurProcess,GrantedAccess,ObjectType);<span class="comment">//递减总的句柄计数 </span></span><br><span class="line">	ObDereferenceObject(Body);<span class="comment">//同时递减一个引用计数(句柄本身也占据一个引用) </span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">ObpDecrementHandleCount</span><span class="params">(IN PVOID ObjectBody,IN PEPROCESS Process, </span></span></span><br><span class="line"><span class="function"><span class="params">                        IN ACCESS_MASK GrantedAccess,IN POBJECT_TYPE ObjectType)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ObjectHeader = OBJECT_TO_OBJECT_HEADER(ObjectBody); </span><br><span class="line">    OldHandleCount = ObjectHeader-&gt;HandleCount; </span><br><span class="line"></span><br><span class="line">	NewCount = InterlockedDecrement(&amp;ObjectHeader-&gt;HandleCount);<span class="comment">//递减句柄计数 ProcessHandleCount = 当前进程对该对象持有的句柄计数； </span></span><br><span class="line">	<span class="keyword">if</span> (ObjectType-&gt;TypeInfo.MaintainHandleCount)  &#123;  递减对应进程对该对象的句柄计数； &#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//每次关闭句柄时都会调用对象类型注册的句柄关闭时函数,如文件对象类提供了IopCloseFile </span></span><br><span class="line">    <span class="keyword">if</span> (ObjectType-&gt;TypeInfo.CloseProcedure) </span><br><span class="line">        ObjectType-&gt;TypeInfo.CloseProcedure(Process,ObjectBody,GrantedAccess, </span><br><span class="line">                                            ProcessHandleCount,OldHandleCount); </span><br><span class="line">    ObpDeleteNameCheck(ObjectBody);<span class="comment">//这个函数在非永久对象的句柄一关完后,就把对象移出对象目录 </span></span><br><span class="line">    InterlockedDecrement((PLONG)&amp;ObjectType-&gt;TotalNumberOfHandles); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上每次关闭前都会检查句柄是否可以关闭,然后关闭句柄,调用注册的句柄关闭时函数。</p>
<h3 id="IopCloseFile"><a href="#IopCloseFile" class="headerlink" title="IopCloseFile"></a>IopCloseFile</h3><p>文件对象类自己注册了一个句柄关闭函数<code>IopCloseFile</code>文件句柄在关完后的工作如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">IopCloseFile</span><span class="params">(IN PEPROCESS Process OPTIONAL,IN PVOID ObjectBody,IN ACCESS_MASK GrantedAccess, </span></span></span><br><span class="line"><span class="function"><span class="params">             IN ULONG HandleCount,<span class="comment">//关闭句柄前,当前进程对该对象持有的句柄计数 IN ULONG SystemHandleCount)// 关闭句柄前,该对象总的句柄计数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">&#123; </span></span></span><br><span class="line"><span class="function"><span class="params">	PFILE_OBJECT FileObject = (PFILE_OBJECT)</span>ObjectBody</span>; </span><br><span class="line">	<span class="keyword">if</span> (HandleCount != <span class="number">1</span>) <span class="keyword">return</span>; </span><br><span class="line">	<span class="keyword">if</span> (SystemHandleCount != <span class="number">1</span>) <span class="keyword">return</span>; </span><br><span class="line">	<span class="comment">//上面两条语句说明,文件对象只有在所有句柄都关完后才做下面的附加工作 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (FileObject-&gt;Flags &amp; FO_DIRECT_DEVICE_OPEN) </span><br><span class="line">	    DeviceObject = IoGetAttachedDevice(FileObject-&gt;DeviceObject);<span class="comment">//物理磁盘卷设备 </span></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	    DeviceObject = IoGetRelatedDeviceObject(FileObject);<span class="comment">//文件系统中的卷设备   </span></span><br><span class="line">	FileObject-&gt;Flags |= FO_HANDLE_CREATED; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FileObject-&gt;Flags &amp; FO_SYNCHRONOUS_IO) IopLockFileObject(FileObject); </span><br><span class="line">	KeClearEvent(&amp;FileObject-&gt;Event); </span><br><span class="line">	KeInitializeEvent(&amp;Event, SynchronizationEvent, FALSE); </span><br><span class="line"></span><br><span class="line">	Irp = IoAllocateIrp(DeviceObject-&gt;StackSize, FALSE); </span><br><span class="line">	Irp-&gt;UserEvent = &amp;Event; </span><br><span class="line">	Irp-&gt;UserIosb = &amp;Irp-&gt;IoStatus; </span><br><span class="line">	Irp-&gt;Tail.Overlay.Thread = PsGetCurrentThread(); </span><br><span class="line">	Irp-&gt;Tail.Overlay.OriginalFileObject = FileObject; </span><br><span class="line">	Irp-&gt;Overlay.AsynchronousParameters.UserApcRoutine = <span class="literal">NULL</span>; </span><br><span class="line">	Irp-&gt;Flags = IRP_CLOSE_OPERATION | IRP_SYNCHRONOUS_API; </span><br><span class="line">	</span><br><span class="line">	StackPtr = IoGetNextIrpStackLocation(Irp); </span><br><span class="line">	StackPtr-&gt;MajorFunction = IRP_MJ_CLEANUP;<span class="comment">//关键 </span></span><br><span class="line">	StackPtr-&gt;FileObject = FileObject; </span><br><span class="line">	IopQueueIrpToThread(Irp);<span class="comment">//将该irp挂入线程的irp队列 </span></span><br><span class="line">	</span><br><span class="line">	Status = IoCallDriver(DeviceObject, Irp);<span class="comment">//发出irp </span></span><br><span class="line">	<span class="keyword">if</span> (Status == STATUS_PENDING) </span><br><span class="line">	    KeWaitForSingleObject(&amp;Event, UserRequest, KernelMode, FALSE, <span class="literal">NULL</span>); </span><br><span class="line">	</span><br><span class="line">	KeRaiseIrql(APC_LEVEL, &amp;OldIrql); </span><br><span class="line">	IopUnQueueIrpFromThread(Irp); </span><br><span class="line">	KeLowerIrql(OldIrql); </span><br><span class="line">	IoFreeIrp(Irp); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FileObject-&gt;Flags &amp; FO_SYNCHRONOUS_IO) IopUnlockFileObject(FileObject); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上在文件对象的所有句柄关闭了时,系统会生成一个<code>IRP_MJ_CLEANUP</code>irp。<br>另外文件对象在引用计数递减到0后,在最后销毁前,会生成<code>IRP_MJ_CLOSE</code> irp。</p>
<blockquote>
<p>简单一句话【柄完清理、引完关闭】,这两个irp 的产生时机是非常重要的。 </p>
</blockquote>
<p><br><br><br></p>
<h1 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h1><p>本篇主要讲述进程的启动过程、线程的调度与切换、进程挂靠 </p>
<h2 id="进程的启动过程"><a href="#进程的启动过程" class="headerlink" title="进程的启动过程"></a>进程的启动过程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcess</span> <span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">	LPCTSTR lpApplicationName,                <span class="comment">// </span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPTSTR lpCommandLine,                     <span class="comment">// command line string </span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPSECURITY_ATTRIBUTES lpProcessAttributes, <span class="comment">// SD </span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPSECURITY_ATTRIBUTES lpThreadAttributes, <span class="comment">// SD </span></span></span></span><br><span class="line"><span class="function"><span class="params">	BOOL bInheritHandles,                    <span class="comment">//  </span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwCreationFlags,                   <span class="comment">// creation flags </span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPVOID lpEnvironment,                    <span class="comment">// new environment block </span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPCTSTR lpCurrentDirectory,              <span class="comment">// current directory name </span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPSTARTUPINFO lpStartupInfo,              <span class="comment">// startup information </span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPPROCESS_INFORMATION lpProcessInformation <span class="comment">// process information </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个 Win32API 在内部最终调用如下: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcess</span><span class="params">(„)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	„ </span><br><span class="line">	NtCreateProcess(„);<span class="comment">//间接调用这个系统服务,先创建进程 </span></span><br><span class="line">	NtCreateThread(„);<span class="comment">//间接调用这个系统服务,再创建该进程的第一个线程(也即主线程) </span></span><br><span class="line">	„ </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进程的<code>4GB</code>地址空间分两部分,<code>内核空间</code>+<code>用户空间</code>看下面几个定义:</p>
<ul>
<li><code>#define MmSystemRangeStart  0x80000000</code> //系统空间的起点 </li>
<li><code>#define MM_USER_PROB_ADDRESS MmSystemRangeStart-64kb</code> //除去高端的 64kb 隔离区 </li>
<li><code>#define MM_HIGHEST_USER_ADDRESS   MmUserProbAddress-1</code> //实际的用户空间中最高可访问地址 </li>
<li><code>#define MM_LOWEST_USER_ADDRESS  64kb</code> //实际的用户空间中最低可访问地址 </li>
<li><code>#define KI_USER_SHARED_DATA 0xffdf0000</code> //内核空间与用户空间共享的一块区域 由此可见,用户地址</li>
</ul>
<p>空间的范围实际上是从<code>64kb----&gt;0x80000000-64kb</code>这块区域。 </p>
<blockquote>
<p>访问<code>NULL</code>指针报异常的原因就是<code>NULL(0)</code>落在了最前面的<code>64kb</code>保留区中 </p>
</blockquote>
<p>内核中提供了一个全局结构变量,该结构的类型是<code>KUSER_SHARED_DATA</code>。<br>内核中的那个结构体变量所在的虚拟页面起始地址为:<code>0xffdf0000</code>大小为一个页面大小。</p>
<p>这个内核页面对应的物理内存页面也映射到了每个进程的用户地址空间中,而且是固定映在同一处:<code>0x7ffe0000</code>。<br>这样用户空间的程序直接访问用户空间中的这个虚拟地址,就相当于直接访问了内核空间中的那个公共页面。</p>
<p>所以那个内核页面称之为内核空间提供给各个进程的一块共享之地。</p>
<blockquote>
<p>事实上这个公共页面非常有用,可以在这个页面中放置代码,应用程序直接在 r3 层运行这些代码 如在内核中进行<code>IAT hook</code></p>
</blockquote>
<p>如上【用户空间的范围就是低<code>2GB</code>的空间除去前后<code>64kb</code>后的那块区域】 </p>
<h2 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h2><p>圈定了用户空间的地皮后,现在就到了划分用户空间的时候了。<br>用户空间的布局:(以区段(<code>Area</code>)为单位进行划分)</p>
<h3 id="MmInitializeProcessAddressSpace"><a href="#MmInitializeProcessAddressSpace" class="headerlink" title="MmInitializeProcessAddressSpace"></a>MmInitializeProcessAddressSpace</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MmInitializeProcessAddressSpace</span><span class="params">(IN PEPROCESS Process,IN PVOID Section,IN OUT PULONG Flags)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	NTSTATUS Status = STATUS_SUCCESS; </span><br><span class="line">	SIZE_T ViewSize = <span class="number">0</span>; </span><br><span class="line">	PVOID ImageBase = <span class="number">0</span>; </span><br><span class="line">	PROS_SECTION_OBJECT SectionObject = Section; </span><br><span class="line">	USHORT Length = <span class="number">0</span>; </span><br><span class="line">	… </span><br><span class="line">	KeAttachProcess(&amp;Process-&gt;Pcb);<span class="comment">//必须将当前线程挂靠到子进程的地址空间 Process-&gt;AddressSpaceInitialized = 2; </span></span><br><span class="line">	<span class="keyword">if</span> (SectionObject) </span><br><span class="line">	&#123; </span><br><span class="line">	    FileName = SectionObject-&gt;FileObject-&gt;FileName; </span><br><span class="line">	    Source = (PWCHAR)((PCHAR)FileName.Buffer + FileName.Length); </span><br><span class="line">	    <span class="keyword">if</span> (FileName.Buffer) </span><br><span class="line">	    &#123; </span><br><span class="line">	        <span class="keyword">while</span> (Source &gt; FileName.Buffer) </span><br><span class="line">	        &#123; </span><br><span class="line">	            <span class="keyword">if</span> (*--Source ==L”\\”) </span><br><span class="line">	            &#123; </span><br><span class="line">	                Source++; </span><br><span class="line">	                <span class="keyword">break</span>; </span><br><span class="line">	            &#125; </span><br><span class="line">	            <span class="keyword">else</span> </span><br><span class="line">	                Length++; </span><br><span class="line">	        &#125; </span><br><span class="line">	    &#125; </span><br><span class="line">	    Destination = Process-&gt;ImageFileName;<span class="comment">//任务管理器显示的进程名就是这个(大小写相同) </span></span><br><span class="line">	    Length = min(Length, <span class="keyword">sizeof</span>(Process-&gt;ImageFileName) - <span class="number">1</span>); </span><br><span class="line">	    <span class="keyword">while</span> (Length--) *Destination++ = (UCHAR)*Source++; </span><br><span class="line">	    *Destination = ’\<span class="number">0</span>’; </span><br><span class="line">	     </span><br><span class="line">	    <span class="comment">//将进程的exe文件映射到地址空间中 </span></span><br><span class="line">	    Status = MmMapViewOfSection(Section,Process,&amp;ImageBase,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">NULL</span>,&amp;ViewSize,<span class="number">0</span>, </span><br><span class="line">	                                MEM_COMMIT,…); </span><br><span class="line">	    Process-&gt;SectionBaseAddress = ImageBase;<span class="comment">//记录实际映射到的地址(一般为0x00400000) </span></span><br><span class="line">	&#125;     </span><br><span class="line">	KeDetachProcess();<span class="comment">//撤销挂靠 </span></span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数将进程的 exe 文件映射到用户地址空间中(注意 exe 文件内部是分开按节映射)</p>
<h3 id="PspMapSystemDll"><a href="#PspMapSystemDll" class="headerlink" title="PspMapSystemDll"></a>PspMapSystemDll</h3><p>映射(即加载)exe文件后,再映射<code>ntdll.dll</code>到用户空间(事实上固定映到某处)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS  <span class="title">PspMapSystemDll</span><span class="params">(PEPROCESS Process,PVOID *DllBase,BOOLEAN UseLargePages)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    LARGE_INTEGER Offset = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;; </span><br><span class="line">	SIZE_T ViewSize = <span class="number">0</span>; </span><br><span class="line">	PVOID ImageBase = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将NTDLL.dll文件映射到地址空间(每个NTDLL.dll事实上都映射到所有进程地址空间的同一处) </span></span><br><span class="line">    Status = MmMapViewOfSection(PspSystemDllSection,Process,&amp;ImageBase,<span class="number">0</span>,<span class="number">0</span>,&amp;Offset,&amp;ViewSiz e, ViewShare,<span class="number">0</span>,…); </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DllBase) *DllBase = ImageBase; </span><br><span class="line">    <span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数将<code>ntdll.dll</code>映射到地址空间下面这个函数创建该进程的<code>PEB</code></p>
<h3 id="MmCreatePeb"><a href="#MmCreatePeb" class="headerlink" title="MmCreatePeb"></a>MmCreatePeb</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS  <span class="title">MmCreatePeb</span><span class="params">(PEPROCESS Process,PINITIAL_PEB InitialPeb,OUT PPEB *BasePeb)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PPEB Peb = <span class="literal">NULL</span>; </span><br><span class="line">	SIZE_T ViewSize = <span class="number">0</span>; </span><br><span class="line">	PVOID TableBase = <span class="literal">NULL</span>; </span><br><span class="line">	KAFFINITY ProcessAffinityMask = <span class="number">0</span>; </span><br><span class="line">	SectionOffset.QuadPart = (ULONGLONG)<span class="number">0</span>; </span><br><span class="line">	*BasePeb = <span class="literal">NULL</span>; </span><br><span class="line">	KeAttachProcess(&amp;Process-&gt;Pcb);<span class="comment">//因为PEB指针是子进程中的地址,所以要挂靠 </span></span><br><span class="line">	<span class="comment">//创建一个PEB </span></span><br><span class="line">	Status = MiCreatePebOrTeb(Process, <span class="keyword">sizeof</span>(PEB), (PULONG_PTR)&amp;Peb); </span><br><span class="line">	RtlZeroMemory(Peb, <span class="keyword">sizeof</span>(PEB)); </span><br><span class="line">	<span class="comment">//根据传入的InitialPeb参数初始化新建的peb </span></span><br><span class="line">	Peb-&gt;InheritedAddressSpace = InitialPeb-&gt;InheritedAddressSpace; </span><br><span class="line">	Peb-&gt;Mutant = InitialPeb-&gt;Mutant; </span><br><span class="line">	Peb-&gt;ImageUsesLargePages = InitialPeb-&gt;ImageUsesLargePages; </span><br><span class="line"></span><br><span class="line">	Peb-&gt;ImageBaseAddress = Process-&gt;SectionBaseAddress;<span class="comment">// </span></span><br><span class="line">	Peb-&gt;OSMajorVersion = NtMajorVersion; Peb-&gt;OSMinorVersion = NtMinorVersion; </span><br><span class="line">	Peb-&gt;OSBuildNumber = (USHORT)(NtBuildNumber &amp; <span class="number">0x3FFF</span>); </span><br><span class="line">	Peb-&gt;OSPlatformId = <span class="number">2</span>; <span class="comment">/* VER_PLATFORM_WIN32_NT */</span> </span><br><span class="line">	Peb-&gt;OSCSDVersion = (USHORT)CmNtCSDVersion; </span><br><span class="line">	 </span><br><span class="line">	Peb-&gt;NumberOfProcessors = KeNumberProcessors; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//经典的两个调试检测标志 </span></span><br><span class="line">	Peb-&gt;BeingDebugged = (BOOLEAN)(Process-&gt;DebugPort != <span class="literal">NULL</span> ? TRUE : FALSE); </span><br><span class="line">	Peb-&gt;NtGlobalFlag = NtGlobalFlag; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Peb-&gt;MaximumNumberOfHeaps = (PAGE_SIZE - <span class="keyword">sizeof</span>(PEB)) / <span class="keyword">sizeof</span>(PVOID); </span><br><span class="line">	Peb-&gt;ProcessHeaps = (PVOID*)(Peb + <span class="number">1</span>);<span class="comment">//PEB结构体后面是一个堆数组 </span></span><br><span class="line"></span><br><span class="line">	NtHeaders = RtlImageNtHeader(Peb-&gt;ImageBaseAddress);<span class="comment">//获取文件头中的NT头 </span></span><br><span class="line">	Characteristics = NtHeaders-&gt;FileHeader.Characteristics; </span><br><span class="line">	<span class="keyword">if</span> (NtHeaders) </span><br><span class="line">	&#123; </span><br><span class="line">		_SEH2_TRY </span><br><span class="line">		&#123; </span><br><span class="line">		    ImageConfigData = RtlImageDirectoryEntryToData(Peb-&gt;ImageBaseAddress,TRUE, </span><br><span class="line">		                              IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,&amp;ViewSize); </span><br><span class="line">		    Peb-&gt;ImageSubsystem = NtHeaders-&gt;OptionalHeader.Subsystem; </span><br><span class="line">		    Peb-&gt;ImageSubsystemMajorVersion = NtHeaders-&gt;OptionalHeader.MajorSubsystemVersio n; </span><br><span class="line">		    Peb-&gt;ImageSubsystemMinorVersion = NtHeaders-&gt;OptionalHeader.MinorSubsystemVersio n; </span><br><span class="line">		    <span class="keyword">if</span> (NtHeaders-&gt;OptionalHeader.Win32VersionValue) </span><br><span class="line">		    &#123; </span><br><span class="line">		        Peb-&gt;OSMajorVersion = NtHeaders-&gt;OptionalHeader.Win32VersionValue &amp; <span class="number">0xFF</span>; </span><br><span class="line">		        Peb-&gt;OSMinorVersion = (NtHeaders-&gt;OptionalHeader.Win32VersionValue &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>; </span><br><span class="line">		        Peb-&gt;OSBuildNumber = (NtHeaders-&gt;OptionalHeader.Win32VersionValue &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x3FFF</span>; </span><br><span class="line">		        Peb-&gt;OSPlatformId = (NtHeaders-&gt;OptionalHeader.Win32VersionValue &gt;&gt; <span class="number">30</span>) ^ <span class="number">2</span>; </span><br><span class="line">		    &#125; </span><br><span class="line">		     </span><br><span class="line">		    <span class="keyword">if</span> (ImageConfigData != <span class="literal">NULL</span>) </span><br><span class="line">		    &#123; </span><br><span class="line">		        ProbeForRead(ImageConfigData,<span class="keyword">sizeof</span>(IMAGE_LOAD_CONFIG_DIRECTORY), </span><br><span class="line">		                     <span class="keyword">sizeof</span>(ULONG));<span class="comment">//读取pe文件中的加载配置信息 </span></span><br><span class="line">		        <span class="keyword">if</span> (ImageConfigData-&gt;CSDVersion) </span><br><span class="line">		            Peb-&gt;OSCSDVersion = ImageConfigData-&gt;CSDVersion; </span><br><span class="line">		        <span class="keyword">if</span> (ImageConfigData-&gt;ProcessAffinityMask) </span><br><span class="line">		            ProcessAffinityMask = ImageConfigData-&gt;ProcessAffinityMask; </span><br><span class="line">		    &#125; </span><br><span class="line">		    <span class="keyword">if</span> (Characteristics &amp; IMAGE_FILE_UP_SYSTEM_ONLY) </span><br><span class="line">		        Peb-&gt;ImageProcessAffinityMask = <span class="number">0</span>; </span><br><span class="line">		    <span class="keyword">else</span> </span><br><span class="line">		        Peb-&gt;ImageProcessAffinityMask = ProcessAffinityMask; </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">		&#123; </span><br><span class="line">		    KeDetachProcess(); </span><br><span class="line"></span><br><span class="line">		    _SEH2_YIELD(<span class="keyword">return</span> STATUS_INVALID_IMAGE_PROTECT); </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_END; </span><br><span class="line">	&#125; </span><br><span class="line">	KeDetachProcess(); </span><br><span class="line">	*BasePeb = Peb; </span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上上面这个函数为进程创建一个<code>PEB</code>并根据<code>exe</code>文件头中的某些信息初始化里面的某些字段事实上<br>这个<code>PEB</code>结构体的地址固定安排在<code>0x7FFDF000</code>处,占据一个页面大小。<br>该页中这个<code>PEB</code>结构体后面就是一个堆数组,存放该进程中创建的所有堆。 </p>
<h3 id="BasepInitializeEnvironment"><a href="#BasepInitializeEnvironment" class="headerlink" title="BasepInitializeEnvironment"></a>BasepInitializeEnvironment</h3><p>下面的函数为子进程分配一个参数块(即创建参数)和环境变量块(即环境变量字符串)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">BasepInitializeEnvironment</span><span class="params">(HANDLE ProcessHandle,PPEB Peb,<span class="comment">//子进程的Peb </span></span></span></span><br><span class="line"><span class="function"><span class="params">                           LPWSTR ApplicationPathName,LPWSTR lpCurrentDirectory, </span></span></span><br><span class="line"><span class="function"><span class="params">                           LPWSTR lpCommandLine, </span></span></span><br><span class="line"><span class="function"><span class="params">                           LPVOID lpEnvironment,<span class="comment">//传给子进程的环境变量块 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                           SIZE_T EnvSize,<span class="comment">//环境变量块的大小 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                           LPSTARTUPINFOW StartupInfo,DWORD CreationFlags, </span></span></span><br><span class="line"><span class="function"><span class="params">                           BOOL InheritHandles)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PRTL_USER_PROCESS_PARAMETERS RemoteParameters = <span class="literal">NULL</span>; </span><br><span class="line">	PPEB OurPeb = NtCurrentPeb();<span class="comment">//当前进程(即父进程)的Peb </span></span><br><span class="line">	LPVOID Environment = lpEnvironment; </span><br><span class="line">	RetVal = GetFullPathNameW(ApplicationPathName, MAX_PATH,FullPath,&amp;Remaining); </span><br><span class="line">	RtlInitUnicodeString(&amp;ImageName, FullPath); </span><br><span class="line">	RtlInitUnicodeString(&amp;CommandLine, lpCommandLine); </span><br><span class="line">	RtlInitUnicodeString(&amp;CurrentDirectory, lpCurrentDirectory); </span><br><span class="line">	<span class="keyword">if</span> (StartupInfo-&gt;lpTitle) </span><br><span class="line">	    RtlInitUnicodeString(&amp;Title, StartupInfo-&gt;lpTitle); </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	    RtlInitUnicodeString(&amp;Title, <span class="string">L""</span>); </span><br><span class="line">	Status = RtlCreateProcessParameters(&amp;ProcessParameters,&amp;ImageName, </span><br><span class="line">	                                    lpCurrentDirectory ?&amp;CurrentDirectory : <span class="literal">NULL</span>, </span><br><span class="line">	                                    &amp;CommandLine,Environment,&amp;Title,..); </span><br><span class="line">	<span class="keyword">if</span> (Environment) </span><br><span class="line">	    Environment = ScanChar = ProcessParameters-&gt;Environment; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	    Environment = ScanChar = OurPeb-&gt;ProcessParameters-&gt;Environment; </span><br><span class="line">	<span class="keyword">if</span> (ScanChar) </span><br><span class="line">	&#123; </span><br><span class="line">		   EnviroSize =CalcEnvSize(ScanChar);<span class="comment">//计算环境变量块的长度 </span></span><br><span class="line"></span><br><span class="line">	    Size = EnviroSize; </span><br><span class="line">	    <span class="comment">//为子进程分配一个环境变量块(跨进程远程分配内存) </span></span><br><span class="line">	    Status = ZwAllocateVirtualMemory(ProcessHandle, </span><br><span class="line">	                                     (PVOID*)&amp;ProcessParameters-&gt;Environment, </span><br><span class="line">	                                     <span class="number">0</span>,&amp;Size,MEM_COMMIT,PAGE_READWRITE); </span><br><span class="line">	    <span class="comment">//将环境变量块复制到子进程的空间中 </span></span><br><span class="line">	    ZwWriteVirtualMemory(ProcessHandle,ProcessParameters-&gt;Environment, </span><br><span class="line">	                         Environment, </span><br><span class="line">	                         EnviroSize, </span><br><span class="line">	                         <span class="literal">NULL</span>); </span><br><span class="line">	&#125; </span><br><span class="line">	ProcessParameters-&gt;StartingX = StartupInfo-&gt;dwX; </span><br><span class="line">	ProcessParameters-&gt;StartingY = StartupInfo-&gt;dwY; </span><br><span class="line">	ProcessParameters-&gt;CountX = StartupInfo-&gt;dwXSize; </span><br><span class="line">	ProcessParameters-&gt;CountY = StartupInfo-&gt;dwYSize; </span><br><span class="line">	ProcessParameters-&gt;CountCharsX = StartupInfo-&gt;dwXCountChars; </span><br><span class="line">	ProcessParameters-&gt;CountCharsY = StartupInfo-&gt;dwYCountChars; </span><br><span class="line">	ProcessParameters-&gt;FillAttribute = StartupInfo-&gt;dwFillAttribute; </span><br><span class="line">	ProcessParameters-&gt;WindowFlags = StartupInfo-&gt;dwFlags; </span><br><span class="line">	ProcessParameters-&gt;ShowWindowFlags = StartupInfo-&gt;wShowWindow; </span><br><span class="line">	<span class="keyword">if</span> (StartupInfo-&gt;dwFlags &amp; STARTF_USESTDHANDLES)<span class="comment">//让子进程使用自定义的三个标准IO句柄 </span></span><br><span class="line">	&#123;  <span class="comment">//经常用于匿名管道重定向 </span></span><br><span class="line">	    ProcessParameters-&gt;StandardInput = StartupInfo-&gt;hStdInput; </span><br><span class="line">	    ProcessParameters-&gt;StandardOutput = StartupInfo-&gt;hStdOutput; </span><br><span class="line">	    ProcessParameters-&gt;StandardError = StartupInfo-&gt;hStdError; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (CreationFlags &amp; DETACHED_PROCESS) </span><br><span class="line">	    ProcessParameters-&gt;ConsoleHandle = HANDLE_DETACHED_PROCESS; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (CreationFlags &amp; CREATE_NO_WINDOW) </span><br><span class="line">	    ProcessParameters-&gt;ConsoleHandle = HANDLE_CREATE_NO_WINDOW; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (CreationFlags &amp; CREATE_NEW_CONSOLE) </span><br><span class="line">	    ProcessParameters-&gt;ConsoleHandle = HANDLE_CREATE_NEW_CONSOLE; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">	<span class="comment">//让子进程继承父进程的控制台句柄 </span></span><br><span class="line">	    ProcessParameters-&gt;ConsoleHandle = OurPeb-&gt;ProcessParameters-&gt;ConsoleHandle; </span><br><span class="line">	    <span class="comment">//让子进程继承父进程的三个标准句柄 </span></span><br><span class="line">	    <span class="keyword">if</span> (!(StartupInfo-&gt;dwFlags &amp; </span><br><span class="line">	               (STARTF_USESTDHANDLES | STARTF_USEHOTKEY | STARTF_SHELLPRIVATE))) </span><br><span class="line">	    &#123; </span><br><span class="line">	        BasepCopyHandles(ProcessParameters,OurPeb-&gt;ProcessParameters,InheritHandles); </span><br><span class="line">	    &#125; </span><br><span class="line">	&#125; </span><br><span class="line">	Size = ProcessParameters-&gt;Length;<span class="comment">//参数块本身的长度 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//在子进程中分配一个参数块 </span></span><br><span class="line">	Status = NtAllocateVirtualMemory(ProcessHandle,&amp;RemoteParameters,<span class="number">0</span>,&amp;Size, </span><br><span class="line">	                                 MEM_COMMIT,PAGE_READWRITE); ProcessParameters-&gt;MaximumLength = Size; </span><br><span class="line">	<span class="comment">//在子进程中分配一个参数块 </span></span><br><span class="line">	Status = NtWriteVirtualMemory(ProcessHandle,RemoteParameters,ProcessParameters, </span><br><span class="line">	                              ProcessParameters-&gt;Length,<span class="literal">NULL</span>); </span><br><span class="line">	<span class="comment">//将参数块复制到子进程的地址空间中 </span></span><br><span class="line">	Status = NtWriteVirtualMemory(ProcessHandle, </span><br><span class="line">	                              &amp;Peb-&gt;ProcessParameters, </span><br><span class="line">	                              &amp;RemoteParameters, </span><br><span class="line">	                              <span class="keyword">sizeof</span>(PVOID), </span><br><span class="line">	                              <span class="literal">NULL</span>); </span><br><span class="line">	RtlDestroyProcessParameters(ProcessParameters); </span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="BasepCreateFirstThread"><a href="#BasepCreateFirstThread" class="headerlink" title="BasepCreateFirstThread"></a>BasepCreateFirstThread</h3><p>下面的函数创建第一个线程的(用户栈、内核栈、初始内核栈帧)   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">BasepCreateFirstThread</span><span class="params">(HANDLE ProcessHandle,LPSECURITY_ATTRIBUTES lpThreadAttributes, </span></span></span><br><span class="line"><span class="function"><span class="params">                       PSECTION_IMAGE_INFORMATION SectionImageInfo,PCLIENT_ID ClientId)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BasepCreateStack(ProcessHandle, </span><br><span class="line">	                 SectionImageInfo-&gt;MaximumStackSize,<span class="comment">//默认为1MB </span></span><br><span class="line">	                 SectionImageInfo-&gt;CommittedStackSize,<span class="comment">//默认为4kb </span></span><br><span class="line">	                 &amp;InitialTeb);<span class="comment">//创建(即分配)该线程的用户栈 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 	BasepInitializeContext(&amp;Context, </span><br><span class="line"> 		NtCurrentPeb(),<span class="comment">//赋给context.ebx </span></span><br><span class="line"> 		SectionImageInfo-&gt;TransferAddress,<span class="comment">//赋给context.eax(也即oep) </span></span><br><span class="line"> 		InitialTeb.StackBase,<span class="comment">// 赋给context.esp </span></span><br><span class="line"> 		<span class="number">0</span>);<span class="comment">//0表示是主线程的用户空间总入口 </span></span><br><span class="line">	</span><br><span class="line">	ObjectAttributes = BasepConvertObjectAttributes(&amp;LocalObjectAttributes, </span><br><span class="line">	                                                lpThreadAttributes,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	Status = NtCreateThread(&amp;hThread,THREAD_ALL_ACCESS,ObjectAttributes,ProcessHandle, </span><br><span class="line">							ClientId,&amp;Context,&amp;InitialTeb,TRUE);     </span><br><span class="line"></span><br><span class="line">	Status = BasepNotifyCsrOfThread(hThread, ClientId);<span class="comment">//通知csrss进程线程创建通知 </span></span><br><span class="line">	<span class="keyword">return</span> hThread; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BasepCreateStack"><a href="#BasepCreateStack" class="headerlink" title="BasepCreateStack"></a>BasepCreateStack</h4><p>下面的函数用来分配一个用户栈(每个线程都要分配一个)【栈底、栈顶、提交界】                                                       </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">BasepCreateStack</span><span class="params">(HANDLE hProcess, </span></span></span><br><span class="line"><span class="function"><span class="params">                 SIZE_T StackReserve,<span class="comment">//栈的保留大小。默认为1MB </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 SIZE_T StackCommit,<span class="comment">//初始提交大小。默认为4KB,一个页面 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 OUT PINITIAL_TEB InitialTeb)</span><span class="comment">//用来构造初始teb </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	ULONG_PTR Stack = <span class="literal">NULL</span>; </span><br><span class="line">	BOOLEAN UseGuard = FALSE; </span><br><span class="line">	Status = NtQuerySystemInformation(SystemBasicInformation,&amp;SystemBasicInfo, </span><br><span class="line">	                              <span class="keyword">sizeof</span>(SYSTEM_BASIC_INFORMATION),<span class="literal">NULL</span>); </span><br><span class="line">	<span class="keyword">if</span> (hProcess == NtCurrentProcess()) </span><br><span class="line">	&#123; </span><br><span class="line">		Headers = RtlImageNtHeader(NtCurrentPeb()-&gt;ImageBaseAddress); </span><br><span class="line">		StackReserve = (StackReserve) ?  </span><br><span class="line">		                StackReserve : Headers-&gt;OptionalHeader.SizeOfStackReserve; </span><br><span class="line">		StackCommit = (StackCommit) ?  </span><br><span class="line">		                StackCommit : Headers-&gt;OptionalHeader.SizeOfStackCommit; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		StackReserve = (StackReserve) ? StackReserve :SystemBasicInfo.AllocationGranularity; </span><br><span class="line">		StackCommit = (StackCommit) ? StackCommit : SystemBasicInfo.PageSize; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//栈的区段长度对齐64kb </span></span><br><span class="line">    StackReserve = ROUND_UP(StackReserve, SystemBasicInfo.AllocationGranularity); </span><br><span class="line">    StackCommit = ROUND_UP(StackCommit, SystemBasicInfo.PageSize); </span><br><span class="line"> </span><br><span class="line">	<span class="comment">//预定这么大小的栈(默认1MB) </span></span><br><span class="line">	Status = ZwAllocateVirtualMemory(hProcess, (PVOID*)&amp;Stack,<span class="number">0</span>,&amp;StackReserve,MEM_RESERVE, </span><br><span class="line">	                         PAGE_READWRITE); </span><br><span class="line">	InitialTeb-&gt;AllocatedStackBase = (PVOID)Stack;<span class="comment">//栈区段的分配基址 </span></span><br><span class="line">	InitialTeb-&gt;StackBase = (PVOID)(Stack + StackReserve);<span class="comment">//栈底 </span></span><br><span class="line"></span><br><span class="line">	Stack += StackReserve - StackCommit; </span><br><span class="line">	<span class="keyword">if</span> (StackReserve &gt; StackCommit) </span><br><span class="line">	&#123; </span><br><span class="line">		UseGuard = TRUE; </span><br><span class="line">		Stack -= SystemBasicInfo.PageSize;  </span><br><span class="line">		StackCommit += SystemBasicInfo.PageSize; <span class="comment">//多提交一个保护页 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//初始提交这么大小的页面(也就是最常见的一个页外加一个保护页的大小) </span></span><br><span class="line">	Status = ZwAllocateVirtualMemory(hProcess, (PVOID*)&amp;Stack,<span class="number">0</span>,&amp;StackCommit,MEM_COMMIT, </span><br><span class="line">	                         PAGE_READWRITE); </span><br><span class="line"></span><br><span class="line">	InitialTeb-&gt;StackLimit = (PVOID)Stack;<span class="comment">// StackLimit表示第一个尚未提交页的边界 </span></span><br><span class="line">	<span class="keyword">if</span> (UseGuard) </span><br><span class="line">	&#123; </span><br><span class="line">		SIZE_T GuardPageSize = SystemBasicInfo.PageSize;     </span><br><span class="line"></span><br><span class="line">		Status = ZwProtectVirtualMemory(hProcess, (PVOID*)&amp;Stack,&amp;GuardPageSize, </span><br><span class="line">		                            PAGE_GUARD | PAGE_READWRITE);<span class="comment">//改为PAGE_GUARD属性 </span></span><br><span class="line">		InitialTeb-&gt;StackLimit = (PVOID)((ULONG_PTR)InitialTeb-&gt;StackLimit - GuardPageSize); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BasepInitializeContext"><a href="#BasepInitializeContext" class="headerlink" title="BasepInitializeContext"></a>BasepInitializeContext</h4><p>下面这个函数构造该线程的初始寄存器上下文</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">BasepInitializeContext</span><span class="params">(IN PCONTEXT Context,IN PVOID Parameter,IN PVOID StartAddress, </span></span></span><br><span class="line"><span class="function"><span class="params">                       IN PVOID StackAddress,IN ULONG ContextType)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	Context-&gt;Eax = (ULONG)StartAddress;<span class="comment">//oep或用户指定的线程入口函数 </span></span><br><span class="line">	Context-&gt;Ebx = (ULONG)Parameter;<span class="comment">//peb </span></span><br><span class="line">	Context-&gt;Esp = (ULONG)StackAddress;<span class="comment">//栈底就是初始栈顶 </span></span><br><span class="line">	Context-&gt;SegFs = KGDT_R3_TEB | RPL_MASK;<span class="comment">//fs指向TEB </span></span><br><span class="line">	Context-&gt;SegEs = KGDT_R3_DATA | RPL_MASK; </span><br><span class="line">	Context-&gt;SegDs = KGDT_R3_DATA | RPL_MASK; </span><br><span class="line">	Context-&gt;SegCs = KGDT_R3_CODE | RPL_MASK; </span><br><span class="line">	Context-&gt;SegSs = KGDT_R3_DATA | RPL_MASK; </span><br><span class="line">	Context-&gt;SegGs = <span class="number">0</span>; </span><br><span class="line">	Context-&gt;EFlags = <span class="number">0x3000</span>; <span class="comment">// IOPL 3  </span></span><br><span class="line">	<span class="keyword">if</span> (ContextType == <span class="number">1</span>)    </span><br><span class="line">	    Context-&gt;Eip = (ULONG)BaseThreadStartupThunk; <span class="comment">//普通线程的用户空间总入口 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ContextType == <span class="number">2</span>) <span class="comment">//纤程 </span></span><br><span class="line">	    Context-&gt;Eip = (ULONG)BaseFiberStartup; </span><br><span class="line">	<span class="keyword">else</span>      </span><br><span class="line">	    Context-&gt;Eip = (ULONG)BaseProcessStartThunk; <span class="comment">//主线程的用户空间总入口 </span></span><br><span class="line">	Context-&gt;ContextFlags = CONTEXT_FULL;<span class="comment">//所有字段全部有效 </span></span><br><span class="line">	Context-&gt;Esp -= <span class="keyword">sizeof</span>(PVOID);<span class="comment">//腾出参数空间 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MmCreateTeb"><a href="#MmCreateTeb" class="headerlink" title="MmCreateTeb"></a>MmCreateTeb</h4><p>当线程创建起来后,会紧跟着创建它的<code>teb</code>。现在暂时不看<code>NtCreateThread</code>是怎样实现的,看一下<code>teb</code>的创建过程。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MmCreateTeb</span><span class="params">(IN PEPROCESS Process, </span></span></span><br><span class="line"><span class="function"><span class="params">            IN PCLIENT_ID ClientId,<span class="comment">//线程的客户id即【进程id.线程id】 </span></span></span></span><br><span class="line"><span class="function"><span class="params">            IN PINITIAL_TEB InitialTeb, </span></span></span><br><span class="line"><span class="function"><span class="params">            OUT PTEB *BaseTeb)</span><span class="comment">//返回teb的地址 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	NTSTATUS Status = STATUS_SUCCESS; </span><br><span class="line">	*BaseTeb = <span class="literal">NULL</span>; </span><br><span class="line">	KeAttachProcess(&amp;Process-&gt;Pcb);<span class="comment">//挂靠到子进程地址空间 </span></span><br><span class="line">	Status = MiCreatePebOrTeb(Process, <span class="keyword">sizeof</span>(TEB), (PULONG_PTR)&amp;Teb);<span class="comment">//从peb处往低地址端搜索 </span></span><br><span class="line">	</span><br><span class="line">	_SEH2_TRY </span><br><span class="line">	&#123; </span><br><span class="line">		RtlZeroMemory(Teb, <span class="keyword">sizeof</span>(TEB)); </span><br><span class="line">		Teb-&gt;NtTib.ExceptionList = <span class="number">-1</span>;<span class="comment">//初始是没有seh </span></span><br><span class="line">		Teb-&gt;NtTib.Self = (PNT_TIB)Teb;<span class="comment">//将self指向指针结构的地址,方便寻址 </span></span><br><span class="line">		Teb-&gt;NtTib.Version = <span class="number">30</span> &lt;&lt; <span class="number">8</span>; </span><br><span class="line">		Teb-&gt;ClientId = *ClientId; </span><br><span class="line">		Teb-&gt;RealClientId = *ClientId; </span><br><span class="line">		Teb-&gt;ProcessEnvironmentBlock = Process-&gt;Peb;<span class="comment">//关键,teb中有个指针指向peb </span></span><br><span class="line">		Teb-&gt;CurrentLocale = PsDefaultThreadLocaleId; </span><br><span class="line">		<span class="keyword">if</span> ((InitialTeb-&gt;PreviousStackBase == <span class="literal">NULL</span>) &amp;&amp; </span><br><span class="line">		                             (InitialTeb-&gt;PreviousStackLimit == <span class="literal">NULL</span>)) </span><br><span class="line">		&#123; </span><br><span class="line">			Teb-&gt;NtTib.StackBase = InitialTeb-&gt;StackBase;<span class="comment">//栈底 </span></span><br><span class="line">		    Teb-&gt;NtTib.StackLimit = InitialTeb-&gt;StackLimit;<span class="comment">//提交边界(最近未提交页的地址) </span></span><br><span class="line">		    Teb-&gt;DeallocationStack = InitialTeb-&gt;AllocatedStackBase; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123; </span><br><span class="line">		    Teb-&gt;NtTib.StackBase = InitialTeb-&gt;PreviousStackBase; </span><br><span class="line">		    Teb-&gt;NtTib.StackLimit = InitialTeb-&gt;PreviousStackLimit; </span><br><span class="line">		&#125; </span><br><span class="line">		Teb-&gt;StaticUnicodeString.MaximumLength = <span class="keyword">sizeof</span>(Teb-&gt;StaticUnicodeBuffer); </span><br><span class="line">		Teb-&gt;StaticUnicodeString.Buffer = Teb-&gt;StaticUnicodeBuffer; </span><br><span class="line">	&#125; </span><br><span class="line">	_SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">	&#123; </span><br><span class="line">		Status = _SEH2_GetExceptionCode(); </span><br><span class="line">	&#125; </span><br><span class="line">	_SEH2_END; </span><br><span class="line">		KeDetachProcess(); </span><br><span class="line">	</span><br><span class="line">	*BaseTeb = Teb; </span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样经过以上的操作后,进程用户空间的典型布局就定出来了。 </p>
<p>—————————————————————————————–&gt; </p>
<table>
<thead>
<tr>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>- </th>
</tr>
</thead>
<tbody>
<tr>
<td>64kb</td>
<td>64kb</td>
<td>64kb</td>
<td>一般1MB</td>
<td>一般在0x00400000处</td>
<td>n*4KB</td>
<td>4kb</td>
<td>4kb</td>
<td>60kb</td>
<td>64kb</td>
<td>0x80000000开始</td>
</tr>
<tr>
<td>禁区</td>
<td>环境变量块</td>
<td>参数块</td>
<td>主线程的栈</td>
<td>其它空间</td>
<td>exe文件各个节</td>
<td>其他空间</td>
<td>各teb</td>
<td>peb</td>
<td>内核用户共享区</td>
<td>无效区, 隔离区, 系统空间</td>
</tr>
</tbody>
</table>
<p>—————————————————————————————–&gt;</p>
<blockquote>
<p> 用户空间的布局:一句口诀【环、参、栈、文、堆、t、p】 </p>
</blockquote>
<h2 id="进程-amp-线程的创建"><a href="#进程-amp-线程的创建" class="headerlink" title="进程&amp;线程的创建"></a>进程&amp;线程的创建</h2><blockquote>
<p>流程分析<br>1.NtCreateThread函数中检查地址参数是否合法和可写,保存Teb作为PspCreateThread传入参数。<br>2.StartRoutine是否有值来决定当前模式是内核/用户模式。为NULL,通过ETHREAD-&gt;Tcb获得运行模式。<br>3.由ProcessHandle参数获得相应的进程对象,保存在局部变量Process。<br>4.调用ObCreateObject 创建ETHREAD的一个对象。<br>5.初始线程的停止保护锁(&amp;Thread-&gt;RundownProtect), 用于跨线程初始化TEB,挂起线程。<br>6.设置线程的进程CID, 线程的CID句柄。函数在PspCidTable句柄表创建句柄表项。<br>7.初始读取的族大小<br> 初始化LPC信号量对象<br> 初始化跨进程通信LPC<br>初始化所有正在处理单尚末完成的I/O请求&lt;IRP对象&gt;<br>初始化配置管理器等级注册表的变化通知<br> 初始化线程锁/时间旋转锁/当前线程的所有定时器<br>8.根据ThreadContext的值来确认此次创建是用户模式线程&lt;非NULL&gt;,或者系统线程<null>.<br>用户模式线程: 创建一个TEB,并用InitialTeb初始化,接着初始线程的启动地址,WINDOWS子系统的启动地址。<br>9.调用KeInitThread函数 &lt;继续初始新线程属性。&gt; 同步Header, WaitBlock,系统服务表 ,APC ,定时器, 线程的内核栈等。<br>10.禁用当前线程内核APC的。且锁定进程。 确保当前进程的状态不是退出或正在终止。进程中Flags标记位判断当前进程是否是死进程。CrossThreadFlags跨线程访问的标志位。<br> 包括Terminated 线程已执行终止操作 创建失败 等信息。<br>11.进程的活动线程数+1。挂入目标进程(EPROCESS中)的线程队列。<br>12.启动该线程运行 KeStartThread函数； 并再次初始化末完成的域,设置线程的优先级, 时限设置等。<br>13.局部变量OldActiveThreads 判断当前创建的线程是否是第一个线程。当为第一个线程: 通知线程创建标注的注册程序.<br>14.检测当前新创建线程的进程是否正处于在一个作业中。<br>15.线程对象引用数+2, 一个是当前创建的操作, 另一个返回线程的句柄。<br>16.CreateSuspended为TURE 挂起目标线程 不让其参与调度。KeSuspendThread挂起目标线程 , KeForceResumeThread 线程唤醒。<br>17.SeCreateAccessStateEx 创建ACCESS_STATE结构 用来插入进程的句柄表中,通过ObInsertObject函数将新线程对象插入。<br>18.KeQuerySystemTime 查询线程创建的时间。 PS_SET_THREAD_CREATE_TIME 设置线程创建的时间。<br>19.目标线程需要根据安全属性描述块确定其允许的访问权限.ObGetObjectSecurity 得到线程SD 。成员GrantedAccess赋值。<br> 注: 已被挂起的线程即使处于就绪状态也不会被调度运行,而要到被解除挂起时才能被调度运行 KeReadyThread函数将线程进入就绪状态。<br>20.最后ObDereferenceObject将引用计数-1,操作完成。线程创建结束。</null></p>
</blockquote>
<p><img src="/2020/11/03/windows-kernel-summary/image-03.jpg" width="600px"></p>
<h3 id="CreateProcessInternalW"><a href="#CreateProcessInternalW" class="headerlink" title="CreateProcessInternalW"></a>CreateProcessInternalW</h3><p>现在具体看一下<code>CreateProcess</code>的创建过程,它会在内部直接转调<code>CreateProcessInternalW</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcessInternalW</span><span class="params">(HANDLE hToken,<span class="comment">//暂时无用 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                       LPCWSTR lpApplicationName,<span class="comment">//程序文件名 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                       LPWSTR lpCommandLine,<span class="comment">//命令行 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                       LPSECURITY_ATTRIBUTES lpProcessAttributes,<span class="comment">//SD </span></span></span></span><br><span class="line"><span class="function"><span class="params">                       LPSECURITY_ATTRIBUTES lpThreadAttributes,<span class="comment">//SD </span></span></span></span><br><span class="line"><span class="function"><span class="params">                       BOOL bInheritHandles,<span class="comment">//是否继承父进程句柄表中的那些可继承句柄 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                       DWORD dwCreationFlags, </span></span></span><br><span class="line"><span class="function"><span class="params">                       LPVOID lpEnvironment,<span class="comment">//环境变量块 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                       LPCWSTR lpCurrentDirectory,<span class="comment">//指定给子进程的当前目录 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                       LPSTARTUPINFOW lpStartupInfo,<span class="comment">//附加启动信息 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                       LPPROCESS_INFORMATION lpProcessInformation,<span class="comment">//返回创建结果 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                       PHANDLE hNewToken)</span><span class="comment">//暂时无用 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BOOLEAN CmdLineIsAppName = FALSE;<span class="comment">//表示文件名是否就是命令行 </span></span><br><span class="line">	UNICODE_STRING ApplicationName = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span> &#125;; </span><br><span class="line">	HANDLE hSection = <span class="literal">NULL</span>, hProcess = <span class="literal">NULL</span>, hThread = <span class="literal">NULL</span>, hDebug = <span class="literal">NULL</span>; </span><br><span class="line">	LPWSTR CurrentDirectory = <span class="literal">NULL</span>; </span><br><span class="line">	PPEB OurPeb = NtCurrentPeb();<span class="comment">//当前进程即父进程的peb </span></span><br><span class="line">	SIZE_T EnvSize = <span class="number">0</span>;<span class="comment">//环境变量块的大小 </span></span><br><span class="line">	<span class="comment">//检查下面的"映像劫持’键,略 </span></span><br><span class="line">	<span class="comment">//&#123;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options&#125; </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((dwCreationFlags &amp; (DETACHED_PROCESS | CREATE_NEW_CONSOLE)) == </span><br><span class="line">	    (DETACHED_PROCESS | CREATE_NEW_CONSOLE)) </span><br><span class="line">	&#123; </span><br><span class="line">	    SetLastError(ERROR_INVALID_PARAMETER);<span class="comment">//这俩标志不可同时使用 </span></span><br><span class="line">	    <span class="keyword">return</span> FALSE; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	StartupInfo = *lpStartupInfo; </span><br><span class="line">	RtlZeroMemory(lpProcessInformation, <span class="keyword">sizeof</span>(PROCESS_INFORMATION)); </span><br><span class="line"> </span><br><span class="line">	PriorityClass.Foreground = FALSE;<span class="comment">//初始创建的进程作为后台进程看待 </span></span><br><span class="line">	<span class="comment">//根据创建标志计算对应的优先级类别(一种优先级类对应一种基本优先级) </span></span><br><span class="line">	PriorityClass.PriorityClass = (UCHAR)BasepConvertPriorityClass(dwCreationFlags); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GetAppName: </span><br><span class="line">	<span class="keyword">if</span> (!lpApplicationName)<span class="comment">//很常见 </span></span><br><span class="line">	&#123; </span><br><span class="line">	    NameBuffer = RtlAllocateHeap(RtlGetProcessHeap(),<span class="number">0</span>,MAX_PATH * <span class="keyword">sizeof</span>(WCHAR)); </span><br><span class="line">	    lpApplicationName = lpCommandLine; </span><br><span class="line">	    <span class="comment">// 处理NameBuffer,略 </span></span><br><span class="line">	    lpApplicationName = NameBuffer;<span class="comment">// 最终获得命令行中包含的应用程序文件名 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!lpCommandLine || *lpCommandLine == UNICODE_NULL) </span><br><span class="line">	&#123; </span><br><span class="line">	    CmdLineIsAppName = TRUE; </span><br><span class="line">	    lpCommandLine = (LPWSTR)lpApplicationName; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//事实上只是为程序文件创建一个section,等待映射(函数名有误导) </span></span><br><span class="line">	Status = BasepMapFile(lpApplicationName, &amp;hSection, &amp;ApplicationName); </span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">	    If(是一个bat批脚本文件) </span><br><span class="line">	       <span class="comment">// 命令行改为“cmd /c bat文件名”,goto GetAppName,重新解析 </span></span><br><span class="line">	    Else … </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (!StartupInfo.lpDesktop)<span class="comment">//继承父进程的桌面 </span></span><br><span class="line">	    StartupInfo.lpDesktop = OurPeb-&gt;ProcessParameters-&gt;DesktopInfo.Buffer; </span><br><span class="line">	<span class="comment">//查询section对象的映像文件信息 </span></span><br><span class="line">	Status = ZwQuerySection(hSection,SectionImageInformation, </span><br><span class="line">	                        &amp;SectionImageInfo,<span class="keyword">sizeof</span>(SectionImageInfo),<span class="literal">NULL</span>); </span><br><span class="line">	<span class="keyword">if</span> (SectionImageInfo.ImageCharacteristics &amp; IMAGE_FILE_DLL) 失败返回； </span><br><span class="line">	<span class="keyword">if</span> (IMAGE_SUBSYSTEM_WINDOWS_GUI == SectionImageInfo.SubSystemType) </span><br><span class="line">	&#123; </span><br><span class="line">	    dwCreationFlags &amp;= ~CREATE_NEW_CONSOLE;<span class="comment">//GUI程序无需控制台 </span></span><br><span class="line">	    dwCreationFlags |= DETACHED_PROCESS; </span><br><span class="line">	&#125; </span><br><span class="line">	ObjectAttributes = BasepConvertObjectAttributes(&amp;LocalObjectAttributes, </span><br><span class="line">	                                                lpProcessAttributes,<span class="literal">NULL</span>); </span><br><span class="line">	<span class="comment">//if创建的是一个要被当前线程调试的子进程 </span></span><br><span class="line">	<span class="keyword">if</span> (dwCreationFlags &amp; (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS)) </span><br><span class="line">	&#123; </span><br><span class="line"></span><br><span class="line">	    Status = DbgUiConnectToDbg();<span class="comment">//连接到 </span></span><br><span class="line">	    hDebug = DbgUiGetThreadDebugObject();<span class="comment">//为当前线程创建一个调试端口(用来父子进程通信) </span></span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//关键。调用系统服务,创建内核中的进程对象,并初始化其地址空间等N多内容 </span></span><br><span class="line">	Status = NtCreateProcess(&amp;hProcess,PROCESS_ALL_ACCESS,ObjectAttributes, </span><br><span class="line">	                         NtCurrentProcess(),bInheritHandles,hSection, </span><br><span class="line">	                         hDebug,); <span class="comment">//当前线程的调试端口(将传给子进程) </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置进程的优先级类别 </span></span><br><span class="line">	<span class="keyword">if</span> (PriorityClass.PriorityClass != PROCESS_PRIORITY_CLASS_INVALID) </span><br><span class="line">	&#123; </span><br><span class="line">	    Status = NtSetInformationProcess(hProcess,ProcessPriorityClass, &amp;PriorityClass,<span class="keyword">sizeof</span>(PROCESS_PRIORITY_CLASS)); </span><br><span class="line">	&#125; </span><br><span class="line">	Status = NtQueryInformationProcess(hProcess,ProcessBasicInformation,&amp;ProcessBasicInfo, <span class="keyword">sizeof</span>(ProcessBasicInfo),<span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(lpEnvironment &amp;&amp; !(dwCreationFlags &amp; CREATE_UNICODE_ENVIRONMENT)) </span><br><span class="line">	    lpEnvironment = BasepConvertUnicodeEnvironment(&amp;EnvSize, lpEnvironment); </span><br><span class="line"></span><br><span class="line">	RemotePeb = ProcessBasicInfo.PebBaseAddress;<span class="comment">//子进程的peb地址(实际上是固定的) </span></span><br><span class="line">	<span class="comment">//关键。创建子进程的参数块和环境变量块 </span></span><br><span class="line">	Status = BasepInitializeEnvironment(hProcess,RemotePeb,lpApplicationName, </span><br><span class="line">	                                    CurrentDirectory,lpCommandLine, </span><br><span class="line">	                                    lpEnvironment,EnvSize,<span class="comment">//环境变量块的地址、长度 </span></span><br><span class="line">	                                    &amp;StartupInfo,dwCreationFlags,bInheritHandles); </span><br><span class="line">	<span class="comment">//如果没有显式指定这三个标准句柄给子进程,就继承父进程中的那3个标准句柄(最常见) </span></span><br><span class="line">	<span class="keyword">if</span> (!bInheritHandles &amp;&amp; !(StartupInfo.dwFlags &amp; STARTF_USESTDHANDLES) &amp;&amp; </span><br><span class="line">	    SectionImageInfo.SubSystemType == IMAGE_SUBSYSTEM_WINDOWS_CUI) </span><br><span class="line">	&#123; </span><br><span class="line">	    PRTL_USER_PROCESS_PARAMETERS RemoteParameters; </span><br><span class="line">	    Status = NtReadVirtualMemory(hProcess,&amp;RemotePeb-&gt;ProcessParameters, </span><br><span class="line">	                                 &amp;RemoteParameters,<span class="keyword">sizeof</span>(PVOID),<span class="literal">NULL</span>); </span><br><span class="line">	    BasepDuplicateAndWriteHandle(hProcess,OurPeb-&gt;ProcessParameters-&gt;StandardInput, </span><br><span class="line">	                                 &amp;RemoteParameters-&gt;StandardInput); </span><br><span class="line">	    BasepDuplicateAndWriteHandle(hProcess,OurPeb-&gt;ProcessParameters-&gt;StandardOutput, </span><br><span class="line">	                                 &amp;RemoteParameters-&gt;StandardOutput); </span><br><span class="line">	    BasepDuplicateAndWriteHandle(hProcess,OurPeb-&gt;ProcessParameters-&gt;StandardError, </span><br><span class="line">	                                 &amp;RemoteParameters-&gt;StandardError); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//通知csrss.exe进程,一个新的进程已创建 </span></span><br><span class="line">	Status = BasepNotifyCsrOfCreation(dwCreationFlags,ProcessBasicInfo.UniqueProcessId, </span><br><span class="line">	                                  bInheritHandles); </span><br><span class="line"></span><br><span class="line">	<span class="comment">//--------------------------------------华丽的分割线--------------------------------- </span></span><br><span class="line">	<span class="comment">//至此,已创建好了进程,接下来创建该进程中的第一个线程(主线程) </span></span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line"></span><br><span class="line">	<span class="comment">//这个函数创建主线程的用户栈、内核栈,并建立起初始的运行环境(内核栈帧) </span></span><br><span class="line">	hThread = BasepCreateFirstThread(hProcess,lpThreadAttributes,&amp;SectionImageInfo, &amp;ClientId);<span class="comment">//返回线程的pid.tid </span></span><br><span class="line">	<span class="keyword">if</span> (!(dwCreationFlags &amp; CREATE_SUSPENDED)) </span><br><span class="line">		NtResumeThread(hThread, &amp;Dummy);<span class="comment">//恢复线程,挂入就绪队列(即可以开始运行这个线程了) </span></span><br><span class="line"></span><br><span class="line">	lpProcessInformation-&gt;dwProcessId = (DWORD)ClientId.UniqueProcess; </span><br><span class="line">	lpProcessInformation-&gt;dwThreadId = (DWORD)ClientId.UniqueThread; </span><br><span class="line">	lpProcessInformation-&gt;hProcess = hProcess; </span><br><span class="line">	lpProcessInformation-&gt;hThread = hThread; </span><br><span class="line">	<span class="keyword">return</span> TRUE; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function">NTSTATUS <span class="title">BasepMapFile</span><span class="params">(IN LPCWSTR lpApplicationName,OUT PHANDLE hSection, IN PUNICODE_STRING ApplicationName)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	RelativeName.Handle = <span class="literal">NULL</span>; </span><br><span class="line">	<span class="comment">//转为NT路径格式 </span></span><br><span class="line">	RtlDosPathNameToNtPathName_U(lpApplicationName,ApplicationName,<span class="literal">NULL</span>,&amp;RelativeName) </span><br><span class="line">	<span class="keyword">if</span> (RelativeName.DosPath.Length) </span><br><span class="line">		ApplicationName = &amp;RelativeName.DosPath; </span><br><span class="line"></span><br><span class="line">	InitializeObjectAttributes(&amp;ObjectAttributes,ApplicationName,OBJ_CASE_INSENSITIVE, </span><br><span class="line">	                       RelativeName.Handle,<span class="literal">NULL</span>); </span><br><span class="line">	<span class="comment">//打开程序文件 </span></span><br><span class="line">	Status = NtOpenFile(&amp;hFile,SYNCHRONIZE | FILE_EXECUTE | FILE_READ_DATA,&amp;ObjectAttribute s, </span><br><span class="line">	                &amp;IoStatusBlock,FILE_SHARE_DELETE | FILE_SHARE_READ, </span><br><span class="line">	                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE); </span><br><span class="line"></span><br><span class="line">	<span class="comment">//为文件创建一个公共section,等候映射(多个进程可以同用一个exe文件) </span></span><br><span class="line">	Status = NtCreateSection(hSection,SECTION_ALL_ACCESS,<span class="literal">NULL</span>,<span class="literal">NULL</span>,PAGE_EXECUTE, </span><br><span class="line">	SEC_IMAGE,hFile); </span><br><span class="line">	NtClose(hFile); </span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上这个函数的名字有误导,其实只是创建一个section,并没有立即映射到地址空间(多个进程可以共享同一程序文件的)<br>函数内部间接性调用了<code>NtCreateProcess</code>,<code>BasepInitializeEnvironment</code>,<code>BasepCreateFirstThread</code></p>
<h3 id="NtCreateProcess"><a href="#NtCreateProcess" class="headerlink" title="NtCreateProcess"></a>NtCreateProcess</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtCreateProcess</span><span class="params">(OUT PHANDLE ProcessHandle, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN HANDLE ParentProcess, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN BOOLEAN InheritObjectTable, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN HANDLE SectionHandle OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN HANDLE DebugPort OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN HANDLE ExceptionPort OPTIONAL)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	ULONG Flags = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">if</span> ((ULONG)SectionHandle &amp; <span class="number">1</span>) Flags = PS_REQUEST_BREAKAWAY; </span><br><span class="line">	<span class="keyword">if</span> ((ULONG)DebugPort &amp; <span class="number">1</span>) Flags |= PS_NO_DEBUG_INHERIT; </span><br><span class="line">	<span class="keyword">if</span> (InheritObjectTable) Flags |= PS_INHERIT_HANDLES; </span><br><span class="line">	<span class="keyword">return</span> NtCreateProcessEx(ProcessHandle, </span><br><span class="line">	                         DesiredAccess, </span><br><span class="line">	                         ObjectAttributes, </span><br><span class="line">	                         ParentProcess, </span><br><span class="line">	                         Flags, </span><br><span class="line">	                         SectionHandle, </span><br><span class="line">	                         DebugPort, </span><br><span class="line">	                         ExceptionPort, </span><br><span class="line">	                         FALSE); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">NtCreateProcessEx</span><span class="params">(OUT PHANDLE ProcessHandle, </span></span></span><br><span class="line"><span class="function"><span class="params">                  IN ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="function"><span class="params">                  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">                  IN HANDLE ParentProcess, </span></span></span><br><span class="line"><span class="function"><span class="params">                  IN ULONG Flags, </span></span></span><br><span class="line"><span class="function"><span class="params">                  IN HANDLE SectionHandle OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">                  IN HANDLE DebugPort OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">                  IN HANDLE ExceptionPort OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">                  IN BOOLEAN InJob)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!ParentProcess) </span><br><span class="line">        Status = STATUS_INVALID_PARAMETER; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        Status = PspCreateProcess(ProcessHandle, </span><br><span class="line">                                  DesiredAccess, </span><br><span class="line">                                  ObjectAttributes, </span><br><span class="line">                                  ParentProcess, </span><br><span class="line">                                  Flags, </span><br><span class="line">                                  SectionHandle, </span><br><span class="line">                                  DebugPort, </span><br><span class="line">                                  ExceptionPort, </span><br><span class="line">                                  InJob); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上<code>CreateProcess</code> API 调用<code>NtCreateProcess</code>系统服务,最终会调用下面的函数完成进程的创建工作 </p>
<h3 id="PspCreateProcess"><a href="#PspCreateProcess" class="headerlink" title="PspCreateProcess"></a>PspCreateProcess</h3><p>下面的<code>NtCreateProcess</code>、<code>PspCreateProces</code>只是创建了一个进程(它的内核对象、地址空间等)<br>进程本身是不能运行的,所以<code>CreateProcess</code>API 最终还会调用<code>NtCreateThread</code>创建并启动主线程。 </p>
<p>线程从运行空间角度看,分为两种线程: </p>
<ul>
<li>1、 用户线程(主线程和<code>CreateThread</code>创建的普通线程都是用户线程):线程部分代码运行在用户空间 </li>
<li>2、 内核线程(由驱动程序调用<code>PsCreateSystemThread</code>创建的线程):线程的所有代码运行在内核空间 两种线程的运行路径分别为: <ul>
<li>1、 KiThreadStartup-&gt;PspUserThreadStartup-&gt;用户空间中的公共入口-&gt;映像文件中的入口 </li>
<li>2、 KiThreadStartup-&gt;PspSystemThreadStartup-&gt;内核空间中用户指定的入口 </li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">PspCreateProcess</span><span class="params">(OUT PHANDLE ProcessHandle,<span class="comment">//返回子进程的句柄 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 IN ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="function"><span class="params">                 IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">                 IN HANDLE ParentProcess OPTIONAL,<span class="comment">//父进程可以是任意第三方进程 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 IN ULONG Flags, </span></span></span><br><span class="line"><span class="function"><span class="params">                 IN HANDLE SectionHandle OPTIONAL,<span class="comment">//exe文件的section对象 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 IN HANDLE DebugPort OPTIONAL,<span class="comment">//调试器进程中某个线程的调试端口 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 IN HANDLE ExceptionPort OPTIONAL)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	ULONG DirectoryTableBase[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//为子进程分配的页目录所在的物理页面地址 </span></span><br><span class="line">	PETHREAD CurrentThread = PsGetCurrentThread(); </span><br><span class="line">	KPROCESSOR_MODE PreviousMode = ExGetPreviousMode(); </span><br><span class="line">	PEPROCESS CurrentProcess = PsGetCurrentProcess(); </span><br><span class="line">	PACCESS_STATE AccessState = &amp;LocalAccessState;<span class="comment">//记录着当前线程的令牌和申请的访问权限 </span></span><br><span class="line">	BOOLEAN NeedsPeb = FALSE;<span class="comment">//表示是否需要为其创建一个peb,绝大多数都要 </span></span><br><span class="line">	<span class="keyword">if</span> (ParentProcess)<span class="comment">//事实上只有”system”进程没有父进程 </span></span><br><span class="line">	&#123; </span><br><span class="line">		Status = ObReferenceObjectByHandle(ParentProcess, </span><br><span class="line">		                           PROCESS_CREATE_PROCESS,<span class="comment">//表示要为其创建子进程 </span></span><br><span class="line">		                           PsProcessType,PreviousMode, (PVOID*)&amp;Parent); </span><br><span class="line">		Affinity = Parent-&gt;Pcb.Affinity;<span class="comment">//继承父进程的cpu亲缘性 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line"></span><br><span class="line">		Parent = <span class="literal">NULL</span>; </span><br><span class="line">		Affinity = KeActiveProcessors; </span><br><span class="line">	&#125; </span><br><span class="line">	MinWs = PsMinimumWorkingSet; MaxWs = PsMaximumWorkingSet; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//关键 ###################################</span></span><br><span class="line">	<span class="comment">//关键。创建该进程的内核对象结构 </span></span><br><span class="line">	<span class="comment">//关键 ###################################</span></span><br><span class="line">	Status = ObCreateObject(PreviousMode, </span><br><span class="line">	            PsProcessType,<span class="comment">//进程对象类型 </span></span><br><span class="line">	            ObjectAttributes,PreviousMode,<span class="literal">NULL</span>, </span><br><span class="line">	            <span class="keyword">sizeof</span>(EPROCESS),<span class="comment">//内核进程对象 </span></span><br><span class="line">	            <span class="number">0</span>,<span class="number">0</span>, (PVOID*)&amp;Process); </span><br><span class="line"></span><br><span class="line">	RtlZeroMemory(Process, <span class="keyword">sizeof</span>(EPROCESS)); </span><br><span class="line">	InitializeListHead(&amp;Process-&gt;ThreadListHead);<span class="comment">//初始时该进程尚无任何线程 </span></span><br><span class="line">	PspInheritQuota(Process, Parent);<span class="comment">//继承父进程的资源配额块 </span></span><br><span class="line">	ObInheritDeviceMap(Parent, Process);<span class="comment">//继承父进程的磁盘卷设备位图 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Parent) </span><br><span class="line">		Process-&gt;InheritedFromUniqueProcessId = Parent-&gt;UniqueProcessId;<span class="comment">//记录父进程的pid </span></span><br><span class="line">	<span class="keyword">if</span> (SectionHandle)<span class="comment">//exe文件的section,一般都有 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//获得对应的section对象 </span></span><br><span class="line">		Status = ObReferenceObjectByHandle(SectionHandle,SECTION_MAP_EXECUTE, </span><br><span class="line">								MmSectionObjectType,PreviousMode, </span><br><span class="line">								(PVOID*)&amp;SectionObject); </span><br><span class="line">	&#125; </span><br><span class="line">	Else … </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	Process-&gt;SectionObject = SectionObject;<span class="comment">//记录该进程的exe文件section </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (DebugPort)<span class="comment">//由调试器启动的子进程,都会传递一个调试端口给子进程 </span></span><br><span class="line">	&#123; </span><br><span class="line">		Status = ObReferenceObjectByHandle(DebugPort, </span><br><span class="line">	                           DEBUG_OBJECT_ADD_REMOVE_PROCESS, </span><br><span class="line">	                           DbgkDebugObjectType,PreviousMode, </span><br><span class="line">	                           (PVOID*)&amp;DebugObject); </span><br><span class="line">		<span class="comment">//每个被调进程与调试器中的一个调试器线程通过一个调试端口连接,形成一个调试会话 </span></span><br><span class="line">		Process-&gt;DebugPort = DebugObject; <span class="comment">//可用于检测调试 </span></span><br><span class="line">		<span class="keyword">if</span> (Flags &amp; PS_NO_DEBUG_INHERIT)<span class="comment">//指示不可将调试端口再继承给它的子进程 </span></span><br><span class="line">			InterlockedOr((PLONG)&amp;Process-&gt;Flags, PSF_NO_DEBUG_INHERIT_BIT); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (Parent) </span><br><span class="line">			DbgkCopyProcessDebugPort(Process, Parent);<span class="comment">//继承父进程的调试端口 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (ExceptionPort) </span><br><span class="line">	&#123; </span><br><span class="line">		Status = ObReferenceObjectByHandle(ExceptionPort,PORT_ALL_ACCESS,LpcPortObjectType, </span><br><span class="line">		                           PreviousMode, (PVOID*)&amp;ExceptionPortObject); </span><br><span class="line">		Process-&gt;ExceptionPort = ExceptionPortObject; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	Process-&gt;ExitStatus = STATUS_PENDING;<span class="comment">//默认的退出码 </span></span><br><span class="line">	<span class="keyword">if</span> (Parent) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">/*创建页目录和内核部分的页表,然后从系统公共的内核页表中复制内核空间中的那些页表项</span></span><br><span class="line"><span class="comment">		(这样每个进程的内核地址空间的映射就相同了)*/</span> </span><br><span class="line">		MmCreateProcessAddressSpace(MinWs,Process,DirectoryTableBase) </span><br><span class="line">	&#125; </span><br><span class="line">	Else … </span><br><span class="line">	InterlockedOr((PLONG)&amp;Process-&gt;Flags, PSF_HAS_ADDRESS_SPACE_BIT); </span><br><span class="line"></span><br><span class="line">	Process-&gt;Vm.MaximumWorkingSetSize = MaxWs; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化进程对象的内部结构成员 </span></span><br><span class="line">	KeInitializeProcess(&amp;Process-&gt;Pcb,PROCESS_PRIORITY_NORMAL,Affinity,DirectoryTableBase); </span><br><span class="line">	Status = PspInitializeProcessSecurity(Process, Parent);<span class="comment">//继承父进程的令牌 </span></span><br><span class="line">	Process-&gt;PriorityClass = PROCESS_PRIORITY_CLASS_NORMAL;<span class="comment">//初始创建时都是普通优先级类 </span></span><br><span class="line">	Status = STATUS_SUCCESS; </span><br><span class="line">	<span class="keyword">if</span> (SectionHandle) <span class="comment">//一般都有 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//初始化地址空间并将exe文件映射到用户空间中 </span></span><br><span class="line">		Status = MmInitializeProcessAddressSpace(Process,SectionObject,&amp;Flags,ImageFileNam e); </span><br><span class="line">		NeedsPeb = TRUE; </span><br><span class="line">	&#125; </span><br><span class="line">	Else … </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (SectionObject)<span class="comment">//映射(即加载)exe文件后,再映射ntdll.dll到用户空间(事实上固定映到某处) </span></span><br><span class="line">		PspMapSystemDll(Process, <span class="literal">NULL</span>, FALSE); </span><br><span class="line">	</span><br><span class="line">	CidEntry.Object = Process; CidEntry.GrantedAccess = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//进程id、线程id实际上都是全局PspCidTable句柄表中的句柄,他们也指向对应的对象 </span></span><br><span class="line">	Process-&gt;UniqueProcessId = ExCreateHandle(PspCidTable, &amp;CidEntry);<span class="comment">//分配pid进程号 </span></span><br><span class="line">	Process-&gt;ObjectTable-&gt;UniqueProcessId = Process-&gt;UniqueProcessId; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((Parent) &amp;&amp; (NeedsPeb))<span class="comment">//用户空间中的进程都会分配一个peb,且固定在某处 </span></span><br><span class="line">	&#123; </span><br><span class="line">		RtlZeroMemory(&amp;InitialPeb, <span class="keyword">sizeof</span>(INITIAL_PEB)); </span><br><span class="line">		InitialPeb.Mutant = (HANDLE)<span class="number">-1</span>; </span><br><span class="line">		<span class="keyword">if</span> (SectionHandle) </span><br><span class="line">			Status = MmCreatePeb(Process, &amp;InitialPeb, &amp;Process-&gt;Peb);<span class="comment">//创建peb(固定在某处) </span></span><br><span class="line">		Else … </span><br><span class="line"></span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">/*将进程加入全局的“活动进程链表”中,这个链表仅供系统统计用,因此可以恣意篡改</span></span><br><span class="line"><span class="comment">	如隐藏进程。任务管理器等其他绝大多数进程枚举工具内部就是遍历的这个进程链表*/</span> </span><br><span class="line">	InsertTailList(&amp;PsActiveProcessHead, &amp;Process-&gt;ActiveProcessLinks); </span><br><span class="line"></span><br><span class="line">	<span class="comment">//这个函数用来将进程对象插入句柄表,返回一个进程句柄 </span></span><br><span class="line">	Status = ObInsertObject(Process,AccessState,DesiredAccess,<span class="number">1</span>,<span class="literal">NULL</span>,&amp;hProcess); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据进程的优先级类计算该进程的基本优先级和时间片(初始创建时作为后台进程) </span></span><br><span class="line">	Process-&gt;Pcb.BasePriority =PspComputeQuantumAndPriority(Process, PsProcessPriorityBackground,&amp;Quantum); </span><br><span class="line">	Process-&gt;Pcb.QuantumReset = Quantum; KeQuerySystemTime(&amp;Process-&gt;CreateTime);<span class="comment">//记录进程的创建时间 </span></span><br><span class="line"></span><br><span class="line">	PspRunCreateProcessNotifyRoutines(Process, TRUE);<span class="comment">//发出一个进程创建通知消息 </span></span><br><span class="line">	*ProcessHandle = hProcess;<span class="comment">//返回对应的句柄 </span></span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面函数创建内核线程对象,然后调用下面的函数初始化对象结构,创建它的内核栈<br>然后构造好它的初始运行环境(<code>指内核栈中的初始状态</code>),设置好初始的优先级和时间片后,就启动线程运行(指加 入就绪队列)。</p>
<p>这样当该线程不久被调度运行时,就能跟着内核栈中初始的状态,一直运行下去</p>
<blockquote>
<p>指调度时:恢复线程切换线程,从<code>KiThreadStartup</code>函数开始运行,然后恢复用户空间寄存器现场<br>回到用户空间的公共总入口处(<code>kernel32</code>模块中的<code>BaseProcessStrartThunk</code>或<code>BaseThreadStrartThunk</code>)继续执行) </p>
</blockquote>
<p>并调用<code>MmInitializeProcessAddressSpace</code>初始化地址空间并将exe文件映射到用户空间中 </p>
<h3 id="KeInitThread"><a href="#KeInitThread" class="headerlink" title="KeInitThread"></a>KeInitThread</h3><p>下面这个函数就是用来实际执行构造线程的初始运行环境(即初始的内核栈状态)工作<br>初始的内核栈会模拟该线程仿佛以前曾经运行过,曾经被切换后的状态,这样该线程一旦得到初始调度 机会,就向得到重新调度机会一样继续运行。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">KeInitThread</span><span class="params">(IN OUT PKTHREAD Thread, </span></span></span><br><span class="line"><span class="function"><span class="params">             IN PKSYSTEM_ROUTINE SystemRoutine,<span class="comment">//用户线程是PspUserThreadStartup </span></span></span></span><br><span class="line"><span class="function"><span class="params">             IN PKSTART_ROUTINE StartRoutine,<span class="comment">//用户线程是NULL,使用公共的总入口 </span></span></span></span><br><span class="line"><span class="function"><span class="params">             IN PVOID StartContext,<span class="comment">//入口参数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">             IN PCONTEXT Context,<span class="comment">//用户空间的初始寄存器上下文 </span></span></span></span><br><span class="line"><span class="function"><span class="params">             IN PVOID Teb,<span class="comment">//用户线程的初始teb </span></span></span></span><br><span class="line"><span class="function"><span class="params">             IN PKPROCESS Process)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BOOLEAN AllocatedStack = FALSE;<span class="comment">//表示是否分配了内核栈 </span></span><br><span class="line">	KeInitializeDispatcherHeader(&amp;Thread-&gt;DispatcherHeader,ThreadObject, </span><br><span class="line">	                         <span class="keyword">sizeof</span>(KTHREAD) / <span class="keyword">sizeof</span>(LONG),FALSE);<span class="comment">//线程也是可等待对象 </span></span><br><span class="line">	InitializeListHead(&amp;Thread-&gt;MutantListHead); </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; (THREAD_WAIT_OBJECTS + <span class="number">1</span>); i++) </span><br><span class="line">	Thread-&gt;WaitBlock[i].Thread = Thread;<span class="comment">//线程内部内置的四个预定等待块 </span></span><br><span class="line">	Thread-&gt;EnableStackSwap = TRUE; <span class="comment">//指示内核栈可以被置换到外存 </span></span><br><span class="line">	Thread-&gt;IdealProcessor = <span class="number">1</span>; </span><br><span class="line">	Thread-&gt;SwapBusy = FALSE;<span class="comment">//一个标记当前线程是否正在进行切换的标记 </span></span><br><span class="line">	Thread-&gt;KernelStackResident = TRUE; <span class="comment">//线程初始创建时,内核栈当然位于物理内存中 </span></span><br><span class="line">	Thread-&gt;AdjustReason = AdjustNone;<span class="comment">//优先级的调整原因 </span></span><br><span class="line">	Thread-&gt;ServiceTable = KeServiceDescriptorTable;<span class="comment">//该线程使用的系统服务表描述符表(非SSDT) </span></span><br><span class="line">	<span class="comment">//初始时,线程的两个APC队列都为空 </span></span><br><span class="line">	InitializeListHead(&amp;Thread-&gt;ApcState.ApcListHead[<span class="number">0</span>]); </span><br><span class="line">	InitializeListHead(&amp;Thread-&gt;ApcState.ApcListHead[<span class="number">1</span>]); </span><br><span class="line">	Thread-&gt;ApcState.Process = Process;<span class="comment">//当前进程 </span></span><br><span class="line">	Thread-&gt;ApcStatePointer[OriginalApcEnvironment] = &amp;Thread-&gt;ApcState; </span><br><span class="line"></span><br><span class="line">	Thread-&gt;ApcStatePointer[AttachedApcEnvironment] = &amp;Thread-&gt;SavedApcState; </span><br><span class="line">	Thread-&gt;ApcStateIndex = OriginalApcEnvironment; </span><br><span class="line">	Thread-&gt;ApcQueueable = TRUE;<span class="comment">//标记初始时,APC队列可插入 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//一个专用于挂起线程的APC,后文会有介绍 </span></span><br><span class="line">	KeInitializeApc(&amp;Thread-&gt;SuspendApc,Thread, </span><br><span class="line">	            OriginalApcEnvironment, </span><br><span class="line">	            KiSuspendNop, </span><br><span class="line">	            KiSuspendRundown, </span><br><span class="line">	            KiSuspendThread,<span class="comment">//该apc真正的函数 </span></span><br><span class="line">	            KernelMode,<span class="literal">NULL</span>); </span><br><span class="line">	KeInitializeSemaphore(&amp;Thread-&gt;SuspendSemaphore, <span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line">	Timer = &amp;Thread-&gt;Timer;<span class="comment">//可复用 </span></span><br><span class="line">	KeInitializeTimer(Timer); </span><br><span class="line">	TimerWaitBlock = &amp;Thread-&gt;WaitBlock[TIMER_WAIT_BLOCK];<span class="comment">//定时器固定占用一个等待快 </span></span><br><span class="line">	TimerWaitBlock-&gt;Object = Timer; </span><br><span class="line">	TimerWaitBlock-&gt;WaitKey = STATUS_TIMEOUT; </span><br><span class="line">	TimerWaitBlock-&gt;WaitType = WaitAny; </span><br><span class="line">	TimerWaitBlock-&gt;NextWaitBlock = <span class="literal">NULL</span>; </span><br><span class="line">	TimerWaitBlock-&gt;WaitListEntry.Flink = &amp;Timer-&gt;Header.WaitListHead; </span><br><span class="line">	TimerWaitBlock-&gt;WaitListEntry.Blink = &amp;Timer-&gt;Header.WaitListHead; </span><br><span class="line"></span><br><span class="line">	Thread-&gt;Teb = Teb;<span class="comment">//记录teb </span></span><br><span class="line">	KernelStack = MmCreateKernelStack(FALSE, <span class="number">0</span>);<span class="comment">//关键。分配该线程的内核栈 </span></span><br><span class="line">	AllocatedStack = TRUE;<span class="comment">//标记为已分配 </span></span><br><span class="line"></span><br><span class="line">	Thread-&gt;InitialStack = KernelStack;<span class="comment">//初始的内核栈顶(即栈底) </span></span><br><span class="line">	Thread-&gt;StackBase = KernelStack;<span class="comment">//内核栈底 </span></span><br><span class="line">	Thread-&gt;StackLimit = KernelStack <span class="number">-12</span>kb;<span class="comment">//普通线程的内核栈的大小为12kb </span></span><br><span class="line">	Thread-&gt;KernelStackResident = TRUE;<span class="comment">//初始时,内核栈当然位于物理内存中 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Status = STATUS_SUCCESS; </span><br><span class="line">	<span class="comment">//关键。下面这个函数构造初始的内核栈帧(模拟切换时的状态) </span></span><br><span class="line">	KiInitializeContextThread(Thread, </span><br><span class="line">	                      SystemRoutine,<span class="comment">//用户线程为PspUserThreadStartup </span></span><br><span class="line">	                      StartRoutine,<span class="comment">//用户线程为NULL(表示使用公共总入口) </span></span><br><span class="line">	                      StartContext,<span class="comment">//入口参数 </span></span><br><span class="line">	                      Context);<span class="comment">//用户空间的初始寄存器上下文 </span></span><br><span class="line">	Thread-&gt;State = Initialized;<span class="comment">//标记为已初始化好,可以运行了 </span></span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KiInitializeContextThread"><a href="#KiInitializeContextThread" class="headerlink" title="KiInitializeContextThread"></a>KiInitializeContextThread</h3><p>每个处于非运行状态的线程的内核栈的布局是:(从栈底到栈顶)【浮点、trap、函数、切】 </p>
<p><code>浮点寄存器帧|trap 现场帧|内核各层函数参数、局部变量帧|线程切换帧</code></p>
<p>每次发生系统调用、中断、异常时线程都会进入内核,在内核栈先保存浮点寄存器,然后保存寄存器现场<br>进入内核函数嵌套调用,最后由于时间片等原因发生线程切换,保存切换时的现场,等待下次调度运行时, 从上次切换出时的断点处继续执行。<br>注意每当重回到用户空间后,线程的内核栈就是空白的。</p>
<p>一个线程的绝大多数时间都是运行在用户空间, 因此绝大多数时刻,线程的内核栈都呈现空白状态(里面没存放任何数据)。 下面这个函数就是用来初始构造模拟线程被切换出时的现场(实际线程还没运行过,即还没切换过)。 </p>
<blockquote>
<p>非常关键。 </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KiInitializeContextThread</span><span class="params">(IN PKTHREAD Thread, </span></span></span><br><span class="line"><span class="function"><span class="params">                          IN PKSYSTEM_ROUTINE SystemRoutine,<span class="comment">//用户线程为PspUserThreadStartup </span></span></span></span><br><span class="line"><span class="function"><span class="params">                          IN PKSTART_ROUTINE StartRoutine, <span class="comment">//用户线程为NULL(表示公共总入口) </span></span></span></span><br><span class="line"><span class="function"><span class="params">                          IN PVOID StartContext, <span class="comment">//入口参数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                          IN PCONTEXT ContextPointer)</span> <span class="comment">//用户线程的初始上下文(内核线程没有) </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PFX_SAVE_AREA FxSaveArea;<span class="comment">//内核栈中的浮点寄存器保存区 </span></span><br><span class="line">	PFXSAVE_FORMAT FxSaveFormat; </span><br><span class="line">	PKSTART_FRAME StartFrame;<span class="comment">//线程公共起始函数KiThreadStartup的栈帧 </span></span><br><span class="line">	PKSWITCHFRAME CtxSwitchFrame;<span class="comment">//切换帧 </span></span><br><span class="line">	PKTRAP_FRAME TrapFrame;<span class="comment">//trap现场帧 </span></span><br><span class="line">	CONTEXT LocalContext;<span class="comment">//临时变量 </span></span><br><span class="line">	PCONTEXT Context = <span class="literal">NULL</span>; </span><br><span class="line">	ULONG ContextFlags; </span><br><span class="line">	PKUINIT_FRAME InitFrame;<span class="comment">//线程的初始内核栈帧(由浮点帧、trap帧、起始函数帧、切换帧组成) </span></span><br><span class="line">	InitFrame = (PKUINIT_FRAME)( Thread-&gt;InitialStack - <span class="keyword">sizeof</span>(KUINIT_FRAME)); </span><br><span class="line">	FxSaveArea = &amp;InitFrame-&gt;FxSaveArea;<span class="comment">//初始帧中的浮点保存区 </span></span><br><span class="line"></span><br><span class="line">	RtlZeroMemory(FxSaveArea,KTRAP_FRAME_LENGTH + <span class="keyword">sizeof</span>(FX_SAVE_AREA)); </span><br><span class="line">	TrapFrame = &amp;InitFrame-&gt;TrapFrame;<span class="comment">//初始帧中的trap现场帧(最重要) </span></span><br><span class="line">	StartFrame = &amp;InitFrame-&gt;StartFrame;<span class="comment">//起始函数(指KiThreadStartup)的参数帧(重要) </span></span><br><span class="line">	CtxSwitchFrame = &amp;InitFrame-&gt;CtxSwitchFrame;<span class="comment">//切换帧(非常重要) </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ContextPointer)<span class="comment">//如果是要构造用户线程的初始帧 </span></span><br><span class="line">	&#123; </span><br><span class="line">	    RtlCopyMemory(&amp;LocalContext, ContextPointer, <span class="keyword">sizeof</span>(CONTEXT)); </span><br><span class="line">	    Context = &amp;LocalContext; </span><br><span class="line">	    ContextFlags = CONTEXT_CONTROL; </span><br><span class="line">	    &#123;初始化浮点寄存器部分略&#125; </span><br><span class="line">	    Context-&gt;ContextFlags &amp;= ~CONTEXT_DEBUG_REGISTERS;<span class="comment">//初始时不需要调试寄存器 </span></span><br><span class="line">	    <span class="comment">//关键。模拟保存进入内核空间中时的现场 </span></span><br><span class="line"></span><br><span class="line">	    KeContextToTrapFrame(Context,<span class="literal">NULL</span>,TrapFrame,Context-&gt;ContextFlags | ContextFlags, </span><br><span class="line">	                         UserMode);<span class="comment">//将Context中各个寄存器填写到Trap帧中(模拟自陷现场) </span></span><br><span class="line">	    TrapFrame-&gt;HardwareSegSs |= RPL_MASK; </span><br><span class="line">	    TrapFrame-&gt;SegDs |= RPL_MASK;TrapFrame-&gt;SegEs |= RPL_MASK; </span><br><span class="line">	    TrapFrame-&gt;Dr7 = <span class="number">0</span>;<span class="comment">//不需要调试寄存器 </span></span><br><span class="line">	    TrapFrame-&gt;DbgArgMark = <span class="number">0xBADB0D00</span>; </span><br><span class="line">	    TrapFrame-&gt;PreviousPreviousMode = UserMode; </span><br><span class="line">	    TrapFrame-&gt;ExceptionList = <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line">	    Thread-&gt;PreviousMode = UserMode;<span class="comment">//模拟从用户空间自陷进来时构造的帧 </span></span><br><span class="line">	    StartFrame-&gt;UserThread = TRUE;<span class="comment">//相当于push传参给KiThreadStartup </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;   </span><br><span class="line">		&#123;内核线程则会初始化成不同的浮点寄存器,略&#125; </span><br><span class="line">	    Thread-&gt;PreviousMode = KernelMode; <span class="comment">//模拟从内核空间发起系统调用时构造的帧 </span></span><br><span class="line">	    StartFrame-&gt;UserThread = FALSE; <span class="comment">//相当于push传参给KiThreadStartup </span></span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	StartFrame-&gt;StartContext = StartContext;<span class="comment">//相当于push传参给KiThreadStartup </span></span><br><span class="line">	StartFrame-&gt;StartRoutine = StartRoutine; <span class="comment">//相当于push传参给KiThreadStartup </span></span><br><span class="line">	StartFrame-&gt;SystemRoutine = SystemRoutine; <span class="comment">//相当于push传参给KiThreadStartup </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//关键。模拟线程仿佛上次在执行call KiThreadStartup时,被切换了出去 </span></span><br><span class="line">	CtxSwitchFrame-&gt;RetAddr = KiThreadStartup;<span class="comment">//以后线程一调度就从这儿开始执行下去  </span></span><br><span class="line">	CtxSwitchFrame-&gt;ApcBypassDisable = TRUE; </span><br><span class="line">	CtxSwitchFrame-&gt;ExceptionList = <span class="number">-1</span>;<span class="comment">//线程的初始内核seh链表当然为空(-1表示空) </span></span><br><span class="line">	Thread-&gt;KernelStack = CtxSwitchFrame;<span class="comment">//记录上次切换时的内核栈顶(模拟的) </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了弄懂线程初始时的内核栈布局,必须理解下面几个结构体定义和函数。 </p>
<h4 id="KUINIT-FRAME"><a href="#KUINIT-FRAME" class="headerlink" title="_KUINIT_FRAME"></a><code>_KUINIT_FRAME</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KUINIT_FRAME</span> //每个线程的初始内核栈帧 </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    KSWITCHFRAME CtxSwitchFrame;<span class="comment">//切换帧 </span></span><br><span class="line">    KSTART_FRAME StartFrame;<span class="comment">//KiThreadStartup函数的参数帧 </span></span><br><span class="line">    KTRAP_FRAME TrapFrame;<span class="comment">//trap现场帧 </span></span><br><span class="line">    FX_SAVE_AREA FxSaveArea;<span class="comment">//浮点保存区 </span></span><br><span class="line">&#125; KUINIT_FRAME, *PKUINIT_FRAME;</span><br></pre></td></tr></table></figure>
<p>其中浮点保存区就位于栈底,向上依次是 trap 现场帧、KiThreadStartup 的参数帧、切换帧 </p>
<h4 id="KSTART-FRAME"><a href="#KSTART-FRAME" class="headerlink" title="_KSTART_FRAME"></a><code>_KSTART_FRAME</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSTART_FRAME</span> //<span class="title">KiThreadStartup</span>的参数帧 </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    PKSYSTEM_ROUTINE SystemRoutine; <span class="comment">//用户线程为PspUserThreadStartup </span></span><br><span class="line">    PKSTART_ROUTINE StartRoutine;<span class="comment">//用户线程为NULL(表示使用公共总入口) </span></span><br><span class="line">    PVOID StartContext;<span class="comment">//入口参数 </span></span><br><span class="line">    BOOLEAN UserThread;<span class="comment">//标志 </span></span><br><span class="line"> </span><br><span class="line">&#125; KSTART_FRAME, *PKSTART_FRAME;</span><br></pre></td></tr></table></figure>
<h4 id="KSWITCHFRAME"><a href="#KSWITCHFRAME" class="headerlink" title="_KSWITCHFRAME"></a><code>_KSWITCHFRAME</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSWITCHFRAME</span> //切换帧 </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	PVOID ExceptionList;<span class="comment">//保存线程切换时的内核she链表(不是用户空间中的seh) </span></span><br><span class="line">	Union </span><br><span class="line">	&#123; </span><br><span class="line">		BOOLEAN ApcBypassDisable;<span class="comment">//用于首次调度 UCHAR WaitIrql;//用于保存切换时的WaitIrql </span></span><br><span class="line">	&#125;; </span><br><span class="line">    PVOID RetAddr;<span class="comment">//保存发生切换时的断点地址(以后切换回来时从这儿继续执行) </span></span><br><span class="line">&#125; KSWITCHFRAME, *PKSWITCHFRAME;</span><br></pre></td></tr></table></figure>
<h3 id="KiThreadStartup"><a href="#KiThreadStartup" class="headerlink" title="KiThreadStartup"></a>KiThreadStartup</h3><p>不管是用户线程还是内核线程,都是最开始从下面这个函数开始执行起来的。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">KiThreadStartup</span><span class="params">(PKSYSTEM_ROUTINE  SystemRoutine <span class="comment">//用户线程为 PspUserThreadStartup </span></span></span></span><br><span class="line"><span class="function"><span class="params">                     PKSTART_ROUTINE StartRoutine <span class="comment">//转用作 PspUserThreadStartup 的参数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                     Void* StartContext<span class="comment">//转用作 PspUserThreadStartup 的参数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                     BOOL UserThread)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	Xor ebx,ebx </span><br><span class="line">	Xor esi,esi </span><br><span class="line">	Xor edi,edi </span><br><span class="line">	Xor ebp,ebp </span><br><span class="line">	Mov ecx,APC_LEVEL   </span><br><span class="line">	Call KfLowerIrql  <span class="comment">//降到 APC 级别 </span></span><br><span class="line">	Pop eax <span class="comment">//弹出的第一个值刚好是 SystemRoutine </span></span><br><span class="line">	Call eax <span class="comment">//调用 SystemRoutine(注意 StartRoutine,StartContext 又是它的参数) </span></span><br><span class="line"></span><br><span class="line">	----------------------------------华丽的分割线------------------------------------------ </span><br><span class="line">	<span class="comment">//注意若创建的是内核线程,那么上面的 eax 是 PspSystemThreadStartup,这个函数是“不返回的”, </span></span><br><span class="line">	<span class="comment">// 它执行完毕后不会 ret 回来,而是直接跳去用户指定的内核入口了。反之,若能回来,那么可以肯定是用户线程</span></span><br><span class="line">	<span class="comment">// (而且,StartRoutine 和 StartContext 这两个参数已被 PspSystemThreadStartup 在内部弹 出)。</span></span><br><span class="line">	<span class="comment">// 那么现在就可以顺利弹出 trap 帧,恢复用户空间中的寄存器上下文继续执行,于是 Jmp Ki ServiceExit2, jmp 到那儿去,退回用户空间。 </span></span><br><span class="line">	Pop ecx <span class="comment">//此时 ecx=栈帧中 UserThread 字段的值 </span></span><br><span class="line">	Or ecx,ecx </span><br><span class="line">	Jz BadThread <span class="comment">//UserThread 不为 1 就显示蓝屏界面 </span></span><br><span class="line">	Mov ebp,esp <span class="comment">//此时的内核栈顶就是 trap 帧的地址。 </span></span><br><span class="line">	Jmp KiServiceExit2 <span class="comment">//此时内核栈中只剩余浮点保存区和 trap 帧,将恢复用户空间现场退回用户空间 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PspUserThreadStartup"><a href="#PspUserThreadStartup" class="headerlink" title="PspUserThreadStartup"></a>PspUserThreadStartup</h4><p>上面的线程公共入口函数内部会<code>call SystemRoutine</code>进入对应的函数。如果创建的是用户线程,调用的 就是<code>PspUserThreadStartup</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">PspUserThreadStartup</span><span class="params">(IN PKSTART_ROUTINE StartRoutine,<span class="comment">//对于用户线程无意义 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                     IN PVOID StartContext)</span><span class="comment">//对于用户线程无意义 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BOOLEAN DeadThread = FALSE; </span><br><span class="line">	KeLowerIrql(PASSIVE_LEVEL); </span><br><span class="line">	Thread = PsGetCurrentThread(); </span><br><span class="line">	<span class="keyword">if</span> (Thread-&gt;DeadThread) </span><br><span class="line">	    DeadThread = TRUE; </span><br><span class="line">	Else … </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(Thread-&gt;DeadThread) &amp;&amp; !(Thread-&gt;HideFromDebugger)) </span><br><span class="line">	    DbgkCreateThread(Thread, StartContext);<span class="comment">//通知内核调试器一个新线程启动了 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!DeadThread)   </span><br><span class="line">	&#123; </span><br><span class="line">	    KeRaiseIrql(APC_LEVEL, &amp;OldIrql); </span><br><span class="line">		<span class="comment">//返回用户空间的总入口前先执行一下apc,完成其他初始工作(如加载其他依赖库) </span></span><br><span class="line">	    KiInitializeUserApc(KeGetExceptionFrame(&amp;Thread-&gt;Tcb), </span><br><span class="line">	                        KeGetTrapFrame(&amp;Thread-&gt;Tcb), </span><br><span class="line">	                        PspSystemDllEntryPoint,<span class="comment">//ntdll.LdrInitializeThunk </span></span><br><span class="line">	                        <span class="literal">NULL</span>,PspSystemDllBase,<span class="literal">NULL</span>); </span><br><span class="line">	    KeLowerIrql(PASSIVE_LEVEL); </span><br><span class="line">	&#125; </span><br><span class="line">	Else … </span><br><span class="line">	<span class="comment">//这个函数是典型的"返回型’函数,会返回到上面函数的call eax指令后面,进而退回用户空间的 总入口函数去去执行。</span></span><br><span class="line">	<span class="comment">// 不过在退回总入口前,这儿插入了一个APC</span></span><br><span class="line">	<span class="comment">// 执行完这个附加的APC后才会正式退回用户空间的总入口(因为这个LdrInitializeThunk APC函数还有一些重要的附加工作要做) </span></span><br><span class="line">	Return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信大家一直有一个疑问,就是用户空间的总入口到底做了什么工作,我们后文再看。 </p>
<hr>
<p>现在我们回到 CreateProcess API,总结一下这个函数到底在内部干了什么,看以下总结 </p>
<ul>
<li>1、 打开目标可执行文件<br>  若是 exe 文件,先检查”映像劫持’键,然后打开文件,创建一个 section,等候映射<br>  若是 bat、cmd 脚本文件,则启动的是 cmd.exe 进程,脚本文件作为命令行参数<br>  若是 DOS 的 exe、com 文件,启动 ntvdm.exe v86 进程,原文件作为命令行参数<br>  若是 posix、os2 文件,启动对应的子系统服务进程 </li>
<li>2、 创建、初始化进程对象；创建初始化地址空间；加载映射 exe 和 ntdll 文件；分配一个 PEB </li>
<li>3、 创建、初始化主线程对象；创建 TEB；构造初始的运行环境(内核初始栈帧) </li>
<li>4、 通知 windows 子系统(csrss.exe 进程)新进程创建事件(csrss.exe 进程含有绝大多数进程的句柄) 这样进程、主线程都创建起来了,只需等待得到 cpu 调度便可投入运行。 </li>
</ul>
<hr>
<p><br></p>
<h3 id="LdrInitializeThunk"><a href="#LdrInitializeThunk" class="headerlink" title="LdrInitializeThunk"></a>LdrInitializeThunk</h3><p>当用户线程从内核的<code>KiThreadStartup</code>运行起来后,进入<code>PspUserThreadStartup</code><br>最后回到用户空间的总入口处(主线程的用户空间根是<code>BaseProcessStartThunk</code>,其他线程的用户空间根是<code>BaseThreadStartThunk</code>)继续运行。</p>
<p>不过前文讲了,在正式从内核回到用户空间的的总入口前,会扫描执行中途插入的 APC 函数, 做完附加的 APC 工作后才从总入口处继续运行。<br>插入的这个 APC 函数是<code>LdrInitializeThunk</code>,它的主要工作是负责加载 exe 文件依赖的所有动态库以及其他工作。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">LdrInitializeThunk</span><span class="params">()</span> <span class="comment">//APC </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	Lea eax,[esp+<span class="number">16</span>] </span><br><span class="line">	Mov [esp+<span class="number">4</span>],eax <span class="comment">//第一个参数=Context* </span></span><br><span class="line">	Xor ebp,ebp </span><br><span class="line">	Jmp LdrpInit  <span class="comment">//实际的工作 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function">VOID  <span class="title">LdrpInit</span><span class="params">(PCONTEXT Context,PVOID SystemArgument1,PVOID SystemArgument2)</span> <span class="comment">//APC </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!LdrpInitialized)<span class="comment">//if 主线程 </span></span><br><span class="line">    &#123; </span><br><span class="line">        LdrpInit2(Context, SystemArgument1, SystemArgument2); </span><br><span class="line">        LdrpInitialized = TRUE; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//各线程创建后都会通知进程中的所有模块一个ThreadAttach消息 </span></span><br><span class="line">    LdrpAttachThread();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 看看主线程的初始化工作,也即进程的初始化工作如下: </span></span><br><span class="line"><span class="function">VOID  <span class="title">LdrpInit2</span><span class="params">(PCONTEXT Context,PVOID SystemArgument1,PVOID SystemArgument2)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PPEB Peb = NtCurrentPeb();<span class="comment">//现在就是子进程的peb啦(在子进程的地址空间中) </span></span><br><span class="line">	PVOID BaseAddress = SystemArgument1;<span class="comment">//ntdll模块的地址 </span></span><br><span class="line">	ImageBase = Peb-&gt;ImageBaseAddress; </span><br><span class="line">	PEDosHeader = (PIMAGE_DOS_HEADER) ImageBase; </span><br><span class="line">	<span class="keyword">if</span> (PEDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE || PEDosHeader-&gt;e_lfanew == <span class="number">0L</span> || </span><br><span class="line">	    *(PULONG)((PUCHAR)ImageBase + PEDosHeader-&gt;e_lfanew) != IMAGE_NT_SIGNATURE) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//验证PE文件签名 </span></span><br><span class="line">		ZwTerminateProcess(NtCurrentProcess(), STATUS_INVALID_IMAGE_FORMAT); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	RtlNormalizeProcessParams(Peb-&gt;ProcessParameters); </span><br><span class="line">	NTHeaders = (PIMAGE_NT_HEADERS)((ULONG_PTR)ImageBase + PEDosHeader-&gt;e_lfanew); </span><br><span class="line">	Status = ZwQuerySystemInformation(SystemBasicInformation,&amp;SystemInformation, </span><br><span class="line">	                              <span class="keyword">sizeof</span>(SYSTEM_BASIC_INFORMATION),<span class="literal">NULL</span>); </span><br><span class="line">	Peb-&gt;NumberOfProcessors = SystemInformation.NumberOfProcessors; </span><br><span class="line"></span><br><span class="line">	RtlInitializeHeapManager(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建进程的默认堆 </span></span><br><span class="line">	Peb-&gt;ProcessHeap = RtlCreateHeap(HEAP_GROWABLE,<span class="literal">NULL</span>, </span><br><span class="line">	                             NTHeaders-&gt;OptionalHeader.SizeOfHeapReserve,<span class="comment">//一般为0 </span></span><br><span class="line">	                             NTHeaders-&gt;OptionalHeader.SizeOfHeapCommit,<span class="comment">//一般为4kb </span></span><br><span class="line">	                             <span class="literal">NULL</span>,<span class="literal">NULL</span>); </span><br><span class="line">	RtlpInitializeVectoredExceptionHandling();<span class="comment">//初始化向量化异常 </span></span><br><span class="line"></span><br><span class="line">	RtlInitializeCriticalSection(&amp;PebLock); </span><br><span class="line">	Peb-&gt;FastPebLock = &amp;PebLock; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化peb中内置的动态tls位图 </span></span><br><span class="line">	Peb-&gt;TlsBitmap = &amp;TlsBitMap; </span><br><span class="line">	Peb-&gt;TlsExpansionBitmap = &amp;TlsExpansionBitMap; </span><br><span class="line">	Peb-&gt;TlsExpansionCounter = <span class="number">64</span>; </span><br><span class="line">	RtlInitializeBitMap(&amp;TlsBitMap, Peb-&gt;TlsBitmapBits,<span class="number">64</span>);<span class="comment">//固定指向内置的那个64位tls位图 </span></span><br><span class="line">	RtlInitializeBitMap(&amp;TlsExpansionBitMap, Peb-&gt;TlsExpansionBitmapBits,<span class="number">1024</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化回调表 </span></span><br><span class="line">	Peb-&gt;KernelCallbackTable = RtlAllocateHeap(RtlGetProcessHeap(),<span class="number">0</span>,<span class="keyword">sizeof</span>(PVOID) * </span><br><span class="line">	                                        (USER32_CALLBACK_MAXIMUM + <span class="number">1</span>)); </span><br><span class="line">	RtlInitializeCriticalSection(&amp;LoaderLock); </span><br><span class="line">	Peb-&gt;LoaderLock = &amp;LoaderLock; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//从默认堆中分配一个加载信息块 </span></span><br><span class="line">	Peb-&gt;Ldr = (PPEB_LDR_DATA) RtlAllocateHeap(Peb-&gt;ProcessHeap,<span class="number">0</span>,<span class="keyword">sizeof</span>(PEB_LDR_DATA)); </span><br><span class="line">	Peb-&gt;Ldr-&gt;Length = <span class="keyword">sizeof</span>(PEB_LDR_DATA); </span><br><span class="line">	Peb-&gt;Ldr-&gt;Initialized = FALSE;<span class="comment">//表示尚未完成初始化(也即尚未完成加载dll等工作) </span></span><br><span class="line">	Peb-&gt;Ldr-&gt;SsHandle = <span class="literal">NULL</span>; </span><br><span class="line">	InitializeListHead(&amp;Peb-&gt;Ldr-&gt;InLoadOrderModuleList);<span class="comment">//加载顺序的模块表 </span></span><br><span class="line">	InitializeListHead(&amp;Peb-&gt;Ldr-&gt;InMemoryOrderModuleList);<span class="comment">//内存地址顺序的模块表 </span></span><br><span class="line">	<span class="comment">//初始化顺序模块表,初始化顺序与加载顺序相反(最底层的dll最先得到初始化) </span></span><br><span class="line">	InitializeListHead(&amp;Peb-&gt;Ldr-&gt;InInitializationOrderModuleList);  </span><br><span class="line">	LoadImageFileExecutionOptions(Peb); </span><br><span class="line"></span><br><span class="line">	ExeModule = RtlAllocateHeap(Peb-&gt;ProcessHeap,<span class="number">0</span>,<span class="keyword">sizeof</span>(LDR_DATA_TABLE_ENTRY)); </span><br><span class="line"></span><br><span class="line">	ExeModule-&gt;DllBase = Peb-&gt;ImageBaseAddress; </span><br><span class="line">	RtlCreateUnicodeString(&amp;ExeModule-&gt;FullDllName, </span><br><span class="line">	Peb-&gt;ProcessParameters-&gt;ImagePathName.Buffer); </span><br><span class="line">	RtlCreateUnicodeString(&amp;ExeModule-&gt;BaseDllName, </span><br><span class="line">	                        wcsrchr(ExeModule-&gt;FullDllName.Buffer, L'\\') + 1); </span><br><span class="line"></span><br><span class="line">	ExeModule-&gt;Flags = LDRP_ENTRY_PROCESSED;<span class="comment">//exe模块没有dll标志 </span></span><br><span class="line">	ExeModule-&gt;LoadCount = <span class="number">-1</span>;<span class="comment">//标记为无法动态卸载 </span></span><br><span class="line">	ExeModule-&gt;TlsIndex = <span class="number">-1</span>;</span><br><span class="line">	ExeModule-&gt;SectionPointer = <span class="literal">NULL</span>;</span><br><span class="line">	ExeModule-&gt;CheckSum = <span class="number">0</span>; </span><br><span class="line">	NTHeaders = RtlImageNtHeader(ExeModule-&gt;DllBase); </span><br><span class="line">	ExeModule-&gt;SizeOfImage = LdrpGetResidentSize(NTHeaders); </span><br><span class="line"></span><br><span class="line">	ExeModule-&gt;TimeDateStamp = NTHeaders-&gt;FileHeader.TimeDateStamp; </span><br><span class="line">	<span class="comment">//先插入exe文件的模块描述符 </span></span><br><span class="line">	InsertTailList(&amp;Peb-&gt;Ldr-&gt;InLoadOrderModuleList,&amp;ExeModule-&gt;InLoadOrderLinks); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	wcscpy(FullNtDllPath, SharedUserData-&gt;NtSystemRoot);<span class="comment">//一般为C:\Windows </span></span><br><span class="line">	wcscat(FullNtDllPath, <span class="string">L"\\system32\\ntdll.dll"</span>); </span><br><span class="line"></span><br><span class="line">	NtModule = (PLDR_DATA_TABLE_ENTRY) </span><br><span class="line">	        RtlAllocateHeap(Peb-&gt;ProcessHeap,<span class="number">0</span>,<span class="keyword">sizeof</span>(LDR_DATA_TABLE_ENTRY)); </span><br><span class="line">	<span class="built_in">memset</span>(NtModule, <span class="number">0</span>, <span class="keyword">sizeof</span>(LDR_DATA_TABLE_ENTRY)); </span><br><span class="line"></span><br><span class="line">	NtModule-&gt;DllBase = BaseAddress; </span><br><span class="line">	NtModule-&gt;EntryPoint = <span class="number">0</span>;    </span><br><span class="line">	RtlCreateUnicodeString(&amp;NtModule-&gt;FullDllName, FullNtDllPath); </span><br><span class="line">	RtlCreateUnicodeString(&amp;NtModule-&gt;BaseDllName, <span class="string">L"ntdll.dll"</span>); </span><br><span class="line">	NtModule-&gt;Flags = LDRP_IMAGE_DLL | LDRP_ENTRY_PROCESSED; </span><br><span class="line"></span><br><span class="line">	NtModule-&gt;LoadCount = <span class="number">-1</span>;<span class="comment">//标记无法动态卸载ntdll.dll </span></span><br><span class="line">	NtModule-&gt;TlsIndex = <span class="number">-1</span>;</span><br><span class="line">	NtModule-&gt;SectionPointer = <span class="literal">NULL</span>;</span><br><span class="line">	NtModule-&gt;CheckSum = <span class="number">0</span>; </span><br><span class="line">	NTHeaders = RtlImageNtHeader(NtModule-&gt;DllBase); </span><br><span class="line">	NtModule-&gt;SizeOfImage = LdrpGetResidentSize(NTHeaders); </span><br><span class="line">	NtModule-&gt;TimeDateStamp = NTHeaders-&gt;FileHeader.TimeDateStamp; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//再插入ntdll文件的模块描述符 </span></span><br><span class="line">	InsertTailList(&amp;Peb-&gt;Ldr-&gt;InLoadOrderModuleList,&amp;NtModule-&gt;InLoadOrderLinks); </span><br><span class="line">	InsertTailList(&amp;Peb-&gt;Ldr-&gt;InInitializationOrderModuleList, </span><br><span class="line">	&amp;NtModule-&gt;InInitializationOrderModuleList);<span class="comment">//NTDLL不依赖其他库 </span></span><br><span class="line">	LdrpInitLoader();<span class="comment">//获取“\KnownDlls\KnownDllPath”路径 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//PE加载器的核心函数,用来执行模块的重定位、加载导入库、处理tls </span></span><br><span class="line">	ExeModule-&gt;EntryPoint = LdrPEStartup(ImageBase, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); </span><br><span class="line">	Peb-&gt;Ldr-&gt;Initialized = TRUE;<span class="comment">//标志该进程的所有dll都已加载完成 </span></span><br><span class="line">	<span class="keyword">if</span> (Peb-&gt;BeingDebugged) </span><br><span class="line">		DbgBreakPoint();<span class="comment">//int 3通知调试器, 首次触发调试中断 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LdrPEStartup"><a href="#LdrPEStartup" class="headerlink" title="LdrPEStartup"></a>LdrPEStartup</h4><p>进程初始时的重点工作就是加载 exe 文件依赖的所有子孙 dll<br>由下面的函数完成这项工作 (注意这个函数专用来启动初始化进程的主 exe 文件,是启动阶段的核心函数) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PEPFUNC <span class="title">LdrPEStartup</span> <span class="params">(PVOID ImageBase,<span class="comment">//exe文件的内存地址(进程的主exe文件) </span></span></span></span><br><span class="line"><span class="function"><span class="params">                      HANDLE SectionHandle, </span></span></span><br><span class="line"><span class="function"><span class="params">                      PLDR_DATA_TABLE_ENTRY* Module, </span></span></span><br><span class="line"><span class="function"><span class="params">                      PWSTR FullDosName)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> </span><br><span class="line">	PEPFUNC   EntryPoint = <span class="literal">NULL</span>; </span><br><span class="line">	DosHeader = (PIMAGE_DOS_HEADER) ImageBase; </span><br><span class="line">	NTHeaders = (PIMAGE_NT_HEADERS) ((ULONG_PTR)ImageBase + DosHeader-&gt;e_lfanew); </span><br><span class="line"></span><br><span class="line">	<span class="comment">//if 实际加载地址与pe头中的预期加载地址不同,执行重定位工作(常见于dll文件,exe文件也可能) </span></span><br><span class="line">	<span class="keyword">if</span> (ImageBase != (PVOID) NTHeaders-&gt;OptionalHeader.ImageBase) </span><br><span class="line">		Status = LdrPerformRelocations(NTHeaders, ImageBase);<span class="comment">//遍历.reloc节中项目,执行重定位 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Module != <span class="literal">NULL</span>)<span class="comment">//也即if 是dll文件(事实上这个条件永不满足) </span></span><br><span class="line">	&#123; </span><br><span class="line">		*Module = LdrAddModuleEntry(ImageBase, NTHeaders, FullDosName);<span class="comment">//加入加模块载顺序链表 </span></span><br><span class="line">		(*Module)-&gt;SectionPointer = SectionHandle; </span><br><span class="line">	&#125; </span><br><span class="line">	Else <span class="comment">//也即进程的主exe文件,这才是正题 </span></span><br><span class="line">	&#123; </span><br><span class="line">		Module = &amp;tmpModule; </span><br><span class="line">		Status = LdrFindEntryForAddress(ImageBase, Module);<span class="comment">//直接在模块表中查找 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (ImageBase != (PVOID) NTHeaders-&gt;OptionalHeader.ImageBase) </span><br><span class="line">		(*Module)-&gt;Flags |= LDRP_IMAGE_NOT_AT_BASE; </span><br><span class="line"></span><br><span class="line">	Status = RtlAllocateActivationContextStack(&amp;ActivationContextStack); </span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">		NtCurrentTeb()-&gt;ActivationContextStackPointer = ActivationContextStack; </span><br><span class="line">		NtCurrentTeb()-&gt;ActivationContextStackPointer-&gt;ActiveFrame = <span class="literal">NULL</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	Status = LdrFixupImports(<span class="literal">NULL</span>, *Module);<span class="comment">//加载子孙dll,修正IAT导入表 </span></span><br><span class="line">	Status = LdrpInitializeTlsForProccess();<span class="comment">//初始化进程的静态tls,详见后文 </span></span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">		LdrpAttachProcess();<span class="comment">//发送一个ProcessAttach消息,调用该模块的DllMain函数 </span></span><br><span class="line">		LdrpTlsCallback(*Module, DLL_PROCESS_ATTACH); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (NTHeaders-&gt;OptionalHeader.AddressOfEntryPoint != <span class="number">0</span>) </span><br><span class="line">		EntryPoint = (ULONG_PTR)ImageBase+ NTHeaders-&gt;OptionalHeader.AddressOfEntryPoint; </span><br><span class="line">	<span class="keyword">return</span> EntryPoint;<span class="comment">//返回oep </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LdrFixupImports"><a href="#LdrFixupImports" class="headerlink" title="LdrFixupImports"></a>LdrFixupImports</h4><p>下面的函数加载指定模块依赖的所有子孙 dll </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">LdrFixupImports</span><span class="params">(IN PWSTR SearchPath OPTIONAL,<span class="comment">//自定义的dll搜索路径(不提供的话就使用标准路径) </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN PLDR_DATA_TABLE_ENTRY Module)</span><span class="comment">//指定模块 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> </span><br><span class="line">	ULONG TlsSize = <span class="number">0</span>; </span><br><span class="line">	NTSTATUS Status = STATUS_SUCCESS; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取tls目录 </span></span><br><span class="line">	TlsDirectory = (PIMAGE_TLS_DIRECTORY)RtlImageDirectoryEntryToData(Module-&gt;DllBase, </span><br><span class="line">	               TRUE,IMAGE_DIRECTORY_ENTRY_TLS,&amp;Size); </span><br><span class="line">	<span class="keyword">if</span> (TlsDirectory) </span><br><span class="line">	&#123; </span><br><span class="line">	   TlsSize = TlsDirectory-&gt;EndAddressOfRawData- TlsDirectory-&gt;StartAddressOfRawData </span><br><span class="line">	               + TlsDirectory-&gt;SizeOfZeroFill; </span><br><span class="line">	   <span class="keyword">if</span> (TlsSize &gt; <span class="number">0</span> &amp;&amp; NtCurrentPeb()-&gt;Ldr-&gt;Initialized)<span class="comment">//if 动态加载该模块 </span></span><br><span class="line">	       TlsDirectory = <span class="literal">NULL</span>;<span class="comment">// 动态加载的模块不支持静态tls </span></span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	ImportModuleDirectory = (PIMAGE_IMPORT_DESCRIPTOR) </span><br><span class="line">	                       RtlImageDirectoryEntryToData(Module-&gt;DllBase, </span><br><span class="line">	                                          TRUE,IMAGE_DIRECTORY_ENTRY_IMPORT,&amp;Size); </span><br><span class="line">	BoundImportDescriptor = (PIMAGE_BOUND_IMPORT_DESCRIPTOR) </span><br><span class="line">	                       RtlImageDirectoryEntryToData(Module-&gt;DllBase,TRUE, </span><br><span class="line">	                                          MAGE_DIRECTORY_ENTRY_BOUND_IMPORT,&amp;Size); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (BoundImportDescriptor != <span class="literal">NULL</span> &amp;&amp; ImportModuleDirectory == <span class="literal">NULL</span>) </span><br><span class="line">		<span class="keyword">return</span> STATUS_UNSUCCESSFUL; </span><br><span class="line">	<span class="keyword">if</span> (BoundImportDescriptor) </span><br><span class="line">		<span class="comment">// 处理绑定导入表,略 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ImportModuleDirectory) </span><br><span class="line">	&#123; </span><br><span class="line">		ImportModuleDirectoryCurrent = ImportModuleDirectory;<span class="comment">//当前依赖的模块 </span></span><br><span class="line">		<span class="keyword">while</span> (ImportModuleDirectoryCurrent-&gt;Name)<span class="comment">//遍历IMT导入模块表中的各个依赖模块 </span></span><br><span class="line">		&#123; </span><br><span class="line">			ImportedName = Module-&gt;DllBase + ImportModuleDirectoryCurrent-&gt;Name;<span class="comment">//模块名 </span></span><br><span class="line">			<span class="keyword">if</span> (SearchPath == <span class="literal">NULL</span>) <span class="comment">//如果没提供自定义搜索路径,就构造一个标准搜索路径 </span></span><br><span class="line">			&#123; </span><br><span class="line">				<span class="comment">//标准搜索路径是:exe文件目录;当前目录;Sytem32目录;Windows目录;Path环境变量 </span></span><br><span class="line">				ModulePath = LdrpQueryAppPaths(Module-&gt;BaseDllName.Buffer); </span><br><span class="line">				Status = LdrpGetOrLoadModule(ModulePath, ImportedName, &amp;ImportedModule, TRU E); </span><br><span class="line">				<span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">					<span class="keyword">goto</span> Success; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//在模块加载表中查找该模块或者加载该模块(找不到就加载) </span></span><br><span class="line">			Status = LdrpGetOrLoadModule(SearchPath, ImportedName, &amp;ImportedModule, TRUE); </span><br><span class="line">			Success: </span><br><span class="line">				<span class="comment">//处理该依赖模块的IAT导入地址表(获取各个导入函数的实际地址,填到IAT对应的表项中) </span></span><br><span class="line">				Status = LdrpProcessImportDirectoryEntry(Module, ImportedModule, ImportModuleDirectoryCurrent); </span><br><span class="line">				ImportModuleDirectoryCurrent++;<span class="comment">//下一个依赖的模块 </span></span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (TlsDirectory &amp;&amp; TlsSize &gt; <span class="number">0</span>) </span><br><span class="line">		LdrpAcquireTlsSlot(Module, TlsSize, FALSE); </span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS  <span class="title">LdrpGetOrLoadModule</span><span class="params">(PWCHAR SearchPath,<span class="comment">//搜索路径 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                              PCHAR Name,<span class="comment">//模块名,是ASC形式 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                              PLDR_DATA_TABLE_ENTRY* Module, </span></span></span><br><span class="line"><span class="function"><span class="params">                              BOOLEAN Load)</span><span class="comment">//指找不到的话,是否加载 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	RtlInitAnsiString(&amp;AnsiDllName, Name); </span><br><span class="line">	Status = RtlAnsiStringToUnicodeString(&amp;DllName, &amp;AnsiDllName, TRUE); </span><br><span class="line"></span><br><span class="line">	Status = LdrFindEntryForName (&amp;DllName, Module, Load); </span><br><span class="line">	<span class="keyword">if</span> (Load &amp;&amp; !NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">		Status = LdrpLoadModule(SearchPath,<span class="number">0</span>,&amp;DllName,Module,<span class="literal">NULL</span>); </span><br><span class="line">		<span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">			Status = LdrFindEntryForName (&amp;DllName, Module, FALSE); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LdrpLoadModule"><a href="#LdrpLoadModule" class="headerlink" title="LdrpLoadModule"></a>LdrpLoadModule</h4><p>之所以要在加载模块表中查找,找不到才加载,是因为避免同一个模块加载两次。<br>下面的函数用来加载一个模块。(注意这个函数也供LoadLibrary API内部间接调用) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">LdrpLoadModule</span><span class="params">(IN PWSTR SearchPath OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params"> 	 	 	   IN ULONG LoadFlags, </span></span></span><br><span class="line"><span class="function"><span class="params"> 	 	 	   IN PUNICODE_STRING Name,<span class="comment">//模块名 </span></span></span></span><br><span class="line"><span class="function"><span class="params"> 	 	 	   PLDR_DATA_TABLE_ENTRY *Module, </span></span></span><br><span class="line"><span class="function"><span class="params"> 	 	 	   PVOID *BaseAddress OPTIONAL)</span><span class="comment">//返回实际加载的地址 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (Module == <span class="literal">NULL</span>) </span><br><span class="line">	Module = &amp;tmpModule; </span><br><span class="line">	LdrAdjustDllName(&amp;AdjustedName, Name, FALSE); </span><br><span class="line">	MappedAsDataFile = FALSE; </span><br><span class="line">	Status = LdrFindEntryForName(&amp;AdjustedName, Module, TRUE);<span class="comment">//仍要先查找 </span></span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> != BaseAddress) </span><br><span class="line">			*BaseAddress = (*Module)-&gt;DllBase; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//先尝试在\KnownDlls对象目录中查找该dll文件的section对象 </span></span><br><span class="line">		Status = LdrpMapKnownDll(&amp;AdjustedName, &amp;FullDosName, &amp;SectionHandle); </span><br><span class="line">		<span class="keyword">if</span> (!NT_SUCCESS(Status))<span class="comment">//若找不到,则为该dll文件创建一个映像文件section </span></span><br><span class="line">		&#123; </span><br><span class="line">			MappedAsDataFile = (<span class="number">0</span> != (LoadFlags &amp; LOAD_LIBRARY_AS_DATAFILE)); </span><br><span class="line">			<span class="comment">//内部会调用NtCreateSection系统服务,创建一个section </span></span><br><span class="line">			Status = LdrpMapDllImageFile(SearchPath, &amp;AdjustedName, &amp;FullDosName, MappedAsDataFile, &amp;SectionHandle); </span><br><span class="line">		&#125; </span><br><span class="line">		ViewSize = <span class="number">0</span>;<span class="comment">//表示映射整个dll文件 </span></span><br><span class="line">		ImageBase = <span class="number">0</span>;<span class="comment">//表示不指定映射的地址 </span></span><br><span class="line">		ArbitraryUserPointer = NtCurrentTeb()-&gt;NtTib.ArbitraryUserPointer; </span><br><span class="line">		NtCurrentTeb()-&gt;NtTib.ArbitraryUserPointer = FullDosName.Buffer; </span><br><span class="line">		Status = NtMapViewOfSection(SectionHandle,NtCurrentProcess(), </span><br><span class="line">		 	 	 	 	 	&amp;ImageBase,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">NULL</span>,&amp;ViewSize,ViewShare,<span class="number">0</span>,…); </span><br><span class="line">		NtCurrentTeb()-&gt;NtTib.ArbitraryUserPointer = ArbitraryUserPointer; </span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> != BaseAddress) </span><br><span class="line">		*BaseAddress = ImageBase; </span><br><span class="line">		<span class="keyword">if</span> (MappedAsDataFile)<span class="comment">//dll可以当做纯数据文件加载 </span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> (<span class="literal">NULL</span> != BaseAddress) </span><br><span class="line">			 	*BaseAddress = (PVOID) ((<span class="keyword">char</span> *) *BaseAddress + <span class="number">1</span>);<span class="comment">//复用标志 </span></span><br><span class="line">			*Module = <span class="literal">NULL</span>; </span><br><span class="line">			<span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">//if 实际加载映射的地址与该dll期望的加载地址不同,执行重定位 </span></span><br><span class="line">		<span class="keyword">if</span> (ImageBase != (PVOID) NtHeaders-&gt;OptionalHeader.ImageBase) </span><br><span class="line">			Status = LdrPerformRelocations(NtHeaders, ImageBase); </span><br><span class="line">		</span><br><span class="line">		*Module = LdrAddModuleEntry(ImageBase, NtHeaders, FullDosName.Buffer); </span><br><span class="line">		(*Module)-&gt;SectionPointer = SectionHandle; </span><br><span class="line">		<span class="keyword">if</span> (ImageBase != (PVOID) NtHeaders-&gt;OptionalHeader.ImageBase) </span><br><span class="line">			(*Module)-&gt;Flags |= LDRP_IMAGE_NOT_AT_BASE; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (NtHeaders-&gt;FileHeader.Characteristics &amp; IMAGE_FILE_DLL) </span><br><span class="line">			(*Module)-&gt;Flags |= LDRP_IMAGE_DLL; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//又加载该dll本身依赖的所有其他dll,修正它的导入表 </span></span><br><span class="line">		Status = LdrFixupImports(SearchPath, *Module); </span><br><span class="line">		<span class="comment">//当所有子孙dll初始化完后,自己才初始化完毕,此时才加入初始化顺序链表中 </span></span><br><span class="line">		InsertTailList(&amp;NtCurrentPeb()-&gt;Ldr-&gt;InInitializationOrderModuleList, </span><br><span class="line">		          &amp;(*Module)-&gt;InInitializationOrderModuleList); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此进程启动时的初始化工作已经初始完毕。<br>Exe文件及其依赖的所有dll以及tls工作最终都完成处理了, 这时候该APC函数将返回。</p>
<h3 id="BaseProcessStartThunk"><a href="#BaseProcessStartThunk" class="headerlink" title="BaseProcessStartThunk"></a>BaseProcessStartThunk</h3><blockquote>
<p>这个<code>LdrInitializeThunk</code>要返回哪里呢？</p>
</blockquote>
<p>答案是返回到内核,然后才恢复用户寄 存器现场,正式退回用户空间,<br>执行主线程的用户空间总入口函数<code>BaseProcessStartThunk</code><br>换句话说当程序流执行到<code>BaseProcessStartThunk</code>这个函数时,进程已初始化,各dll已完成加载。<br>此时,万事俱备只欠东风了,线程可以放马在用户空间执行了。 </p>
<h4 id="主线程的用户空间总入口"><a href="#主线程的用户空间总入口" class="headerlink" title="主线程的用户空间总入口"></a>主线程的用户空间总入口</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">_BaseProcessStartThunk@<span class="number">0</span>:<span class="comment">//主线程的用户空间总入口(内核总入口是KiThreadStartup) </span></span><br><span class="line">&#123; </span><br><span class="line">    xor ebp, ebp    </span><br><span class="line">    push eax                 <span class="comment">//oep </span></span><br><span class="line">    push <span class="number">0</span>                  <span class="comment">//表示不会返回 jmp _BaseProcessStartup@4 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">declspec(noreturn) <span class="function">VOID  <span class="title">BaseProcessStartup</span><span class="params">(PPROCESS_START_ROUTINE lpStartAddress)</span>   <span class="comment">//主线程的入口 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    UINT uExitCode = <span class="number">0</span>; </span><br><span class="line">    _SEH2_TRY <span class="comment">//放在try块中保护 </span></span><br><span class="line">    &#123; </span><br><span class="line">		NtSetInformationThread(NtCurrentThread(),ThreadQuerySetWin32StartAddress, &amp;lpStartAddress,<span class="keyword">sizeof</span>(PPROCESS_START_ROUTINE)); </span><br><span class="line">		<span class="comment">//lpStartAddress即oep,一般就是WinMainCRTStartup/MainCRTStartup </span></span><br><span class="line">		uExitCode = (lpStartAddress)();<span class="comment">//转去oep </span></span><br><span class="line">    &#125; </span><br><span class="line">    _SEH2_EXCEPT(BaseExceptionFilter(_SEH2_GetExceptionInformation())) </span><br><span class="line">    &#123; </span><br><span class="line">        uExitCode = _SEH2_GetExceptionCode(); </span><br><span class="line">    &#125; </span><br><span class="line">    _SEH2_END; </span><br><span class="line">    </span><br><span class="line">    ExitProcess(uExitCode);<span class="comment">//当WinMain函数正常退出后,进程才退出 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="普通线程的用户空间总入口"><a href="#普通线程的用户空间总入口" class="headerlink" title="普通线程的用户空间总入口"></a>普通线程的用户空间总入口</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_BaseThreadStartupThunk@<span class="number">0</span>: <span class="comment">//一般普通线程的用户空间总入口(内核总入口是KiThreadStartup) </span></span><br><span class="line">&#123; </span><br><span class="line">    xor ebp, ebp   </span><br><span class="line">    push ebx                 <span class="comment">//用户自己的context*参数 </span></span><br><span class="line">    push eax                 <span class="comment">//用户自己的线程入口函数 </span></span><br><span class="line">    push <span class="number">0</span>                  <span class="comment">//表示不会返回 jmp _BaseThreadStartup@8 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//一般普通线程的入口 </span></span><br><span class="line">declspec(noreturn) </span><br><span class="line"><span class="function">VOID  <span class="title">BaseThreadStartup</span><span class="params">(LPTHREAD_START_ROUTINE lpStartAddress,<span class="comment">//用户自己的线程入口函数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                        LPVOID lpParameter)</span><span class="comment">//用户自己函数的context* </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">volatile</span> UINT uExitCode = <span class="number">0</span>; </span><br><span class="line">	_SEH2_TRY <span class="comment">//也置于try块中保护 </span></span><br><span class="line">	&#123; </span><br><span class="line">		uExitCode = (lpStartAddress)((PVOID)lpParameter); </span><br><span class="line">	&#125; </span><br><span class="line">	_SEH2_EXCEPT(BaseThreadExceptionFilter(_SEH2_GetExceptionInformation())) </span><br><span class="line">	&#123; </span><br><span class="line">		uExitCode = _SEH2_GetExceptionCode(); </span><br><span class="line">	&#125; _SEH2_END; </span><br><span class="line"></span><br><span class="line">	ExitThread(uExitCode);<span class="comment">//用户自己的线程入口函数返回后,线程自然退出 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LoadLibraryW"><a href="#LoadLibraryW" class="headerlink" title="LoadLibraryW"></a>LoadLibraryW</h3><p>Dll可以在进程启动初期,被PE加载器静态加载外,程序员也可以调用<code>LoadLibrary</code>API显式的动态加载。<br>看一下这个函数的原理,实际上这个函数不是API,是个宏,指向<code>LoadLibraryW</code>/<code>LoadLibraryA</code>。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HINSTANCE <span class="title">LoadLibraryW</span> <span class="params">(LPCWSTR lpLibFileName)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> 	<span class="keyword">return</span> LoadLibraryExW (lpLibFileName, <span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">HINSTANCE <span class="title">LoadLibraryExW</span> <span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params"> 	 	 	LPCWSTR  lpLibFileName, </span></span></span><br><span class="line"><span class="function"><span class="params"> 	 	 	HANDLE	hFile, </span></span></span><br><span class="line"><span class="function"><span class="params"> 	 	 	DWORD	dwFlags)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (dwFlags &amp; DONT_RESOLVE_DLL_REFERENCES) </span><br><span class="line">	DllCharacteristics = IMAGE_FILE_EXECUTABLE_IMAGE; </span><br><span class="line">	dwFlags &amp;= LOAD_WITH_ALTERED_SEARCH_PATH; </span><br><span class="line">	SearchPath = GetDllLoadPath(lpLibFileName);<span class="comment">//构造该dll的标准搜索路径 </span></span><br><span class="line">	RtlInitUnicodeString(&amp;DllName, (LPWSTR)lpLibFileName); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (dwFlags &amp; LOAD_LIBRARY_AS_DATAFILE) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//在加载模块表中查找该dll </span></span><br><span class="line">		Status = LdrGetDllHandle(SearchPath, <span class="literal">NULL</span>, &amp;DllName, (PVOID*)&amp;hInst); </span><br><span class="line">		<span class="keyword">if</span> (!NT_SUCCESS(Status))<span class="comment">//若找不到 </span></span><br><span class="line">		&#123; </span><br><span class="line">		    Status = LoadLibraryAsDatafile(SearchPath, DllName.Buffer, &amp;hInst); </span><br><span class="line">		    Return Status; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (InWindows) <span class="comment">//Windows中的实现 </span></span><br><span class="line">		Status = LdrLoadDll(SearchPath,&amp;DllCharacteristics,&amp;DllName, (PVOID*)&amp;hInst); </span><br><span class="line">	Else <span class="comment">//ROS中的实现 </span></span><br><span class="line">		Status = LdrLoadDll(SearchPath, &amp;dwFlags, &amp;DllName, (PVOID*)&amp;hInst); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ( !NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">		SetLastErrorByStatus (Status); </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> hInst; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GetDllLoadPath"><a href="#GetDllLoadPath" class="headerlink" title="GetDllLoadPath"></a>GetDllLoadPath</h4><p>下面的函数用来从指定dll文件路径构造一个dll搜索路径(完整原代码) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPWSTR <span class="title">GetDllLoadPath</span><span class="params">(LPCWSTR lpModule)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> 	ULONG Pos = <span class="number">0</span>, Length = <span class="number">0</span>; </span><br><span class="line"> 	PWCHAR EnvironmentBufferW = <span class="literal">NULL</span>; </span><br><span class="line"> 	LPCWSTR lpModuleEnd = <span class="literal">NULL</span>; </span><br><span class="line"> 	UNICODE_STRING ModuleName; </span><br><span class="line"> 	DWORD LastError = GetLastError();  </span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">if</span> ((lpModule != <span class="literal">NULL</span>) &amp;&amp; (wcslen(lpModule) &gt; <span class="number">2</span>) &amp;&amp; (lpModule[<span class="number">1</span>] == <span class="string">':'</span>)) </span><br><span class="line"> 	 	lpModuleEnd = lpModule + wcslen(lpModule); </span><br><span class="line"> 	<span class="keyword">else</span> </span><br><span class="line"> 	&#123; </span><br><span class="line"> 	 	ModuleName = NtCurrentPeb()-&gt;ProcessParameters-&gt;ImagePathName; </span><br><span class="line"> 	 	lpModule = ModuleName.Buffer; </span><br><span class="line"> 	 	lpModuleEnd = lpModule + (ModuleName.Length / <span class="keyword">sizeof</span>(WCHAR)); </span><br><span class="line"> 	&#125; </span><br><span class="line"> 	<span class="keyword">if</span> (lpModule != <span class="literal">NULL</span>) </span><br><span class="line"> 	&#123; </span><br><span class="line"> 	 	while (lpModuleEnd &gt; lpModule &amp;&amp; *lpModuleEnd != L'/' &amp;&amp; </span><br><span class="line"> 	 	       *lpModuleEnd != L'\\' &amp;&amp; *lpModuleEnd != L':') </span><br><span class="line"> 	 	&#123; </span><br><span class="line"> 	 	 	--lpModuleEnd; </span><br><span class="line"> 	 	&#125; </span><br><span class="line"> 	 	Length = (lpModuleEnd - lpModule) + <span class="number">1</span>; </span><br><span class="line"> 	&#125; </span><br><span class="line">     <span class="comment">//看到没,LoadLibrary的dll搜索路径顺序是这样(注意与静态加载时的搜索路径不同) </span></span><br><span class="line"> 	Length += GetCurrentDirectoryW(<span class="number">0</span>, <span class="literal">NULL</span>); </span><br><span class="line"> 	Length += GetDllDirectoryW(<span class="number">0</span>, <span class="literal">NULL</span>); </span><br><span class="line"> 	Length += GetSystemDirectoryW(<span class="literal">NULL</span>, <span class="number">0</span>); </span><br><span class="line"> 	Length += GetWindowsDirectoryW(<span class="literal">NULL</span>, <span class="number">0</span>); </span><br><span class="line"> 	Length += GetEnvironmentVariableW(<span class="string">L"PATH"</span>, <span class="literal">NULL</span>, <span class="number">0</span>); </span><br><span class="line"> 	EnvironmentBufferW = RtlAllocateHeap(RtlGetProcessHeap(), <span class="number">0</span>,Length * <span class="keyword">sizeof</span>(WCHAR)); </span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">if</span> (lpModule) </span><br><span class="line"> 	&#123; </span><br><span class="line"> 	 	RtlCopyMemory(EnvironmentBufferW, lpModule, (lpModuleEnd - lpModule) *<span class="keyword">sizeof</span>(WCHA R)); </span><br><span class="line"> 	 	Pos += lpModuleEnd - lpModule; </span><br><span class="line"> 	 	EnvironmentBufferW[Pos++] = L';'; </span><br><span class="line"> 	&#125; </span><br><span class="line"> 	Pos += GetCurrentDirectoryW(Length, EnvironmentBufferW + Pos); </span><br><span class="line"> 	EnvironmentBufferW[Pos++] = L';'; </span><br><span class="line"> 	Pos += GetDllDirectoryW(Length - Pos, EnvironmentBufferW + Pos); </span><br><span class="line"> 	EnvironmentBufferW[Pos++] = L';'; </span><br><span class="line"> 	Pos += GetSystemDirectoryW(EnvironmentBufferW + Pos, Length - Pos); </span><br><span class="line"> 	EnvironmentBufferW[Pos++] = L';'; </span><br><span class="line"> 	Pos += GetWindowsDirectoryW(EnvironmentBufferW + Pos, Length - Pos); </span><br><span class="line"> 	EnvironmentBufferW[Pos++] = L';'; </span><br><span class="line"> 	Pos += GetEnvironmentVariableW(<span class="string">L"PATH"</span>, EnvironmentBufferW + Pos, Length - Pos); </span><br><span class="line"> 	SetLastError(LastError); </span><br><span class="line"> 	<span class="keyword">return</span> EnvironmentBufferW; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">NTSTATUS NTAPI </span><br><span class="line">LdrLoadDll (IN PWSTR SearchPath OPTIONAL, </span><br><span class="line"> 	 	 	IN PULONG LoadFlags OPTIONAL, </span><br><span class="line"> 	 	 	IN PUNICODE_STRING Name, </span><br><span class="line"> 	 	 	OUT PVOID *BaseAddress)<span class="comment">//也即返回的hModule </span></span><br><span class="line">&#123; </span><br><span class="line"> 	PPEB Peb = NtCurrentPeb(); </span><br><span class="line"> 	Status = LdrpLoadModule(SearchPath, LoadFlags ? *LoadFlags : <span class="number">0</span>, Name, &amp;Module, BaseAddr ess); </span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">if</span> (NT_SUCCESS(Status) &amp;&amp; (!LoadFlags || <span class="number">0</span> == (*LoadFlags &amp; LOAD_LIBRARY_AS_DATAFILE))) </span><br><span class="line"> 	&#123; </span><br><span class="line"> 	 	<span class="keyword">if</span> (!(Module-&gt;Flags &amp; LDRP_PROCESS_ATTACH_CALLED)) </span><br><span class="line"> 	 	 	Status = LdrpAttachProcess();<span class="comment">//通知一个ProcessAttach消息 </span></span><br><span class="line"> 	&#125; </span><br><span class="line"> 	*BaseAddress = NT_SUCCESS(Status) ? Module-&gt;DllBase : <span class="literal">NULL</span>; </span><br><span class="line"> 	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LdrpAttachThread"><a href="#LdrpAttachThread" class="headerlink" title="LdrpAttachThread"></a>LdrpAttachThread</h4><p>下面的函数在每次一个新线程创建时调用,用以调用各个模块的DllMain和tls回调函数 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS  <span class="title">LdrpAttachThread</span> <span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	Status = LdrpInitializeTlsForThread(); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">		ModuleListHead = &amp;NtCurrentPeb()-&gt;Ldr-&gt;InInitializationOrderModuleList; </span><br><span class="line">		Entry = ModuleListHead-&gt;Flink; </span><br><span class="line">		<span class="keyword">while</span> (Entry != ModuleListHead)<span class="comment">//遍历初始化顺序模块表 </span></span><br><span class="line">		&#123; </span><br><span class="line">			Module = CONTAINING_RECORD(Entry, LDR_DATA_TABLE_ENTRY, InInitializationOrderM</span><br><span class="line">			oduleList); </span><br><span class="line">			 	<span class="keyword">if</span> (Module-&gt;Flags &amp; LDRP_PROCESS_ATTACH_CALLED &amp;&amp; </span><br><span class="line">			 	 	!(Module-&gt;Flags &amp; LDRP_DONT_CALL_FOR_THREADS) &amp;&amp; </span><br><span class="line">			 	 	!(Module-&gt;Flags &amp; LDRP_UNLOAD_IN_PROGRESS)) </span><br><span class="line">			 	&#123; </span><br><span class="line">					<span class="comment">//调用DllMain,注意是DLL_THREAD_ATTACH通知码 </span></span><br><span class="line">					LdrpCallDllEntry(Module, DLL_THREAD_ATTACH, <span class="literal">NULL</span>); </span><br><span class="line">			 	&#125; </span><br><span class="line">				Entry = Entry-&gt;Flink; </span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">		Entry = NtCurrentPeb()-&gt;Ldr-&gt;InLoadOrderModuleList.Flink;<span class="comment">//exe模块 </span></span><br><span class="line">		Module = CONTAINING_RECORD(Entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks); </span><br><span class="line">		LdrpTlsCallback(Module, DLL_THREAD_ATTACH); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LdrpAttachProcess"><a href="#LdrpAttachProcess" class="headerlink" title="LdrpAttachProcess"></a>LdrpAttachProcess</h4><p>下面的函数在主线程创建时调用,用以调用各个模块的DllMain和tls回调函数 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">LdrpAttachProcess</span><span class="params">(VOID)</span> </span>&#123; </span><br><span class="line">	NTSTATUS Status = STATUS_SUCCESS; </span><br><span class="line">	ModuleListHead = &amp;NtCurrentPeb()-&gt;Ldr-&gt;InInitializationOrderModuleList; </span><br><span class="line">	Entry = ModuleListHead-&gt;Flink; </span><br><span class="line">	<span class="keyword">while</span> (Entry != ModuleListHead) </span><br><span class="line">	&#123; </span><br><span class="line">		Module = CONTAINING_RECORD(Entry, LDR_DATA_TABLE_ENTRY, </span><br><span class="line">		InInitializationOrderModuleList); </span><br><span class="line">		<span class="keyword">if</span> (!(Module-&gt;Flags &amp; (LDRP_LOAD_IN_PROGRESS|LDRP_UNLOAD_IN_PROGRESS| </span><br><span class="line">				LDRP_ENTRY_PROCESSED)))</span><br><span class="line">		&#123; </span><br><span class="line">			Module-&gt;Flags |= LDRP_LOAD_IN_PROGRESS; </span><br><span class="line">			<span class="comment">//调用DllMain,注意是DLL_PROCESS_ATTACH通知码 </span></span><br><span class="line">				Result = LdrpCallDllEntry(Module, DLL_PROCESS_ATTACH, (Module-&gt;LoadCount == </span><br><span class="line">			LDRP_PROCESS_CREATION_TIME ? <span class="number">1</span> : <span class="number">0</span>)); </span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (Module-&gt;Flags &amp; LDRP_IMAGE_DLL &amp;&amp; Module-&gt;EntryPoint != <span class="number">0</span>) </span><br><span class="line">				Module-&gt;Flags |= LDRP_PROCESS_ATTACH_CALLED|LDRP_ENTRY_PROCESSED; </span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				Module-&gt;Flags |= LDRP_ENTRY_PROCESSED; </span><br><span class="line">			</span><br><span class="line">			Module-&gt;Flags &amp;= ~LDRP_LOAD_IN_PROGRESS; </span><br><span class="line">		&#125; </span><br><span class="line">		Entry = Entry-&gt;Flink; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="线程调度与切换"><a href="#线程调度与切换" class="headerlink" title="线程调度与切换"></a>线程调度与切换</h2><p>众所周知:Windows系统是一个分时抢占式系统,分时指每个线程分配时间片,抢占指时间片到期前,中途可以被其他更高优先级的线程强制抢占。<br>背景知识:每个cpu都有一个TSS,叫”任务状态段’。<br>这个TSS内部中的一些字段记录着该cpu上当前正在 运行的那个线程的一些信息(如ESP0记录着该线程的内核栈位置,IO权限位图记录着当前线程的IO空间权限)<br>IO空间有64KB,IO权限位图中的每一位记录着对应IO地址的IN、OUT许可权限,所以IO权限位图本身有8KB 大小,TSS中就就记录着当前线程IO权限位图的偏移位置。 </p>
<p>每当切换线程时:自然要跟着修改TSS中的ESP0和IO权限位图。</p>
<blockquote>
<p>TSS0中为什么要保存当前线程的内核栈位置？</p>
</blockquote>
<p>原因是:每当一个线程内部,从用户模式进入内核模式时,需要将cpu中的esp换成该线程的内核栈(各 线程的内核栈是不同的)<br>每当进入内核模式时,cpu就自动从TSS中找到ESP0,然后MOV ESP, TSS.ESP0,换 成内核栈后,cpu然后在内核栈中压入浮点寄存器和标准的5个寄存器:原cs、原eip、原ss、原esp、原ef lags。<br>这就是为什么需要在TSS中记录当前线程的内核栈地址。(注意ESP0并不是栈底地址,而是要压入保 存寄存器处的存放地址) </p>
<h3 id="线程切换相关数据结构"><a href="#线程切换相关数据结构" class="headerlink" title="线程切换相关数据结构"></a>线程切换相关数据结构</h3><h4 id="KPCR"><a href="#KPCR" class="headerlink" title="KPCR"></a>KPCR</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Struct KPCR <span class="comment">//处理器控制块(内核中的fs寄存器总是指向这个结构体的基址) </span></span><br><span class="line">&#123; </span><br><span class="line">   KPCR_TIB Tib; </span><br><span class="line">   KPCR* self;<span class="comment">//方便寻址 </span></span><br><span class="line">   KPRCB* Prcb; </span><br><span class="line">   KIRQL irql;<span class="comment">//物理上表示cpu的当前中断级,逻辑上理解为当前线程的中断级更好 </span></span><br><span class="line">   USHORT* IDT;<span class="comment">//本cpu的中断描述符表的地址 </span></span><br><span class="line">   USHORT* GDT;<span class="comment">//本cpu的全局描述符表的地址 </span></span><br><span class="line">   KTSS* TSS;<span class="comment">//本cpu上当前线程的信息(ESP0) </span></span><br><span class="line">   … </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KPCR-TIB"><a href="#KPCR-TIB" class="headerlink" title="KPCR_TIB"></a>KPCR_TIB</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Struct KPCR_TIB </span><br><span class="line">&#123; </span><br><span class="line">   Void* ExceptionList;<span class="comment">//当前线程的内核seh链表头结点地址 </span></span><br><span class="line">   Void* StackBase;<span class="comment">//内核栈底地址 </span></span><br><span class="line">   Void* StackLimit;<span class="comment">//栈的提交边界 </span></span><br><span class="line">   … </span><br><span class="line">   KPCR_TIB* self;<span class="comment">//方便寻址 </span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KPRCB"><a href="#KPRCB" class="headerlink" title="KPRCB"></a>KPRCB</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Struct KPRCB </span><br><span class="line">&#123; </span><br><span class="line">   … </span><br><span class="line">   KTHREAD* CurrentThread;<span class="comment">//本cpu上当前正在运行的线程 </span></span><br><span class="line">   KTHREAD* NextThread;<span class="comment">//将剥夺(即抢占)当前线程的下一个线程 </span></span><br><span class="line">  KTHREAD* IdleThread;<span class="comment">//空转线程 </span></span><br><span class="line">  BOOL QuantumEnd;<span class="comment">//重要字段。指当前线程的时间片是否已经用完。 </span></span><br><span class="line">  LIST_ENTRY WaitListHead;<span class="comment">//本cpu的等待线程队列 </span></span><br><span class="line">  ULONG ReadSummary;<span class="comment">//各就绪队列中是否为空的标志 </span></span><br><span class="line">  ULONG SelectNextLast; </span><br><span class="line">  LIST_ENTRY DispatcherReadyListHead[<span class="number">32</span>];<span class="comment">//对应32个优先级的32个就绪线程队列 </span></span><br><span class="line">  FX_SAVE_AREA NpxSaveArea; </span><br><span class="line">  … </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KSWITCHFRAME-1"><a href="#KSWITCHFRAME-1" class="headerlink" title="_KSWITCHFRAME"></a><code>_KSWITCHFRAME</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSWITCHFRAME</span> //切换帧(用来保存切换线程) </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	PVOID ExceptionList;<span class="comment">//保存线程切换时的内核she链表(不是用户空间中的seh) Union </span></span><br><span class="line">	&#123; </span><br><span class="line">		BOOLEAN ApcBypassDisable;</span><br><span class="line">		<span class="comment">//用于首次调度 UCHAR </span></span><br><span class="line">		WaitIrql;</span><br><span class="line">		<span class="comment">//用于保存切换时的WaitIrql </span></span><br><span class="line">	&#125;; </span><br><span class="line">	<span class="comment">//实际上首次时为KiThreadStartup,以后都固定为call KiSwapContextInternal后面的那条指令 </span></span><br><span class="line"></span><br><span class="line">    PVOID RetAddr;<span class="comment">//保存发生切换时的断点地址(以后切换回来时从这儿继续执行) </span></span><br><span class="line">&#125; KSWITCHFRAME, *PKSWITCHFRAME;</span><br></pre></td></tr></table></figure>
<h4 id="Trap现场帧"><a href="#Trap现场帧" class="headerlink" title="Trap现场帧"></a>Trap现场帧</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KTRAP_FRAME</span>  </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="comment">// ------------------这些是KiSystemService保存的--------------------------- </span></span><br><span class="line">	ULONG DbgEbp; </span><br><span class="line">	ULONG DbgEip; </span><br><span class="line">	ULONG DbgArgMark; </span><br><span class="line">	ULONG DbgArgPointer; </span><br><span class="line">	ULONG TempSegCs; </span><br><span class="line">	ULONG TempEsp; </span><br><span class="line">	ULONG Dr0; </span><br><span class="line">	ULONG Dr1; </span><br><span class="line">	ULONG Dr2; </span><br><span class="line">	ULONG Dr3; </span><br><span class="line">	ULONG Dr6; </span><br><span class="line">	ULONG Dr7; </span><br><span class="line">	ULONG SegGs; </span><br><span class="line">	ULONG SegEs; </span><br><span class="line"></span><br><span class="line">	ULONG SegDs; </span><br><span class="line">	ULONG Edx;<span class="comment">//xy 这个位置不是用来保存edx的,而是用来保存上个Trap帧,因为Trap帧是可以嵌套的 </span></span><br><span class="line">	ULONG Ecx; <span class="comment">//中断和异常引起的自陷要保存eax,系统调用则不需保存ecx </span></span><br><span class="line">	ULONG Eax;<span class="comment">//中断和异常引起的自陷要保存eax,系统调用则不需保存eax </span></span><br><span class="line">	ULONG PreviousPreviousMode; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> <span class="title">FAR</span> *<span class="title">ExceptionList</span>;</span><span class="comment">//上次seh链表的开头地址 </span></span><br><span class="line">	ULONG SegFs; </span><br><span class="line">	ULONG Edi; </span><br><span class="line">	ULONG Esi; </span><br><span class="line">	ULONG Ebx; ULONG Ebp; </span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------- </span></span><br><span class="line">	ULONG ErrCode;<span class="comment">//发生的不是中断,而是异常时,cpu还会自动在栈中压入对应的具体异常码在这儿 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------下面5个寄存器是由int 2e内部本身保存的或KiFastCallEntry模拟保存的现场--------- </span></span><br><span class="line">	ULONG Eip; </span><br><span class="line">	ULONG SegCs; </span><br><span class="line">	ULONG EFlags; </span><br><span class="line">	ULONG HardwareEsp; ULONG HardwareSegSs; </span><br><span class="line"><span class="comment">// ---------------以下用于用于保存V86模式的4个寄存器也是cpu自动压入的------------------- </span></span><br><span class="line">	ULONG V86Es; </span><br><span class="line">	ULONG V86Ds; </span><br><span class="line">	ULONG V86Fs; ULONG V86Gs; </span><br><span class="line">&#125; KTRAP_FRAME, *PKTRAP_FRAME;</span><br></pre></td></tr></table></figure>
<h3 id="KiSwapContex切换线程核心"><a href="#KiSwapContex切换线程核心" class="headerlink" title="KiSwapContex切换线程核心"></a>KiSwapContex切换线程核心</h3><p>下面这个核心函数用来切换线程(从当前线程切换到新线程去)。<br>这个函数的原型是:<code>BOOL FASTCALL KiSwapContex(KTHREAD* Currentthread*, KTHREAD* NewThread);</code><br>返回值表示下次切换回来时是否需要手动扫描执行内核APC。</p>
<p>这个函数的汇编代码为:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@KiSwapContext@<span class="number">8</span>:  <span class="comment">//开头的@表示fastcall调用约定 </span></span><br><span class="line">&#123; </span><br><span class="line">	sub esp, <span class="number">4</span> * <span class="number">4</span> <span class="comment">//腾出局部变量空间 </span></span><br><span class="line">	<span class="comment">//保存这4个寄存器,因为KiSwapContextInternal函数内部要使用这几个寄存器 </span></span><br><span class="line">	mov [esp+<span class="number">12</span>], ebx </span><br><span class="line">	mov [esp+<span class="number">8</span>], esi </span><br><span class="line">	mov [esp+<span class="number">4</span>], edi </span><br><span class="line">	mov [esp+<span class="number">0</span>], ebp </span><br><span class="line"></span><br><span class="line">	mov ebx, fs:[KPCR_SELF] <span class="comment">//ebx=当前cpu的KPCR* </span></span><br><span class="line">	mov edi, ecx <span class="comment">//edi= KiSwapContext的第一个参数,即CurrentThread </span></span><br><span class="line">	mov esi, edx <span class="comment">//edi= KiSwapContext的第而个参数,即NewThread </span></span><br><span class="line">	movzx ecx, byte ptr [edi+KTHREAD_WAIT_IRQL] <span class="comment">//ecx=当前线程的WaitIrql </span></span><br><span class="line"></span><br><span class="line">	call @KiSwapContextInternal@<span class="number">0</span> <span class="comment">//调用真正的切换工作函数 </span></span><br><span class="line">	<span class="comment">// 这中间已经被切换到新线程去了,当前线程已经让出cpu,挂入了就绪队列。</span></span><br><span class="line">	<span class="comment">// 需要等到下次重新被调度运行时,才又从这儿的断点处继续向下执行下去 </span></span><br><span class="line"></span><br><span class="line">	mov ebp, [esp+<span class="number">0</span>] <span class="comment">//这条指令就是断点处,以后切换回来时就从这个断点处继续执行 </span></span><br><span class="line">	mov edi, [esp+<span class="number">4</span>] </span><br><span class="line">	mov esi, [esp+<span class="number">8</span>] </span><br><span class="line">	mov ebx, [esp+<span class="number">12</span> </span><br><span class="line">	add esp, <span class="number">4</span> * <span class="number">4</span> </span><br><span class="line">	ret </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="KiSwapContextInternal"><a href="#KiSwapContextInternal" class="headerlink" title="KiSwapContextInternal"></a>KiSwapContextInternal</h3><p>下面的函数完成真正的切换工作(返回值表示切换回来后是否需要手动扫描执行内核apc)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">@KiSwapContextInternal@<span class="number">0</span>: <span class="comment">//edi指向当前线程,esi指向要切换到的新线程,ebx指向当前KPCR* </span></span><br><span class="line">&#123; </span><br><span class="line">	inc dword ptr es:[ebx+KPCR_CONTEXT_SWITCHES] <span class="comment">//递增当前cpu上发生的历史线程切换计数 </span></span><br><span class="line">	push ecx <span class="comment">//保存本线程切换时的WaitIrql </span></span><br><span class="line">	push [ebx+KPCR_EXCEPTION_LIST] <span class="comment">//保存本线程切换时的内核seh链表 </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ----------至此,上面的两条push连同本函数的返回地址(即断点地址),就构成了一个切换帧。</span></span><br><span class="line">	<span class="comment">// ----------当前线程切换时的内核栈顶位置就在此处</span></span><br><span class="line">AfterTrace: </span><br><span class="line">	mov ebp, cr0 </span><br><span class="line">	mov edx, ebp <span class="comment">//将cr0寄存器保存在edx中(cr0的Bit3位“TaskSwitched”标志位,与浮点运算相关) </span></span><br><span class="line"></span><br><span class="line">SetStack: </span><br><span class="line">	mov [edi+KTHREAD_KERNEL_STACK], esp <span class="comment">//保存本线程切换时的内核栈顶位置 </span></span><br><span class="line">	mov eax, [esi+KTHREAD_INITIAL_STACK] <span class="comment">//eax=新线程的内核栈底地址 </span></span><br><span class="line">	-------------------------------------------------------------------------------- </span><br><span class="line">	cli <span class="comment">//下面检查Npx浮点寄存器,要关中断 </span></span><br><span class="line">	movzx ecx, byte ptr [esi+KTHREAD_NPX_STATE] <span class="comment">//ecx=新线程的Npx状态 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">and</span> edx, ~(CR0_MP + CR0_EM + CR0_TS) </span><br><span class="line">	<span class="keyword">or</span> ecx, edx </span><br><span class="line">	<span class="keyword">or</span> ecx, [eax - (NPX_FRAME_LENGTH - FN_CR0_NPX_STATE)] <span class="comment">//获得新线程需要的cr0 </span></span><br><span class="line">	cmp ebp, ecx </span><br><span class="line">	jnz NewCr0 <span class="comment">//如果新线程需要的cr0不同于当前的cr0,则修改当前cr0为新线程的cr0 StackOk: </span></span><br><span class="line">	Sti </span><br><span class="line">	-------------------------------------------------------------------------------- </span><br><span class="line">	mov esp, [esi+KTHREAD_KERNEL_STACK] <span class="comment">//关键。恢复成新线程当初被切换时的内核栈顶 </span></span><br><span class="line">	mov ebp, [esi+KTHREAD_APCSTATE_PROCESS] <span class="comment">//ebp=目标进程 </span></span><br><span class="line">	mov eax, [edi+KTHREAD_APCSTATE_PROCESS] <span class="comment">//eax=当前进程 </span></span><br><span class="line">	cmp ebp, eax <span class="comment">//检查是否是切换到同一个进程中的其他线程(若是。就不用切换LDT和cr3) </span></span><br><span class="line">	jz SameProcess  <span class="comment">//若切换到其他进程中的线程,则要同时修改LDT和CR3 </span></span><br><span class="line"></span><br><span class="line">	mov ecx, [ebp+KPROCESS_LDT_DESCRIPTOR0] </span><br><span class="line">	<span class="keyword">or</span> ecx, [eax+KPROCESS_LDT_DESCRIPTOR0] </span><br><span class="line">	jnz LdtReload <span class="comment">//如果两个进程的LDT不同,就要换用不同的LDT </span></span><br><span class="line"></span><br><span class="line">UpdateCr3: </span><br><span class="line">	mov eax, [ebp+KPROCESS_DIRECTORY_TABLE_BASE] </span><br><span class="line">	mov cr3, eax <span class="comment">//关键。将cr3换成目标进程的页目录 </span></span><br><span class="line"></span><br><span class="line">SameProcess: </span><br><span class="line">	xor eax, eax </span><br><span class="line">	mov gs, ax </span><br><span class="line">	mov eax, [esi+KTHREAD_TEB] <span class="comment">//新线程的TEB地址 </span></span><br><span class="line">	mov [ebx+KPCR_TEB], eax <span class="comment">//当前KPCR中的TEB指向新线程的TEB </span></span><br><span class="line">	mov ecx, [ebx+KPCR_GDT] </span><br><span class="line">	<span class="comment">//修改GDT中的TEB描述符,指向新线程的TEB </span></span><br><span class="line">	mov [ecx+<span class="number">0x3A</span>], ax </span><br><span class="line">	shr eax, <span class="number">16</span> </span><br><span class="line">	mov [ecx+<span class="number">0x3C</span>], al </span><br><span class="line">	mov [ecx+<span class="number">0x3F</span>], ah </span><br><span class="line">	mov eax, [esi+KTHREAD_INITIAL_STACK] <span class="comment">//eax=新线程的内核栈底位置 </span></span><br><span class="line">	sub eax, NPX_FRAME_LENGTH <span class="comment">//跳过浮点保存区空间 </span></span><br><span class="line">	test dword ptr [eax - KTRAP_FRAME_SIZE + KTRAP_FRAME_EFLAGS], EFLAGS_V86_MASK </span><br><span class="line">	jnz NoAdjust <span class="comment">//检查新线程是否运行在V86模式 </span></span><br><span class="line">	sub eax, KTRAP_FRAME_V86_GS - KTRAP_FRAME_SS <span class="comment">//跳过V86保存区 </span></span><br><span class="line"></span><br><span class="line">NoAdjust: </span><br><span class="line">	mov ecx, [ebx+KPCR_TSS] </span><br><span class="line">	mov [ecx+KTSS_ESP0], eax <span class="comment">//关键,修改TSS中的ESP0,指向新线程的内核栈底 </span></span><br><span class="line">	mov ax, [ebp+KPROCESS_IOPM_OFFSET] </span><br><span class="line">	mov [ecx+KTSS_IOMAPBASE], ax <span class="comment">//修改TSS中的IO权限位图偏移指向新进程中的IO权限位图 </span></span><br><span class="line">	inc dword ptr [esi+KTHREAD_CONTEXT_SWITCHES] <span class="comment">//递增线程的切换次数(也即历史调度次数) </span></span><br><span class="line">	pop [ebx+KPCR_EXCEPTION_LIST] <span class="comment">//将当前KPCR中记录的seh链表恢复成新线程的seh链表 </span></span><br><span class="line">	pop ecx <span class="comment">//ecx=新线程原来切换前的WaitIrql </span></span><br><span class="line"></span><br><span class="line">	cmp byte ptr [ebx+KPCR_PRCB_DPC_ROUTINE_ACTIVE], <span class="number">0</span> <span class="comment">//检查当前是否有DPC函数处于活动状态 </span></span><br><span class="line">	jnz BugCheckDpc <span class="comment">//蓝屏 </span></span><br><span class="line">	<span class="comment">//至此,cpu中的寄存器内容全部换成了新线程的那些寄存器,从这个意思上说,此时就已完成了全部 切换工作,下面的代码都是在新线程的环境中运行了。 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	--------------------------------新线程环境--------------------------------------- </span><br><span class="line">	--------------------------------新线程环境---------------------------------------</span><br><span class="line">	--------------------------------新线程环境---------------------------------------</span><br><span class="line">	</span><br><span class="line">	cmp byte ptr [esi+KTHREAD_PENDING_KERNEL_APC], <span class="number">0</span> </span><br><span class="line">	jnz CheckApc <span class="comment">//看到没,每次线程得到重新调度运行前,都会扫描执行内核apc队列中的函数 </span></span><br><span class="line">	xor eax, eax  </span><br><span class="line">	ret <span class="comment">//此处返回值表示没有内核apc </span></span><br><span class="line"></span><br><span class="line">CheckApc: </span><br><span class="line">	cmp word ptr [esi+KTHREAD_SPECIAL_APC_DISABLE], <span class="number">0</span> <span class="comment">//检查是否禁用了APC </span></span><br><span class="line">	jnz ApcReturn </span><br><span class="line">	test cl, cl <span class="comment">//检查WaitIrql,如果是APC级,就在本函数内部返回前,发出apc中断 </span></span><br><span class="line"></span><br><span class="line">	jz ApcReturn </span><br><span class="line">	<span class="comment">//if(SPECIAL APC 没禁用 &amp;&amp; WaitIrql!=PASSIVE_LEVEL),切换回来时就先执行内核APC </span></span><br><span class="line">	mov cl, APC_LEVEL </span><br><span class="line">	call @HalRequestSoftwareInterrupt@<span class="number">4</span> <span class="comment">//发出一个apc中断 </span></span><br><span class="line">	<span class="keyword">or</span> eax, esp <span class="comment">//既然发出apc中断了,那么就return FALSE表示无需手动扫描执行apc </span></span><br><span class="line"></span><br><span class="line">ApcReturn: </span><br><span class="line">	setz al </span><br><span class="line">	ret <span class="comment">//此处返回值表示切回来后是否需要手动扫描执行apc </span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当这个函数返回时,之前已经换成新线程的内核栈了。</span></span><br><span class="line">	<span class="comment">// 当函数返回后,将回到KiSwapContext中,当 KiSwapContext返回到调用方时,那个调用方就是新线程当初调用的KiSwapContext的函数</span></span><br><span class="line">	<span class="comment">// 这样就沿着 新线程的内核栈,逐级向上回溯到新线程中了。</span></span><br><span class="line"> 	<span class="comment">// 因此,可以说切换内核栈,即是切换线程。 </span></span><br><span class="line"></span><br><span class="line"> LdtReload: </span><br><span class="line">	mov eax, [ebp+KPROCESS_LDT_DESCRIPTOR0] </span><br><span class="line">	test eax, eax <span class="comment">//检测目标进程有没有LDT </span></span><br><span class="line">	jz LoadLdt </span><br><span class="line">	mov ecx, [ebx+KPCR_GDT] </span><br><span class="line">	mov [ecx+KGDT_LDT], eax <span class="comment">//改指目标进程的LDT </span></span><br><span class="line">	mov eax, [ebp+KPROCESS_LDT_DESCRIPTOR1] </span><br><span class="line">	mov [ecx+KGDT_LDT+<span class="number">4</span>], eax<span class="comment">//改指目标进程的LDT </span></span><br><span class="line">	<span class="comment">/* Write the INT21 handler */</span> </span><br><span class="line">	mov ecx, [ebx+KPCR_IDT] </span><br><span class="line">	mov eax, [ebp+KPROCESS_INT21_DESCRIPTOR0] </span><br><span class="line">	mov [ecx+<span class="number">0x108</span>], eax </span><br><span class="line">	mov eax, [ebp+KPROCESS_INT21_DESCRIPTOR1] </span><br><span class="line">	mov [ecx+<span class="number">0x10C</span>], eax </span><br><span class="line">	mov eax, KGDT_LDT </span><br><span class="line"></span><br><span class="line">LoadLdt: </span><br><span class="line">	lldt ax </span><br><span class="line">	jmp UpdateCr3 </span><br><span class="line"></span><br><span class="line">NewCr0: </span><br><span class="line">	mov cr0, ecx </span><br><span class="line">	jmp StackOk </span><br><span class="line"></span><br><span class="line">BugCheckDpc: </span><br><span class="line">	mov eax, [edi+KTHREAD_INITIAL_STACK] </span><br><span class="line">	push <span class="number">0</span> </span><br><span class="line">	push eax </span><br><span class="line">	push esi </span><br><span class="line">	push edi </span><br><span class="line">	push ATTEMPTED_SWITCH_FROM_DPC </span><br><span class="line">	call _KeBugCheckEx@<span class="number">20</span>  <span class="comment">//蓝屏提示:“尝试从活动DPC例程中切换线程” </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上:线程从<code>KiSwapContextInternal</code>这个函数内部切换出去,某一时刻又切换回这个函数内。<br>或者也可以理解为:线程从KiSwapContext这个函数切换出去,某一时刻又切换回这个函数内。<br>(注:可以hook这两个函数,来达到检测隐藏进程的目的) </p>
<p><br><br><br></p>
<h2 id="线程的调度策略与切换时机"><a href="#线程的调度策略与切换时机" class="headerlink" title="线程的调度策略与切换时机"></a>线程的调度策略与切换时机</h2><p>明白了线程切换的过程,所做的工作后<br>接下来看:线程的切换时机(也即一个线程什么时候会调用<code>KiSwapContext</code>这个函数把自己切换出去),相信这是大伙最感兴趣的问题。</p>
<p>调度策略:Windows严格按优先级调度线程。<br>优先级分成32个,每个cpu对应有32个就绪线程队列。<br>每当要发生线程切换时,就根据调度策略从32条就绪 队列中,按优先级从高到低的顺序扫描(同一个就绪队列中,由于优先级相同,则按FIFO顺序扫描)<br>这样从32条就绪队列中,找到优先级最高的那个候选就绪线程,给予调度执行。 </p>
<p>当一个线程得到调度执行时,如果一直没有任何其他就绪线程的优先级高于本线程,本线程就可以畅通无 阻地一直执行下去,直到本次的时间片用完。<br>但是如果本次执行的过程中,如果有个就绪线程的优先级突 然高于了本线程,那么本线程将被抢占,cpu将转去执行那个线程。<br>但是这种抢占可能不是立即性的,只有在当前线程的irql在<code>DISPATCH_LEVEL</code>以下(不包括),才会被立即抢占,<br>否则推迟抢占(即把那个高 优先级的就绪线程暂时记录到当前cpu的<code>KPCR</code>结构中的<code>NextThread</code>字段中,标记要将抢占)。 </p>
<blockquote>
<p>切换时机:一句话【时片、抢占、等、主动】 </p>
</blockquote>
<ul>
<li>1、 时间片耗尽 </li>
<li>2、 被抢占 </li>
<li>3、 因等待事件、资源、信号时主动放弃cpu(如调用WaitForSingleObject) </li>
<li>4、 主动切换(如主动调用SwitchToThread这个Win32 API)<br>但是即使到了切换时机了,也只有当线程的irql在<code>DISPATCH_LEVEL</code>以下(不包括)时,才可以被切换出 去,否则线程将继续占有cpu,一直等到irql降到<code>DISPATCH_LEVEL</code>以下。 </li>
</ul>
<p>线程的状态(不含挂起态,其实挂起态本质上也是一种等待态) </p>
<ul>
<li>1、Ready就绪态(挂入相应的就绪队列) </li>
<li>2、某一时刻得到调度变成Running运行态 </li>
<li>3、因等待某一事件、信号、资源等变成Waiting等待状态 </li>
<li>4、Standby状态。指处于抢占者状态(NextThread就是自己) </li>
<li>5、DeferredReady状态。指”将’进入就绪态。 </li>
</ul>
<h3 id="主动放弃cpu-NtYieldExecution"><a href="#主动放弃cpu-NtYieldExecution" class="headerlink" title="主动放弃cpu(NtYieldExecution)"></a>主动放弃cpu(NtYieldExecution)</h3><p>先看一下主动放弃cpu,切换线程的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtYieldExecution</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	NTSTATUS Status = STATUS_NO_YIELD_PERFORMED; </span><br><span class="line">	KIRQL OldIrql; </span><br><span class="line">	PKPRCB Prcb = KeGetCurrentPrcb();<span class="comment">//当前cpu的控制块 </span></span><br><span class="line">	PKTHREAD Thread = KeGetCurrentThread(), NextThread; <span class="keyword">if</span> (Prcb-&gt;ReadySummary==<span class="number">0</span>) </span><br><span class="line">	<span class="keyword">return</span> Status;<span class="comment">//如果没有其他线程处于就绪态,就不用切换了 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//重要。线程的调度过程与切换过程,本身就运行在SynchLevel,目的是防止在执行调度、切换工作的 过程中又被切换了出去。</span></span><br><span class="line">	<span class="comment">// 因此可以说,调度、切换这个过程是原子的。 </span></span><br><span class="line">	OldIrql = KeRaiseIrqlToSynchLevel();<span class="comment">//先提到SynchLevel,再做调度、切换工作 </span></span><br><span class="line">	<span class="keyword">if</span> (Prcb-&gt;ReadySummary!=<span class="number">0</span>)<span class="comment">//如果当前cpu上有就绪线程 </span></span><br><span class="line">	&#123; </span><br><span class="line">		KiAcquireThreadLock(Thread); </span><br><span class="line">		KiAcquirePrcbLock(Prcb); </span><br><span class="line">		<span class="keyword">if</span> (Prcb-&gt;NextThread != <span class="literal">NULL</span>) </span><br><span class="line">		NextThread = Prcb-&gt;NextThread;<span class="comment">//优先选择那个等待抢占的线程 </span></span><br><span class="line">		Else <span class="comment">//如果当前没有候选抢占线程,就从就绪队列调度出一个线程 </span></span><br><span class="line">		NextThread = KiSelectReadyThread(<span class="number">1</span>, Prcb);         </span><br><span class="line">		<span class="keyword">if</span> (NextThread) </span><br><span class="line">		&#123; </span><br><span class="line">			Thread-&gt;Quantum = Thread-&gt;QuantumReset;<span class="comment">//设置下次调度运行的时间片 </span></span><br><span class="line">			Thread-&gt;Priority = KiComputeNewPriority(Thread, <span class="number">1</span>);<span class="comment">//略微降低一个优先级 </span></span><br><span class="line">			KiReleaseThreadLock(Thread); </span><br><span class="line">			KiSetThreadSwapBusy(Thread);<span class="comment">//标记本线程正在被切换 </span></span><br><span class="line">			Prcb-&gt;CurrentThread = NextThread;<span class="comment">//标记已切换到下一个线程 </span></span><br><span class="line">			Prcb-&gt;NextThread = <span class="literal">NULL</span>;<span class="comment">//初始运行时尚未有任何抢占者线程 </span></span><br><span class="line">			NextThread-&gt;State = Running;<span class="comment">//标记线程状态正在运行 </span></span><br><span class="line">			Thread-&gt;WaitReason = WrYieldExecution;<span class="comment">//标记本线程上次被切换的原因是主动放弃 </span></span><br><span class="line">			KxQueueReadyThread(Thread, Prcb);<span class="comment">//将本线程转入就绪队列 </span></span><br><span class="line">			Thread-&gt;WaitIrql = APC_LEVEL;<span class="comment">//这将导致下次切换回来时会自动发出apc中断 </span></span><br><span class="line">			MiSyncForContextSwitch(NextThread); </span><br><span class="line">			KiSwapContext(Thread, NextThread);<span class="comment">//真正切换到目标线程 </span></span><br><span class="line">			</span><br><span class="line">			---------------------------华丽的分割线--------------------------------------- </span><br><span class="line">			Status = STATUS_SUCCESS;<span class="comment">//本线程下次切回来时继续从这里执行下去 </span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123; </span><br><span class="line">			KiReleasePrcbLock(Prcb); </span><br><span class="line">			KiReleaseThreadLock(Thread); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	KeLowerIrql(OldIrql);<span class="comment">//完成调度、切换过程后,降低到原irql(这个过程可能会执行apc) </span></span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调度策略-KiSelectReadyThread"><a href="#调度策略-KiSelectReadyThread" class="headerlink" title="调度策略(KiSelectReadyThread)"></a>调度策略(KiSelectReadyThread)</h3><p>下面就是调度策略:按优先级从高到低的顺序扫描32条就绪队列,取下最高优先级的线程<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PKTHREAD <span class="title">KiSelectReadyThread</span><span class="params">(IN KPRIORITY Priority,<span class="comment">//指调度出的线程必须&gt;=这个优先级 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    IN PKPRCB Prcb)</span><span class="comment">//指定cpu </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	ULONG PrioritySet; </span><br><span class="line">	LONG HighPriority;<span class="comment">//含有就绪线程的最高优先级队列 </span></span><br><span class="line">	PLIST_ENTRY ListEntry; </span><br><span class="line">	PKTHREAD Thread = <span class="literal">NULL</span>;<span class="comment">//调度出来的线程 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	PrioritySet = Prcb-&gt;ReadySummary &gt;&gt; Priority; </span><br><span class="line">	<span class="keyword">if</span> (!PrioritySet) <span class="keyword">goto</span> Quickie; </span><br><span class="line">	BitScanReverse((PULONG)&amp;HighPriority, PrioritySet);<span class="comment">//从高位到地位扫描那个标志位图 </span></span><br><span class="line">	HighPriority += Priority; </span><br><span class="line">	ASSERT(IsListEmpty(&amp;Prcb-&gt;DispatcherReadyListHead[HighPriority]) == FALSE); </span><br><span class="line"></span><br><span class="line">	ListEntry = Prcb-&gt;DispatcherReadyListHead[HighPriority].Flink;<span class="comment">//队列中的第一个线程 </span></span><br><span class="line">	Thread = CONTAINING_RECORD(ListEntry, KTHREAD, WaitListEntry); </span><br><span class="line">	ASSERT(HighPriority == Thread-&gt;Priority);<span class="comment">//确保优先级符合 </span></span><br><span class="line">	ASSERT(Thread-&gt;Affinity &amp; AFFINITY_MASK(Prcb-&gt;Number));<span class="comment">//确保cpu亲缘性 </span></span><br><span class="line">	ASSERT(Thread-&gt;NextProcessor == Prcb-&gt;Number);<span class="comment">//确保是在那个cpu中等待调度 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (RemoveEntryList(&amp;Thread-&gt;WaitListEntry))<span class="comment">//取下来 </span></span><br><span class="line">		Prcb-&gt;ReadySummary ^= PRIORITY_MASK(HighPriority);<span class="comment">//如果队列变空了,修改对应的标志位 Quickie: </span></span><br><span class="line">	<span class="keyword">return</span> Thread; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="KiComputeNewPriority"><a href="#KiComputeNewPriority" class="headerlink" title="KiComputeNewPriority"></a>KiComputeNewPriority</h4><p>每当一个非实时线程被切换出去,放弃cpu后,系统都会略微降低该线程的优先级,以免该线程总是占住cpu不放。</p>
<p>下面的函数就是做这个目的。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SCHAR  <span class="title">KiComputeNewPriority</span><span class="params">(IN PKTHREAD Thread,<span class="comment">//非实时线程 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                            IN SCHAR Adjustment)</span><span class="comment">//"调减量"</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	SCHAR Priority; </span><br><span class="line">	Priority = Thread-&gt;Priority;<span class="comment">//原优先级 </span></span><br><span class="line">	<span class="keyword">if</span> (Priority &lt; LOW_REALTIME_PRIORITY)<span class="comment">//只对非实时性线程做调整 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//先减去"恢减量’(对应于唤醒线程时系统临时提高的优先级量,现在要把它恢复回去) </span></span><br><span class="line">		Priority -= Thread-&gt;PriorityDecrement;  </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//再减去"调减量’,这才是真正的调整,上面只是恢复优先级 </span></span><br><span class="line">		Priority -= Adjustment; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (Priority &lt; Thread-&gt;BasePriority) </span><br><span class="line">			Priority = Thread-&gt;BasePriority;<span class="comment">//优先级不管怎么调,不能低于基本优先级 </span></span><br><span class="line">		</span><br><span class="line">		Thread-&gt;PriorityDecrement = <span class="number">0</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Priority; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="被动切换"><a href="#被动切换" class="headerlink" title="被动切换"></a>被动切换</h3><p>前面说的主动切换。但主动切换是非常少见的,一般都是不情愿的,被动切换。</p>
<h4 id="时间片切换"><a href="#时间片切换" class="headerlink" title="时间片切换"></a>时间片切换</h4><p>典型的被动切换情形是: 每触发一次时钟中断(通常每10毫秒触发一次),就会在时钟中断的isr中递减当前线程<code>KTHREAD</code>结构中的<code>Quantum</code>字段(表示剩余时间片),当减到0时(也即时间片耗尽时),会将<code>KPCRB</code>结构中的<code>QuantumEnd</code>字段 标记为TRUE。</p>
<p>同时当cpu在每次扫描执行完DPC队列中的函数后,irql将降到<code>DISPATCH_LEVEL</code>以下,这时 系统会检查<code>QuantumEnd</code>字段,若发现时间片已经用完(可能已经用完很久了),就会调用下面的函数切换线程,这时切换线程的一种典型时机。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KiQuantumEnd</span><span class="params">()</span> <span class="comment">//每次时间片自然到期后执行这个函数 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PKPRCB Prcb = KeGetCurrentPrcb(); </span><br><span class="line">	PKTHREAD NextThread, Thread = Prcb-&gt;CurrentThread;<span class="comment">//当前线程 </span></span><br><span class="line">	<span class="keyword">if</span> (InterlockedExchange(&amp;Prcb-&gt;DpcSetEventRequest, <span class="number">0</span>))<span class="comment">//检查是否有"触发DPC事件’的请求 </span></span><br><span class="line">	KeSetEvent(&amp;Prcb-&gt;DpcEvent, <span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">	KeRaiseIrqlToSynchLevel();<span class="comment">//提升到SynchLevel,准备调度、切换 </span></span><br><span class="line">	KiAcquireThreadLock(Thread); </span><br><span class="line">	KiAcquirePrcbLock(Prcb); </span><br><span class="line">	<span class="keyword">if</span> (Thread-&gt;Quantum &lt;= <span class="number">0</span>)<span class="comment">//确认该线程的时间片已到期 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> ((Thread-&gt;Priority &gt;= LOW_REALTIME_PRIORITY) &amp;&amp; </span><br><span class="line">		                    (Thread-&gt;ApcState.Process-&gt;DisableQuantum)) </span><br><span class="line">		&#123; </span><br><span class="line">			Thread-&gt;Quantum = MAX_QUANTUM;<span class="comment">//实时线程可以禁用时间片机制 </span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123; </span><br><span class="line">			Thread-&gt;Quantum = Thread-&gt;QuantumReset;<span class="comment">//设置下次调度时的时间片 </span></span><br><span class="line">			Thread-&gt;Priority = KiComputeNewPriority(Thread,<span class="number">1</span>);<span class="comment">//降低一个优先级(以免占住cpu) </span></span><br><span class="line">			<span class="keyword">if</span> (Prcb-&gt;NextThread != <span class="literal">NULL</span>) </span><br><span class="line"></span><br><span class="line">			&#123; </span><br><span class="line">				NextThread = Prcb-&gt;NextThread<span class="comment">//直接使用这个候选的线程 </span></span><br><span class="line">				Thread-&gt;Preempted = FALSE;<span class="comment">//因为是时间片到期发生的切换,所以不是被抢占 </span></span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;  </span><br><span class="line">				NextThread = KiSelectReadyThread(Thread-&gt;Priority, Prcb);<span class="comment">//调度出一个线程 </span></span><br><span class="line">				<span class="comment">//表示这个线程已被选中处于候选抢占状态,将立马上架投入运行 </span></span><br><span class="line">				NextThread-&gt;State = Standby;  </span><br><span class="line"></span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	KiReleaseThreadLock(Thread); </span><br><span class="line"></span><br><span class="line">	KiSetThreadSwapBusy(Thread);<span class="comment">//标记当前线程正在被切换 </span></span><br><span class="line">	Prcb-&gt;CurrentThread = NextThread;<span class="comment">//标记为切换到下一个线程了 </span></span><br><span class="line">	Prcb-&gt;NextThread = <span class="literal">NULL</span>;<span class="comment">//初始运行时没有抢占者线程 </span></span><br><span class="line">	NextThread-&gt;State = Running;<span class="comment">//已在运行了 </span></span><br><span class="line">	Thread-&gt;WaitReason = WrQuantumEnd;<span class="comment">//标记上次被切换的原因是时间片到期 </span></span><br><span class="line">	KxQueueReadyThread(Thread, Prcb);<span class="comment">//当前线程转入就绪队列 </span></span><br><span class="line">	Thread-&gt;WaitIrql = APC_LEVEL;<span class="comment">// 这将导致下次切换回来时会自动发出apc中断 </span></span><br><span class="line"></span><br><span class="line">	KiSwapContext(Thread, NextThread);<span class="comment">//正式切换到新线程 </span></span><br><span class="line">	---------------------------华丽的分割线--------------------------------------- </span><br><span class="line">	KeLowerIrql(DISPATCH_LEVEL); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优先级切换"><a href="#优先级切换" class="headerlink" title="优先级切换"></a>优先级切换</h4><p>除了时间片自然到期,线程被切换外,线程还可以在运行的过程中被其他高优先级线程,强制抢占而切换。 </p>
<h5 id="ResumeThread"><a href="#ResumeThread" class="headerlink" title="ResumeThread"></a>ResumeThread</h5><p>如一个线程调用<code>ResumeThread</code>将别的线程恢复调度时,自己会检查那个刚被恢复成就绪态的线程是否因优    先级高于自己而要抢占本线程,如果是,就会切换到那个线程。</p>
<p>因此这个api内部有切换线程的可能<code>ResumeThread</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">ULONG  <span class="title">KeResumeThread</span><span class="params">(IN PKTHREAD Thread)</span> <span class="comment">//恢复指定目标线程 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	KLOCK_QUEUE_HANDLE ApcLock; </span><br><span class="line">	ULONG PreviousCount; </span><br><span class="line">	ASSERT_IRQL_LESS_OR_EQUAL(DISPATCH_LEVEL);<span class="comment">//当前irql一定&lt;=DISPATCH_LEVEL </span></span><br><span class="line">	KiAcquireApcLock(Thread, &amp;ApcLock);<span class="comment">//锁定apc队列,同时提升irql到DISPATCH_LEVEL </span></span><br><span class="line">	PreviousCount = Thread-&gt;SuspendCount; </span><br><span class="line">	<span class="keyword">if</span> (PreviousCount) </span><br><span class="line">	&#123; </span><br><span class="line">		Thread-&gt;SuspendCount--;<span class="comment">//递减挂起计数 </span></span><br><span class="line">		<span class="comment">//若挂起计数减到0,唤醒目标线程,进入就绪队列或者变成抢占者线程 </span></span><br><span class="line">		<span class="keyword">if</span> ((!Thread-&gt;SuspendCount) &amp;&amp; (!Thread-&gt;FreezeCount))  </span><br><span class="line">		&#123; </span><br><span class="line">			KiAcquireDispatcherLockAtDpcLevel(); </span><br><span class="line"></span><br><span class="line">			Thread-&gt;SuspendSemaphore.Header.SignalState++; </span><br><span class="line">			KiWaitTest(&amp;Thread-&gt;SuspendSemaphore.Header, IO_NO_INCREMENT);<span class="comment">//尝试唤醒它 </span></span><br><span class="line">			KiReleaseDispatcherLockFromDpcLevel(); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	KiReleaseApcLockFromDpcLevel(&amp;ApcLock);<span class="comment">//注意这个函数只释放apc队列锁,不降低irql </span></span><br><span class="line">	<span class="comment">//关键函数。降低当前线程的irql,同时先检查是否有抢占者线程,若有,先执行抢占切换。 </span></span><br><span class="line">	KiExitDispatcher(ApcLock.OldIrql);  </span><br><span class="line">	<span class="keyword">return</span> PreviousCount;<span class="comment">//返回之前的挂起计数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IRQL降低"><a href="#IRQL降低" class="headerlink" title="IRQL降低"></a>IRQL降低</h4><p>下面这个函数的主功能是降回当前线程的irql到指定OldIrql。<br>不过在正式的降低前,会先检查是否发生了抢占,若有就先执行线程切换,等下次切换回来后再降低当前线程的irql。 </p>
<p>这个函数经常在系统中的其它线程的运行状态一改变后,就主动调用。</p>
<p>其目的是检测是否为此而发生了可能的抢占现象,若已发生,就立即进行抢占式切换。<br>比如,改变了某其它线程的优先级,唤醒了某其他线程,挂起恢复了某其他线程,给某线程挂入了一个APC等等操作后,都会调用,以尝试立即切换。</p>
<h5 id="KiExitDispatcher"><a href="#KiExitDispatcher" class="headerlink" title="KiExitDispatcher"></a>KiExitDispatcher</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这个函数只能在DISPATCH_LEVEL及其以上irql级别调用  </span></span><br><span class="line"><span class="comment">//降低irql检测是否有抢占 </span></span><br><span class="line"><span class="function">VOID   FASTCALL <span class="title">KiExitDispatcher</span><span class="params">(IN KIRQL OldIrql)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PKPRCB Prcb = KeGetCurrentPrcb(); </span><br><span class="line">	PKTHREAD Thread, NextThread; </span><br><span class="line">	BOOLEAN PendingApc; </span><br><span class="line">	ASSERT(KeGetCurrentIrql() &gt;= DISPATCH_LEVEL); <span class="comment">//确保 </span></span><br><span class="line">	KiCheckDeferredReadyList(Prcb); </span><br><span class="line">	<span class="keyword">if</span> (OldIrql &gt;= DISPATCH_LEVEL)<span class="comment">//如果要降回的irql不在DISPATCH_LEVEL以下,那就不能切换 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> ((Prcb-&gt;NextThread) &amp;&amp; !(Prcb-&gt;DpcRoutineActive)) </span><br><span class="line">		    HalRequestSoftwareInterrupt(DISPATCH_LEVEL); </span><br><span class="line">			<span class="keyword">goto</span> Quickie; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (!Prcb-&gt;NextThread)<span class="comment">//如果没有抢占者线程,那很好,直接降低irql就是 </span></span><br><span class="line">		<span class="keyword">goto</span> Quickie; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//若发现有抢占发生,下面将执行抢占切换 </span></span><br><span class="line">	KiAcquirePrcbLock(Prcb); </span><br><span class="line">	NextThread = Prcb-&gt;NextThread; </span><br><span class="line">	Thread = Prcb-&gt;CurrentThread; KiSetThreadSwapBusy(Thread); </span><br><span class="line">	Prcb-&gt;CurrentThread = NextThread; </span><br><span class="line">	Prcb-&gt;NextThread = <span class="literal">NULL</span>; </span><br><span class="line">	NextThread-&gt;State = Running; </span><br><span class="line">	KxQueueReadyThread(Thread, Prcb); </span><br><span class="line">	Thread-&gt;WaitIrql = OldIrql;<span class="comment">//可以肯定:OldIrql=APC_LEVEL或PASSIVE_LEVEL,并且:如果原irq l是在AP_LEVEL的话,KiSwapContext内部会在返回前发出apc中断 </span></span><br><span class="line">	PendingApc = KiSwapContext(Thread, NextThread); </span><br><span class="line">	</span><br><span class="line">	-------------------------------------华丽的分割线--------------------------------------- </span><br><span class="line">	-------------------------------------华丽的分割线---------------------------------------</span><br><span class="line">	-------------------------------------华丽的分割线--------------------------------------- </span><br><span class="line"> </span><br><span class="line">	<span class="comment">//如果切回来后发现阻塞有内核apc,需要手动扫描执行apc(可以肯定原irql不是APC_LEVEL)    </span></span><br><span class="line">	<span class="keyword">if</span> (PendingApc)</span><br><span class="line">	&#123; </span><br><span class="line">		ASSERT(OldIrql == PASSIVE_LEVEL);<span class="comment">//可以肯定原来是PASSIVE_LEVEL级 </span></span><br><span class="line">		KeLowerIrql(APC_LEVEL);<span class="comment">//当然要先降到APC级别去 </span></span><br><span class="line">		KiDeliverApc(KernelMode, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//切换回来后,自己手动扫描执行内核apc </span></span><br><span class="line">	&#125; Quickie: </span><br><span class="line">    KeLowerIrql(OldIrql);<span class="comment">//本函数真正的工作:降低到指定irql </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数在降低irql前,先尝试检测是否发生了抢占式切换。若有立即切换。 否则,降低irql。<br>注意降低irql到<code>DISPATCH_LEVEL</code>下以后,也可能会因为之前时间片早已到期,但是在<code>DISPATCH_LEVEL</code>以上迟迟没有得到切换,现在降到下面了就会引发线程切换(迟来的切换！) </p>
<p>当一个线程被唤醒时(如isr中将某线程唤醒),往往会提高其优先级,导致发生抢占。<br>一旦发现某个线程的优先级高于当前线程的优先级(并且也高于上一个候选的抢占者线程的优先级)<br>系统就会把这个线程作为新的候选抢占者线程记录到KPCRB结构的<code>NextThread</code>字段中。<br>这样只要时机一成熟就会发生抢占式切换。 </p>
<h6 id="KiUnwaitThread"><a href="#KiUnwaitThread" class="headerlink" title="KiUnwaitThread"></a>KiUnwaitThread</h6><p>下面的函数用来唤醒一个线程<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">KiUnwaitThread</span><span class="params">(IN PKTHREAD Thread, </span></span></span><br><span class="line"><span class="function"><span class="params">               IN LONG_PTR WaitStatus, </span></span></span><br><span class="line"><span class="function"><span class="params">               IN KPRIORITY Increment)</span><span class="comment">//略微提高的优先级量(以便目标线程尽快得到调度) </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    KiUnlinkThread(Thread, WaitStatus);<span class="comment">//从所有等待对象的线程链表中脱链 </span></span><br><span class="line">    Thread-&gt;AdjustIncrement = (SCHAR)Increment;<span class="comment">//要调整的优先级量 </span></span><br><span class="line">    Thread-&gt;AdjustReason = AdjustUnwait;<span class="comment">//跳转原因为唤醒 </span></span><br><span class="line">    KiReadyThread(Thread);<span class="comment">//关键函数。将线程转为就绪态 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="KiReadyThread"><a href="#KiReadyThread" class="headerlink" title="KiReadyThread"></a>KiReadyThread</h6><p>下面的函数用来将一个线程转为就绪态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID  <span class="title">KiReadyThread</span><span class="params">(IN PKTHREAD Thread)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	IN PKPROCESS Process = Thread-&gt;ApcState.Process; </span><br><span class="line">	<span class="keyword">if</span> (Process-&gt;State != ProcessInMemory) </span><br><span class="line">	ASSERT(FALSE);<span class="comment">//蓝屏 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!Thread-&gt;KernelStackResident)<span class="comment">//如果该线程的内核栈被置换到外存了 </span></span><br><span class="line">	&#123; </span><br><span class="line">		ASSERT(Process-&gt;StackCount != MAXULONG_PTR); </span><br><span class="line">		Process-&gt;StackCount++; </span><br><span class="line">		ASSERT(Thread-&gt;State != Transition); </span><br><span class="line">		Thread-&gt;State = Transition; </span><br><span class="line">		ASSERT(FALSE);<span class="comment">//蓝屏 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		KiInsertDeferredReadyList(Thread);<span class="comment">//实质函数 </span></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="function">VOID <span class="title">KiInsertDeferredReadyList</span><span class="params">(IN PKTHREAD Thread)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	Thread-&gt;State = DeferredReady;<span class="comment">//将进入就绪态 </span></span><br><span class="line">	Thread-&gt;DeferredProcessor = <span class="number">0</span>;<span class="comment">//0号cpu </span></span><br><span class="line">	KiDeferredReadyThread(Thread);<span class="comment">//实质函数,就绪化指定线程 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的函数将指定线程转换为<code>&quot;就绪态&quot;</code>或者<code>&quot;抢占态&quot;</code><br>也可理解为<code>&quot;就绪化&quot;</code>某个线程,但特殊处理抢占情形(抢占态是一种特殊的就绪态) </p>
<h6 id="KiDeferredReadyThread"><a href="#KiDeferredReadyThread" class="headerlink" title="KiDeferredReadyThread"></a>KiDeferredReadyThread</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">KiDeferredReadyThread</span><span class="params">(IN PKTHREAD Thread)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PKPRCB Prcb; BOOLEAN Preempted; </span><br><span class="line">	ULONG Processor = <span class="number">0</span>;<span class="comment">//一律挂入0号cpu的就绪队列 KPRIORITY OldPriority;//目标线程的当前优先级 </span></span><br><span class="line">	PKTHREAD NextThread; </span><br><span class="line">	<span class="keyword">if</span> (Thread-&gt;AdjustReason == AdjustBoost) <span class="comment">//if是线程首次启动时的调整优先级 。。。 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Thread-&gt;AdjustReason == AdjustUnwait) <span class="comment">//if是唤醒时调整的优先级 。。。 </span></span><br><span class="line">	Preempted = Thread-&gt;Preempted; </span><br><span class="line">	OldPriority = Thread-&gt;Priority; </span><br><span class="line">	Thread-&gt;Preempted = FALSE; </span><br><span class="line">	Thread-&gt;NextProcessor = <span class="number">0</span>; </span><br><span class="line">	Prcb = KiProcessorBlock[<span class="number">0</span>]; </span><br><span class="line">	KiAcquirePrcbLock(Prcb); </span><br><span class="line">	<span class="keyword">if</span> (KiIdleSummary)<span class="comment">//如果0号cpu运行着空转线程,目标线程的优先级肯定高于那个空转线程 </span></span><br><span class="line">	&#123; </span><br><span class="line">		KiIdleSummary = <span class="number">0</span>; </span><br><span class="line">		Thread-&gt;State = Standby;<span class="comment">//将目标程序改为"抢占态"</span></span><br><span class="line">		Prcb-&gt;NextThread = Thread;<span class="comment">//指向自己 </span></span><br><span class="line">		KiReleasePrcbLock(Prcb); </span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	Thread-&gt;NextProcessor = (UCHAR)Processor;<span class="comment">//0 </span></span><br><span class="line">	NextThread = Prcb-&gt;NextThread;<span class="comment">//获得0号cpu上的原抢占者线程 </span></span><br><span class="line">	<span class="keyword">if</span> (NextThread)<span class="comment">//如果原来已有一个抢占者线程 </span></span><br><span class="line">	&#123; </span><br><span class="line">		ASSERT(NextThread-&gt;State == Standby);<span class="comment">//可以确定那个线程处于抢占态 </span></span><br><span class="line">		<span class="keyword">if</span> (OldPriority &gt; NextThread-&gt;Priority)<span class="comment">//若高于原"抢占者线程’的优先级  </span></span><br><span class="line">		&#123; </span><br><span class="line">			NextThread-&gt;Preempted = TRUE;<span class="comment">//标志那个抢占者线程又被目标线程抢占了 </span></span><br><span class="line">			Prcb-&gt;NextThread = Thread;<span class="comment">//更改新的抢占者线程,时机一成熟就抢占 </span></span><br><span class="line">			Thread-&gt;State = Standby;<span class="comment">//更为抢占态 </span></span><br><span class="line">			NextThread-&gt;State = DeferredReady;<span class="comment">//原抢占者线程进入将就绪态 </span></span><br><span class="line"></span><br><span class="line">			NextThread-&gt;DeferredProcessor = Prcb-&gt;Number;<span class="comment">//0 </span></span><br><span class="line">			KiReleasePrcbLock(Prcb); </span><br><span class="line">			KiDeferredReadyThread(NextThread);<span class="comment">//原抢占者线程转入0号cpu就绪队列 </span></span><br><span class="line">			<span class="keyword">return</span>; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span><span class="comment">//如果原来没有抢占者线程(最典型的情况) </span></span><br><span class="line">	&#123; </span><br><span class="line">		NextThread = Prcb-&gt;CurrentThread; </span><br><span class="line">		<span class="keyword">if</span> (OldPriority &gt; NextThread-&gt;Priority)<span class="comment">//如果优先级高于当前运行的那个线程 </span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> (NextThread-&gt;State == Running) </span><br><span class="line">			NextThread-&gt;Preempted = TRUE;<span class="comment">//标记已被抢占 </span></span><br><span class="line">			Prcb-&gt;NextThread = Thread; <span class="comment">//指定抢占者线程,时机一成熟就抢占 </span></span><br><span class="line">			Thread-&gt;State = Standby;<span class="comment">//标记目标线程处于抢占态了 </span></span><br><span class="line">			KiReleasePrcbLock(Prcb); </span><br><span class="line">			<span class="keyword">if</span> (KeGetCurrentProcessorNumber() != <span class="number">0</span>) </span><br><span class="line">			KiIpiSend(AFFINITY_MASK(Thread-&gt;NextProcessor), IPI_DPC);<span class="comment">//给0号cpu发一个通知 </span></span><br><span class="line">			<span class="keyword">return</span>; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果目标线程的优先级低于当前的抢占者线程,也低于当前运行中的线程 </span></span><br><span class="line">	Thread-&gt;State = Ready;<span class="comment">//更为就绪态 </span></span><br><span class="line">	Thread-&gt;WaitTime = KeTickCount.LowPart;<span class="comment">//记录上次被切换的时间 </span></span><br><span class="line">	<span class="comment">//如果目标线程上次是因为被抢占而切出的cpu,现在就挂入队头(平衡怒气) </span></span><br><span class="line">	Preempted ? InsertHeadList(&amp;Prcb-&gt;DispatcherReadyListHead[OldPriority], </span><br><span class="line">	                       &amp;Thread-&gt;WaitListEntry) : </span><br><span class="line">				InsertTailList(&amp;Prcb-&gt;DispatcherReadyListHead[OldPriority], </span><br><span class="line">	                       &amp;Thread-&gt;WaitListEntry); </span><br><span class="line">	Prcb-&gt;ReadySummary |= PRIORITY_MASK(OldPriority);<span class="comment">//更改相应就绪队列的标志 </span></span><br><span class="line">	KiReleasePrcbLock(Prcb); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数用于将线程挂入0号cpu的就绪队列或者置为抢占者线程。 </p>
<p><br><br><br></p>
<h2 id="进程、线程的优先级"><a href="#进程、线程的优先级" class="headerlink" title="进程、线程的优先级"></a>进程、线程的优先级</h2><p>线程的调度策略是严格按优先级的,因此优先级,不妨叫做<code>&quot;调度优先级&quot;</code>。</p>
<blockquote>
<p>那么优先级是啥,是怎么确定的呢？ </p>
</blockquote>
<p>先要弄清几个概念: </p>
<ul>
<li>进程的优先级类:每种优先级类对应一种基本优先级 </li>
<li>进程的基本优先级:为各个线程的默认基本优先级 </li>
<li>线程的基本优先级:每个线程刚创建时的基本优先级继承它所属进程的基本优先级,但可以人为调整 </li>
<li>线程的当前优先级:又叫时机优先级。当前优先级可以浮动,但永远不会降到该线程的基本优先级下面 </li>
</ul>
<p>系统调度线程时,是以线程的当前优先级为准的,它才不管你的基本优先级是什么,你所属的进程的基本 优先级又是什么,它只看你的当前优先级。 </p>
<p>进程基本优先级与线程基本优先级是一种水涨船高的关系。<br>进程的基本优先级变高了,那么它里面的各个线程的基本优先级也会跟着升高对应的幅度。<br>各个线程初始创建时的基本优先级等于其进程的基本优先级 </p>
<p>线程的基本优先级与线程的当前优先级也是一种水涨船高的关系。<br>线程的基本优先级升高了,那么线程的当前优先级也会跟着升高对应的幅度。</p>
<p>另外:线程的当前优先级可以随时变化(比如每次一让出cpu时就略微降低那么一点点优先级)<br>但是永远不会降到其基本优先级以下。<br>基本优先级就是它的最低保障！ </p>
<p>综上可理解为:线程基本优先级相对于进程的基本优先级,线程的当前优先级相对于线程的基本优先级 </p>
<p><img src="/2020/11/03/windows-kernel-summary/image-02.png" width="900px"></p>
<p>系统中总共分32个优先级:0到31,其中又分为两段。0到15的是非实时优先级,16-31的表示实时优先级。 </p>
<ul>
<li><code>#define LOW_PRIORITY 0</code></li>
<li><code>#define LOW_RELATIVE_PRIORITY  15</code> //最低的实时优先级 </li>
<li><code>#define HIGH_PRIORITY 31</code>//最高的实时优先级,也是整个系统最高的优先级 </li>
</ul>
<h3 id="修改优先级"><a href="#修改优先级" class="headerlink" title="修改优先级"></a>修改优先级</h3><h4 id="SetPriorityClass"><a href="#SetPriorityClass" class="headerlink" title="SetPriorityClass"></a>SetPriorityClass</h4><p><code>SetPriorityClass</code>这个Win32 API改变的就是一个进程的优先级类,而一种优先级类对应一种基 本优先级,所以这个函数实际上改变的是进程的基本优先级。</p>
<p>实际上最终调用到下面的函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">KPRIORITY <span class="title">KeSetPriorityAndQuantumProcess</span><span class="params">(IN PKPROCESS Process, </span></span></span><br><span class="line"><span class="function"><span class="params">                               IN KPRIORITY Priority,<span class="comment">//新的基本优先级 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                               IN UCHAR Quantum OPTIONAL)</span><span class="comment">//新的时间片 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	KLOCK_QUEUE_HANDLE ProcessLock; </span><br><span class="line">	KPRIORITY Delta; </span><br><span class="line">	PLIST_ENTRY NextEntry, ListHead; </span><br><span class="line">	KPRIORITY NewPriority, OldPriority; </span><br><span class="line">	PKTHREAD Thread; </span><br><span class="line">	ASSERT_IRQL_LESS_OR_EQUAL(DISPATCH_LEVEL); </span><br><span class="line">	<span class="keyword">if</span> (Process-&gt;BasePriority == Priority) </span><br><span class="line">		<span class="keyword">return</span> Process-&gt;BasePriority; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (Priority==<span class="number">0</span>) </span><br><span class="line">		Priority = <span class="number">1</span>;<span class="comment">//只有空转线程的优先级才能是0 </span></span><br><span class="line">	</span><br><span class="line">	KiAcquireProcessLock(Process, &amp;ProcessLock);<span class="comment">//获得自旋锁,同时提升irql到DISPATCH_LEVEL </span></span><br><span class="line">	<span class="keyword">if</span> (Quantum) </span><br><span class="line">		Process-&gt;QuantumReset = Quantum;<span class="comment">//修改进程的时间片(也即里面各个线程的时间片) </span></span><br><span class="line">	</span><br><span class="line">	OldPriority = Process-&gt;BasePriority; </span><br><span class="line">	Process-&gt;BasePriority = (SCHAR)Priority;<span class="comment">//修改为新的基本优先级 </span></span><br><span class="line">	Delta = Priority - OldPriority;<span class="comment">//计算提升幅度(注意Delta可以是负数) </span></span><br><span class="line"></span><br><span class="line">	ListHead = &amp;Process-&gt;ThreadListHead; </span><br><span class="line">	NextEntry = ListHead-&gt;Flink; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Priority &gt;= LOW_REALTIME_PRIORITY)<span class="comment">//如果将基本优先级提到了实时级别 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">while</span> (NextEntry != ListHead)<span class="comment">//遍历该进程中的每个线程 </span></span><br><span class="line">		&#123; </span><br><span class="line">			Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry); </span><br><span class="line">			<span class="keyword">if</span> (Quantum) </span><br><span class="line">				Thread-&gt;QuantumReset = Quantum;<span class="comment">//同时设置线程的时间片 </span></span><br><span class="line">			</span><br><span class="line">			KiAcquireThreadLock(Thread); </span><br><span class="line">			NewPriority = Thread-&gt;BasePriority + Delta;<span class="comment">//水涨船高 </span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (NewPriority &lt; LOW_REALTIME_PRIORITY) </span><br><span class="line">				NewPriority = LOW_REALTIME_PRIORITY;<span class="comment">// 实时优先级的最小值 </span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (NewPriority &gt; HIGH_PRIORITY) </span><br><span class="line">				NewPriority = HIGH_PRIORITY;<span class="comment">// 实时优先级的最大值 </span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (!(Thread-&gt;Saturation) || (OldPriority &lt; LOW_REALTIME_PRIORITY)) </span><br><span class="line">			&#123; </span><br><span class="line">				Thread-&gt;BasePriority = (SCHAR)NewPriority; <span class="comment">//水涨船高 </span></span><br><span class="line">				Thread-&gt;Quantum = Thread-&gt;QuantumReset;<span class="comment">//当前剩余时间片=初始时间片 </span></span><br><span class="line">				Thread-&gt;PriorityDecrement = <span class="number">0</span>; </span><br><span class="line">				KiSetPriorityThread(Thread, NewPriority);<span class="comment">//提高线程优先级要做的附加工作 </span></span><br><span class="line">			&#125; </span><br><span class="line">			KiReleaseThreadLock(Thread); </span><br><span class="line">			NextEntry = NextEntry-&gt;Flink;<span class="comment">//下一个线程 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span><span class="comment">//如果将基本优先级提到了非实时级别 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">while</span> (NextEntry != ListHead) </span><br><span class="line">		&#123; </span><br><span class="line">			Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry); </span><br><span class="line">			<span class="keyword">if</span> (Quantum) </span><br><span class="line">				Thread-&gt;QuantumReset = Quantum; </span><br><span class="line">			</span><br><span class="line">			KiAcquireThreadLock(Thread); </span><br><span class="line">			NewPriority = Thread-&gt;BasePriority + Delta; </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (NewPriority &gt;= LOW_REALTIME_PRIORITY) </span><br><span class="line">				NewPriority = LOW_REALTIME_PRIORITY - <span class="number">1</span>;<span class="comment">//非实时优先级的最大值 </span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (NewPriority &lt;= LOW_PRIORITY) </span><br><span class="line">				NewPriority = <span class="number">1</span>;<span class="comment">//非实时优先级的最小值 </span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!(Thread-&gt;Saturation) || (OldPriority &gt;= LOW_REALTIME_PRIORITY)) </span><br><span class="line">			&#123; </span><br><span class="line">				Thread-&gt;BasePriority = (SCHAR)NewPriority;<span class="comment">//水涨船高 </span></span><br><span class="line">				Thread-&gt;Quantum = Thread-&gt;QuantumReset;<span class="comment">//当前剩余时间片=初始的时间片 </span></span><br><span class="line">				Thread-&gt;PriorityDecrement = <span class="number">0</span>; </span><br><span class="line">				KiSetPriorityThread(Thread, NewPriority); <span class="comment">//提高线程优先级要做的附加工作 </span></span><br><span class="line">			&#125; </span><br><span class="line">			KiReleaseThreadLock(Thread); </span><br><span class="line">			NextEntry = NextEntry-&gt;Flink;<span class="comment">//下一个线程 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	KiReleaseDispatcherLockFromDpcLevel(); </span><br><span class="line">	KiReleaseProcessLockFromDpcLevel(&amp;ProcessLock); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//降低到原irql,同时先检查是否发生了抢占式切换</span></span><br><span class="line">	<span class="comment">// 因为显式改变了线程的优先级,有可能让其他线程的优先级突然高于了当前线程而要发生抢占现象,所以要检测这种情况 </span></span><br><span class="line">	KiExitDispatcher(ProcessLock.OldIrql);  </span><br><span class="line">	<span class="keyword">return</span> OldPriority; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程的基本优先级一变了,它的当前优先级就会跟着变,线程的当前优先级一变了,那么就会有很多的附加工作要做,</p>
<h4 id="KiSetPriorityThread"><a href="#KiSetPriorityThread" class="headerlink" title="KiSetPriorityThread"></a>KiSetPriorityThread</h4><p>下面的函数就用来做这个工作(如改变就绪队列、置为抢占者等)。 </p>
<p>这个函数改变目标线程的优先级为指定优先级,并根据目标线程的当前所处状态<br>最对应的就绪队列、抢占者线程调整。<br>可见强行改变某个线程的当前优先级并不是件简单的工作,需要全盘综合考虑各                                         方面因素,做出相应的调整。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置线程的当前优先级</span></span><br><span class="line"><span class="function">VOID FASTCALL  <span class="title">KiSetPriorityThread</span><span class="params">(IN PKTHREAD Thread, </span></span></span><br><span class="line"><span class="function"><span class="params">                    IN KPRIORITY Priority)</span><span class="comment">//新的当前优先级 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PKPRCB Prcb; </span><br><span class="line">	ULONG Processor; </span><br><span class="line">	BOOLEAN RequestInterrupt = FALSE; </span><br><span class="line">	KPRIORITY OldPriority; </span><br><span class="line">	PKTHREAD NewThread; </span><br><span class="line">	<span class="keyword">if</span> (Thread-&gt;Priority != Priority)<span class="comment">//if 优先级变了 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">for</span> (;;) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> (Thread-&gt;State == Ready)<span class="comment">//如果目标线程处于就绪态 </span></span><br><span class="line">			&#123; </span><br><span class="line">				<span class="keyword">if</span> (!Thread-&gt;ProcessReadyQueue)<span class="comment">//其实一般都会满足这个条件 </span></span><br><span class="line">				&#123; </span><br><span class="line">					Processor = Thread-&gt;NextProcessor; </span><br><span class="line">					Prcb = KiProcessorBlock[Processor]; </span><br><span class="line">					KiAcquirePrcbLock(Prcb); </span><br><span class="line">					<span class="comment">//如果现在仍处于就绪态,并且仍在那个cpu上等待 </span></span><br><span class="line">					<span class="keyword">if</span> ((Thread-&gt;State == Ready) &amp;&amp; (Thread-&gt;NextProcessor == Prcb-&gt;Number)) </span><br><span class="line">					&#123; </span><br><span class="line">						<span class="keyword">if</span> (RemoveEntryList(&amp;Thread-&gt;WaitListEntry))<span class="comment">//从原就绪队列摘下 </span></span><br><span class="line">							Prcb-&gt;ReadySummary ^= PRIORITY_MASK(Thread-&gt;Priority); </span><br><span class="line">						Thread-&gt;Priority = (SCHAR)Priority;<span class="comment">//=更为新的优先级 </span></span><br><span class="line">						KiInsertDeferredReadyList(Thread);<span class="comment">//挂入新的就绪队列(或置为抢占态) </span></span><br><span class="line">						KiReleasePrcbLock(Prcb); </span><br><span class="line">					&#125; </span><br><span class="line">					Else … </span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Thread-&gt;State == Standby) <span class="comment">//如果目标线程处于抢占态 </span></span><br><span class="line">			&#123; </span><br><span class="line">				Processor = Thread-&gt;NextProcessor; </span><br><span class="line">				Prcb = KiProcessorBlock[Processor]; </span><br><span class="line">				KiAcquirePrcbLock(Prcb); </span><br><span class="line">				<span class="keyword">if</span> (Thread == Prcb-&gt;NextThread)<span class="comment">//如果仍处于抢占态 </span></span><br><span class="line">				&#123; </span><br><span class="line">					OldPriority = Thread-&gt;Priority; </span><br><span class="line">					Thread-&gt;Priority = (SCHAR)Priority;<span class="comment">//更改优先级 </span></span><br><span class="line">					<span class="keyword">if</span> (Priority &lt; OldPriority)<span class="comment">//如果优先级降了(可能不再成为抢占者线程了) </span></span><br><span class="line">					&#123; </span><br><span class="line">						NewThread = KiSelectReadyThread(Priority + <span class="number">1</span>, Prcb); </span><br><span class="line">						<span class="keyword">if</span> (NewThread)<span class="comment">//如果选出了一个比现在的优先级更高的线程 </span></span><br><span class="line">						&#123; </span><br><span class="line">							NewThread-&gt;State = Standby; </span><br><span class="line">							Prcb-&gt;NextThread = NewThread;<span class="comment">//更为新的抢占者线程 </span></span><br><span class="line">							KiInsertDeferredReadyList(Thread);<span class="comment">//原抢占线程则转入就绪队列 </span></span><br><span class="line">						&#125; </span><br><span class="line">					&#125; </span><br><span class="line">					KiReleasePrcbLock(Prcb); </span><br><span class="line">				&#125; </span><br><span class="line">				Else … </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Thread-&gt;State == Running) <span class="comment">//如果目标线程正在运行 </span></span><br><span class="line">				&#123; </span><br><span class="line">				Processor = Thread-&gt;NextProcessor; </span><br><span class="line">				Prcb = KiProcessorBlock[Processor]; </span><br><span class="line">				KiAcquirePrcbLock(Prcb); </span><br><span class="line">				<span class="keyword">if</span> (Thread == Prcb-&gt;CurrentThread)<span class="comment">//如果仍在运行 </span></span><br><span class="line">				&#123; </span><br><span class="line">					OldPriority = Thread-&gt;Priority; </span><br><span class="line">					Thread-&gt;Priority = (SCHAR)Priority;<span class="comment">//更改优先级 </span></span><br><span class="line">					<span class="keyword">if</span> ((Priority &lt; OldPriority) &amp;&amp; !(Prcb-&gt;NextThread))<span class="comment">//可能会出现抢占 </span></span><br><span class="line">					&#123; </span><br><span class="line">						NewThread = KiSelectReadyThread(Priority + <span class="number">1</span>, Prcb); </span><br><span class="line">						<span class="keyword">if</span> (NewThread)<span class="comment">// 如果选出了一个比现在的优先级更高的线程 </span></span><br><span class="line">						&#123; </span><br><span class="line">							NewThread-&gt;State = Standby; </span><br><span class="line">							Prcb-&gt;NextThread = NewThread;<span class="comment">//出现了新的抢占线程 </span></span><br><span class="line">							RequestInterrupt = TRUE;<span class="comment">//需要立即中断 </span></span><br><span class="line">						&#125; </span><br><span class="line">					&#125; </span><br><span class="line">					KiReleasePrcbLock(Prcb); </span><br><span class="line">					<span class="keyword">if</span> (RequestInterrupt) </span><br><span class="line">					&#123; </span><br><span class="line">						<span class="comment">//通知目标cpu进行抢占切换 </span></span><br><span class="line">						<span class="keyword">if</span> (KeGetCurrentProcessorNumber() != Processor) </span><br><span class="line">							KiIpiSend(AFFINITY_MASK(Processor), IPI_DPC); </span><br><span class="line">					&#125; </span><br><span class="line">				&#125; </span><br><span class="line">				Else … </span><br><span class="line">			&#125; </span><br><span class="line">			Else … </span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上这个函数改变目标线程的优先级为指定优先级,并根据目标线程的当前所处状态,最对应的就绪队列、抢占者线程调整。<br>可见强行改变某个线程的当前优先级并不是件简单的工作,需要全盘综合考虑各                                         方面因素,做出相应的调整。 </p>
<h4 id="KeSetPriorityThread"><a href="#KeSetPriorityThread" class="headerlink" title="KeSetPriorityThread"></a>KeSetPriorityThread</h4><p>下面的函数是一个小型的封装函数:(他还会还原时间片)     </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">KPRIORITY <span class="title">KeSetPriorityThread</span><span class="params">(IN PKTHREAD Thread, </span></span></span><br><span class="line"><span class="function"><span class="params">                    IN KPRIORITY Priority)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	KIRQL OldIrql; </span><br><span class="line">	KPRIORITY OldPriority; </span><br><span class="line">	OldIrql = KiAcquireDispatcherLock(); </span><br><span class="line">	KiAcquireThreadLock(Thread); </span><br><span class="line">	OldPriority = Thread-&gt;Priority; </span><br><span class="line">	Thread-&gt;PriorityDecrement = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">if</span> (Priority != Thread-&gt;Priority)<span class="comment">//if 优先级变了 </span></span><br><span class="line">	&#123; </span><br><span class="line">		Thread-&gt;Quantum = Thread-&gt;QuantumReset;<span class="comment">//关键。还原时间片 </span></span><br><span class="line">		KiSetPriorityThread(Thread, Priority);<span class="comment">//再做真正的修改工作 </span></span><br><span class="line">	&#125; </span><br><span class="line">	KiReleaseThreadLock(Thread); </span><br><span class="line">	KiReleaseDispatcherLock(OldIrql); </span><br><span class="line">	<span class="keyword">return</span> OldPriority; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了修改进程的基本优先级会影响到里面每个线程的基本优先级和当前优先级外</span></span><br><span class="line"><span class="comment">// 也可以用下面的函数直接修改线程的基本优先级和当前优先级。 </span></span><br><span class="line"> </span><br><span class="line"><span class="function">NTSTATUS <span class="title">NtSetInformationThread</span><span class="params">(IN HANDLE ThreadHandle, </span></span></span><br><span class="line"><span class="function"><span class="params">                       IN THREADINFOCLASS ThreadInformationClass, </span></span></span><br><span class="line"><span class="function"><span class="params">                       IN PVOID ThreadInformation, </span></span></span><br><span class="line"><span class="function"><span class="params">                       IN ULONG ThreadInformationLength)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	… </span><br><span class="line">	<span class="keyword">switch</span> (ThreadInformationClass) </span><br><span class="line">	&#123; </span><br><span class="line">	<span class="keyword">case</span> ThreadPriority:<span class="comment">//设置当前优先级 </span></span><br><span class="line">		Priority = *(PLONG)ThreadInformation;<span class="comment">//这个值是相对于进程基本优先级的差值 </span></span><br><span class="line">		KeSetPriorityThread(&amp;Thread-&gt;Tcb, Priority); </span><br><span class="line">		<span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> ThreadBasePriority:<span class="comment">//设置基本优先级 </span></span><br><span class="line">		Priority = *(PLONG)ThreadInformation; </span><br><span class="line">		KeSetBasePriorityThread(&amp;Thread-&gt;Tcb, Priority); </span><br><span class="line">		<span class="keyword">break</span>; </span><br><span class="line">	<span class="keyword">case</span> … </span><br><span class="line">	</span><br><span class="line">	&#125;<span class="comment">//end switch </span></span><br><span class="line">&#125;<span class="comment">//end func </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的基本优先级(非当前优先级)可以用下面的函数设置</span></span><br><span class="line"><span class="function">LONG  <span class="title">KeSetBasePriorityThread</span><span class="params">(IN PKTHREAD Thread, </span></span></span><br><span class="line"><span class="function"><span class="params">                        IN LONG Increment)</span><span class="comment">//这个是相对于进程基本优先级的差值 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	KIRQL OldIrql; </span><br><span class="line">	KPRIORITY OldBasePriority, Priority, BasePriority; </span><br><span class="line">	LONG OldIncrement; </span><br><span class="line">	PKPROCESS Process; </span><br><span class="line">	ASSERT_IRQL_LESS_OR_EQUAL(DISPATCH_LEVEL); </span><br><span class="line">	Process = Thread-&gt;ApcState.Process; </span><br><span class="line">	OldIrql = KiAcquireDispatcherLock(); </span><br><span class="line">	KiAcquireThreadLock(Thread); </span><br><span class="line">	OldBasePriority = Thread-&gt;BasePriority; </span><br><span class="line">	OldIncrement = OldBasePriority - Process-&gt;BasePriority; </span><br><span class="line">	<span class="keyword">if</span> (Thread-&gt;Saturation) <span class="comment">//如果是个饱和增量 </span></span><br><span class="line">		OldIncrement = <span class="number">16</span> * Thread-&gt;Saturation;<span class="comment">//16或-16 </span></span><br><span class="line"></span><br><span class="line">	Thread-&gt;Saturation = <span class="number">0</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">abs</span>(Increment) &gt;= <span class="number">16</span>) <span class="comment">//饱和增量 </span></span><br><span class="line">		Thread-&gt;Saturation = (Increment &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>; </span><br><span class="line">	</span><br><span class="line">	BasePriority = Process-&gt;BasePriority + Increment;<span class="comment">//算得现在的基本优先级 </span></span><br><span class="line">	<span class="keyword">if</span> (Process-&gt;BasePriority &gt;= LOW_REALTIME_PRIORITY) </span><br><span class="line">	&#123; </span><br><span class="line">		Priority = BasePriority;<span class="comment">//实时线程例外,当前优先级=基本优先级 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">	 	Priority = KiComputeNewPriority(Thread, <span class="number">0</span>);<span class="comment">//其实就是当前优先级 </span></span><br><span class="line">		<span class="comment">//看到没,线程的基本优先级一升高,它的当前优先级跟着升高对应的幅度 </span></span><br><span class="line">		Priority += (BasePriority - OldBasePriority);  </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	Thread-&gt;BasePriority = (SCHAR)BasePriority;<span class="comment">//更改线程的基本优先级 </span></span><br><span class="line">	Thread-&gt;PriorityDecrement = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">if</span> (Priority != Thread-&gt;Priority)<span class="comment">//如果当前优先级变了,做相关的附加工作 </span></span><br><span class="line">	&#123; </span><br><span class="line">		Thread-&gt;Quantum = Thread-&gt;QuantumReset; </span><br><span class="line">		KiSetPriorityThread(Thread, Priority); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	KiReleaseThreadLock(Thread); </span><br><span class="line">	KiReleaseDispatcherLock(OldIrql); </span><br><span class="line">	<span class="keyword">return</span> OldIncrement; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="线程局部存储-TLS"><a href="#线程局部存储-TLS" class="headerlink" title="线程局部存储:TLS"></a>线程局部存储:TLS</h2><p>对TLS这个概念陌生的朋友请先自己查阅相关资料。 </p>
<p>TLS分为两种方法:静态tls、动态tls。<br>两种方法都可以达到tls的目的。<br>静态tls:<br>在编写程序时:只需在要声明为tls的全局变量前加上 declspec(thread)关键字即可。如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declspec(thread) int g_a = 1; </span><br><span class="line">declspec(thread) int g_b; </span><br><span class="line">declspec(thread) int g_c = 0; </span><br><span class="line">declspec(thread) int g_d;</span><br></pre></td></tr></table></figure></p>
<p>编译器在遇到这样的变量时,自然会将这种变量当做tls变量看待,编译链接存放到pe文件的.tls节中, Exe文件中可使用静态tls,动态库文件中使用静态tls则会有很大的缺点,所以动态库文件中一般都使用动 态tls来达到tls的目的。</p>
<p>为此Windows专门提供了一组api和相关基础设施来实现动态tls</p>
<ul>
<li><code>DWORD TlsAlloc():</code>为当前线程分配一个 tls 槽。返回本线程分得的槽号 </li>
<li><code>BOOL TlsSetValue(DWORD idx,void* val):</code>写数据到指定槽中 </li>
<li><code>VOID* TlsGetValue(DWORD idx ):</code>从指定槽中读数据 </li>
<li><code>BOOL TlsFree(DWORD idx);</code>释放这个槽给进程,使得其他线程可以分得这个槽 相关</li>
</ul>
<h3 id="相关结构-1"><a href="#相关结构-1" class="headerlink" title="相关结构"></a>相关结构</h3><h4 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Struct PEB </span><br><span class="line">&#123; </span><br><span class="line">   … </span><br><span class="line"> </span><br><span class="line">   RTL_BITMAP* TlsBitmap;<span class="comment">//标准的 64 位动态 tls 分配标志位图(固定使用下面的 64 位结构) </span></span><br><span class="line">   DWORD TlsBitmapBits[<span class="number">2</span>];<span class="comment">//内置的 64bit 大小的 tls 位图(每一位标志表示对应 tls 槽的分配情况) </span></span><br><span class="line">   … </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RTL-BITMAP"><a href="#RTL-BITMAP" class="headerlink" title="RTL_BITMAP"></a>RTL_BITMAP</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Struct RTL_BITMAP </span><br><span class="line">&#123; </span><br><span class="line">   ULONG SizeOfBitmap;<span class="comment">//动态 tls 位图的大小,默认就是 8B(64bit) </span></span><br><span class="line">   BYTE* Buffer;<span class="comment">//动态 tls 位图的地址,默认就指向 PEB 结构中的那个内置的 tls 位图。当要使用的 tl s 槽个数超过 64 个时,将使用扩展的 tls 位图。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Struct TEB </span><br><span class="line">&#123; </span><br><span class="line">   … </span><br><span class="line">   Void* ThreadLocalStoragePointer;<span class="comment">//本线程的那片静态 tls 区的地址 </span></span><br><span class="line">   Void* TlsSlots[<span class="number">64</span>];<span class="comment">//内置的 64 个 tls 槽(每个槽中可以存放 4B 大小的任意数据) </span></span><br><span class="line">   Void* TlsExpansionSlots;<span class="comment">//另外扩展的 1024 个 tls 槽 </span></span><br><span class="line">   … </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="动态Tls相关函数"><a href="#动态Tls相关函数" class="headerlink" title="动态Tls相关函数"></a>动态Tls相关函数</h3><h4 id="TlsAlloc"><a href="#TlsAlloc" class="headerlink" title="TlsAlloc"></a>TlsAlloc</h4><p>下面的函数分配一个空闲的 tls 槽,返回分到的槽号(即索引)<code>DWORD TlsAlloc()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">TlsAlloc</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	ULONG Index; </span><br><span class="line">	RtlAcquirePebLock(); </span><br><span class="line">	<span class="comment">//先从标准的64位tls位图中找到一个空闲的tls槽(也即未被其他线程占用的tls槽) </span></span><br><span class="line">	Index = RtlFindClearBitsAndSet(NtCurrentPeb()-&gt;TlsBitmap, <span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">	<span class="keyword">if</span> (Index == <span class="number">-1</span>)<span class="comment">//如果找不到 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//再去扩展的tls槽位图中查找 </span></span><br><span class="line">		Index = RtlFindClearBitsAndSet(NtCurrentPeb()-&gt;TlsExpansionBitmap, <span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">		<span class="keyword">if</span> (Index != <span class="number">-1</span>)<span class="comment">//如果找到了 </span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> (NtCurrentTeb()-&gt;TlsExpansionSlots == <span class="literal">NULL</span>) </span><br><span class="line">			&#123; </span><br><span class="line">				NtCurrentTeb()-&gt;TlsExpansionSlots = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,<span class="number">1024</span> * <span class="keyword">sizeof</span>(PVOID)); </span><br><span class="line">			&#125; </span><br><span class="line">			NtCurrentTeb()-&gt;TlsExpansionSlots[Index] = <span class="number">0</span>;<span class="comment">//分到对应的槽后,自动将内容清0 </span></span><br><span class="line">			Index += <span class="number">64</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			SetLastError(ERROR_NO_MORE_ITEMS); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line"></span><br><span class="line">	NtCurrentTeb()-&gt;TlsSlots[Index] = <span class="number">0</span>; <span class="comment">//分到对应的槽后,自动将内容清0 </span></span><br><span class="line">	RtlReleasePebLock(); </span><br><span class="line">	<span class="keyword">return</span> Index; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TlsSetValue"><a href="#TlsSetValue" class="headerlink" title="TlsSetValue"></a>TlsSetValue</h4><p>下面的函数将数据写入指定 tls 槽中 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TlsSetValue</span><span class="params">(DWORD Index, LPVOID Value)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (Index &gt;= <span class="number">64</span>) <span class="comment">//扩展tls槽中 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (NtCurrentTeb()-&gt;TlsExpansionSlots == <span class="literal">NULL</span>) </span><br><span class="line">		&#123; </span><br><span class="line">			NtCurrentTeb()-&gt;TlsExpansionSlots = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,<span class="number">1024</span> *<span class="keyword">sizeof</span>(PVOID)); </span><br><span class="line">		&#125; </span><br><span class="line">		NtCurrentTeb()-&gt;TlsExpansionSlots[Index - <span class="number">64</span>] = Value; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		NtCurrentTeb()-&gt;TlsSlots[Index] = Value; </span><br><span class="line">	<span class="keyword">return</span> TRUE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TlsGetValue"><a href="#TlsGetValue" class="headerlink" title="TlsGetValue"></a>TlsGetValue</h4><p>下面的函数读取指定 tls 槽中的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">TlsGetValue</span><span class="params">(DWORD Index)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (Index &gt;= <span class="number">64</span>) </span><br><span class="line">		<span class="keyword">return</span> NtCurrentTeb()-&gt;TlsExpansionSlots[Index - <span class="number">64</span>]; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> NtCurrentTeb()-&gt;TlsSlots[Index]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TlsFree"><a href="#TlsFree" class="headerlink" title="TlsFree"></a>TlsFree</h4><p>下面的函数用来释放一个 tls 槽给进程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TlsFree</span><span class="params">(DWORD Index)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BOOL BitSet; </span><br><span class="line">	RtlAcquirePebLock(); </span><br><span class="line">	<span class="keyword">if</span> (Index &gt;= <span class="number">64</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//检测该tls槽是否已分配 </span></span><br><span class="line">		BitSet = RtlAreBitsSet(NtCurrentPeb()-&gt;TlsExpansionBitmap,Index - <span class="number">64</span>,<span class="number">1</span>); </span><br><span class="line">		<span class="keyword">if</span> (BitSet)<span class="comment">//若已分配,现在标记为空闲 </span></span><br><span class="line">			RtlClearBits(NtCurrentPeb()-&gt;TlsExpansionBitmap,Index - <span class="number">64</span>,<span class="number">1</span>); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		BitSet = RtlAreBitsSet(NtCurrentPeb()-&gt;TlsBitmap, Index, <span class="number">1</span>); </span><br><span class="line">		<span class="keyword">if</span> (BitSet) </span><br><span class="line">			RtlClearBits(NtCurrentPeb()-&gt;TlsBitmap, Index, <span class="number">1</span>); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (BitSet) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//将所有线程的对应tls槽内容清0 </span></span><br><span class="line">		NtSetInformationThread(NtCurrentThread(),ThreadZeroTlsCell,&amp;Index,<span class="keyword">sizeof</span>(DWORD)); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		SetLastError(ERROR_INVALID_PARAMETER); </span><br><span class="line">	</span><br><span class="line">	RtlReleasePebLock(); </span><br><span class="line">	<span class="keyword">return</span> BitSet; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这些关于动态tls的函数都不难理解。<br>动态tls功能强大,但使用起来不方便。<br>静态tls不好用在动态库中,比较局限,但静态tls使用方便。<br>话又说回来,静态的tls的使用方便背后,又包含着较为复杂的初始化流程。<br>下面看静态tls的初始化流程。 </p>
<h3 id="静态Tls"><a href="#静态Tls" class="headerlink" title="静态Tls"></a>静态Tls</h3><h4 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h4><p>回顾一下进程创建时的启动流程: 在进程启动时,初始化主exe文件的函数内部</p>
<h5 id="LdrPEStartup-1"><a href="#LdrPEStartup-1" class="headerlink" title="LdrPEStartup"></a>LdrPEStartup</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PEFUNC <span class="title">LdrPEStartup</span><span class="params">(…)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	… </span><br><span class="line">	Status = LdrFixupImports(<span class="literal">NULL</span>, *Module);<span class="comment">//加载子孙dll,修正IAT导入表 </span></span><br><span class="line">	Status = LdrpInitializeTlsForProccess();<span class="comment">//初始化进程的静态tls </span></span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">		LdrpAttachProcess();<span class="comment">//发送一个ProcessAttach消息,调用该模块的DllMain函数 </span></span><br><span class="line">		LdrpTlsCallback(*Module, DLL_PROCESS_ATTACH);<span class="comment">//调用各模块的tls回调函数  </span></span><br><span class="line">	&#125; </span><br><span class="line">	… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>钻进各个函数里面去看一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">LdrFixupImports</span><span class="params">(…)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   … </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (TlsDirectory) </span><br><span class="line">	&#123; </span><br><span class="line">		TlsSize = TlsDirectory-&gt;EndAddressOfRawData- TlsDirectory-&gt;StartAddressOfRawData </span><br><span class="line">		           + TlsDirectory-&gt;SizeOfZeroFill; </span><br><span class="line">		<span class="keyword">if</span> (TlsSize &gt; <span class="number">0</span> &amp;&amp; NtCurrentPeb()-&gt;Ldr-&gt;Initialized)<span class="comment">//if 动态加载该模块 </span></span><br><span class="line">			TlsDirectory = <span class="literal">NULL</span>;<span class="comment">// 动态加载的模块不支持静态tls </span></span><br><span class="line">	&#125; </span><br><span class="line">	… </span><br><span class="line">	<span class="keyword">if</span> (TlsDirectory &amp;&amp; TlsSize &gt; <span class="number">0</span>)<span class="comment">//处理静态加载的dll模块中的静态tls节 </span></span><br><span class="line">		LdrpAcquireTlsSlot(Module, TlsSize, FALSE); </span><br><span class="line">	… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="LdrpAcquireTlsSlot"><a href="#LdrpAcquireTlsSlot" class="headerlink" title="LdrpAcquireTlsSlot"></a>LdrpAcquireTlsSlot</h6><p>在修正每个exe、dll文件的导入表时,会检查该文件中.tls节的大小。<br>由于这个函数本身也会被<code>LoadLibrary</code>函数在内部调用,所以这个函数他会检测是不是在动态加载dll<br>若是如果发现dll中含有静态tls 节,就什么都不做。<br>反之若dll是在进程启动阶段静态加载的,就会调用<code>LdrpAcquireTlsSlot</code>处理那个模块中的tls节。</p>
<p>具体是怎么处理的呢？我们看:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">LdrpAcquireTlsSlot</span><span class="params">(PLDR_DATA_TABLE_ENTRY Module, ULONG Size, BOOLEAN Locked)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (!Locked) </span><br><span class="line">		RtlEnterCriticalSection (NtCurrentPeb()-&gt;LoaderLock); </span><br><span class="line">	</span><br><span class="line">	Module-&gt;TlsIndex = LdrpTlsCount;<span class="comment">//记录这个模块tls节的索引(即tls号) </span></span><br><span class="line">	LdrpTlsCount++;<span class="comment">//递增进程中的tls节个数 </span></span><br><span class="line">	LdrpTlsSize += Size;<span class="comment">//递增进程中tls节总大小 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!Locked) </span><br><span class="line">		RtlLeaveCriticalSection(NtCurrentPeb()-&gt;LoaderLock); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上每个模块在进程启动时的静态加载过程中,只是递增一下进程中总的tls节个数与大小,以及分配该 模块的tls节编号,以便在进程完全初始化完成(即加载了所有模块)后,统一集中处理各模块中的静态tls节。 </p>
<h6 id="LdrpInitializeTlsForProccess"><a href="#LdrpInitializeTlsForProccess" class="headerlink" title="LdrpInitializeTlsForProccess"></a>LdrpInitializeTlsForProccess</h6><p>下面再看<code>LdrPEStartup</code>函数中调用的<code>LdrpInitializeTlsForProccess</code>函数,显然这个函数是在<code>LdrFixup Imports</code>函数加载了该exe依赖的所有子孙dll文件后才调用的。<br>前面已经统计完了该进程中所有模块的所有tls节的总大小以及tls节总个数,现在就到调用这个函数集中统一处理该进程的静态tls时候了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">LdrpInitializeTlsForProccess</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PLIST_ENTRY ModuleListHead; </span><br><span class="line">	PLIST_ENTRY Entry; </span><br><span class="line">	PLDR_DATA_TABLE_ENTRY Module; </span><br><span class="line">	PIMAGE_TLS_DIRECTORY TlsDirectory; </span><br><span class="line">	PTLS_DATA TlsData; </span><br><span class="line">	ULONG Size; </span><br><span class="line">	<span class="keyword">if</span> (LdrpTlsCount &gt; <span class="number">0</span>) <span class="comment">//如果有模块中存在tls节 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//分配一个tls描述符数组,用来记录各模块的tls节信息</span></span><br><span class="line">		<span class="comment">// 注意分配的只是描述符,并不用来存放tls节体。</span></span><br><span class="line">		<span class="comment">// 另外每个进程的tls描述符数组都记录在ntdll.dll模块中的LdrpTlsArray全局变量中 </span></span><br><span class="line">		LdrpTlsArray = RtlAllocateHeap(RtlGetProcessHeap(),<span class="number">0</span>, LdrpTlsCount * <span class="keyword">sizeof</span>(TLS_DATA)); </span><br><span class="line"></span><br><span class="line">		ModuleListHead = &amp;NtCurrentPeb()-&gt;Ldr-&gt;InLoadOrderModuleList; </span><br><span class="line">		Entry = ModuleListHead-&gt;Flink; </span><br><span class="line"></span><br><span class="line">		<span class="comment">//遍历所有含有tls节的静态加载模块</span></span><br><span class="line">		<span class="keyword">while</span> (Entry != ModuleListHead) </span><br><span class="line">		&#123; </span><br><span class="line">			Module = CONTAINING_RECORD(Entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks); </span><br><span class="line">			<span class="keyword">if</span> (Module-&gt;LoadCount ==<span class="number">-1</span> &amp;&amp; Module-&gt;TlsIndex != <span class="number">-1</span>) </span><br><span class="line">			&#123; </span><br><span class="line">				<span class="comment">//获得pe文件中tls目录的信息 </span></span><br><span class="line">				TlsDirectory = RtlImageDirectoryEntryToData(Module-&gt;DllBase, </span><br><span class="line">					                TRUE,IMAGE_DIRECTORY_ENTRY_TLS,&amp;Size); </span><br><span class="line">                </span><br><span class="line">                TlsData = &amp;LdrpTlsArray[Module-&gt;TlsIndex];<span class="comment">//指向该模块对应的描述符 </span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">//非0区在原模块中的地址 </span></span><br><span class="line">				TlsData-&gt;StartAddressOfRawData = TlsDirectory-&gt;StartAddressOfRawData; </span><br><span class="line">				<span class="comment">//非0区的大小 </span></span><br><span class="line">				TlsData-&gt;TlsDataSize = TlsDirectory-&gt;EndAddressOfRawData - TlsDirectory-&gt;StartAddressOfRawData; </span><br><span class="line">				<span class="comment">//0区的大小(即尚未初始化的tls变量总大小) </span></span><br><span class="line">				TlsData-&gt;TlsZeroSize = TlsDirectory-&gt;SizeOfZeroFill; </span><br><span class="line">				<span class="comment">//tls回调函数数组的地址 </span></span><br><span class="line">				<span class="keyword">if</span> (TlsDirectory-&gt;AddressOfCallBacks) </span><br><span class="line">					TlsData-&gt;TlsAddressOfCallBacks = TlsDirectory-&gt;AddressOfCallBacks; </span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					TlsData-&gt;TlsAddressOfCallBacks = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line">				TlsData-&gt;Module = Module;<span class="comment">//该tls节所在的原模块 </span></span><br><span class="line">				<span class="comment">//重要。回填到原模块中,该tls节分得的索引。(写复制机制可确保各进程一份) </span></span><br><span class="line">				*(PULONG)TlsDirectory-&gt;AddressOfIndex = Module-&gt;TlsIndex; </span><br><span class="line">			&#125; </span><br><span class="line">			Entry = Entry-&gt;Flink; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上这个函数为进程建立起一个tls描述符数组。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tls节描述符 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TLS_DATA</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	PVOID StartAddressOfRawData; <span class="comment">//非0区在原模块中的地址 </span></span><br><span class="line">	DWORD TlsDataSize;<span class="comment">// 非0区的大小 </span></span><br><span class="line">	DWORD TlsZeroSize;<span class="comment">// 0区大小 </span></span><br><span class="line">	PIMAGE_TLS_CALLBACK *TlsAddressOfCallBacks;<span class="comment">//回调函数数组 </span></span><br><span class="line">	PLDR_DATA_TABLE_ENTRY Module;<span class="comment">//所在模块 </span></span><br><span class="line">&#125; TLS_DATA, *PTLS_DATA;</span><br></pre></td></tr></table></figure>
<p>非0区与0区是什么意思呢？<br>tls节中各个变量可能有的没有初值,凡是没有初值的tls的变量都被安排到tls节的末尾,并且不予分配文件空间(这样,可以节省文件体积),只记录他们的总字节数即可。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declspec(thread) int g_a = 1;//已初始化,被安排到tls节中的非0区 </span><br><span class="line">declspec(thread) int g_b;//被安排到0区 </span><br><span class="line">declspec(thread) int g_c = 0;//已初始化,被安排到tls节中的非0区 </span><br><span class="line">declspec(thread) int g_d; //被安排到0区 所</span><br></pre></td></tr></table></figure>
<h5 id="LdrpAttachThread-1"><a href="#LdrpAttachThread-1" class="headerlink" title="LdrpAttachThread"></a>LdrpAttachThread</h5><p>有未予初始化的tls变量都默认赋予初值0。<br>最后每当一个线程创建时的初始化工作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">LdrpAttachThread</span> <span class="params">(VOID)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	...</span><br><span class="line">	Status = LdrpInitializeTlsForThread();</span><br><span class="line">	<span class="comment">//关键处。初始化每个线程的静态tls </span></span><br><span class="line">	<span class="comment">// 调用各dll的DllMain,略 </span></span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上每当一个线程初始运行时,除了会调用进程中各个dll的DllMain函数外,还会初始化自己的静态tls,建立起本线程独立的一份静态tls副本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">LdrpInitializeTlsForThread</span><span class="params">(VOID)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PVOID* TlsPointers; </span><br><span class="line">	PTLS_DATA TlsInfo; </span><br><span class="line">	PVOID TlsData; </span><br><span class="line">	ULONG i; </span><br><span class="line">	PTEB Teb = NtCurrentTeb(); </span><br><span class="line">	Teb-&gt;StaticUnicodeString.Length = <span class="number">0</span>; </span><br><span class="line">	Teb-&gt;StaticUnicodeString.MaximumLength = <span class="keyword">sizeof</span>(Teb-&gt;StaticUnicodeBuffer); </span><br><span class="line">	Teb-&gt;StaticUnicodeString.Buffer = Teb-&gt;StaticUnicodeBuffer; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (LdrpTlsCount &gt; <span class="number">0</span>)<span class="comment">//如果本进程中有包含tls节的静态模块 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//将各模块内部的tls节提取出来,连成一片,形成一块‘tls片区’ </span></span><br><span class="line">		TlsPointers = RtlAllocateHeap(RtlGetProcessHeap(),<span class="number">0</span>, LdrpTlsCount * <span class="keyword">sizeof</span>(PVOID) + LdrpTlsSize);<span class="comment">//头部指针数组+所有tls块的总大 小 </span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//指向头部后面的各tls节体部分 </span></span><br><span class="line">		TlsData = (PVOID)((ULONG_PTR)TlsPointers + LdrpTlsCount * <span class="keyword">sizeof</span>(PVOID)); </span><br><span class="line">		Teb-&gt;ThreadLocalStoragePointer = TlsPointers;<span class="comment">//指向本线程自己的那份tls的头部  </span></span><br><span class="line">		TlsInfo = LdrpTlsArray;<span class="comment">//指向本进程的tls描述符数组 </span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LdrpTlsCount; i++, TlsInfo++) </span><br><span class="line">		&#123; </span><br><span class="line">			TlsPointers[i] = TlsData;<span class="comment">//将数组指针指向对应的tls块 </span></span><br><span class="line">			<span class="keyword">if</span> (TlsInfo-&gt;TlsDataSize) </span><br><span class="line">			&#123;     </span><br><span class="line">				<span class="comment">//提取对应模块内部的tls节体(非0区部分)到这儿来 </span></span><br><span class="line">				<span class="built_in">memcpy</span>(TlsData, TlsInfo-&gt;StartAddressOfRawData, TlsInfo-&gt;TlsDataSize); </span><br><span class="line"></span><br><span class="line">				TlsData = (PVOID)((ULONG_PTR)TlsData + TlsInfo-&gt;TlsDataSize); </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">if</span> (TlsInfo-&gt;TlsZeroSize)<span class="comment">//0区部分 </span></span><br><span class="line">			&#123; </span><br><span class="line">				<span class="built_in">memset</span>(TlsData, <span class="number">0</span>, TlsInfo-&gt;TlsZeroSize);<span class="comment">//自动初始化为0 </span></span><br><span class="line">				TlsData = (PVOID)((ULONG_PTR)TlsData + TlsInfo-&gt;TlsZeroSize);<span class="comment">//跨过0区部分 			</span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125; 	</span><br><span class="line">	&#125; 		</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到没,每个线程诞生之初,就将进程中各模块内部的tls节提取出来,复制到一个集中的地方存放,这样, 吗,每个线程都建立了一份自己连续的tls片区。<br>以后要访问tls变量时,访问的都是自己的那份tls片区</p>
<p>当然如何访问？<br>这离不开编译器对静态tls机制提供的支持。<br>编译器在遇到<code>declspec(thread)</code>关键字时,会认为那个变量是tls变量,将之编译链接到pe文件的.tls 节中存放,另外每条访问tls变量的高级语句都被做了恰当的编译。</p>
<p>每个tls变量都被编译为二级地址: <code>&quot;Tls节号.节内偏移&quot;</code>,每个模块的tls节号(即索引)保存在那个模块的tls目录中的某个固定字段中(详 见: <code>*(PULONG)TlsDirectory-&gt;AddressOfIndex = Module-&gt;TlsIndex</code>这条语句)<br>这样编译器从模块的这个位置取得该模块的tls节分得的节号,以此节号为索引,根据TEB中的保存的那块<code>&quot;tls片区&quot;</code>的头部数组,找到对应于本模块tls节副本的位置,然后加上该tls变量在节内的偏移,就正确找到对应的内存单元了。 </p>
<p><br><br><br></p>
<h2 id="进程挂靠与跨进程操作"><a href="#进程挂靠与跨进程操作" class="headerlink" title="进程挂靠与跨进程操作"></a>进程挂靠与跨进程操作</h2><p>前面总在说：“将一个线程挂靠到其他进程的地址空间”,这是怎么回事？</p>
<p>当父进程要创建一个子进程时：会在父进程中调用<code>CreateProcess</code>。<br>这个函数本身是运行在父进程的地址空间中的,但是由它创建了子进程,创建了子进程的地址空间,创建了子进程的PEB。<br>当要初始化子进程的PEB结构时,由于PEB本身位于子进程的地址空间中,如果直接访问PEB那是不对的,那将会映射到不同的物理内存。<br>所以必须挂靠到子进程的地址空间中,去读写PEB结构体中的值。</p>
<h3 id="KeAttachProcess"><a href="#KeAttachProcess" class="headerlink" title="KeAttachProcess"></a>KeAttachProcess</h3><p>下面的函数就是用来挂靠的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将当前线程挂靠到指定进程的地址空间</span></span><br><span class="line"><span class="function">VOID <span class="title">KeAttachProcess</span><span class="params">(IN PKPROCESS Process)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	KLOCK_QUEUE_HANDLE ApcLock; </span><br><span class="line">	PKTHREAD Thread = KeGetCurrentThread(); </span><br><span class="line">	<span class="keyword">if</span> (Thread-&gt;ApcState.Process == Process) </span><br><span class="line">		<span class="keyword">return</span>;<span class="comment">//如果已经位于目标进程返回 </span></span><br><span class="line">	<span class="keyword">if</span> ((Thread-&gt;ApcStateIndex != OriginalApcEnvironment) || (KeIsExecutingDpc())) </span><br><span class="line">		KeBugCheckEx(~);<span class="comment">//蓝屏错误 </span></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		KiAcquireApcLock(Thread, &amp;ApcLock); </span><br><span class="line">		KiAcquireDispatcherLockAtDpcLevel();<span class="comment">//挂靠过程操作过程中禁止线程切换 </span></span><br><span class="line">		KiAttachProcess(Thread, Process, &amp;ApcLock, &amp;Thread-&gt;SavedApcState);<span class="comment">//实质函数 </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function">VOID <span class="title">KiAttachProcess</span><span class="params">(IN PKTHREAD Thread,<span class="comment">//指定线程 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN PKPROCESS Process,<span class="comment">//要挂靠到的目标进程 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN PKLOCK_QUEUE_HANDLE ApcLock, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN PRKAPC_STATE SavedApcState)</span><span class="comment">//保存原apc队列状态 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Process-&gt;StackCount++;<span class="comment">//目标线程的内核栈个数递增(也即增加线程个数) </span></span><br><span class="line">    KiMoveApcState(&amp;Thread-&gt;ApcState, SavedApcState);<span class="comment">//复制保存原apc队列状态 </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//每当一挂靠,必然要清空原apc队列 </span></span><br><span class="line">    InitializeListHead(&amp;Thread-&gt;ApcState.ApcListHead[KernelMode]); </span><br><span class="line">    InitializeListHead(&amp;Thread-&gt;ApcState.ApcListHead[UserMode]); </span><br><span class="line">    Thread-&gt;ApcState.Process = Process;<span class="comment">//关键。将表示当前进程的字段更为目标进程 </span></span><br><span class="line">    Thread-&gt;ApcState.KernelApcInProgress = FALSE; </span><br><span class="line">    Thread-&gt;ApcState.KernelApcPending = FALSE; </span><br><span class="line">    Thread-&gt;ApcState.UserApcPending = FALSE; </span><br><span class="line">    <span class="keyword">if</span> (SavedApcState == &amp;Thread-&gt;SavedApcState)<span class="comment">//一般满足 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//修改指向,但不管怎么修改,ApcState字段总是表示当前apc状态 </span></span><br><span class="line">		Thread-&gt;ApcStatePointer[OriginalApcEnvironment] = &amp;Thread-&gt;SavedApcState; </span><br><span class="line">		Thread-&gt;ApcStatePointer[AttachedApcEnvironment] = &amp;Thread-&gt;ApcState; </span><br><span class="line">		Thread-&gt;ApcStateIndex = AttachedApcEnvironment; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Process-&gt;State == ProcessInMemory)<span class="comment">//if 没被置换出去 </span></span><br><span class="line">	&#123; </span><br><span class="line">		KiReleaseDispatcherLockFromDpcLevel(); </span><br><span class="line">		KiReleaseApcLockFromDpcLevel(ApcLock); </span><br><span class="line">		KiSwapProcess(Process, SavedApcState-&gt;Process);<span class="comment">//实质函数 </span></span><br><span class="line">		<span class="comment">//调用这个函数的目的是检测可能的抢占切换条件是否已发生。(若已发生就赶紧切换) </span></span><br><span class="line">		KiExitDispatcher(ApcLock-&gt;OldIrql);<span class="comment">//降到指定irql(同时检查是否发生了抢占式切换) </span></span><br><span class="line">	&#125; </span><br><span class="line">	Else … </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="KiSwapProcess"><a href="#KiSwapProcess" class="headerlink" title="KiSwapProcess"></a>KiSwapProcess</h4><p>实质性的函数是<code>KiSwapProcess</code>继续看 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KiSwapProcess</span><span class="params">(IN PKPROCESS NewProcess,IN PKPROCESS OldProcess)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PKIPCR Pcr = (PKIPCR)KeGetPcr(); </span><br><span class="line">	<span class="comment">//关键。修改cr3(存放进程页目录的物理地址)寄存器为目标进程的页表 </span></span><br><span class="line">	writecr3(NewProcess-&gt;DirectoryTableBase[<span class="number">0</span>]); </span><br><span class="line">	Ke386SetGs(<span class="number">0</span>);<span class="comment">//将gs寄存器清0 </span></span><br><span class="line">	Pcr-&gt;TSS-&gt;IoMapBase = NewProcess-&gt;IopmOffset;<span class="comment">//修改当前线程的IO权限位图为目标进程的那份 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到没进程挂靠的实质工作,就是将cr3寄存器改为目标寄存器的地址空间<br>这样线程的所有有关内存的操作,操作的都是目标进程的地址空间。<br>明白了进程挂靠后,理解跨进程操作就很容易了。 </p>
<p>一个进程可以调用<code>OpenProcess</code>打开另一个进程,取得目标进程的句柄后,就可调用<code>VirtualAllocEx</code>、<code>Wri teProcessMemory</code>、<code>ReadProcessMemory</code>、<code>CreateRemoteThread</code>等函数操作那个进程的地址空间。<br>这些跨进程操作的函数功能强大,而且带有破坏性,以至于往往被杀毒软件重点封杀,特别是<code>CreateRemoteThread</code>这个函数,冤啊。</p>
<h3 id="打开目标进程"><a href="#打开目标进程" class="headerlink" title="打开目标进程"></a>打开目标进程</h3><p>所有的跨进程操作都必经一步：打开目标进程。(这是一道需要重点把手的关口)  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenProcess</span><span class="params">(DWORD dwDesiredAccess,<span class="comment">//申请的权限 </span></span></span></span><br><span class="line"><span class="function"><span class="params">            BOOL bInheritHandle,<span class="comment">//指本次打开得到的句柄是否可继承给子进程 </span></span></span></span><br><span class="line"><span class="function"><span class="params">            DWORD dwProcessId)</span><span class="comment">//目标进程的pid </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	NTSTATUS errCode; </span><br><span class="line">	HANDLE ProcessHandle; </span><br><span class="line">	OBJECT_ATTRIBUTES ObjectAttributes; </span><br><span class="line">	CLIENT_ID ClientId; </span><br><span class="line">	ClientId.UniqueProcess = UlongToHandle(dwProcessId); </span><br><span class="line">	ClientId.UniqueThread = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">	InitializeObjectAttributes(&amp;ObjectAttributes,<span class="literal">NULL</span>, (bInheritHandle ? OBJ_INHERIT : <span class="number">0</span>),<span class="literal">NULL</span>,<span class="literal">NULL</span>); </span><br><span class="line">	<span class="comment">//调用系统服务打开进程 </span></span><br><span class="line">	errCode = NtOpenProcess(&amp;ProcessHandle,dwDesiredAccess,&amp;ObjectAttributes,&amp;ClientId); </span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(errCode)) </span><br><span class="line">	&#123; </span><br><span class="line">		SetLastErrorByStatus(errCode); </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> ProcessHandle; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">NtOpenProcess</span><span class="params">(OUT PHANDLE ProcessHandle, </span></span></span><br><span class="line"><span class="function"><span class="params">              IN ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="function"><span class="params">              IN POBJECT_ATTRIBUTES ObjectAttributes, </span></span></span><br><span class="line"><span class="function"><span class="params">              IN PCLIENT_ID ClientId)</span><span class="comment">//pid.tid </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	KPROCESSOR_MODE PreviousMode = KeGetPreviousMode(); </span><br><span class="line">	ULONG Attributes = <span class="number">0</span>; </span><br><span class="line">	BOOLEAN HasObjectName = FALSE; </span><br><span class="line"></span><br><span class="line">	PETHREAD Thread = <span class="literal">NULL</span>; </span><br><span class="line">	PEPROCESS Process = <span class="literal">NULL</span>; </span><br><span class="line">	<span class="keyword">if</span> (PreviousMode != KernelMode) </span><br><span class="line">	&#123; </span><br><span class="line">		_SEH2_TRY </span><br><span class="line">		&#123; </span><br><span class="line">			ProbeForWriteHandle(ProcessHandle); </span><br><span class="line">			<span class="keyword">if</span> (ClientId) </span><br><span class="line">			&#123; </span><br><span class="line">			    ProbeForRead(ClientId, <span class="keyword">sizeof</span>(CLIENT_ID), <span class="keyword">sizeof</span>(ULONG)); </span><br><span class="line">			    SafeClientId = *ClientId; </span><br><span class="line">			    ClientId = &amp;SafeClientId; </span><br><span class="line">			&#125; </span><br><span class="line">			ProbeForRead(ObjectAttributes,<span class="keyword">sizeof</span>(OBJECT_ATTRIBUTES),<span class="keyword">sizeof</span>(ULONG)); </span><br><span class="line">			HasObjectName = (ObjectAttributes-&gt;ObjectName != <span class="literal">NULL</span>); </span><br><span class="line">			Attributes = ObjectAttributes-&gt;Attributes; </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">		&#123; </span><br><span class="line">			_SEH2_YIELD(<span class="keyword">return</span> _SEH2_GetExceptionCode()); </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_END; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		HasObjectName = (ObjectAttributes-&gt;ObjectName != <span class="literal">NULL</span>); </span><br><span class="line">		Attributes = ObjectAttributes-&gt;Attributes; </span><br><span class="line">	&#125; </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((HasObjectName) &amp;&amp; (ClientId))<span class="comment">//不能同时给定进程名与id </span></span><br><span class="line"> 		<span class="keyword">return</span> STATUS_INVALID_PARAMETER_MIX; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//传递当前令牌以及要求的权限到AccessState中 </span></span><br><span class="line">	Status = SeCreateAccessState(&amp;AccessState,&amp;AuxData,DesiredAccess, </span><br><span class="line">	                     &amp;PsProcessType-&gt;TypeInfo.GenericMapping); </span><br><span class="line">	<span class="comment">//检查当前令牌是否具有调试特权(这就是为什么经常在打开目标进程前要启用调试特权) </span></span><br><span class="line">	<span class="keyword">if</span> (SeSinglePrivilegeCheck(SeDebugPrivilege, PreviousMode)) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (AccessState.RemainingDesiredAccess &amp; MAXIMUM_ALLOWED) </span><br><span class="line">			AccessState.PreviouslyGrantedAccess |= PROCESS_ALL_ACCESS; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			AccessState.PreviouslyGrantedAccess |=AccessState.RemainingDesiredAccess; </span><br><span class="line">		AccessState.RemainingDesiredAccess = <span class="number">0</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (HasObjectName) <span class="comment">//以对象名的方式查找该进程对象 </span></span><br><span class="line">	&#123; </span><br><span class="line">		Status = ObOpenObjectByName(ObjectAttributes,PsProcessType,PreviousMode, &amp;AccessState,<span class="number">0</span>,<span class="literal">NULL</span>,&amp;hProcess); </span><br><span class="line">		SeDeleteAccessState(&amp;AccessState); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ClientId) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (ClientId-&gt;UniqueThread)<span class="comment">//根据tid查找线程、进程对象 </span></span><br><span class="line">			Status = PsLookupProcessThreadByCid(ClientId, &amp;Process, &amp;Thread); </span><br><span class="line">		Else <span class="comment">//根据pid从获活动进程链表中查找进程对象,最常见 </span></span><br><span class="line">			Status = PsLookupProcessByProcessId(ClientId-&gt;UniqueProcess,&amp;Process); </span><br><span class="line">		<span class="keyword">if</span> (!NT_SUCCESS(Status)) </span><br><span class="line">		&#123; </span><br><span class="line">			SeDeleteAccessState(&amp;AccessState); </span><br><span class="line">			<span class="keyword">return</span> Status; </span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//在该进程对象上打开一个句柄 </span></span><br><span class="line">		Status = ObOpenObjectByPointer(Process,Attributes,&amp;AccessState,<span class="number">0</span>, </span><br><span class="line">		                           PsProcessType,PreviousMode,&amp;hProcess); </span><br><span class="line">		SeDeleteAccessState(&amp;AccessState); </span><br><span class="line">		<span class="keyword">if</span> (Thread) </span><br><span class="line">			ObDereferenceObject(Thread); </span><br><span class="line">		ObDereferenceObject(Process); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> STATUS_INVALID_PARAMETER_MIX; </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">		_SEH2_TRY </span><br><span class="line">		&#123; </span><br><span class="line">			*ProcessHandle = hProcess;<span class="comment">//返回打开得到的进程句柄 </span></span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">		&#123; </span><br><span class="line">			Status = _SEH2_GetExceptionCode(); </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_END; </span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上这个函数在检测权限满足后,就打开目标进程,返回一个句柄给调用者。<br>看下面的典型跨进程写数据函数：</p>
<h3 id="跨进程读写数据"><a href="#跨进程读写数据" class="headerlink" title="跨进程读写数据"></a>跨进程读写数据</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtWriteVirtualMemory</span><span class="params">(IN HANDLE ProcessHandle,<span class="comment">//远程进程 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                     IN PVOID BaseAddress, </span></span></span><br><span class="line"><span class="function"><span class="params">                     IN PVOID Buffer, </span></span></span><br><span class="line"><span class="function"><span class="params">                     IN SIZE_T NumberOfBytesToWrite, </span></span></span><br><span class="line"><span class="function"><span class="params">                     OUT PSIZE_T NumberOfBytesWritten OPTIONAL)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	KPROCESSOR_MODE PreviousMode = ExGetPreviousMode(); </span><br><span class="line">	PEPROCESS Process; </span><br><span class="line">	NTSTATUS Status = STATUS_SUCCESS; </span><br><span class="line">	SIZE_T BytesWritten = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">if</span> (PreviousMode != KernelMode) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> ((((ULONG_PTR)BaseAddress + NumberOfBytesToWrite) &lt; (ULONG_PTR)BaseAddress) || </span><br><span class="line">				(((ULONG_PTR)Buffer + NumberOfBytesToWrite) &lt; (ULONG_PTR)Buffer) || </span><br><span class="line">				(((ULONG_PTR)BaseAddress + NumberOfBytesToWrite) &gt; MmUserProbeAddress) || </span><br><span class="line">				(((ULONG_PTR)Buffer + NumberOfBytesToWrite) &gt; MmUserProbeAddress)) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">return</span> STATUS_ACCESS_VIOLATION; </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_TRY </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> (NumberOfBytesWritten) </span><br><span class="line">				ProbeForWriteSize_t(NumberOfBytesWritten); </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">		&#123; </span><br><span class="line">			_SEH2_YIELD(<span class="keyword">return</span> _SEH2_GetExceptionCode()); </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_END; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (NumberOfBytesToWrite) </span><br><span class="line">	&#123; </span><br><span class="line">		Status = ObReferenceObjectByHandle(ProcessHandle,PROCESS_VM_WRITE,PsProcessType, PreviousMode, (PVOID*)&amp;Process,<span class="literal">NULL</span>); </span><br><span class="line">		<span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">		&#123; </span><br><span class="line">			Status = MmCopyVirtualMemory(PsGetCurrentProcess(),Buffer,Process, </span><br><span class="line">									BaseAddress,NumberOfBytesToWrite, </span><br><span class="line">									PreviousMode,&amp;BytesWritten); </span><br><span class="line">			ObDereferenceObject(Process); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (NumberOfBytesWritten) </span><br><span class="line">	&#123; </span><br><span class="line">		_SEH2_TRY </span><br><span class="line">		&#123; </span><br><span class="line">			*NumberOfBytesWritten = BytesWritten; </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">		&#123; </span><br><span class="line"></span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_END; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MmCopyVirtualMemory</span><span class="params">(IN PEPROCESS SourceProcess, </span></span></span><br><span class="line"><span class="function"><span class="params">                    IN PVOID SourceAddress, </span></span></span><br><span class="line"><span class="function"><span class="params">                    IN PEPROCESS TargetProcess, </span></span></span><br><span class="line"><span class="function"><span class="params">                    OUT PVOID TargetAddress, </span></span></span><br><span class="line"><span class="function"><span class="params">                    IN SIZE_T BufferSize, </span></span></span><br><span class="line"><span class="function"><span class="params">                    IN KPROCESSOR_MODE PreviousMode, </span></span></span><br><span class="line"><span class="function"><span class="params">                    OUT PSIZE_T ReturnSize)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	NTSTATUS Status; </span><br><span class="line">	PEPROCESS Process = SourceProcess; </span><br><span class="line">	<span class="keyword">if</span> (SourceProcess == PsGetCurrentProcess()) </span><br><span class="line">		Process = TargetProcess; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (BufferSize &gt; <span class="number">512</span>)<span class="comment">//需要使用MDL </span></span><br><span class="line">	&#123; </span><br><span class="line">		Status = MiDoMappedCopy(SourceProcess,SourceAddress,TargetProcess,TargetAddress, </span><br><span class="line">	                    BufferSize,PreviousMode,ReturnSize); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		Status = MiDoPoolCopy(SourceProcess,SourceAddress,TargetProcess,TargetAddress, </span><br><span class="line">	                  BufferSize,PreviousMode,ReturnSize); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MiDoMappedCopy</span><span class="params">(IN PEPROCESS SourceProcess, </span></span></span><br><span class="line"><span class="function"><span class="params">               IN PVOID SourceAddress, </span></span></span><br><span class="line"><span class="function"><span class="params">               IN PEPROCESS TargetProcess, </span></span></span><br><span class="line"><span class="function"><span class="params">               OUT PVOID TargetAddress, </span></span></span><br><span class="line"><span class="function"><span class="params">               IN SIZE_T BufferSize, </span></span></span><br><span class="line"><span class="function"><span class="params">               IN KPROCESSOR_MODE PreviousMode, </span></span></span><br><span class="line"><span class="function"><span class="params">               OUT PSIZE_T ReturnSize)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PFN_NUMBER MdlBuffer[(<span class="keyword">sizeof</span>(MDL) / <span class="keyword">sizeof</span>(PFN_NUMBER)) + MI_MAPPED_COPY_PAGES + <span class="number">1</span>]; </span><br><span class="line">	PMDL Mdl = (PMDL)MdlBuffer; </span><br><span class="line"></span><br><span class="line">	SIZE_T TotalSize, CurrentSize, RemainingSize; </span><br><span class="line">	<span class="keyword">volatile</span> BOOLEAN FailedInProbe = FALSE, FailedInMapping = FALSE, FailedInMoving; </span><br><span class="line">	<span class="keyword">volatile</span> BOOLEAN PagesLocked; </span><br><span class="line"></span><br><span class="line">	PVOID CurrentAddress = SourceAddress, CurrentTargetAddress = TargetAddress; </span><br><span class="line">	<span class="keyword">volatile</span> PVOID MdlAddress; </span><br><span class="line">	KAPC_STATE ApcState; </span><br><span class="line">	BOOLEAN HaveBadAddress; </span><br><span class="line">	ULONG_PTR BadAddress; </span><br><span class="line">	NTSTATUS Status = STATUS_SUCCESS; </span><br><span class="line">	TotalSize = <span class="number">14</span> * PAGE_SIZE;<span class="comment">//每次拷贝14个页面大小 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (BufferSize &lt;= TotalSize) </span><br><span class="line">		TotalSize = BufferSize; </span><br><span class="line">	CurrentSize = TotalSize; </span><br><span class="line">	RemainingSize = BufferSize; </span><br><span class="line">	<span class="keyword">while</span> (RemainingSize &gt; <span class="number">0</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (RemainingSize &lt; CurrentSize) </span><br><span class="line">			CurrentSize = RemainingSize; </span><br><span class="line">		</span><br><span class="line">		KeStackAttachProcess(&amp;SourceProcess-&gt;Pcb, &amp;ApcState);<span class="comment">//挂靠到源进程 </span></span><br><span class="line">		MdlAddress = <span class="literal">NULL</span>; </span><br><span class="line">		PagesLocked = FALSE; </span><br><span class="line">		FailedInMoving = FALSE; </span><br><span class="line">		_SEH2_TRY </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> ((CurrentAddress == SourceAddress) &amp;&amp; (PreviousMode != KernelMode)) </span><br><span class="line">			&#123; </span><br><span class="line">				FailedInProbe = TRUE; </span><br><span class="line">				ProbeForRead(SourceAddress, BufferSize, <span class="keyword">sizeof</span>(CHAR)); </span><br><span class="line">				FailedInProbe = FALSE; </span><br><span class="line">			&#125; </span><br><span class="line">			MmInitializeMdl(Mdl, CurrentAddress, CurrentSize); </span><br><span class="line">			MmProbeAndLockPages(Mdl, PreviousMode, IoReadAccess); </span><br><span class="line">			PagesLocked = TRUE; </span><br><span class="line">			MdlAddress = MmMapLockedPagesSpecifyCache(Mdl,KernelMode,MmCached, <span class="literal">NULL</span>, </span><br><span class="line">			                                          FALSE,HighPagePriority); </span><br><span class="line">			KeUnstackDetachProcess(&amp;ApcState);<span class="comment">//撤销挂靠 </span></span><br><span class="line">			KeStackAttachProcess(&amp;TargetProcess-&gt;Pcb, &amp;ApcState);<span class="comment">//挂靠到目标进程 </span></span><br><span class="line">			<span class="keyword">if</span> ((CurrentAddress == SourceAddress) &amp;&amp; (PreviousMode != KernelMode)) </span><br><span class="line">			&#123; </span><br><span class="line">				FailedInProbe = TRUE; </span><br><span class="line">				ProbeForWrite(TargetAddress, BufferSize, <span class="keyword">sizeof</span>(CHAR)); </span><br><span class="line">				FailedInProbe = FALSE; </span><br><span class="line">			&#125; </span><br><span class="line"></span><br><span class="line">			FailedInMoving = TRUE; </span><br><span class="line">			RtlCopyMemory(CurrentTargetAddress, MdlAddress, CurrentSize);<span class="comment">//拷贝 </span></span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_EXCEPT()..... </span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Status != STATUS_SUCCESS) </span><br><span class="line">			<span class="keyword">return</span> Status; </span><br><span class="line"></span><br><span class="line">		KeUnstackDetachProcess(&amp;ApcState); </span><br><span class="line">		MmUnmapLockedPages(MdlAddress, Mdl); </span><br><span class="line">		MmUnlockPages(Mdl); </span><br><span class="line">		RemainingSize -= CurrentSize; </span><br><span class="line">		CurrentAddress = (PVOID)((ULONG_PTR)CurrentAddress + CurrentSize); </span><br><span class="line">		CurrentTargetAddress = (PVOID)((ULONG_PTR)CurrentTargetAddress + CurrentSize); </span><br><span class="line">	&#125; </span><br><span class="line">	*ReturnSize = BufferSize; </span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="线程的挂起与恢复"><a href="#线程的挂起与恢复" class="headerlink" title="线程的挂起与恢复"></a>线程的挂起与恢复</h2><p><code>SuspendThread-&gt;NtSuspendThread-&gt;PsSuspenThread-&gt; KeSuspendThread</code></p>
<p>直接看<code>KeSuspendThread</code>函数</p>
<h3 id="KeSuspendThread"><a href="#KeSuspendThread" class="headerlink" title="KeSuspendThread"></a>KeSuspendThread</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULONG <span class="title">KeSuspendThread</span><span class="params">(PKTHREAD Thread)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	KLOCK_QUEUE_HANDLE ApcLock; </span><br><span class="line">	ULONG PreviousCount; </span><br><span class="line">	ASSERT_IRQL_LESS_OR_EQUAL(DISPATCH_LEVEL); </span><br><span class="line">	KiAcquireApcLock(Thread, &amp;ApcLock); </span><br><span class="line">	PreviousCount = Thread-&gt;SuspendCount; </span><br><span class="line">	<span class="keyword">if</span> (Thread-&gt;ApcQueueable) </span><br><span class="line">	&#123; </span><br><span class="line">		Thread-&gt;SuspendCount++;<span class="comment">//递增挂起计数 </span></span><br><span class="line">		<span class="keyword">if</span> (!(PreviousCount) &amp;&amp; !(Thread-&gt;FreezeCount)) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> (!Thread-&gt;SuspendApc.Inserted)<span class="comment">//if尚未插入那个挂起APC </span></span><br><span class="line">			&#123; </span><br><span class="line">				Thread-&gt;SuspendApc.Inserted = TRUE; </span><br><span class="line">				KiInsertQueueApc(&amp;Thread-&gt;SuspendApc, IO_NO_INCREMENT);<span class="comment">//插入挂起APC </span></span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123; </span><br><span class="line">				KiAcquireDispatcherLockAtDpcLevel(); </span><br><span class="line">				Thread-&gt;SuspendSemaphore.Header.SignalState--; </span><br><span class="line">				KiReleaseDispatcherLockFromDpcLevel(); </span><br><span class="line"></span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	KiReleaseApcLockFromDpcLevel(&amp;ApcLock); </span><br><span class="line">	KiExitDispatcher(ApcLock.OldIrql); </span><br><span class="line">	<span class="keyword">return</span> PreviousCount; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个专有的<code>&quot;挂起APC&quot;</code>是一个特殊的APC,我们看他的工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KiSuspendThread</span><span class="params">(IN PVOID NormalContext, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN PVOID SystemArgument1, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN PVOID SystemArgument2)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//等待挂起计数减到0 </span></span><br><span class="line">	KeWaitForSingleObject(&amp;KeGetCurrentThread()-&gt;SuspendSemaphore,Suspended,KernelMode, </span><br><span class="line">							FALSE,<span class="literal">NULL</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上向指定线程插入一个<code>挂起APC</code>后,那个线程下次一得到调度,就会先执行内核中的所有APC<br>当执行到这个APC的时候,就会一直等到挂起计数降到0。换言之线程刚一得到调度运行的就会,就又重新进入等待了。<br>因此<code>挂起态</code>也是一种特殊的<code>等待态</code>。</p>
<h3 id="KeResumeThread"><a href="#KeResumeThread" class="headerlink" title="KeResumeThread"></a>KeResumeThread</h3><p>什么时候挂起计数会减到0呢？<br>只有在别的线程恢复这个线程的挂起计数时。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULONG <span class="title">KeResumeThread</span><span class="params">(IN PKTHREAD Thread)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	KLOCK_QUEUE_HANDLE ApcLock; </span><br><span class="line">	ULONG PreviousCount; </span><br><span class="line">	ASSERT_IRQL_LESS_OR_EQUAL(DISPATCH_LEVEL); </span><br><span class="line">	KiAcquireApcLock(Thread, &amp;ApcLock); </span><br><span class="line">	PreviousCount = Thread-&gt;SuspendCount; </span><br><span class="line">	<span class="keyword">if</span> (PreviousCount) </span><br><span class="line">	&#123; </span><br><span class="line">		Thread-&gt;SuspendCount--;<span class="comment">//递减挂起计数 </span></span><br><span class="line">		<span class="keyword">if</span> ((Thread-&gt;SuspendCount==<span class="number">0</span>) &amp;&amp; (!Thread-&gt;FreezeCount)) </span><br><span class="line">		&#123; </span><br><span class="line">			KiAcquireDispatcherLockAtDpcLevel(); </span><br><span class="line">			Thread-&gt;SuspendSemaphore.Header.SignalState++; </span><br><span class="line">			<span class="comment">//当挂起计数减到0时,唤醒目标线程 </span></span><br><span class="line">			KiWaitTest(&amp;Thread-&gt;SuspendSemaphore.Header, IO_NO_INCREMENT); </span><br><span class="line">			KiReleaseDispatcherLockFromDpcLevel(); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	KiReleaseApcLockFromDpcLevel(&amp;ApcLock); </span><br><span class="line">	KiExitDispatcher(ApcLock.OldIrql); </span><br><span class="line">	<span class="keyword">return</span> PreviousCount; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就这样简单。 </p>
<p>当一个线程处于等待状态时,可以指示本次睡眠是否可被强制唤醒,不必等到条件满足<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForSingleObjectEx</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hHandle,         </span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwMilliseconds,  </span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL bAlertable    <span class="comment">//指示本次等待过程中是否可以被其他线程(或其他线程发来的APC)强制唤醒。</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">KeAlertThread</span><span class="params">(IN PKTHREAD Thread, </span></span></span><br><span class="line"><span class="function"><span class="params">              IN KPROCESSOR_MODE AlertMode)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BOOLEAN PreviousState; </span><br><span class="line">	KLOCK_QUEUE_HANDLE ApcLock; </span><br><span class="line">	ASSERT_IRQL_LESS_OR_EQUAL(DISPATCH_LEVEL); </span><br><span class="line">	KiAcquireApcLock(Thread, &amp;ApcLock); </span><br><span class="line">	KiAcquireDispatcherLockAtDpcLevel(); </span><br><span class="line">	</span><br><span class="line">	PreviousState = Thread-&gt;Alerted[AlertMode];<span class="comment">//检测是否收到了来自那个模式的强制唤醒要求 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (PreviousState==FALSE) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> ((Thread-&gt;State == Waiting) &amp;&amp; <span class="comment">//线程处于等待状态 </span></span><br><span class="line">			(Thread-&gt;Alertable) &amp;&amp; <span class="comment">//线程可被强制唤醒 </span></span><br><span class="line">			(AlertMode &lt;= Thread-&gt;WaitMode)) <span class="comment">//模式条件符合 </span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">//强制唤醒那个线程 </span></span><br><span class="line">			KiUnwaitThread(Thread, STATUS_ALERTED, THREAD_ALERT_INCREMENT); </span><br><span class="line">		&#125; </span><br><span class="line">		Else <span class="comment">//仅仅标记已收到过来自那个模式的强制唤醒请求 </span></span><br><span class="line">			Thread-&gt;Alerted[AlertMode] = TRUE; </span><br><span class="line">	&#125; </span><br><span class="line">	KiReleaseDispatcherLockFromDpcLevel(); </span><br><span class="line">	KiReleaseApcLockFromDpcLevel(&amp;ApcLock); </span><br><span class="line">	KiExitDispatcher(ApcLock.OldIrql); </span><br><span class="line">	<span class="keyword">return</span> PreviousState; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意<code>AlertMode &lt;= Thread-&gt;WaitMode</code>条件指：用户模式的强制唤醒请求不能唤醒内核模式的等待。 </p>
<p><br></p>
<h2 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h2><p>前面讲过每个进程在启动的时候会加载主exe文件依赖的所有子孙dll。<br>实际上一般的<code>Win32 GUI</code>进程都会加载<code>user32.dll</code>模块。<br>这个模块一加载就会自动搜索注册表键<code>HKEY_LOCAL_MACHINE\Software\Mic rosoft\Windows NT\CurrentVersion\Windows</code>下的值：<code>AppInit_DLLs</code>,该值是一个dll列表,<code>user32.dll</code>会读取这个值,调用<code>LoadLibrary</code>加载里面的每个dll</p>
<p>因此我们可以把我们的dll名称添加到这个列表中,达到dll注入的目的</p>
<h3 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain"></a>DllMain</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//User32.dll的DllMain </span></span><br><span class="line"><span class="function">INT <span class="title">DllMain</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">          IN PVOID hInstanceDll, </span></span></span><br><span class="line"><span class="function"><span class="params">          IN ULONG dwReason, </span></span></span><br><span class="line"><span class="function"><span class="params">          IN PVOID reserved)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">switch</span> (dwReason) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">case</span> DLL_PROCESS_ATTACH: </span><br><span class="line">		Init();<span class="comment">//会调用这个函数 </span></span><br><span class="line">		… </span><br><span class="line">		… </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Init</span><span class="params">(VOID)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  … </span><br><span class="line">  LoadAppInitDlls();<span class="comment">//会调用这个函数加载那些dll </span></span><br><span class="line">  … </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LoadAppInitDlls"><a href="#LoadAppInitDlls" class="headerlink" title="LoadAppInitDlls"></a>LoadAppInitDlls</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">LoadAppInitDlls</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	szAppInit[<span class="number">0</span>] = UNICODE_NULL; </span><br><span class="line">	<span class="keyword">if</span> (GetDllList())<span class="comment">//读取这册表键的值,将要加载的dll列表保存在全局变量szAppInit中 </span></span><br><span class="line">	&#123; </span><br><span class="line">		WCHAR buffer[KEY_LENGTH]; </span><br><span class="line">		LPWSTR ptr; </span><br><span class="line">		<span class="keyword">size_t</span> i; </span><br><span class="line">		RtlCopyMemory(buffer, szAppInit, KEY_LENGTH); </span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_LENGTH; ++ i) </span><br><span class="line">		&#123; </span><br><span class="line">			if(buffer[i] == L' ' || buffer[i] == L',')//dll名称之间必须用空格或逗号隔开 </span><br><span class="line">			buffer[i] = <span class="number">0</span>; </span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_LENGTH; ) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span>(buffer[i] == <span class="number">0</span>) </span><br><span class="line">				++ i; </span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123; </span><br><span class="line">				ptr = buffer + i; </span><br><span class="line">				i += wcslen(ptr); </span><br><span class="line">				LoadLibraryW(ptr);<span class="comment">//加载每个dll </span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125; 	</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GetDllList"><a href="#GetDllList" class="headerlink" title="GetDllList"></a>GetDllList</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetDllList</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	NTSTATUS Status; </span><br><span class="line">	OBJECT_ATTRIBUTES Attributes; </span><br><span class="line">	BOOL bRet = FALSE; </span><br><span class="line">	BOOL bLoad; </span><br><span class="line">	HANDLE hKey = <span class="literal">NULL</span>; </span><br><span class="line">	DWORD dwSize; </span><br><span class="line">	PKEY_VALUE_PARTIAL_INFORMATION kvpInfo = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line">	UNICODE_STRING szKeyName = RTL_CONSTANT_STRING(<span class="string">L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows"</span>); </span><br><span class="line"></span><br><span class="line">	UNICODE_STRING szLoadName = RTL_CONSTANT_STRING(<span class="string">L"LoadAppInit_DLLs"</span>); </span><br><span class="line">	UNICODE_STRING szDllsName = RTL_CONSTANT_STRING(<span class="string">L"AppInit_DLLs"</span>); </span><br><span class="line">	</span><br><span class="line">	InitializeObjectAttributes(&amp;Attributes, &amp;szKeyName, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>); </span><br><span class="line">	Status = NtOpenKey(&amp;hKey, KEY_READ, &amp;Attributes); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">		dwSize = <span class="keyword">sizeof</span>(KEY_VALUE_PARTIAL_INFORMATION) + <span class="keyword">sizeof</span>(DWORD); </span><br><span class="line">		kvpInfo = HeapAlloc(GetProcessHeap(), <span class="number">0</span>, dwSize); </span><br><span class="line">		<span class="keyword">if</span> (!kvpInfo) </span><br><span class="line">			<span class="keyword">goto</span> end; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//先要在那个键中建立一个DWORD值：LoadAppInit_DLLs,并将数值设为1 </span></span><br><span class="line">		Status = NtQueryValueKey(hKey,&amp;szLoadName,KeyValuePartialInformation, </span><br><span class="line">				kvpInfo,dwSize,&amp;dwSize); </span><br><span class="line">		</span><br><span class="line">		RtlMoveMemory(&amp;bLoad,kvpInfo-&gt;Data,kvpInfo-&gt;DataLength); </span><br><span class="line">		HeapFree(GetProcessHeap(), <span class="number">0</span>, kvpInfo); </span><br><span class="line">		kvpInfo = <span class="literal">NULL</span>; </span><br><span class="line">		<span class="keyword">if</span> (bLoad)<span class="comment">//if 需要加载初始列表的那些dll </span></span><br><span class="line">		&#123; </span><br><span class="line">			Status = NtQueryValueKey(hKey,&amp;szDllsName,KeyValuePartialInformation, <span class="literal">NULL</span>,<span class="number">0</span>,&amp;dwSize); </span><br><span class="line">			kvpInfo = HeapAlloc(GetProcessHeap(), <span class="number">0</span>, dwSize); </span><br><span class="line">			Status = NtQueryValueKey(hKey, &amp;szDllsName,KeyValuePartialInformation, </span><br><span class="line">			         kvpInfo,dwSize,&amp;dwSize); </span><br><span class="line">			<span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">			&#123; </span><br><span class="line">				LPWSTR lpBuffer = (LPWSTR)kvpInfo-&gt;Data; </span><br><span class="line">				<span class="keyword">if</span> (*lpBuffer != UNICODE_NULL) </span><br><span class="line">				&#123; </span><br><span class="line">					INT bytesToCopy, nullPos; </span><br><span class="line">					bytesToCopy = min(kvpInfo-&gt;DataLength, KEY_LENGTH * <span class="keyword">sizeof</span>(WCHAR)); </span><br><span class="line">					<span class="keyword">if</span> (bytesToCopy != <span class="number">0</span>) </span><br><span class="line">					&#123; </span><br><span class="line">						<span class="comment">//dll列表拷到全局变量 </span></span><br><span class="line">						RtlMoveMemory(szAppInit,kvpInfo-&gt;Data,bytesToCopy);  </span><br><span class="line">						nullPos = (bytesToCopy / <span class="keyword">sizeof</span>(WCHAR)) - <span class="number">1</span>; </span><br><span class="line">						szAppInit[nullPos] = UNICODE_NULL; </span><br><span class="line">						bRet = TRUE; </span><br><span class="line">					&#125; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">end: </span><br><span class="line">	<span class="keyword">if</span> (hKey) </span><br><span class="line">		NtClose(hKey); </span><br><span class="line">	<span class="keyword">if</span> (kvpInfo) </span><br><span class="line">		HeapFree(GetProcessHeap(), <span class="number">0</span>, kvpInfo); </span><br><span class="line">	<span class="keyword">return</span> bRet; 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此只需在那个键下面添加一个DWORD值：<code>LoadAppInit_DLLs</code>,设为1<br>然后在<code>AppInit_DLLs</code>值中添加我们的dll即可达到将我们的dll加载到任意GUI进程的地址空间中。 </p>
<p><br><br><br></p>
<h1 id="APC"><a href="#APC" class="headerlink" title="APC"></a>APC</h1><p>异步过程调用, 这是一种常见的技术。<br>前面进程启动的初始过程就是：主线程在内核构造好运行环境后,从<code>KiThreadStartup</code>开始运行,然后调用<code>PspUserThreadStartup</code>,在该线程的<code>apc</code>队列中插入一个APC：<code>LdrInitializeThunk</code></p>
<p>这样当<code>PspUserThreadStartup</code>返回后,正式退回用户空间的总入口 <code>BaseProcessStartThunk</code>前,会执行中途插入的那个 apc,完成进程的用户空间初始化工作(链接 dll 的加载等) </p>
<p>可见APC 的执行时机之一就是从内核空间返回用户空间的前夕。<br>也即在返回用户空间前,会<code>中断</code>那么一下。因此APC 就是一种软中断。 </p>
<p>除了这种 APC 用途外,应用程序中也经常使用 APC。如<code>Win32 API ReadFileEx</code> 就可以使用 APC 机制来实现异步读写文件的功能。 </p>
<h2 id="ReadFileEx异步读写Apc实现"><a href="#ReadFileEx异步读写Apc实现" class="headerlink" title="ReadFileEx异步读写Apc实现"></a>ReadFileEx异步读写Apc实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReadFileEx</span><span class="params">(IN HANDLE hFile, </span></span></span><br><span class="line"><span class="function"><span class="params">			IN LPVOID lpBuffer, </span></span></span><br><span class="line"><span class="function"><span class="params">			IN DWORD nNumberOfBytesToRead OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">			IN LPOVERLAPPED lpOverlapped,<span class="comment">//完成结果 </span></span></span></span><br><span class="line"><span class="function"><span class="params">			IN LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)</span><span class="comment">//预置APC将调用的完成例程 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	LARGE_INTEGER Offset; </span><br><span class="line">	NTSTATUS Status; </span><br><span class="line">	Offset.u.LowPart = lpOverlapped-&gt;Offset; </span><br><span class="line">	Offset.u.HighPart = lpOverlapped-&gt;OffsetHigh; </span><br><span class="line">	lpOverlapped-&gt;Internal = STATUS_PENDING; </span><br><span class="line">	Status = NtReadFile(hFile, </span><br><span class="line">				<span class="literal">NULL</span>, <span class="comment">//Event=NULL </span></span><br><span class="line">				ApcRoutine,<span class="comment">//这个是内部预置的APC例程 </span></span><br><span class="line">				lpCompletionRoutine,<span class="comment">//APC的Context </span></span><br><span class="line">				(PIO_STATUS_BLOCK)lpOverlapped, </span><br><span class="line">				lpBuffer, </span><br><span class="line">				nNumberOfBytesToRead, </span><br><span class="line">				&amp;Offset, </span><br><span class="line">				<span class="literal">NULL</span>);<span class="comment">//Key=NULL </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">		SetLastErrorByStatus(Status);<span class="comment">// </span></span><br><span class="line">		<span class="keyword">return</span> FALSE; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> TRUE; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">VOID  <span class="title">ApcRoutine</span><span class="params">(PVOID ApcContext,<span class="comment">//指向用户提供的完成例程 </span></span></span></span><br><span class="line"><span class="function"><span class="params">			_IO_STATUS_BLOCK* IoStatusBlock,<span class="comment">//完成结果 </span></span></span></span><br><span class="line"><span class="function"><span class="params">			ULONG Reserved)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine = ApcContext; </span><br><span class="line">	DWORD dwErrorCode = RtlNtStatusToDosError(IoStatusBlock-&gt;Status); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用用户提供的完成例程 </span></span><br><span class="line">	lpCompletionRoutine(dwErrorCode, IoStatusBlock-&gt;Information,  (LPOVERLAPPED)IoStatusBlock); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此应用层的用户提供的完成例程实际上是作为 APC 函数进行的,它运行在<code>APC_LEVEL irql</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtReadFile</span><span class="params">(IN HANDLE FileHandle, </span></span></span><br><span class="line"><span class="function"><span class="params">           IN HANDLE Event OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">           IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,<span class="comment">//内置的APC </span></span></span></span><br><span class="line"><span class="function"><span class="params">           IN PVOID ApcContext OPTIONAL,<span class="comment">//应用程序中用户提供的完成例程 </span></span></span></span><br><span class="line"><span class="function"><span class="params">           OUT PIO_STATUS_BLOCK IoStatusBlock, </span></span></span><br><span class="line"><span class="function"><span class="params">           OUT PVOID Buffer, </span></span></span><br><span class="line"><span class="function"><span class="params">           IN ULONG Length, </span></span></span><br><span class="line"><span class="function"><span class="params">           IN PLARGE_INTEGER ByteOffset OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">           IN PULONG Key OPTIONAL)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	… </span><br><span class="line">	Irp = IoAllocateIrp(DeviceObject-&gt;StackSize, FALSE);<span class="comment">//分配一个 irp </span></span><br><span class="line">	Irp-&gt;Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;<span class="comment">//记录 </span></span><br><span class="line">	Irp-&gt;Overlay.AsynchronousParameters.UserApcContext = ApcContext;<span class="comment">//记录 </span></span><br><span class="line">	… </span><br><span class="line">	Status = IoCallDriver(DeviceObject, Irp);<span class="comment">//把这个构造的 irp 发给底层驱动 </span></span><br><span class="line">	… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当底层驱动完成这个 irp 后,会调用<code>IoCompleteRequest</code>完成掉这个 irp,这个<code>IoCompleteRequest</code>实际上内部最终调用<code>IopCompleteRequest</code>来做一些完成时的工作 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">IopCompleteRequest</span><span class="params">(IN PKAPC Apc, </span></span></span><br><span class="line"><span class="function"><span class="params">                   IN PKNORMAL_ROUTINE* NormalRoutine, </span></span></span><br><span class="line"><span class="function"><span class="params">                   IN PVOID* NormalContext, </span></span></span><br><span class="line"><span class="function"><span class="params">                   IN PVOID* SystemArgument1, </span></span></span><br><span class="line"><span class="function"><span class="params">                   IN PVOID* SystemArgument2)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   … </span><br><span class="line">	<span class="keyword">if</span> (Irp-&gt;Overlay.AsynchronousParameters.UserApcRoutine)<span class="comment">//上面传入的APC </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//构造一个APC </span></span><br><span class="line">		KeInitializeApc(&amp;Irp-&gt;Tail.Apc,KeGetCurrentThread(),CurrentApcEnvironment, </span><br><span class="line">				IopFreeIrpKernelApc, </span><br><span class="line">				IopAbortIrpKernelApc, </span><br><span class="line"></span><br><span class="line">		(PKNORMAL_ROUTINE)Irp-&gt;Overlay.AsynchronousParameters.UserApcRoutine, </span><br><span class="line">		Irp-&gt;RequestorMode, </span><br><span class="line">		Irp-&gt;Overlay.AsynchronousParameters.UserApcContext);<span class="comment">//应用层的完成例程 </span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//插入到APC队列 </span></span><br><span class="line">		KeInsertQueueApc(&amp;Irp-&gt;Tail.Apc, Irp-&gt;UserIosb, <span class="literal">NULL</span>, <span class="number">2</span>); </span><br><span class="line">	&#125;<span class="comment">//end if </span></span><br><span class="line">   … </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上<code>ReadFileEx</code>函数的异步 APC 机制是：在这个请求完成后,IO 管理器会将一个 APC 插入队列中,然后在返回用户空间前夕调用那个内置 APC,最终调用应用层用户提供的完成例程。 </p>
<p>明白了 APC 大致原理后,现在详细看一下 APC 的工作原理。<br>APC分两种,用户 APC、内核 APC。<br>前者指在用户空间执行的 APC,后者指在内核空间执行的 APC。 </p>
<h2 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h2><p>先看一下内核为支持 APC 机制提供的一些基础结构设施。 </p>
<h3 id="KAPC-STATE"><a href="#KAPC-STATE" class="headerlink" title="_KAPC_STATE"></a><code>_KAPC_STATE</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Typedef <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">   … </span><br><span class="line">	KAPC_STATE ApcState;<span class="comment">//表示本线程当前使用的 APC 状态(即 apc 队列的状态) </span></span><br><span class="line">	KAPC_STATE SavedApcState;<span class="comment">//表示保存的原 apc 状态,备份用 </span></span><br><span class="line">	KAPC_STATE* ApcStatePointer[<span class="number">2</span>];<span class="comment">//状态数组,包含两个指向 APC 状态的指针 </span></span><br><span class="line">	UCHAR ApcStateIndex;<span class="comment">//0 或 1,指当前的 ApcState 在 ApcStatePointer 数组中的索引位置 </span></span><br><span class="line">	UCHAR ApcQueueable;<span class="comment">//指本线程的 APC 队列是否可插入 apc </span></span><br><span class="line">	ULONG KernelApcDisable;<span class="comment">//禁用标志 </span></span><br><span class="line">	<span class="comment">//专用于挂起操作的 APC(这个函数在线程一得到调度就重新进入等待态,等待挂起计数减到 0) </span></span><br><span class="line">	KAPC SuspendApc; </span><br><span class="line">	…    </span><br><span class="line">&#125;	KTHREAD; </span><br><span class="line"></span><br><span class="line"><span class="comment">//APC 队列的状态描述符 </span></span><br><span class="line">Typedef <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC_STATE</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	LIST_EBTRY ApcListHead[<span class="number">2</span>];<span class="comment">//每个线程有两个 apc 队列 </span></span><br><span class="line">	PKPROCESS Process;<span class="comment">//当前线程所在的进程 </span></span><br><span class="line">	BOOL KernelApcInProgress;<span class="comment">//指示本线程是否当前正在 内核 apc </span></span><br><span class="line">	BOOL KernelApcPending;<span class="comment">//表示内核 apc 队列中是否有 apc </span></span><br><span class="line">	BOOL UserApcPending;<span class="comment">//表示用户 apc 队列中是否 apc </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KAPC-ENVIRONMENT"><a href="#KAPC-ENVIRONMENT" class="headerlink" title="_KAPC_ENVIRONMENT"></a><code>_KAPC_ENVIRONMENT</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Typedef <span class="keyword">enum</span> _KAPC_ENVIRONMENT </span><br><span class="line">&#123; </span><br><span class="line">	OriginalApcEnvironment,<span class="comment">//0,状态数组索引 </span></span><br><span class="line">	AttachedApcEnvironment;<span class="comment">//1,状态数组索引 </span></span><br><span class="line">	CurrentApc Environment;<span class="comment">//2,表示使用当前 apc 状态 </span></span><br><span class="line">	CurrentApc Environment;<span class="comment">//3,表示使用插入 apc 时那时的线程的 apc 状态 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个线程可以挂靠到其他进程的地址空间中,因此,一个线程的状态分两种：常态、挂靠态。<br>常态下状态数组中 0 号元素指向<code>ApcState</code>(即当前 apc 状态),1 号元素指向<code>SavedApcState</code>(非当前 apc 状态);<br>挂靠态下,两个元素的指向刚好相反。但无论如何<code>KTHREAD</code>结构中的<code>ApcStateIndex</code>总是指当前状态的位置,<code>ApcState</code> 则总是表示线程当前使用的 apc 状态。</p>
<p>于是有<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PsGetCurrentProcess IoGetCurrentProces PEPROCESS IoGetCurrentProces() </span></span><br><span class="line">&#123; </span><br><span class="line">	Return PsGetCurrentThread()-&gt;Tcb.ApcState.Process;//ApcState 中的进程字段总是表示当前进程 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不管当前线程是处于常态还是挂靠态下,它都有两个 apc 队列,一个内核,一个用户。<br>把 apc 插入对应的队列后就可以在恰当的时机得到执行。</p>
<p>注意：每当一个线程挂靠到其他进程时,挂靠初期,两个 apc 队列都会变空。<br>下面看下每个 apc 本身的结构 </p>
<h3 id="KAPC"><a href="#KAPC" class="headerlink" title="_KAPC"></a><code>_KAPC</code></h3><p>若这个 apc 是内核 apc,那么<code>NormalRoutine</code>表示用户自己提供的内核 apc 函数,<code>NormalContext</code>则是该 apc 函数的<code>context*</code>,<code>SystemArgument1</code> 与<code>SystemArgument2</code> 表示插入队列时的附加参数 </p>
<p>若这个 apc 是用户 apc,那么<code>NormalRoutine</code>表示该 apc 的用户空间总 apc 函数,<code>NormalContext</code>才是真正用户自己提供的用户空间 apc 函数,<code>SystemArgument1</code>则表示该真正 apc 的 <code>context*</code>。(一切错位了) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  UCHAR Type;<span class="comment">//结构体的类型 </span></span><br><span class="line">  UCHAR Size;<span class="comment">//结构体的大小 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span> *<span class="title">Thread</span>;</span><span class="comment">//目标线程 </span></span><br><span class="line">  LIST_ENTRY ApcListEntry;<span class="comment">//用来挂入目标apc队列 </span></span><br><span class="line">  PKKERNEL_ROUTINE KernelRoutine;<span class="comment">//该apc的内核总入口 </span></span><br><span class="line">  PKRUNDOWN_ROUTINE RundownRoutine; </span><br><span class="line">  PKNORMAL_ROUTINE NormalRoutine;<span class="comment">//该apc的用户空间总入口或者用户真正的内核apc函数 </span></span><br><span class="line">  PVOID NormalContext;<span class="comment">//真正用户提供的用户空间apc函数或者用户真正的内核apc函数的context* </span></span><br><span class="line">  PVOID SystemArgument1;<span class="comment">//挂入时的附加参数1。真正用户apc的context* </span></span><br><span class="line">  PVOID SystemArgument2;<span class="comment">//挂入时的附加参数2 </span></span><br><span class="line">  CCHAR ApcStateIndex;<span class="comment">//指要挂入目标线程的哪个状态时的apc队列 </span></span><br><span class="line">  KPROCESSOR_MODE ApcMode;<span class="comment">//指要挂入用户apc队列还是内核apc队列 </span></span><br><span class="line">  BOOLEAN Inserted;<span class="comment">//表示本apc是否已挂入队列 </span></span><br><span class="line">&#125; KAPC, *PKAPC;</span><br></pre></td></tr></table></figure>
<h2 id="Api流程-1"><a href="#Api流程-1" class="headerlink" title="Api流程"></a>Api流程</h2><h3 id="QueueUserAPC"><a href="#QueueUserAPC" class="headerlink" title="QueueUserAPC"></a>QueueUserAPC</h3><p>下面这个 Win32 API 可以用来手动插入一个 apc 到指定线程的用户 apc 队列中 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DWORD  </span><br><span class="line">QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData) </span><br><span class="line">&#123; </span><br><span class="line">  NTSTATUS Status; </span><br><span class="line">  <span class="comment">//调用对应的系统服务 </span></span><br><span class="line">  Status = NtQueueApcThread(hThread,<span class="comment">//目标线程 </span></span><br><span class="line">					IntCallUserApc,<span class="comment">//用户空间中的总apc入口 </span></span><br><span class="line">					pfnAPC,<span class="comment">//用户自己真正提供的apc函数 (PVOID)dwData,//SysArg1=context* </span></span><br><span class="line">					<span class="literal">NULL</span>);<span class="comment">//SysArg2=NULL </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">		SetLastErrorByStatus(Status); </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NtQueueApcThread"><a href="#NtQueueApcThread" class="headerlink" title="NtQueueApcThread"></a>NtQueueApcThread</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtQueueApcThread</span><span class="params">(IN HANDLE ThreadHandle,<span class="comment">//目标线程 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 IN PKNORMAL_ROUTINE ApcRoutine,<span class="comment">//用户空间中的总apc </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 IN PVOID NormalContext,<span class="comment">//用户自己真正的apc函数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 IN PVOID SystemArgument1,<span class="comment">//用户自己apc的context* </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 IN PVOID SystemArgument2)</span><span class="comment">//其它 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PKAPC Apc; </span><br><span class="line">	PETHREAD Thread; </span><br><span class="line">	NTSTATUS Status = STATUS_SUCCESS; </span><br><span class="line">	Status = ObReferenceObjectByHandle(ThreadHandle,THREAD_SET_CONTEXT,PsThreadType, </span><br><span class="line">	                                   ExGetPreviousMode(), (PVOID)&amp;Thread,<span class="literal">NULL</span>); </span><br><span class="line">	<span class="comment">//分配一个apc结构,这个结构最终在PspQueueApcSpecialApc中释放 </span></span><br><span class="line">	Apc = ExAllocatePoolWithTag(NonPagedPool |POOL_QUOTA_FAIL_INSTEAD_OF_RAISE, </span><br><span class="line">	                            <span class="keyword">sizeof</span>(KAPC),TAG_PS_APC); </span><br><span class="line">	<span class="comment">//构造一个apc </span></span><br><span class="line">	KeInitializeApc(Apc, </span><br><span class="line">	                &amp;Thread-&gt;Tcb,<span class="comment">//目标线程 </span></span><br><span class="line">	                OriginalApcEnvironment,<span class="comment">//目标apc状态(此服务固定为OriginalApcEnvironment) </span></span><br><span class="line">	                PspQueueApcSpecialApc,<span class="comment">//内核apc总入口 </span></span><br><span class="line">	                <span class="literal">NULL</span>,<span class="comment">//Rundown Rounine=NULL </span></span><br><span class="line">	                ApcRoutine,<span class="comment">//用户空间的总apc </span></span><br><span class="line">	                UserMode,<span class="comment">//此系统服务固定插入到用户apc队列 </span></span><br><span class="line">	                NormalContext);<span class="comment">//用户自己真正的apc函数 </span></span><br><span class="line">	<span class="comment">//插入到目标线程的用户apc队列 </span></span><br><span class="line">	KeInsertQueueApc(Apc, </span><br><span class="line">	                 SystemArgument1,<span class="comment">//插入时的附加参数1,此处为用户自己apc的context* </span></span><br><span class="line">	                 SystemArgument2, <span class="comment">//插入时的附加参数2 </span></span><br><span class="line">	                 IO_NO_INCREMENT)<span class="comment">//表示不予调整目标线程的调度优先级 </span></span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KeInitializeApc"><a href="#KeInitializeApc" class="headerlink" title="KeInitializeApc"></a>KeInitializeApc</h4><p>这个函数用来构造一个要插入指定目标队列的 apc 对象 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KeInitializeApc</span><span class="params">(IN PKAPC Apc, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN PKTHREAD Thread,<span class="comment">//目标线程 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN KAPC_ENVIRONMENT TargetEnvironment,<span class="comment">//目标线程的目标apc状态 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN PKKERNEL_ROUTINE KernelRoutine,<span class="comment">//内核apc总入口 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN PKNORMAL_ROUTINE NormalRoutine,<span class="comment">//用户空间的总apc </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN KPROCESSOR_MODE Mode,<span class="comment">//要插入用户apc队列还是内核apc队列 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN PVOID Context)</span> <span class="comment">//用户自己真正的apc函数 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	Apc-&gt;Type = ApcObject; </span><br><span class="line">	Apc-&gt;Size = <span class="keyword">sizeof</span>(KAPC); </span><br><span class="line">	<span class="keyword">if</span> (TargetEnvironment == CurrentApcEnvironment)<span class="comment">//CurrentApcEnvironment表示使用当前apc状态 </span></span><br><span class="line">		Apc-&gt;ApcStateIndex = Thread-&gt;ApcStateIndex; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		Apc-&gt;ApcStateIndex = TargetEnvironment; </span><br><span class="line">	Apc-&gt;Thread = Thread; </span><br><span class="line">	Apc-&gt;KernelRoutine = KernelRoutine; </span><br><span class="line">	Apc-&gt;RundownRoutine = RundownRoutine; </span><br><span class="line">	Apc-&gt;NormalRoutine = NormalRoutine; </span><br><span class="line">	<span class="keyword">if</span> (NormalRoutine)<span class="comment">//if 提供了用户空间总apc入口 </span></span><br><span class="line">	&#123; </span><br><span class="line">		Apc-&gt;ApcMode = Mode; </span><br><span class="line">		Apc-&gt;NormalContext = Context; </span><br><span class="line">	&#125; </span><br><span class="line">	Else<span class="comment">//若没提供,肯定是内核模式 </span></span><br><span class="line">	&#123; </span><br><span class="line">		Apc-&gt;ApcMode = KernelMode; </span><br><span class="line">		Apc-&gt;NormalContext = <span class="literal">NULL</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	Apc-&gt;Inserted = FALSE;<span class="comment">//表示初始构造后,尚未挂入apc队列 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KeInsertQueueApc"><a href="#KeInsertQueueApc" class="headerlink" title="KeInsertQueueApc"></a>KeInsertQueueApc</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">KeInsertQueueApc</span><span class="params">(IN PKAPC Apc,IN PVOID SystemArgument1,IN PVOID SystemArgument2, </span></span></span><br><span class="line"><span class="function"><span class="params">                 IN KPRIORITY PriorityBoost)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PKTHREAD Thread = Apc-&gt;Thread; </span><br><span class="line">	KLOCK_QUEUE_HANDLE ApcLock; </span><br><span class="line">	BOOLEAN State = TRUE; </span><br><span class="line">	KiAcquireApcLock(Thread, &amp;ApcLock);<span class="comment">//插入过程需要独占队列 </span></span><br><span class="line">	<span class="keyword">if</span> (!(Thread-&gt;ApcQueueable) || (Apc-&gt;Inserted))<span class="comment">//检查队列是否可以插入apc </span></span><br><span class="line">		State = FALSE; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		Apc-&gt;SystemArgument1 = SystemArgument1;<span class="comment">//记录该apc的附加插入时的参数 </span></span><br><span class="line">		Apc-&gt;SystemArgument2 = SystemArgument2; <span class="comment">//记录该apc的附加插入时的参数 </span></span><br><span class="line">		Apc-&gt;Inserted = TRUE;<span class="comment">//标记为已插入队列 </span></span><br><span class="line">		   <span class="comment">//插入目标线程的目标apc队列(如果目标线程正处于睡眠状态,可能会唤醒它) </span></span><br><span class="line">		KiInsertQueueApc(Apc, PriorityBoost);  </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	KiReleaseApcLockFromDpcLevel(&amp;ApcLock); </span><br><span class="line">	KiExitDispatcher(ApcLock.OldIrql);<span class="comment">//可能引发一次线程切换,以立即切换到目标线程执行apc </span></span><br><span class="line">	<span class="keyword">return</span> State; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KiInsertQueueApc"><a href="#KiInsertQueueApc" class="headerlink" title="KiInsertQueueApc"></a>KiInsertQueueApc</h4><p>这个函数既可以给当前线程发送 apc,也可以给目标线程发送 apc。<br>若给当前线程发送内核 apc 时, 会立即请求发出一个 apc 中断。若给其他线程发送 apc 时,可能会唤醒目标线程。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">KiInsertQueueApc</span><span class="params">(IN PKAPC Apc,IN KPRIORITY PriorityBoost)</span><span class="comment">//唤醒目标线程后的优先级增量 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PKTHREAD Thread = Apc-&gt;Thread; </span><br><span class="line">	BOOLEAN RequestInterrupt = FALSE; </span><br><span class="line">	<span class="keyword">if</span> (Apc-&gt;ApcStateIndex == InsertApcEnvironment) <span class="comment">//if要动态插入到当前的apc状态队列 </span></span><br><span class="line">		Apc-&gt;ApcStateIndex = Thread-&gt;ApcStateIndex;  </span><br><span class="line">	</span><br><span class="line">	ApcState = Thread-&gt;ApcStatePointer[(UCHAR)Apc-&gt;ApcStateIndex];<span class="comment">//目标状态 </span></span><br><span class="line">	ApcMode = Apc-&gt;ApcMode; </span><br><span class="line">	<span class="comment">//先插入apc到指定位置 </span></span><br><span class="line">	<span class="comment">/* 插入位置的确定：分三种情形 </span></span><br><span class="line"><span class="comment">	* 1) Kernel APC with Normal Routine or User APC : Put it at the end of the List </span></span><br><span class="line"><span class="comment">	* 2) User APC which is PsExitSpecialApc : Put it at the front of the List </span></span><br><span class="line"><span class="comment">	* 3) Kernel APC without Normal Routine : Put it at the end of the No-Normal Routine Kernel APC list </span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (Apc-&gt;NormalRoutine)<span class="comment">//有NormalRoutine的APC都插入尾部(用户模式发来的线程终止APC除外) </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> ((ApcMode == UserMode) &amp;&amp; (Apc-&gt;KernelRoutine == PsExitSpecialApc)) </span><br><span class="line">		&#123; </span><br><span class="line">			Thread-&gt;ApcState.UserApcPending = TRUE; </span><br><span class="line">			InsertHeadList(&amp;ApcState-&gt;ApcListHead[ApcMode],&amp;Apc-&gt;ApcListEntry); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			InsertTailList(&amp;ApcState-&gt;ApcListHead[ApcMode],&amp;Apc-&gt;ApcListEntry); </span><br><span class="line">	&#125; </span><br><span class="line">	Else <span class="comment">//无NormalRoutine的特殊类APC(内核APC),少见 </span></span><br><span class="line">	&#123; </span><br><span class="line">		ListHead = &amp;ApcState-&gt;ApcListHead[ApcMode]; </span><br><span class="line">		NextEntry = ListHead-&gt;Blink; </span><br><span class="line">		<span class="keyword">while</span> (NextEntry != ListHead) </span><br><span class="line">		&#123; </span><br><span class="line">			QueuedApc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry); </span><br><span class="line">			<span class="keyword">if</span> (!QueuedApc-&gt;NormalRoutine) <span class="keyword">break</span>; </span><br><span class="line">			</span><br><span class="line">			NextEntry = NextEntry-&gt;Blink; </span><br><span class="line">		&#125; </span><br><span class="line">			InsertHeadList(NextEntry, &amp;Apc-&gt;ApcListEntry);<span class="comment">//插在这儿 </span></span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入到相应的位置后,下面检查Apc状态是否匹配 </span></span><br><span class="line">	<span class="keyword">if</span> (Thread-&gt;ApcStateIndex == Apc-&gt;ApcStateIndex)<span class="comment">//if 插到了当前apc状态的apc队列中 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (Thread == KeGetCurrentThread())<span class="comment">//if就是给当前线程发送的apc </span></span><br><span class="line">		&#123; </span><br><span class="line">			ASSERT(Thread-&gt;State == Running);<span class="comment">//当前线程肯定没有睡眠,这不废话吗？ </span></span><br><span class="line">			<span class="keyword">if</span> (ApcMode == KernelMode) </span><br><span class="line">			&#123; </span><br><span class="line">				Thread-&gt;ApcState.KernelApcPending = TRUE; </span><br><span class="line">				<span class="keyword">if</span> (!Thread-&gt;SpecialApcDisable)<span class="comment">//发出一个apc中断,待下次降低irql时将执行apc </span></span><br><span class="line">					HalRequestSoftwareInterrupt(APC_LEVEL); <span class="comment">//关键 </span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">		Else <span class="comment">//给其他线程发送的内核apc </span></span><br><span class="line">		&#123; </span><br><span class="line">			KiAcquireDispatcherLock(); </span><br><span class="line">			<span class="keyword">if</span> (ApcMode == KernelMode) </span><br><span class="line">			&#123; </span><br><span class="line">				Thread-&gt;ApcState.KernelApcPending = TRUE; </span><br><span class="line">				<span class="keyword">if</span> (Thread-&gt;State == Running) </span><br><span class="line">					RequestInterrupt = TRUE;<span class="comment">//需要给它发出一个apc中断 </span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> ((Thread-&gt;State == Waiting) &amp;&amp; (Thread-&gt;WaitIrql == PASSIVE_LEVEL) &amp;&amp; </span><br><span class="line">				     !(Thread-&gt;SpecialApcDisable) &amp;&amp; (!(Apc-&gt;NormalRoutine) || </span><br><span class="line">				     (!(Thread-&gt;KernelApcDisable) &amp;&amp; </span><br><span class="line">				     !(Thread-&gt;ApcState.KernelApcInProgress)))) </span><br><span class="line">				&#123; </span><br><span class="line">					Status = STATUS_KERNEL_APC; </span><br><span class="line">					KiUnwaitThread(Thread, Status, PriorityBoost);<span class="comment">//临时唤醒目标线程执行apc </span></span><br><span class="line">				&#125; </span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (Thread-&gt;State == GateWait) … </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((Thread-&gt;State == Waiting) &amp;&amp; (Thread-&gt;WaitMode == UserMode) &amp;&amp; </span><br><span class="line">			 ((Thread-&gt;Alertable) || (Thread-&gt;ApcState.UserApcPending))) </span><br><span class="line">			&#123; </span><br><span class="line">				Thread-&gt;ApcState.UserApcPending = TRUE; </span><br><span class="line">				Status = STATUS_USER_APC; </span><br><span class="line"></span><br><span class="line">				KiUnwaitThread(Thread, Status, PriorityBoost);<span class="comment">//强制唤醒目标线程 </span></span><br><span class="line">			&#125; </span><br><span class="line">			KiReleaseDispatcherLockFromDpcLevel(); </span><br><span class="line">			KiRequestApcInterrupt(RequestInterrupt, Thread-&gt;NextProcessor); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="用户态APC的执行时机"><a href="#用户态APC的执行时机" class="headerlink" title="用户态APC的执行时机"></a>用户态APC的执行时机</h2><p>回顾一下从内核返回用户时的流程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">KiSystemService()<span class="comment">//int 2e 的 isr,内核服务函数总入口,注意这个函数可以嵌套、递归！！！ </span></span><br><span class="line">&#123; </span><br><span class="line">	 SaveTrap();<span class="comment">//保存 trap 现场 Sti //开中断 </span></span><br><span class="line">	</span><br><span class="line">	---------------上面保存完寄存器等现场后,开始查 SST 表调用系统服务------------------ </span><br><span class="line">	FindTableCall(); </span><br><span class="line">	---------------------------------调用完系统服务函数后------------------------------ </span><br><span class="line">	</span><br><span class="line">	Move esp,kthread.TrapFrame; <span class="comment">//将栈顶回到 trap 帧结构体处 Cli //关中断 </span></span><br><span class="line">	If(上次模式==UserMode) </span><br><span class="line">	&#123; </span><br><span class="line">		Call KiDeliverApc <span class="comment">//遍历执行本线程的内核 APC 和用户 APC 队列中的所有 APC 函数 清理 Trap 帧,恢复寄存器现场 </span></span><br><span class="line">		Iret  <span class="comment">//返回用户空间 </span></span><br><span class="line">	&#125; </span><br><span class="line">	Else </span><br><span class="line">	&#123; </span><br><span class="line">		返回到原 call 处后面的那条指令处 </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不光是从系统调用返回用户空间要扫描执行 apc,从异常和中断返回用户空间也同样需要扫描执行。<br>现在我们只看从系统调用返回时 apc 的执行过程。 </p>
<p>上面是伪代码,实际的从 Cli 后面的代码,是下面这样的。 </p>
<h3 id="Cli后面处理"><a href="#Cli后面处理" class="headerlink" title="Cli后面处理"></a>Cli后面处理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Test dword ptr[ebp+KTRAP_FRAME_EFLAGS], EFLAGS_V86_MASK <span class="comment">//检查 eflags 是否标志运行在 V86 模式 </span></span><br><span class="line">Jnz <span class="number">1</span> <span class="comment">//若运行在 V86 模式,那么上次模式肯定是从用户空间进入内核的,跳过下面的检查 </span></span><br><span class="line"></span><br><span class="line">Test byte ptr[ebp+KTRAP_FRAME_CS],<span class="number">1</span> </span><br><span class="line">Je <span class="number">2</span> <span class="comment">//若上次模式不是用户模式,跳过下面的流程,不予扫描 apc </span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>: </span><br><span class="line">Mov ebx,PCR[KPCR_CURRENT_THREAD] <span class="comment">//ebx=KTHREAD*(当前线程对象的地址)</span></span><br><span class="line">Mov byte ptr[ebx+KTHREAD_ALERTED],<span class="number">0</span> <span class="comment">//kthread.Alert 修改为不可提醒 </span></span><br><span class="line">Cmp  byte  ptr[ebx+KTHREAD_PENDING_USER_APC],<span class="number">0</span>   </span><br><span class="line">Je <span class="number">2</span> <span class="comment">//如果当前线程的用户 apc 队列为空,直接跳过 </span></span><br><span class="line">Mov ebx,ebp <span class="comment">//ebx=TrapFrame 帧的地址 </span></span><br><span class="line">Mov [ebx,KTRAP_FRAME_EAX],eax <span class="comment">//保存 </span></span><br><span class="line"></span><br><span class="line">Mov ecx,APC_LEVEL </span><br><span class="line">Call KfRaiseIrql <span class="comment">//call KfRaiseIrql(APC_LEVEL) </span></span><br><span class="line">Push eax <span class="comment">//保存提升 irql 之前的 irql </span></span><br><span class="line"></span><br><span class="line">Sti </span><br><span class="line">Push ebx <span class="comment">//TrapFrame 帧的地址 Push NULL </span></span><br><span class="line">Push UserMode </span><br><span class="line">Call KiDeliverApc   <span class="comment">//call KiDeliverApc(UserMode, NULL, TrapFrame*)  </span></span><br><span class="line">Pop ecx <span class="comment">// ecx=之前的 irql </span></span><br><span class="line"></span><br><span class="line">Call KfLowerIrql <span class="comment">//call KfLowerIrql(之前的 irql) </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Move eax, [ebx,KTRAP_FRAME_EAX] <span class="comment">//恢复 eax </span></span><br><span class="line">Cli </span><br><span class="line">Jmp <span class="number">1</span> <span class="comment">//再次跳回 1 处循环,扫描 apc 队列 </span></span><br><span class="line">…</span><br></pre></td></tr></table></figure>
<h3 id="KiDeliverApc"><a href="#KiDeliverApc" class="headerlink" title="KiDeliverApc"></a>KiDeliverApc</h3><p>关键的函数是<code>KiDeliverApc</code>,这个函数用来真正扫描 apc 队列执行所有 apc </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KiDeliverApc</span><span class="params">(IN KPROCESSOR_MODE DeliveryMode,<span class="comment">//指要执行哪个apc队列中的函数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">             IN PKEXCEPTION_FRAME ExceptionFrame,<span class="comment">//传入的是NULL </span></span></span></span><br><span class="line"><span class="function"><span class="params">             IN PKTRAP_FRAME TrapFrame)</span><span class="comment">//即将返回用户空间前的Trap现场帧 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PKTHREAD Thread = KeGetCurrentThread(); </span><br><span class="line">	PKPROCESS Process = Thread-&gt;ApcState.Process; </span><br><span class="line">	OldTrapFrame = Thread-&gt;TrapFrame; </span><br><span class="line">	Thread-&gt;TrapFrame = TrapFrame; </span><br><span class="line">	Thread-&gt;ApcState.KernelApcPending = FALSE;  </span><br><span class="line">	<span class="keyword">if</span> (Thread-&gt;SpecialApcDisable) <span class="keyword">goto</span> Quickie; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//先固定执行掉内核apc队列中的所有apc函数 </span></span><br><span class="line">	<span class="keyword">while</span> (!IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[KernelMode])) </span><br><span class="line">	&#123; </span><br><span class="line">		KiAcquireApcLockAtApcLevel(Thread, &amp;ApcLock);<span class="comment">//锁定apc队列 </span></span><br><span class="line">		ApcListEntry = Thread-&gt;ApcState.ApcListHead[KernelMode].Flink;<span class="comment">//队列头部中的apc </span></span><br><span class="line">		Apc = CONTAINING_RECORD(ApcListEntry, KAPC, ApcListEntry); </span><br><span class="line">		KernelRoutine = Apc-&gt;KernelRoutine;<span class="comment">//内核总apc函数 </span></span><br><span class="line">		NormalRoutine = Apc-&gt;NormalRoutine;<span class="comment">//用户自己真正的内核apc函数 </span></span><br><span class="line">		NormalContext = Apc-&gt;NormalContext;<span class="comment">//真正内核apc函数的context* </span></span><br><span class="line">		SystemArgument1 = Apc-&gt;SystemArgument1; </span><br><span class="line">		SystemArgument2 = Apc-&gt;SystemArgument2; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (NormalRoutine==<span class="literal">NULL</span>) <span class="comment">//称为Special Apc,少见 </span></span><br><span class="line">		&#123; </span><br><span class="line">			RemoveEntryList(ApcListEntry);<span class="comment">//关键,移除队列 </span></span><br><span class="line">			Apc-&gt;Inserted = FALSE; </span><br><span class="line"></span><br><span class="line">			KiReleaseApcLock(&amp;ApcLock); </span><br><span class="line">			<span class="comment">//执行内核中的总apc函数 </span></span><br><span class="line">			KernelRoutine(Apc,&amp;NormalRoutine,&amp;NormalContext, </span><br><span class="line">			              &amp;SystemArgument1,&amp;SystemArgument2); </span><br><span class="line">		&#125; </span><br><span class="line">		Else <span class="comment">//典型,一般程序员都会提供一个自己的内核apc函数 </span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> ((Thread-&gt;ApcState.KernelApcInProgress) || (Thread-&gt;KernelApcDisable)) </span><br><span class="line">			&#123; </span><br><span class="line">			    KiReleaseApcLock(&amp;ApcLock); </span><br><span class="line">			    <span class="keyword">goto</span> Quickie; </span><br><span class="line">			&#125; </span><br><span class="line">			RemoveEntryList(ApcListEntry); <span class="comment">//关键,移除队列 </span></span><br><span class="line">			Apc-&gt;Inserted = FALSE; </span><br><span class="line">			KiReleaseApcLock(&amp;ApcLock); </span><br><span class="line"></span><br><span class="line">			<span class="comment">//执行内核中的总apc函数 </span></span><br><span class="line">			KernelRoutine(Apc, </span><br><span class="line">			              &amp;NormalRoutine,<span class="comment">//注意,内核中的总apc可能会在内部修改NormalRoutine </span></span><br><span class="line">			              &amp;NormalContext, </span><br><span class="line">			              &amp;SystemArgument1, </span><br><span class="line">			              &amp;SystemArgument2); </span><br><span class="line">			<span class="keyword">if</span> (NormalRoutine)<span class="comment">//如果内核总apc没有修改NormalRoutine成NULL </span></span><br><span class="line">			&#123; </span><br><span class="line">			    Thread-&gt;ApcState.KernelApcInProgress = TRUE;<span class="comment">//标记当前线程正在执行内核apc </span></span><br><span class="line">			    KeLowerIrql(PASSIVE_LEVEL); </span><br><span class="line">			    <span class="comment">//直接调用用户提供的真正内核apc函数 </span></span><br><span class="line">			    NormalRoutine(NormalContext, SystemArgument1, SystemArgument2); </span><br><span class="line">			    KeRaiseIrql(APC_LEVEL, &amp;ApcLock.OldIrql); </span><br><span class="line">			&#125; </span><br><span class="line">			Thread-&gt;ApcState.KernelApcInProgress = FALSE; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//上面的循环,执行掉所有内核apc函数后,下面开始执行用户apc队列中的第一个apc </span></span><br><span class="line">	<span class="keyword">if</span> ((DeliveryMode == UserMode) &amp;&amp; </span><br><span class="line">		!(IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[UserMode])) &amp;&amp; </span><br><span class="line">		(Thread-&gt;ApcState.UserApcPending)) </span><br><span class="line">	&#123; </span><br><span class="line">		KiAcquireApcLockAtApcLevel(Thread, &amp;ApcLock);<span class="comment">//锁定apc队列 </span></span><br><span class="line">		Thread-&gt;ApcState.UserApcPending = FALSE; </span><br><span class="line"></span><br><span class="line">		ApcListEntry = Thread-&gt;ApcState.ApcListHead[UserMode].Flink;<span class="comment">//队列头 </span></span><br><span class="line">		Apc = CONTAINING_RECORD(ApcListEntry, KAPC, ApcListEntry); </span><br><span class="line">		KernelRoutine = Apc-&gt;KernelRoutine; <span class="comment">//内核总apc函数 </span></span><br><span class="line">		NormalRoutine = Apc-&gt;NormalRoutine; <span class="comment">//用户空间的总apc函数 </span></span><br><span class="line"></span><br><span class="line">		NormalContext = Apc-&gt;NormalContext;<span class="comment">//用户真正的用户空间apc函数 </span></span><br><span class="line">		SystemArgument1 = Apc-&gt;SystemArgument1;<span class="comment">//真正apc的context* </span></span><br><span class="line">		SystemArgument2 = Apc-&gt;SystemArgument2; </span><br><span class="line">		RemoveEntryList(ApcListEntry);<span class="comment">//关键,移除队列 </span></span><br><span class="line">		</span><br><span class="line">		Apc-&gt;Inserted = FALSE; </span><br><span class="line">		KiReleaseApcLock(&amp;ApcLock); </span><br><span class="line"></span><br><span class="line">		KernelRoutine(Apc, </span><br><span class="line">		          &amp;NormalRoutine,<span class="comment">// 注意,内核中的总apc可能会在内部修改NormalRoutine </span></span><br><span class="line">		          &amp;NormalContext, </span><br><span class="line">		          &amp;SystemArgument1, </span><br><span class="line">		          &amp;SystemArgument2); </span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!NormalRoutine) </span><br><span class="line">			KeTestAlertThread(UserMode); </span><br><span class="line">		Else <span class="comment">//典型,准备提前回到用户空间调用用户空间的总apc函数 </span></span><br><span class="line">		&#123; </span><br><span class="line">			KiInitializeUserApc(ExceptionFrame,<span class="comment">//NULL </span></span><br><span class="line">		                    TrapFrame,<span class="comment">//Trap帧的地址 </span></span><br><span class="line">		                    NormalRoutine, <span class="comment">//用户空间的总apc函数 </span></span><br><span class="line">		                    NormalContext, <span class="comment">//用户真正的用户空间apc函数 </span></span><br><span class="line">		                    SystemArgument1, <span class="comment">//真正apc的context* </span></span><br><span class="line">		                    SystemArgument2); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Quickie: </span><br><span class="line">	Thread-&gt;TrapFrame = OldTrapFrame; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上这个函数既可以用来投递处理内核 apc 函数,也可以用来投递处理用户 apc 队列中的函数。<br>特别的当要调用这个函数投递处理用户 apc 队列中的函数时,它每次只处理一个用户 apc。 由于正式回到用户空间前,会循环调用这个函数。</p>
<p>因此实际的处理顺序是:<br><code>扫描执行内核 apc 队列所有 apc</code>-&gt;<code>执行用户 apc 队列中一个 apc</code>-&gt;<code>再次扫描执行内核 apc 队列所有 apc</code>-&gt;<code>执行用户 apc 队列中下一个 apc</code>-&gt;<code>再次扫描执行内核 apc 队列所有 apc</code>-&gt;<code>再次执行用户 apc 队列中下一个 apc</code></p>
<p>如此循环直到将用户 apc 队列中的所有 apc 都执行掉。 </p>
<p>执行用户 apc 队列中的 apc 函数与内核 apc 不同,因为用户 apc 队列中的 apc 函数自然是要在用户空间中执行的<br>而<code>KiDeliverApc</code>这个函数本身位于内核空间,因此不能直接调用用户 apc 函数,需要<code>提前</code> 回到用户空间去执行队列中的每个用户 apc,然后重新返回内核,再次扫描整个内核 apc 队列,再执行用 户 apc 队列中遗留的下一个用户 apc。<br>如此循环直至执行完所有用户 apc 后,才<code>正式</code>返回用户空间。 </p>
<h3 id="KiInitializeUserApc"><a href="#KiInitializeUserApc" class="headerlink" title="KiInitializeUserApc"></a>KiInitializeUserApc</h3><p>下面的函数就是用来为执行用户 apc 做准备的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KiInitializeUserApc</span><span class="params">(IN PKEXCEPTION_FRAME ExceptionFrame, </span></span></span><br><span class="line"><span class="function"><span class="params">                    IN PKTRAP_FRAME TrapFrame,<span class="comment">//原真正的断点现场帧 </span></span></span></span><br><span class="line"><span class="function"><span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">                    IN PKNORMAL_ROUTINE NormalRoutine, </span></span></span><br><span class="line"><span class="function"><span class="params">                    IN PVOID NormalContext, </span></span></span><br><span class="line"><span class="function"><span class="params">                    IN PVOID SystemArgument1, </span></span></span><br><span class="line"><span class="function"><span class="params">                    IN PVOID SystemArgument2)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	Context.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS; </span><br><span class="line">	<span class="comment">//将原真正的Trap帧打包保存在一个Context结构中 </span></span><br><span class="line">	KeTrapFrameToContext(TrapFrame, ExceptionFrame, &amp;Context); </span><br><span class="line"></span><br><span class="line">	_SEH2_TRY </span><br><span class="line">	&#123; </span><br><span class="line">		AlignedEsp = Context.Esp &amp; ~<span class="number">3</span>;<span class="comment">//对齐4B </span></span><br><span class="line">		<span class="comment">//为用户空间中KiUserApcDisatcher函数的参数腾出空间(4个参数+ CONTEXT + 8B的seh节点) </span></span><br><span class="line">		ContextLength = CONTEXT_ALIGNED_SIZE + (<span class="number">4</span> * <span class="keyword">sizeof</span>(ULONG_PTR)); </span><br><span class="line">		Stack = ((AlignedEsp - <span class="number">8</span>) &amp; ~<span class="number">3</span>) - ContextLength;<span class="comment">//8表示seh节点的大小 </span></span><br><span class="line">		<span class="comment">//模拟压入KiUserApcDispatcher函数的4个参数 </span></span><br><span class="line">		*(PULONG_PTR)(Stack + <span class="number">0</span> * <span class="keyword">sizeof</span>(ULONG_PTR)) = (ULONG_PTR)NormalRoutine; </span><br><span class="line">		*(PULONG_PTR)(Stack + <span class="number">1</span> * <span class="keyword">sizeof</span>(ULONG_PTR)) = (ULONG_PTR)NormalContext; </span><br><span class="line">		*(PULONG_PTR)(Stack + <span class="number">2</span> * <span class="keyword">sizeof</span>(ULONG_PTR)) = (ULONG_PTR)SystemArgument1; </span><br><span class="line">		*(PULONG_PTR)(Stack + <span class="number">3</span> * <span class="keyword">sizeof</span>(ULONG_PTR)) = (ULONG_PTR)SystemArgument2; </span><br><span class="line">		<span class="comment">//将原真正trap帧保存在用户栈的一个CONTEXT结构中,方便以后还原 </span></span><br><span class="line">		RtlCopyMemory( (Stack + (<span class="number">4</span> * <span class="keyword">sizeof</span>(ULONG_PTR))),&amp;Context,<span class="keyword">sizeof</span>(CONTEXT)); </span><br><span class="line"></span><br><span class="line">		<span class="comment">//强制修改当前Trap帧中的返回地址与用户栈地址(偏离原来的返回路线) </span></span><br><span class="line">		TrapFrame-&gt;Eip = (ULONG)KeUserApcDispatcher;<span class="comment">//关键,新的返回断点地址 </span></span><br><span class="line">		TrapFrame-&gt;HardwareEsp = Stack;<span class="comment">//关键,新的用户栈顶 </span></span><br><span class="line">		TrapFrame-&gt;SegCs = Ke386SanitizeSeg(KGDT_R3_CODE, UserMode); </span><br><span class="line">		TrapFrame-&gt;HardwareSegSs = Ke386SanitizeSeg(KGDT_R3_DATA, UserMode); </span><br><span class="line">		TrapFrame-&gt;SegDs = Ke386SanitizeSeg(KGDT_R3_DATA, UserMode); </span><br><span class="line">		TrapFrame-&gt;SegEs = Ke386SanitizeSeg(KGDT_R3_DATA, UserMode); </span><br><span class="line">		TrapFrame-&gt;SegFs = Ke386SanitizeSeg(KGDT_R3_TEB, UserMode); </span><br><span class="line">		TrapFrame-&gt;SegGs = <span class="number">0</span>; </span><br><span class="line">		TrapFrame-&gt;ErrCode = <span class="number">0</span>; </span><br><span class="line">		TrapFrame-&gt;EFlags = Ke386SanitizeFlags(Context.EFlags, UserMode); </span><br><span class="line">		<span class="keyword">if</span> (KeGetCurrentThread()-&gt;Iopl) TrapFrame-&gt;EFlags |= EFLAGS_IOPL; </span><br><span class="line">	&#125; </span><br><span class="line">	_SEH2_EXCEPT((RtlCopyMemory(&amp;SehExceptRecord, _SEH2_GetExceptionInformation()-&gt;ExceptionRecord, <span class="keyword">sizeof</span>(EXCEPTION_RECORD)),    EXCEPTION_EXECUTE_HANDLER)) </span><br><span class="line">	&#123; </span><br><span class="line">		SehExceptRecord.ExceptionAddress = (PVOID)TrapFrame-&gt;Eip; </span><br><span class="line">		KiDispatchException(&amp;SehExceptRecord,ExceptionFrame,TrapFrame,UserMode,TRUE); </span><br><span class="line">	&#125; </span><br><span class="line">	_SEH2_END; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于为什么要放在一个 try 块中保护,是因为用户空间中的栈地址,谁也无法保证会不会出现崩溃。 </p>
<h3 id="KiUserApcDisatcher"><a href="#KiUserApcDisatcher" class="headerlink" title="KiUserApcDisatcher"></a>KiUserApcDisatcher</h3><p>如上这个函数修改返回地址,回到用户空间中的<code>KiUserApcDisatcher</code>函数处去。然后把原<code>trap 帧</code>保存在用户栈中。<br>由于<code>KiUserApcDisatcher</code>这个函数有参数,所以需要模拟压入这个函数的参数<br>这样当返回到用户空间时,就仿佛是在调用这个函数。</p>
<p>看下那个函数的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">KiUserApcDisatcher(NormalRoutine, </span><br><span class="line">                   NormalContext, </span><br><span class="line">                   SysArg1, </span><br><span class="line">                   SysArg2 </span><br><span class="line">) </span><br><span class="line">&#123; </span><br><span class="line">	Lea eax,[esp+ CONTEXT_ALIGNED_SIZE+<span class="number">16</span>]  <span class="comment">//eax 指向 seh 异常节点的地址 </span></span><br><span class="line">	Mov ecx,fs:[TEB_EXCEPTION_LIST] </span><br><span class="line">	Mov edx,offset KiUserApcExceptionHandler </span><br><span class="line">	-------------------------------------------------------------------------------------- </span><br><span class="line">	Mov [eax],ecx <span class="comment">//seh 节点的 next 指针成员 </span></span><br><span class="line">	Mov [eax+<span class="number">4</span>],edx <span class="comment">//she 节点的 handler 函数指针成员 </span></span><br><span class="line">	Mov fs:[TEB_EXCEPTION_LIST],eax </span><br><span class="line">	</span><br><span class="line">	--------------------上面三条指令在栈中构造一个 <span class="number">8B</span> 的标准 seh 节点----------------------- </span><br><span class="line">	Pop eax <span class="comment">//eax=NormalRoutine(即 IntCallUserApc 这个总 apc 函数) </span></span><br><span class="line">	Lea edi,[esp+<span class="number">12</span>] <span class="comment">//edi=栈中保存的 CONTEXT 结构的地址 </span></span><br><span class="line">	Call eax <span class="comment">//相当于 call IntCallUserApc(NormalContext,SysArg1,SysArg2) </span></span><br><span class="line"></span><br><span class="line">	Mov ecx,[edi+ CONTEXT_ALIGNED_SIZE] </span><br><span class="line">	Mov fs:[ TEB_EXCEPTION_LIST],ecx  <span class="comment">//撤销栈中的 seh 节点 </span></span><br><span class="line"></span><br><span class="line">	Push TRUE <span class="comment">//表示回到内核后需要继续检测执行用户 apc 队列中的 apc 函数 </span></span><br><span class="line">	Push edi <span class="comment">//传入原栈帧的 CONTEXT 结构的地址给这个函数,以做恢复工作 </span></span><br><span class="line">	Call NtContinue  <span class="comment">//调用这个函数重新进入内核(注意这个函数正常情况下是不会返回到下面的) </span></span><br><span class="line">	</span><br><span class="line">	----------------------------------华丽的分割线------------------------------------------- </span><br><span class="line">	Mov esi,eax </span><br><span class="line">	Push esi </span><br><span class="line">	Call RtlRaiseStatus <span class="comment">//若 ZwContinue 返回了,那一定是内部出现了异常 </span></span><br><span class="line">	Jmp StatusRaiseApc </span><br><span class="line">	Ret <span class="number">16</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上每当要执行一个用户空间 apc 时,都会<code>提前</code>偏离原来的路线返回用户空间的这个函数处去执行用户的 apc。<br>在执行这个函数前,会先构造一个 seh 节点,也即相当于把这个函数的调用放在 try 块中保护。<br>这个函数内部会调用<code>IntCallUserApc</code>,执行完真正的用户 apc 函数后,调用<code>ZwContinue</code>重返内核。  </p>
<h3 id="IntCallUserApc"><a href="#IntCallUserApc" class="headerlink" title="IntCallUserApc"></a>IntCallUserApc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//用户空间的总 apc 函数 </span><br><span class="line">Void CALLBACK IntCallUserApc(void* RealApcFunc, void* SysArg1,void* SysArg2) </span><br><span class="line">&#123; </span><br><span class="line">   (*RealApcFunc)(SysArg1);//也即调用 RealApcFunc(void* context) </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ZwContinue"><a href="#ZwContinue" class="headerlink" title="ZwContinue"></a>ZwContinue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtContinue</span><span class="params">(CONTEXT* Context, <span class="comment">//原真正的 TraFrame  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    BOOL TestAlert <span class="comment">//指示是否继续执行用户 apc 队列中的 apc 函数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	Push ebp <span class="comment">//此时 ebp=本系统服务自身的 TrapFrame 地址 </span></span><br><span class="line">	Mov ebx,PCR[KPCR_CURRENT_THREAD] <span class="comment">//ebx=当前线程的 KTHREAD 对象地址 </span></span><br><span class="line">	Mov edx,[ebp+KTRAP_FRAME_EDX] <span class="comment">//注意 TrapFrame 中的这个 edx 字段不是用来保存 edx 的 </span></span><br><span class="line">	Mov [ebx+KTHREAD_TRAP_FRAME],edx <span class="comment">//将当前的 TrapFrame 改为上一个 TrapFrame 的地址 </span></span><br><span class="line">	Mov ebp,esp </span><br><span class="line">	Mob eax,[ebp] <span class="comment">//eax=本系统服务自身的 TrapFrame 地址 </span></span><br><span class="line">	Mov ecx,[ebp+<span class="number">8</span>] /本函数的第一个参数,即 Context </span><br><span class="line">	Push eax </span><br><span class="line">	Push <span class="literal">NULL</span> </span><br><span class="line">	Push ecx </span><br><span class="line">	Call KiContinue  <span class="comment">//call KiContinue(Context*,NULL,TrapFrame*) </span></span><br><span class="line">	Or eax,eax </span><br><span class="line">	Jnz error </span><br><span class="line">	Cmp dword ptr[ebp+<span class="number">12</span>],<span class="number">0</span> <span class="comment">//检查 TestAlert 参数的值 </span></span><br><span class="line">	Je DontTest </span><br><span class="line">	Mov al,[ebx+KTHREAD_PREVIOUS_MODE] </span><br><span class="line">	Push eax </span><br><span class="line">	Call KeTestAlertThread <span class="comment">//检测用户 apc 队列是否为空 </span></span><br><span class="line">	DontTest:</span><br><span class="line">	Pop ebp </span><br><span class="line">	Mov esp,ebp </span><br><span class="line">	Jmp KiServiceExit2 <span class="comment">//返回用户空间(返回前,又会去扫描执行 apc 队列中的下一个用户 apc) </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">KiContinue</span><span class="params">(IN PCONTEXT Context,<span class="comment">//原来的断点现场 </span></span></span></span><br><span class="line"><span class="function"><span class="params">           IN PKEXCEPTION_FRAME ExceptionFrame, </span></span></span><br><span class="line"><span class="function"><span class="params">           IN PKTRAP_FRAME TrapFrame)</span> <span class="comment">//NtContinue自身的TrapFrame地址 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	NTSTATUS Status = STATUS_SUCCESS; </span><br><span class="line">	KIRQL OldIrql = APC_LEVEL; </span><br><span class="line">	KPROCESSOR_MODE PreviousMode = KeGetPreviousMode(); <span class="keyword">if</span> (KeGetCurrentIrql() &lt; APC_LEVEL)  </span><br><span class="line">	KeRaiseIrql(APC_LEVEL, &amp;OldIrql); </span><br><span class="line">	_SEH2_TRY </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (PreviousMode != KernelMode) </span><br><span class="line">			KiContinuePreviousModeUser(Context,ExceptionFrame,TrapFrame);<span class="comment">//恢复成原TrapFrame </span></span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123; </span><br><span class="line">			KeContextToTrapFrame(Context,ExceptionFrame,TrapFrame,Context-&gt;ContextFlags, </span><br><span class="line">		                     KernelMode); <span class="comment">//恢复成原TrapFrame </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	_SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">	&#123; </span><br><span class="line">	    Status = _SEH2_GetExceptionCode(); </span><br><span class="line">	&#125; </span><br><span class="line">	_SEH2_END; </span><br><span class="line">	<span class="keyword">if</span> (OldIrql &lt; APC_LEVEL) </span><br><span class="line">		KeLowerIrql(OldIrql); </span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">KiContinuePreviousModeUser</span><span class="params">(IN PCONTEXT Context,<span class="comment">//原来的断点现场 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                           IN PKEXCEPTION_FRAME ExceptionFrame, </span></span></span><br><span class="line"><span class="function"><span class="params">                           IN PKTRAP_FRAME TrapFrame)</span><span class="comment">//NtContinue自身的TrapFrame地址 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	CONTEXT LocalContext; </span><br><span class="line">	ProbeForRead(Context, <span class="keyword">sizeof</span>(CONTEXT), <span class="keyword">sizeof</span>(ULONG)); </span><br><span class="line">	RtlCopyMemory(&amp;LocalContext, Context, <span class="keyword">sizeof</span>(CONTEXT)); Context = &amp;LocalContext; </span><br><span class="line">	<span class="comment">//看到没,将原Context中的成员填写到NtContinue系统服务的TrapFrame帧中(也即修改成原来的 TrapFrame) </span></span><br><span class="line">	KeContextToTrapFrame(&amp;LocalContext,ExceptionFrame,TrapFrame, LocalContext.ContextFlags,UserMode); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数,就把<code>NtContinue</code>的<code>TrapFrame</code>强制还原成原来的<code>TrapFrame</code>,以好<code>正式</code>返回到用 户空间的真正断点处<br>不过在返回用户空间前,又要去扫描用户 apc 队列,若仍有用户 apc 函数,就先执行掉内核 apc 队列中的所有 apc 函数<br>然后又偏离原来的返回路线,<code>提前</code>返回到用户空间的<code>KiUserApcDispatcher</code>函数去执行用户 apc,这是一个不断循环的过程。<br>可见<code>NtContinue</code>这个函数不仅含有继续回到原真正用户空间断点处的意思,还含有继续执行用户 apc 队列中下一个 apc 函数的意思 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN  <span class="title">KeTestAlertThread</span><span class="params">(IN KPROCESSOR_MODE AlertMode)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PKTHREAD Thread = KeGetCurrentThread(); </span><br><span class="line">	KiAcquireApcLock(Thread, &amp;ApcLock); </span><br><span class="line">	OldState = Thread-&gt;Alerted[AlertMode]; </span><br><span class="line">	<span class="keyword">if</span> (OldState) </span><br><span class="line">		Thread-&gt;Alerted[AlertMode] = FALSE; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((AlertMode != KernelMode) &amp;&amp; (!IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[UserMode]))) </span><br><span class="line">	&#123; </span><br><span class="line">		Thread-&gt;ApcState.UserApcPending = TRUE;<span class="comment">//关键。又标记为不空,从而又去执行用户apc </span></span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	KiReleaseApcLock(&amp;ApcLock); </span><br><span class="line">	<span class="keyword">return</span> OldState; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数的关键工作是检测到用户 apc 队列不为空,就又将<code>UserApcPending</code>标志置于TRUE。 </p>
<p><br><br><br></p>
<h2 id="内核态APC的执行时机"><a href="#内核态APC的执行时机" class="headerlink" title="内核态APC的执行时机"></a>内核态APC的执行时机</h2><p>前面我们看到的是用户 apc 队列的执行机制与时机,那是用户 apc 唯一的执行时机。<br>内核 apc 队列中的 apc 执行时机是不相同的,而且有很多执行时机。 </p>
<p>内核 apc 的执行时机主要有</p>
<ul>
<li>1、 每次返回用户空间前,每执行一个用户 apc 前,就会扫描执行整个内核 apc 队列 </li>
<li>2、 每当调用 KeLowerIrql,从<code>APC_LEVEL</code>以上(不包括 APC_LEVEL) 降到<code>APC_LEVEL</code>以下(不包括<code>APC_ LEVEL</code>)前,中途会检查是否有阻塞的 apc 中断请求,若有就扫描执行内核 apc 队列 </li>
<li>3、 每当线程重新得到调度,开始运行前,会扫描执行内核 apc 队列或者发出 apc 中断请求内核</li>
</ul>
<blockquote>
<p>apc 的执行时机：【调度、返、降】apc </p>
</blockquote>
<h3 id="KeLowerIrql"><a href="#KeLowerIrql" class="headerlink" title="KeLowerIrql"></a>KeLowerIrql</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">KfLowerIrql</span><span class="params">(IN KIRQL OldIrql)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	ULONG EFlags; </span><br><span class="line">	ULONG PendingIrql, PendingIrqlMask; </span><br><span class="line">	PKPCR Pcr = KeGetPcr(); </span><br><span class="line">	PIC_MASK Mask; </span><br><span class="line">	EFlags =  readeflags();<span class="comment">//保存原eflags </span></span><br><span class="line">	_disable();<span class="comment">//关中断 </span></span><br><span class="line">	Pcr-&gt;Irql = OldIrql;<span class="comment">//降到目标irql </span></span><br><span class="line">	<span class="comment">//检测是否有高于目标irql的阻塞中的软中断 </span></span><br><span class="line">	PendingIrqlMask = Pcr-&gt;IRR &amp; FindHigherIrqlMask[OldIrql]; </span><br><span class="line">	<span class="keyword">if</span> (PendingIrqlMask)<span class="comment">//若有 </span></span><br><span class="line">	&#123; </span><br><span class="line">		BitScanReverse(&amp;PendingIrql, PendingIrqlMask);<span class="comment">//找到最高级别的软中断 </span></span><br><span class="line">		<span class="keyword">if</span> (PendingIrql &gt; DISPATCH_LEVEL) </span><br><span class="line">		&#123; </span><br><span class="line">			Mask.Both = Pcr-&gt;IDR; </span><br><span class="line">			outbyte(PIC1_DATA_PORT, Mask.Master); </span><br><span class="line">			outbyte(PIC2_DATA_PORT, Mask.Slave); </span><br><span class="line">			Pcr-&gt;IRR ^= (<span class="number">1</span> &lt;&lt; PendingIrql); </span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">		SWInterruptHandlerTable[PendingIrql]();<span class="comment">//处理阻塞的软中断(即扫描执行队列中的函数) </span></span><br><span class="line">	&#125; </span><br><span class="line">	writeeflags(EFlags);<span class="comment">//恢复原eflags </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数在从当前 irql 降到目标 irql 时,会按 irql 高低顺序执行各个软中断的 isr。 软中断是用来模拟硬件中断的一种中断。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define PASSIVE_LEVEL          0 </span><br><span class="line">#define APC_LEVEL              1 </span><br><span class="line">#define DISPATCH_LEVEL         2 </span><br><span class="line">#define CMCI_LEVEL             5</span><br></pre></td></tr></table></figure>
<p>比如,当调用<code>KfLowerIrql</code>要将 cpu 的 irql 从<code>CMCI_LEVEL</code>降低到<code>PASSIVE_LEVEL</code>时</p>
<ul>
<li>这个函数中途会先看看当前 cpu 是否收到了<code>CMCI_LEVEL</code>级的软中断,若有就调用那个软中断的 isr 处理之。</li>
<li>然后再检查是否收到有<code>DISPATCH_LEVEL</code>级的软中断,若有调用那个软中断的 isr 处理之</li>
<li>然后检查是否有 APC 中断,若有同样处理之。</li>
<li>最后降到目标 irql,即<code>PASSIVE_LEVEL</code>。<br>换句话说在 irql 的降低过程中会一路检查、处理中途的软中断。<br>Cpu 数据结构中有一个<code>IRR</code>字段,即表示当前 cpu 累积收到了哪些级别的软中断。 </li>
</ul>
<h3 id="HalRequestSoftwareInterrupt"><a href="#HalRequestSoftwareInterrupt" class="headerlink" title="HalRequestSoftwareInterrupt"></a>HalRequestSoftwareInterrupt</h3><p>下面的函数可用于模拟硬件,向 cpu 发出任意 irql 级别的软中断,请求 cpu 处理执行那种中断。<br>那么什么时候,系统会调用这个函数,向 cpu 发出 apc 中断呢？ </p>
<p>典型的情形 1:<br>在切换线程时,若将线程的<code>WaitIrql</code>置为<code>APC_LEVEL</code>,将导致<code>KiSwapContextInternal</code>函数内部在重新切回来后,立即自动发出一个 apc 中断,以在下次降低 irql 到<code>PASSIVE_LEVEL</code>时处理执行队列中那些阻塞的 apc。<br>反之若将线程的<code>WaitIrql</code>置为<code>PASSIVE_LEVEL</code>,将导致<code>KiSwapContextInternal</code>函数内部在重新切回来后,不会发出 apc 中断,然后系统会自行显式调用<code>KiDeliverApc</code>给予扫描执行 </p>
<p>典型情形 2:<br>在给自身线程发送一个内核 apc 时,在 apc 进队的同时,会发出 apc 中断,以请求 cpu 在下次降低 irql 时,扫描执行 apc。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">HalRequestSoftwareInterrupt</span><span class="params">(IN KIRQL Irql)</span><span class="comment">//Irql一般是APC_LEVEL/DPC_LEVEL </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	ULONG EFlags; </span><br><span class="line">	PKPCR Pcr = KeGetPcr(); </span><br><span class="line">	KIRQL PendingIrql; </span><br><span class="line">	EFlags =  readeflags();<span class="comment">//保存老的eflags寄存器 </span></span><br><span class="line">	_disable();<span class="comment">//关中断 </span></span><br><span class="line">	Pcr-&gt;IRR |= (<span class="number">1</span> &lt;&lt; Irql);<span class="comment">//关键。标志向cpu发出了一个对应irql级的软中断 </span></span><br><span class="line">	PendingIrql = SWInterruptLookUpTable[Pcr-&gt;IRR &amp; <span class="number">3</span>];<span class="comment">//IRR后两位表示是否有阻塞的apc中断 </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//若有阻塞的apc中断,并且当前irql是PASSIVE_LEVEL,立即执行apc</span></span><br><span class="line">	<span class="comment">//也即在PASSIVE_LEVEL级时发出 任意软中断后,会立即检查执行现有的apc中断。 </span></span><br><span class="line">	<span class="keyword">if</span> (PendingIrql &gt; Pcr-&gt;Irql) </span><br><span class="line">		SWInterruptHandlerTable[PendingIrql]();<span class="comment">//调用执行apc中断的isr,处理apc中断 </span></span><br><span class="line">	writeeflags(EFlags);<span class="comment">//恢复原eflags寄存器 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HalpApcInterruptHandler"><a href="#HalpApcInterruptHandler" class="headerlink" title="HalpApcInterruptHandler"></a>HalpApcInterruptHandler</h3><p>Apc 是一种软中断,既然是中断,他也有类似的 isr, Apc 中断的 isr 最终进入<code>HalpApcInterruptHandler</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">HalpApcInterruptHandler</span><span class="params">(IN PKTRAP_FRAME TrapFrame)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//模拟硬件中断压入保存的寄存器 </span></span><br><span class="line">	TrapFrame-&gt;EFlags =  readeflags(); </span><br><span class="line">	TrapFrame-&gt;SegCs = KGDT_R0_CODE; </span><br><span class="line">	TrapFrame-&gt;Eip = TrapFrame-&gt;Eax; </span><br><span class="line">	KiEnterInterruptTrap(TrapFrame);<span class="comment">//构造Trap现场帧 </span></span><br><span class="line">	扫描执行当前线程的内核apc队列,略… </span><br><span class="line">	KiEoiHelper(TrapFrame);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>一个线程可以等待一个对象或多个对象而进入等待状态(也叫睡眠状态),另一个线程可以触发那个等待对象,唤醒在那个对象上等待的所有线程。<br>一个线程可以等待一个对象或多个对象,而一个对象也可以同时被 N 个线程等待。<br>这样线程与等待对象之间是多对多的关系。<br>他们之间的等待关系由一个队列和一个<code>等待块</code>来控制,等待块就是线程与等待目标对象之间的纽带。 </p>
<p><code>WaitForSingleObject</code>可以等待那些<code>可等待对象</code>,哪些对象是<code>可等待</code>的呢？</p>
<p>进程、线程、作业、文件对象、IO 完成端口、可等待定时器、互斥、事件、信号量等,这些都是<code>可等待</code>对象,可用于<code>WaitForSingleObject</code> 等函数。 </p>
<h2 id="直接间接等待对象"><a href="#直接间接等待对象" class="headerlink" title="直接间接等待对象"></a>直接间接等待对象</h2><p><code>可等待</code>对象又分为<code>可直接等待对象</code>和<code>可间接等待对象</code><br>互斥、事件、信号量、进程、线程这些对象由于内部结构中的自第一个字段是<code>DISPATCHER_HEADER</code>结构(可以看成是继承了<code>DISPATCHER_HEADER</code>),因此是可直接等待的。<br>而文件对象不带这个结构,但文件对象内部有一个事件对象,因此文件对象是<code>可间接等待对象</code>。 </p>
<h2 id="WaitForSingleObject"><a href="#WaitForSingleObject" class="headerlink" title="WaitForSingleObject"></a>WaitForSingleObject</h2><p><code>WaitForSingleObject</code>内部最终调用下面的系统服务 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtWaitForSingleObject</span><span class="params">(IN HANDLE ObjectHandle,<span class="comment">//直接或间接可等待对象的句柄 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                      IN BOOLEAN Alertable,<span class="comment">//表示本次等待操作是否可被吵醒(即被强制唤醒) </span></span></span></span><br><span class="line"><span class="function"><span class="params">                      IN PLARGE_INTEGER TimeOut OPTIONAL)</span><span class="comment">//超时 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PVOID Object, WaitableObject; </span><br><span class="line">	KPROCESSOR_MODE PreviousMode = ExGetPreviousMode(); </span><br><span class="line">	LARGE_INTEGER SafeTimeOut; </span><br><span class="line">	NTSTATUS Status; </span><br><span class="line">	<span class="keyword">if</span> ((TimeOut) &amp;&amp; (PreviousMode != KernelMode)) </span><br><span class="line">	&#123; </span><br><span class="line">		_SEH2_TRY </span><br><span class="line">		&#123; </span><br><span class="line">			SafeTimeOut = ProbeForReadLargeInteger(TimeOut); </span><br><span class="line">			TimeOut = &amp;SafeTimeOut; </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">		&#123; </span><br><span class="line">			_SEH2_YIELD(<span class="keyword">return</span> _SEH2_GetExceptionCode()); </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_END; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	Status = ObReferenceObjectByHandle(ObjectHandle,SYNCHRONIZE,<span class="literal">NULL</span>,PreviousMode, &amp;Object,<span class="literal">NULL</span>); </span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//得到那个对象的`可直接等待对象`DefaultObject </span></span><br><span class="line">		WaitableObject = OBJECT_TO_OBJECT_HEADER(Object)-&gt;Type-&gt;DefaultObject; </span><br><span class="line">		<span class="keyword">if</span> (IsPointerOffset(WaitableObject))<span class="comment">//if DefaultObject是个偏移,不是指针 </span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">//加上偏移值,获得内部的`可直接等待对象` </span></span><br><span class="line">			WaitableObject = (PVOID)((ULONG_PTR)Object + (ULONG_PTR)WaitableObject); </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_TRY </span><br><span class="line">		&#123; </span><br><span class="line">			Status = KeWaitForSingleObject(WaitableObject,<span class="comment">//这个函数只能等待`直接等待对象` </span></span><br><span class="line">		                               UserRequest,PreviousMode,Alertable,TimeOut); </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">		&#123; </span><br><span class="line">			Status = _SEH2_GetExceptionCode(); </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_END; </span><br><span class="line">		ObDereferenceObject(Object); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>#define IsPointerOffset(Ptr) ((LONG)(Ptr) &gt;= 0)</code></p>
<p>每个对象的对象类型都有一个默认的可直接等待对象,要么直接指向对象,要么是个偏移值。<br>如果是个偏移值,那么<code>DefaultObject</code>值的最高位为 0,否则为 1。</p>
<p><code>NtWaitForSingleObject</code>可以等待直接的、间接的可等待对象,然而<code>KeWaitForSingleObject</code>只能等待真正的可直接等待对象,所以必须将间接可等待对象转换为直接可等待对象,而每个对象的可直接等待对象记录在其对象类型的<code>DefaultObject</code>字段中。 </p>
<h3 id="KeWaitForSingleObject"><a href="#KeWaitForSingleObject" class="headerlink" title="KeWaitForSingleObject"></a>KeWaitForSingleObject</h3><p>下面这个函数是重点。这个函数很不好理解,我也是认真看了好几遍才有所明白,这个函数本身逻辑量比较大,函数也较长。<br>重要的是对唤醒原因的理解。(把<code>WaitStatus</code>理解为唤醒原因就好了) </p>
<p>注意下面的函数只能在<code>DISPATCH_LEVEL</code>以下调用,否则蓝屏。(<code>除非Timeout!=NULL &amp;&amp; *Timeout==0</code>) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">KeWaitForSingleObject</span><span class="params">(IN PVOID Object,<span class="comment">//要等待的`可直接等待对象` </span></span></span></span><br><span class="line"><span class="function"><span class="params">                      IN KWAIT_REASON WaitReason,<span class="comment">//线程上次被切出原因 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                      IN KPROCESSOR_MODE WaitMode,<span class="comment">//表示这是来自用户模式/内核模式的等待请求 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                      IN BOOLEAN Alertable,<span class="comment">//表示本次等待操作是否可以被强制唤醒 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                      IN PLARGE_INTEGER Timeout OPTIONAL)</span><span class="comment">//超时值 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PKTHREAD Thread = KeGetCurrentThread(); </span><br><span class="line">	PKMUTANT CurrentObject = (PKMUTANT)Object;<span class="comment">//其实意思是(DISPATCHER_HEADER*)Object </span></span><br><span class="line">	PKWAIT_BLOCK WaitBlock = &amp;Thread-&gt;WaitBlock[<span class="number">0</span>]; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//内置的第4个等待块固定用于定时器(TIMER_WAIT_BLOCK是索引3) </span></span><br><span class="line">	PKWAIT_BLOCK TimerBlock = &amp;Thread-&gt;WaitBlock[TIMER_WAIT_BLOCK];  </span><br><span class="line">	PKTIMER Timer = &amp;Thread-&gt;Timer;<span class="comment">//复用这个超时定时器 </span></span><br><span class="line">	NTSTATUS WaitStatus;<span class="comment">//其实表示‘上次唤醒原因’ </span></span><br><span class="line">	BOOLEAN Swappable;<span class="comment">//内核栈是否可换到外存 </span></span><br><span class="line">	LARGE_INTEGER DueTime, NewDueTime, InterruptTime; </span><br><span class="line">	PLARGE_INTEGER OriginalDueTime = Timeout; ULONG Hand = <span class="number">0</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//首次等待时需从WaitStart处开始,加锁,提升irql至DISPATCH_LEVEL </span></span><br><span class="line">	<span class="keyword">if</span> (!Thread-&gt;WaitNext) <span class="keyword">goto</span> WaitStart;  </span><br><span class="line">	</span><br><span class="line">	Thread-&gt;WaitNext = FALSE;<span class="comment">//复位 </span></span><br><span class="line">	KxSingleThreadWait();<span class="comment">//这是一个宏,主要用来构造当前线程的等待块链表 </span></span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">	<span class="keyword">for</span> (;;)<span class="comment">//首次循环、以后每次临时唤醒切回来时的入口 </span></span><br><span class="line">	&#123; </span><br><span class="line">		Thread-&gt;Preempted = FALSE;<span class="comment">//表示因等待而主动放弃的cpu,不是被抢占 </span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//if进入等待态前的原irql是APC_LEVEL,每次切回来时会自动在KiSwapContextInternal执行掉所有内核APC。</span></span><br><span class="line">		<span class="comment">//if进入等待态前的原irql是PASSIVE_LEVEL,则用下面的语句手动执行掉所有内核APC。</span></span><br><span class="line">		<span class="comment">//总之确保每次切回来时,总是会先执行掉所有内核APC </span></span><br><span class="line">		<span class="keyword">if</span> ((Thread-&gt;ApcState.KernelApcPending) &amp;&amp; !(Thread-&gt;SpecialApcDisable) &amp;&amp; (Thread-&gt;WaitIrql == PASSIVE_LEVEL)) </span><br><span class="line">		&#123; </span><br><span class="line">			KiReleaseDispatcherLock(Thread-&gt;WaitIrql);<span class="comment">//执行掉所有Pending中的内核APC </span></span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//每轮循环中(即每次切回来时),测试是否条件成熟,可以退出睡眠。可以退出的3种条件为:</span></span><br><span class="line">		<span class="comment">// 1、 所等待的对象有信号了 </span></span><br><span class="line">		<span class="comment">// 2、 可被强制唤醒了 </span></span><br><span class="line">		<span class="comment">// 3、 超时了 </span></span><br><span class="line">		Else </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">//先检测所等待的对象是否有信号了,不过互斥对象需要特殊判断。 </span></span><br><span class="line">			<span class="keyword">if</span> (CurrentObject-&gt;Header.Type == MutantObject) </span><br><span class="line">			&#123; </span><br><span class="line"></span><br><span class="line">				<span class="comment">//if等待的互斥对象有信号了,或者当前线程本身就是该互斥对象的拥有者(一个线程 可以反复多次等待同一个互斥对象的) </span></span><br><span class="line">				<span class="keyword">if</span> ((CurrentObject-&gt;Header.SignalState &gt; <span class="number">0</span>) || (Thread == CurrentObject-&gt;OwnerThread)) </span><br><span class="line">				&#123; </span><br><span class="line">					<span class="keyword">if</span> (CurrentObject-&gt;Header.SignalState != (LONG)MINLONG) </span><br><span class="line">					&#123; </span><br><span class="line">						KiSatisfyMutantWait(CurrentObject, Thread); </span><br><span class="line">						WaitStatus = Thread-&gt;WaitStatus;<span class="comment">//唤醒原因 </span></span><br><span class="line">						<span class="keyword">goto</span> DontWait;<span class="comment">//退出函数 </span></span><br><span class="line">					&#125; </span><br><span class="line">					Else 抛出异常… </span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//普通的等待对象只要DISPATCHER_HEADER头部中的SignalState &gt; 0就表示有信号了 </span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (CurrentObject-&gt;Header.SignalState &gt; <span class="number">0</span>) </span><br><span class="line">			&#123; </span><br><span class="line">				KiSatisfyNonMutantWait(CurrentObject);<span class="comment">//递减信号状态量计数 </span></span><br><span class="line">				WaitStatus = STATUS_WAIT_0;<span class="comment">//唤醒原因为‘真唤醒’ </span></span><br><span class="line">				<span class="keyword">goto</span> DontWait; <span class="comment">//退出函数 </span></span><br><span class="line">			&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="comment">//若所等等待的对象没有信号,就检查当前状态是否可被强制唤醒 </span></span><br><span class="line">			WaitStatus = KiCheckAlertability(Thread, Alertable, WaitMode); </span><br><span class="line">			<span class="keyword">if</span> (WaitStatus != STATUS_WAIT_0)<span class="comment">//if 可以强制唤醒了,就break退出循环,退出函数 </span></span><br><span class="line">				<span class="keyword">break</span>;  </span><br><span class="line">			</span><br><span class="line">			<span class="comment">//如果无法强制唤醒,就再检测是否已经等待超时了 </span></span><br><span class="line">			<span class="keyword">if</span> (Timeout)<span class="comment">//if用户提供了一个超时值,就检测超时情况 </span></span><br><span class="line">			&#123; </span><br><span class="line">				InterruptTime.QuadPart = KeQueryInterruptTime(); </span><br><span class="line">				<span class="keyword">if</span> ((ULONGLONG)InterruptTime.QuadPart &gt;= Timer-&gt;DueTime.QuadPart) </span><br><span class="line">				&#123; </span><br><span class="line">					WaitStatus = STATUS_TIMEOUT;<span class="comment">//唤醒原因为‘超时’ </span></span><br><span class="line">					<span class="keyword">goto</span> DontWait; <span class="comment">//退出函数 </span></span><br><span class="line">				&#125; </span><br><span class="line">				Timer-&gt;Header.Inserted = TRUE; </span><br><span class="line">			&#125; </span><br><span class="line">			</span><br><span class="line">			<span class="comment">//如果所有条件都不满足,就需要进入睡眠(首轮检测)或继续进入睡眠(每次临时唤醒切 回来时的检查) </span></span><br><span class="line">			<span class="comment">//将等待块挂入目标等待对象内部的等待块链表中 </span></span><br><span class="line">			InsertTailList(&amp;CurrentObject-&gt;Header.WaitListHead,&amp;WaitBlock-&gt;WaitListEntry); </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (Thread-&gt;Queue) KiActivateWaiterQueue(Thread-&gt;Queue); </span><br><span class="line">			</span><br><span class="line">			Thread-&gt;State = Waiting;<span class="comment">//将线程标记为等待状态(即睡眠状态) </span></span><br><span class="line">			KiAddThreadToWaitList(Thread, Swappable);<span class="comment">//加入到当前cpu的等待线程链表中             </span></span><br><span class="line">			<span class="keyword">if</span> (Timeout) </span><br><span class="line">				KxInsertTimer(Timer, Hand); </span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				KiReleaseDispatcherLockFromDpcLevel(); </span><br><span class="line">			</span><br><span class="line">			KiSetThreadSwapBusy(Thread);<span class="comment">//标记线程正在进行切换 </span></span><br><span class="line">			WaitStatus = KiSwapThread(Thread, KeGetCurrentPrcb());<span class="comment">//关键。切出线程,进入睡眠 </span></span><br><span class="line"></span><br><span class="line">			-------------------------------华丽的分割线--------------------------------------</span><br><span class="line">			-------------------------------华丽的分割线--------------------------------------</span><br><span class="line">			-------------------------------华丽的分割线-------------------------------------- </span><br><span class="line"></span><br><span class="line">			<span class="comment">//上面函数的返回值表示线程唤醒切回来的原因(大体分为三种)【临时、强制、真唤醒】 </span></span><br><span class="line">			<span class="comment">//1、 临时唤醒。指被其他线程发来的内核APC临时唤醒,要求执行紧急APC任务 </span></span><br><span class="line">			<span class="comment">//2、 强制唤醒。指被其他线程发来的强制唤醒要求唤醒/被发来的用户APC强制唤醒 </span></span><br><span class="line">			<span class="comment">//3、 真唤醒。指所等待的对象真的有信号了而被唤醒 </span></span><br><span class="line">			<span class="keyword">if</span> (WaitStatus != STATUS_KERNEL_APC)<span class="comment">//if唤醒原因不是临时唤醒,就退出函数了 </span></span><br><span class="line">				<span class="keyword">return</span> WaitStatus; </span><br><span class="line">			</span><br><span class="line">			<span class="comment">//下面的代码,是当被临时唤醒回来后,需要继续执行的。临时唤醒回来后,需要重新计算 剩余超时值、执行内核APC,继续进入下轮循环,测试是否可以退出睡眠。 </span></span><br><span class="line">			<span class="keyword">if</span> (Timeout)<span class="comment">//重新计算剩余超时值 </span></span><br><span class="line">				Timeout = KiRecalculateDueTime(OriginalDueTime,&amp;DueTime,&amp;NewDueTime); </span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">WaitStart:<span class="comment">//首次开始进入等待时,从这儿开始,提升irql </span></span><br><span class="line">		Thread-&gt;WaitIrql = KeRaiseIrqlToSynchLevel(); </span><br><span class="line">		KxSingleThreadWait();<span class="comment">//构造好线程的等待块链表 </span></span><br><span class="line">		KiAcquireDispatcherLockAtDpcLevel(); </span><br><span class="line">	&#125; </span><br><span class="line">    KiReleaseDispatcherLock(Thread-&gt;WaitIrql);<span class="comment">//break方式退出到这儿 </span></span><br><span class="line">    <span class="keyword">return</span> WaitStatus; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DontWait: </span><br><span class="line">    KiReleaseDispatcherLockFromDpcLevel(); </span><br><span class="line">    KiAdjustQuantumThread(Thread);<span class="comment">//调整时间片 </span></span><br><span class="line">    <span class="keyword">return</span> WaitStatus;<span class="comment">//返回本次睡眠的唤醒原因 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上这个函数是一个循环测试,概念上有点类似忙式等待。</p>
<p>首先第一轮循环,从<code>WaitStart</code>处开始, 提升 irql(目的是防止被切换),然后回到 for 循环开头处,测试条件。<br>如果所要等待的对象本来就有信号,那么第一轮循环时,就不用进入睡眠了,直接退出函数。<br>否则就切出线程,让出cpu,构造好线程的等待块链表,并将等待块(此处意指线程自身)挂入目标等待对象的等待块队列中(可理解为等待者线程队列)。<br>然后当以后条件成熟,唤醒回来时,检测唤醒原因。若是被临时唤醒的,就继续进入下轮循环测试等待条件,否则即可退出函数,退出睡眠了。 </p>
<h3 id="KWAIT-BLOCK"><a href="#KWAIT-BLOCK" class="headerlink" title="_KWAIT_BLOCK"></a><code>_KWAIT_BLOCK</code></h3><p>下面的等待块结构是线程的等待机制核心,它即用来挂入线程的等待块链表,也用来挂入等待对象的队列 中。<br>当挂入前者时,等待块就可理解为一个等待对象,当挂入后者时就可理解为一个等待者线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KWAIT_BLOCK</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	LIST_ENTRY WaitListEntry;<span class="comment">//用来挂入目标对象的等待者线程队列 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span> *<span class="title">Thread</span>;</span><span class="comment">//所属线程 </span></span><br><span class="line">	PVOID Object;<span class="comment">//要等待的目标对象 </span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">KWAIT_BLOCK</span> *<span class="title">NextWaitBlock</span>;</span><span class="comment">//下一个等待块(用来挂入线程的等待块链表) </span></span><br><span class="line">	USHORT WaitKey;<span class="comment">//本等待块是所属线程的第几个等待对象 </span></span><br><span class="line">	UCHAR WaitType;<span class="comment">//WaitAll/WaitAny </span></span><br><span class="line">	<span class="keyword">volatile</span> UCHAR BlockState; </span><br><span class="line">&#125; KWAIT_BLOCK, *PKWAIT_BLOCK, *PRKWAIT_BLOCK;</span><br></pre></td></tr></table></figure>
<p>上面的函数中牵涉到一个重要宏和几个子函数,我们看。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KxSingleThreadWait()                                                                                    </span></span><br><span class="line">    Thread-&gt;WaitBlockList = WaitBlock;<span class="comment">//等待块链表                                       </span></span><br><span class="line">    WaitBlock-&gt;WaitKey = <span class="number">0</span>;<span class="comment">//即等待块的索引                                     </span></span><br><span class="line">    WaitBlock-&gt;Object = Object;<span class="comment">//要等待的目标对象                                              </span></span><br><span class="line">    WaitBlock-&gt;WaitType = WaitAny; <span class="comment">//只等待一个对象的话就固定是WaitAny                                          </span></span><br><span class="line">    Thread-&gt;WaitStatus = <span class="number">0</span>; <span class="comment">//复位唤醒原因                                                                      </span></span><br><span class="line">    <span class="keyword">if</span> (Timeout)  <span class="comment">//if给定了超时值                                                         </span></span><br><span class="line">    &#123;                                                                                                           </span><br><span class="line">        KxSetTimerForThreadWait(Timer, *Timeout, &amp;Hand);<span class="comment">//设置好定时器对象                                      </span></span><br><span class="line">        DueTime.QuadPart = Timer-&gt;DueTime.QuadPart;                                                             </span><br><span class="line">        WaitBlock-&gt;NextWaitBlock = TimerBlock; <span class="comment">//定时器对象等待块也挂入链表中                              </span></span><br><span class="line">        TimerBlock-&gt;NextWaitBlock = WaitBlock;<span class="comment">//单循环链表                                                      </span></span><br><span class="line">        Timer-&gt;Header.WaitListHead.Flink = &amp;TimerBlock-&gt;WaitListEntry;       </span><br><span class="line">        Timer-&gt;Header.WaitListHead.Blink = &amp;TimerBlock-&gt;WaitListEntry;       </span><br><span class="line">    &#125;                                                                        </span><br><span class="line">    <span class="keyword">else</span>                                                                     </span><br><span class="line">    &#123;                                                                                                 </span><br><span class="line">        WaitBlock-&gt;NextWaitBlock = WaitBlock; <span class="comment">//单循环链表                                 </span></span><br><span class="line">    &#125;                                                                                                           </span><br><span class="line">    Thread-&gt;Alertable = Alertable;<span class="comment">//线程睡眠模式,是否可被提醒(即强制唤醒)                                    </span></span><br><span class="line">    Thread-&gt;WaitMode = WaitMode;<span class="comment">//来自用户还是内核模式的等待请求                                             </span></span><br><span class="line">    Thread-&gt;WaitReason = WaitReason; <span class="comment">//上次线程切换原因                                                         </span></span><br><span class="line">    Thread-&gt;WaitListEntry.Flink = <span class="literal">NULL</span>;                                      </span><br><span class="line">    Swappable  =  KiCheckThreadStackSwap(Thread,  WaitMode);<span class="comment">//检测本线程的内核栈是否可以换到外存                    </span></span><br><span class="line">    Thread-&gt;WaitTime = KeTickCount.LowPart;<span class="comment">//记录上次切出时间</span></span><br></pre></td></tr></table></figure>
<p>如上这个宏的主要功能就是用来构造好该线程的等待块链表,以及一些其它乱七八糟的工作,上面<br>的函数<code>KiCheckThreadStackSwap</code>用来检测本线程的内核栈是否可以置换到外存 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN  <span class="title">KiCheckThreadStackSwap</span><span class="params">(IN PKTHREAD Thread,IN KPROCESSOR_MODE WaitMode)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span> ((WaitMode == UserMode) &amp;&amp; (Thread-&gt;EnableStackSwap) &amp;&amp; </span><br><span class="line">	                          (Thread-&gt;Priority &gt;= (LOW_REALTIME_PRIORITY + <span class="number">9</span>))) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">return</span> TRUE; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">return</span> FALSE; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上,超级实时类的线程在处理来自用户模式的等待请求时,内核栈可以置换到外存。 </p>
<h3 id="KiCheckAlertability"><a href="#KiCheckAlertability" class="headerlink" title="KiCheckAlertability"></a>KiCheckAlertability</h3><p>下面的函数用来在线程被临时唤醒后,测试线程的状态是否可被强制唤醒。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">KiCheckAlertability</span><span class="params">(IN PKTHREAD Thread, </span></span></span><br><span class="line"><span class="function"><span class="params">                    IN BOOLEAN Alertable,<span class="comment">//本次睡眠操作是否支持强制唤醒 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    IN KPROCESSOR_MODE WaitMode)</span><span class="comment">//来自哪个模式的等待请求 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (Alertable)<span class="comment">//if本次睡眠操作支持强制唤醒(即可被强制唤醒) </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (Thread-&gt;Alerted[WaitMode])<span class="comment">//if 真收到了来自那个模式的强制唤醒要求 </span></span><br><span class="line">		&#123; </span><br><span class="line">			Thread-&gt;Alerted[WaitMode] = FALSE;<span class="comment">//复位 </span></span><br><span class="line">			<span class="keyword">return</span> STATUS_ALERTED;<span class="comment">//唤醒原因设为强制唤醒 </span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">//若没收到其他线程发来对应模式的强制唤醒要求,但收到了用户APC </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((WaitMode != KernelMode) &amp;&amp; </span><br><span class="line">		    (!IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[UserMode]))) </span><br><span class="line">		&#123; </span><br><span class="line">			Thread-&gt;ApcState.UserApcPending = TRUE; </span><br><span class="line">			<span class="keyword">return</span> STATUS_USER_APC;<span class="comment">//标记为被用户APC给强制唤醒了 </span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">//只要收到了内核模式的强制唤醒要求,就可被强制唤醒(不必模式匹配) </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Thread-&gt;Alerted[KernelMode]) </span><br><span class="line">		&#123; </span><br><span class="line">			Thread-&gt;Alerted[KernelMode] = FALSE; </span><br><span class="line">			<span class="keyword">return</span> STATUS_ALERTED; <span class="comment">//唤醒原因设为强制唤醒 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//即使本次睡眠不支持强制唤醒,但其他线程发来的用户APC仍可强制唤醒本线程 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((WaitMode != KernelMode) &amp;&amp; (Thread-&gt;ApcState.UserApcPending)) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">return</span> STATUS_USER_APC; <span class="comment">//标记为被用户APC给强制唤醒了 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> STATUS_WAIT_0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上当线程的本次睡眠支持强制唤醒的情况下,可被对应模式或内核模式的强制唤醒要求给唤醒,即使不支持强制唤醒,也会被其他线程发来的用户 APC 给强制搞醒。 </p>
<p>关于模式匹配记住下面一点。来自内核模式的强制唤醒要求可以强制唤醒来自内核模式、用户模式的等待 请求<br>而来自用户模式的强制唤醒要求只能强制唤醒来自用户模式的等待请求。</p>
<p>这就好比:内核空间的程序可以访问内核空间的代码和数据,而用户空间的程序只能访问用户空间的代码和数据。这样记就容易了。</p>
<p><br></p>
<h2 id="线程等待唤醒"><a href="#线程等待唤醒" class="headerlink" title="线程等待唤醒"></a>线程等待唤醒</h2><p>线程的睡眠其工作之一就是线程切换。线程一被切出了,要么进入就绪态,要么进入等待态。<br>因等待对象而引起的线程切换,将使线程处于等待态。等待态与就绪态的本质区别就是处于就绪态的线程直接挂入就 绪队列,随时等候被调度运行,处于等待态的线程,则要将自己挂入 cpu 的等待队列,挂入各个目标等待 对象的等待线程队列,然后一直等待别的线程触发等待对象,唤醒自己,重新进入就绪态或运行态。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KiAddThreadToWaitList(Thread, Swappable)                             </span></span><br><span class="line">&#123;                                                                                            </span><br><span class="line">	<span class="keyword">if</span> (Swappable) <span class="comment">//为什么要满足这个条件,我也搞不清                                                          </span></span><br><span class="line">		InsertTailList(&amp;KeGetCurrentPrcb()-&gt;WaitListHead, &amp;Thread-&gt;WaitListEntry);                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个线程处于睡眠态时,最典型的唤醒原因就是所等待的对象有了信号。</p>
<h3 id="KiWaitTest"><a href="#KiWaitTest" class="headerlink" title="KiWaitTest"></a>KiWaitTest</h3><p>当一个等待对象有了信号时,系统(指别的线程)会调用下面的函数尝试唤醒在该等待对象上等待的所有线程。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">KiWaitTest</span><span class="params">(IN PVOID ObjectPointer,<span class="comment">//目标等待对象 </span></span></span></span><br><span class="line"><span class="function"><span class="params">           IN KPRIORITY Increment)</span><span class="comment">//唤醒线程后的优先级增量(以便尽快得到调度运行) </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PLIST_ENTRY WaitEntry, WaitList; </span><br><span class="line">	PKWAIT_BLOCK WaitBlock; </span><br><span class="line">	PKTHREAD WaitThread; </span><br><span class="line">	PKMUTANT FirstObject = ObjectPointer; </span><br><span class="line">	NTSTATUS WaitStatus; </span><br><span class="line">	WaitList = &amp;FirstObject-&gt;Header.WaitListHead; WaitEntry = WaitList-&gt;Flink; </span><br><span class="line">	<span class="comment">//遍历等待者线程队列,尝试唤醒所有线程,直到信号状态量分配完毕 </span></span><br><span class="line">	<span class="keyword">while</span> ((FirstObject-&gt;Header.SignalState &gt; <span class="number">0</span>) &amp;&amp; (WaitEntry != WaitList)) </span><br><span class="line">	&#123; </span><br><span class="line">		WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry); </span><br><span class="line">		WaitThread = WaitBlock-&gt;Thread; </span><br><span class="line">		WaitStatus = STATUS_KERNEL_APC;<span class="comment">//模拟给那个等待者线程发送内核apc而临时唤醒它 </span></span><br><span class="line">		<span class="keyword">if</span> (WaitBlock-&gt;WaitType == WaitAny)<span class="comment">//WaitAnt类型的话,肯定满足分配了 </span></span><br><span class="line">		&#123; </span><br><span class="line">			WaitStatus = (NTSTATUS)WaitBlock-&gt;WaitKey;<span class="comment">//唤醒原因改为‘真唤醒’,此处即索引 </span></span><br><span class="line">			KiSatisfyObjectWait(FirstObject, WaitThread);<span class="comment">//分配资源,递减对象的信号状态量计数 </span></span><br><span class="line">		&#125; </span><br><span class="line">		KiUnwaitThread(WaitThread, WaitStatus, Increment);<span class="comment">//关键函数 </span></span><br><span class="line">		WaitEntry = WaitList-&gt;Flink;<span class="comment">//下一个线程 </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上这个函数会在每一个等待对象变成有信号时,尝试唤醒所有在该对象上等待的所有线程。<br>注意,若队列中的某个等待块类型是<code>WaitAny</code>时,那么那个等待者线程必然真的满足了等待条件,所以需要将唤 醒原因改为<code>真唤醒</code>类型。<br>反之若那个线程的等待类型是<code>WaitAll</code>,也即它还要等待其他对象,那么就模拟给它发送内核 apc 的方式(其实没发送),临时唤醒它,进入下轮循环,继续测试它所等待的其他对象,这一点务必要注意。</p>
<h3 id="KiSatisfyObjectWait-分配唤醒信号"><a href="#KiSatisfyObjectWait-分配唤醒信号" class="headerlink" title="KiSatisfyObjectWait(分配唤醒信号)"></a>KiSatisfyObjectWait(分配唤醒信号)</h3><p>下面的宏用于当满足分配条件时,分配信号状态量给指定线程。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KiSatisfyObjectWait(Object, Thread)                                  </span></span><br><span class="line">&#123;                                                                            </span><br><span class="line">                                    </span><br><span class="line">	<span class="keyword">if</span> ((Object)-&gt;Header.Type == MutantObject) <span class="comment">//互斥对象要特殊处理                              </span></span><br><span class="line">	&#123;                                                                                              </span><br><span class="line">		(Object)-&gt;Header.SignalState--;<span class="comment">//递减信号状态量计数(此处为拥有计数)                                   </span></span><br><span class="line">		<span class="keyword">if</span> ((Object)-&gt;Header.SignalState == <span class="number">0</span>)<span class="comment">//if拥有计数==0 </span></span><br><span class="line">		&#123;                                                                                                 </span><br><span class="line">			(Object)-&gt;OwnerThread = Thread;                                                       </span><br><span class="line">			Thread-&gt;KernelApcDisable = Thread-&gt;KernelApcDisable - (Object)-&gt;ApcDisable;                         </span><br><span class="line">			<span class="keyword">if</span> ((Object)-&gt;Abandoned)<span class="comment">//如果该互斥对象是因为原拥有者线程意外终止了而让出的                        </span></span><br><span class="line">			&#123;                                                                             </span><br><span class="line">				(Object)-&gt;Abandoned = FALSE;<span class="comment">//复位                                                              </span></span><br><span class="line">				Thread-&gt;WaitStatus = STATUS_ABANDONED;<span class="comment">//唤醒原因                       </span></span><br><span class="line">			&#125;   </span><br><span class="line">			<span class="comment">//插入本线程获得的所有互斥对象链表中                                                                </span></span><br><span class="line">			InsertHeadList(Thread-&gt;MutantListHead.Blink, &amp;(Object)-&gt;MutantListEntry);                      </span><br><span class="line">		&#125;                                                                    </span><br><span class="line">	&#125;    </span><br><span class="line">	<span class="comment">//如果是`自动复位`型事件,触发对象后,又立马复位它的状态                                                  </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (((Object)-&gt;Header.Type &amp; TIMER_OR_EVENT_TYPE) == EventSynchronizationObject)                       </span><br><span class="line">		(Object)-&gt;Header.SignalState = <span class="number">0</span>;                                                                       </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((Object)-&gt;Header.Type == SemaphoreObject)                       </span><br><span class="line">		(Object)-&gt;Header.SignalState--;<span class="comment">//递减信号状态量计数(此处为真的信号量计数)                             </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熟悉 Win32 多线程编程的朋友想必不用解释这段代码了吧。<br>只是要提醒一下,不管是什么同步对象,其内部的<code>SignalState</code>表示信号状态量计数,当该值&lt;=0 时表示无信号,&gt;0 时表示有信号。</p>
<p>其实这个字段本用于信号量的,不过所有的同步对象都可以看做是<code>SignalState</code>只有 0 和 1 两种情况的<code>特殊信号量</code>。 </p>
<h3 id="KiUnwaitThread-唤醒指定线程"><a href="#KiUnwaitThread-唤醒指定线程" class="headerlink" title="KiUnwaitThread(唤醒指定线程)"></a>KiUnwaitThread(唤醒指定线程)</h3><p>下面的这个函数可以说是线程的等待唤醒机制的核心,其功能用来唤醒指定线程 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">KiUnwaitThread</span><span class="params">(IN PKTHREAD Thread,<span class="comment">//目标线程 </span></span></span></span><br><span class="line"><span class="function"><span class="params">               IN LONG_PTR WaitStatus,<span class="comment">//唤醒原因 </span></span></span></span><br><span class="line"><span class="function"><span class="params">               IN KPRIORITY Increment)</span><span class="comment">//唤醒后的优先级增量,以便唤醒后尽快得到调度运行 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    KiUnlinkThread(Thread, WaitStatus);<span class="comment">//将所有等待块脱链 </span></span><br><span class="line">    Thread-&gt;AdjustIncrement = (SCHAR)Increment;<span class="comment">//上次优先级调整增量 </span></span><br><span class="line">    Thread-&gt;AdjustReason = AdjustUnwait;<span class="comment">//调整原因 </span></span><br><span class="line">    KiReadyThread(Thread);<span class="comment">//‘就绪化’指定线程(也即转入就绪队列或者置为抢占者线程) </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任意一个线程都可以调用这个函数唤醒目标线程。唤醒原因大体分为：<code>临时唤醒</code>、<code>强制唤醒</code>、<code>真唤醒</code><br>每当插入一个 apc 的时候,将调用下面的函数 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">KiInsertQueueApc</span><span class="params">(…)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> </span><br><span class="line">	……. </span><br><span class="line">	<span class="keyword">if</span> (Thread != KeGetCurrentThread()) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (ApcMode == KernelMode)<span class="comment">//若要给其他线程插入一个内核apc </span></span><br><span class="line">		&#123; </span><br><span class="line">			Thread-&gt;ApcState.KernelApcPending = TRUE; </span><br><span class="line">			<span class="keyword">if</span> (Thread-&gt;State == Running) </span><br><span class="line">			&#123; </span><br><span class="line">				RequestInterrupt = TRUE; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((Thread-&gt;State == Waiting) &amp;&amp; (Thread-&gt;WaitIrql == PASSIVE_LEVEL) &amp;&amp; </span><br><span class="line">			     !(Thread-&gt;SpecialApcDisable) &amp;&amp; (!(Apc-&gt;NormalRoutine) || </span><br><span class="line">			(!(Thread-&gt;KernelApcDisable)&amp;&amp;!(Thread-&gt;ApcState.KernelApcInProgress)))) </span><br><span class="line">			&#123; </span><br><span class="line">				Status = STATUS_KERNEL_APC; </span><br><span class="line">				KiUnwaitThread(Thread, Status, PriorityBoost);<span class="comment">//临时唤醒目标线程 </span></span><br><span class="line">			&#125; </span><br><span class="line">			……. </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((Thread-&gt;State == Waiting) &amp;&amp; (Thread-&gt;WaitMode == UserMode) &amp;&amp; </span><br><span class="line">		 ((Thread-&gt;Alertable) || (Thread-&gt;ApcState.UserApcPending))) </span><br><span class="line">		&#123; </span><br><span class="line">			Thread-&gt;ApcState.UserApcPending = TRUE; </span><br><span class="line">			Status = STATUS_USER_APC; </span><br><span class="line">			KiUnwaitThread(Thread, Status, PriorityBoost);<span class="comment">//插入用户APC,强制唤醒目标线程 </span></span><br><span class="line">		&#125; </span><br><span class="line">	…… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到没,插入内核 apc 的时候可能会临时唤醒目标线程,插入用户 apc 的时候可能会强制唤醒目标线程。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">KiUnlinkThread</span><span class="params">(IN PKTHREAD Thread, IN NTSTATUS WaitStatus)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PKWAIT_BLOCK WaitBlock; </span><br><span class="line">	PKTIMER Timer; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关键。唤醒原因记录在线程结构的这个字段中,KiSwapContext返回的就是这个字段值 </span></span><br><span class="line">	Thread-&gt;WaitStatus |= WaitStatus;  </span><br><span class="line">	WaitBlock = Thread-&gt;WaitBlockList; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//让各个等待块脱离各自等待对象的队列 </span></span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">	&#123; </span><br><span class="line">		RemoveEntryList(&amp;WaitBlock-&gt;WaitListEntry); </span><br><span class="line">		WaitBlock = WaitBlock-&gt;NextWaitBlock; </span><br><span class="line">	&#125; <span class="keyword">while</span> (WaitBlock != Thread-&gt;WaitBlockList); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//脱离cpu的等待线程队列 </span></span><br><span class="line">	<span class="keyword">if</span> (Thread-&gt;WaitListEntry.Flink) </span><br><span class="line">		RemoveEntryList(&amp;Thread-&gt;WaitListEntry); </span><br><span class="line"></span><br><span class="line">	Timer = &amp;Thread-&gt;Timer; </span><br><span class="line">	<span class="keyword">if</span> (Timer-&gt;Header.Inserted) KxRemoveTreeTimer(Timer); </span><br><span class="line">	<span class="keyword">if</span> (Thread-&gt;Queue) Thread-&gt;Queue-&gt;CurrentCount++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面的这个函数只是脱离各个等待对象的等待块队列。<br>线程自己的等待块队列还在。 </p>
<p>现在看一下<code>KeWaitForSingleObject</code>那个函数内部调用的<code>KiSwapThread</code>。注意是<code>KiSwapThread</code>不是<code>KiSwapContext</code>。</p>
<h3 id="KiSwapThread"><a href="#KiSwapThread" class="headerlink" title="KiSwapThread"></a>KiSwapThread</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG FASTCALL <span class="title">KiSwapThread</span><span class="params">(IN PKTHREAD CurrentThread,IN PKPRCB Prcb)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BOOLEAN ApcState = FALSE; </span><br><span class="line">	KIRQL WaitIrql;<span class="comment">//上次切出时的irql </span></span><br><span class="line">	LONG_PTR WaitStatus;<span class="comment">//上次唤醒原因 </span></span><br><span class="line">	PKTHREAD NextThread; </span><br><span class="line">	KiAcquirePrcbLock(Prcb); </span><br><span class="line">	NextThread = Prcb-&gt;NextThread;<span class="comment">//当前的抢占者线程 </span></span><br><span class="line">	<span class="keyword">if</span> (NextThread) </span><br><span class="line">	&#123; </span><br><span class="line">		Prcb-&gt;NextThread = <span class="literal">NULL</span>; </span><br><span class="line">		Prcb-&gt;CurrentThread = NextThread; </span><br><span class="line">		NextThread-&gt;State = Running; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		NextThread = KiSelectReadyThread(<span class="number">0</span>, Prcb);<span class="comment">//调度处一个 </span></span><br><span class="line">		<span class="keyword">if</span> (NextThread) </span><br><span class="line">		&#123; </span><br><span class="line">			Prcb-&gt;CurrentThread = NextThread; </span><br><span class="line">			NextThread-&gt;State = Running; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123; </span><br><span class="line">			InterlockedOr((PLONG)&amp;KiIdleSummary, Prcb-&gt;SetMember); </span><br><span class="line">			NextThread = Prcb-&gt;IdleThread;<span class="comment">//使用空转线程 </span></span><br><span class="line">			Prcb-&gt;CurrentThread = NextThread; </span><br><span class="line">			NextThread-&gt;State = Running; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	KiReleasePrcbLock(Prcb); </span><br><span class="line"></span><br><span class="line">	WaitIrql = CurrentThread-&gt;WaitIrql;<span class="comment">//记录上次切出时的irql </span></span><br><span class="line">	MiSyncForContextSwitch(NextThread); </span><br><span class="line"></span><br><span class="line">	ApcState = KiSwapContext(CurrentThread, NextThread); </span><br><span class="line"></span><br><span class="line">	----------------------------------------华丽的分割线--------------------------------------- </span><br><span class="line">	----------------------------------------华丽的分割线--------------------------------------- </span><br><span class="line">	----------------------------------------华丽的分割线--------------------------------------- </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (ApcState)<span class="comment">//切回来后,例行执行内核apc </span></span><br><span class="line">	&#123; </span><br><span class="line">		KeLowerIrql(APC_LEVEL); </span><br><span class="line">		KiDeliverApc(KernelMode, <span class="literal">NULL</span>, <span class="literal">NULL</span>); </span><br><span class="line">		ASSERT(WaitIrql == PASSIVE_LEVEL); </span><br><span class="line">	&#125; </span><br><span class="line">	KeLowerIrql(WaitIrql); </span><br><span class="line">	WaitStatus = CurrentThread-&gt;WaitStatus;<span class="comment">//关键。返回该线程上次唤醒的原因 </span></span><br><span class="line">	<span class="keyword">return</span> WaitStatus; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信到此为止,大家理解了线程如何等待单个对象的机制了吧？</p>
<h2 id="KeWaitForMultipleObjects"><a href="#KeWaitForMultipleObjects" class="headerlink" title="KeWaitForMultipleObjects"></a>KeWaitForMultipleObjects</h2><p>一个线程可以同时等待对个对象我们看。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">KeWaitForMultipleObjects</span><span class="params">(IN ULONG Count,<span class="comment">//数组元素个数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                         IN PVOID Object[],<span class="comment">//等待对象数组 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                         IN WAIT_TYPE WaitType,<span class="comment">//WaitAll/AitAny </span></span></span></span><br><span class="line"><span class="function"><span class="params">                         IN KWAIT_REASON WaitReason,<span class="comment">//上次切换原因 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                         IN KPROCESSOR_MODE WaitMode,<span class="comment">//来自用户模式/内核模式的等待请求 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                         IN BOOLEAN Alertable,<span class="comment">//本次等待是否可提醒(指是否可被强制唤醒) </span></span></span></span><br><span class="line"><span class="function"><span class="params">                         IN PLARGE_INTEGER Timeout OPTIONAL,<span class="comment">//超时 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                         OUT PKWAIT_BLOCK WaitBlockArray OPTIONAL)</span><span class="comment">//等待块数组 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PKMUTANT CurrentObject; </span><br><span class="line">	PKWAIT_BLOCK WaitBlock; </span><br><span class="line">	PKTHREAD Thread = KeGetCurrentThread(); </span><br><span class="line">	PKWAIT_BLOCK TimerBlock = &amp;Thread-&gt;WaitBlock[TIMER_WAIT_BLOCK];<span class="comment">//定时器等待块是固定的 </span></span><br><span class="line">	PKTIMER Timer = &amp;Thread-&gt;Timer; </span><br><span class="line">	NTSTATUS WaitStatus = STATUS_SUCCESS; </span><br><span class="line">	BOOLEAN Swappable; </span><br><span class="line">	</span><br><span class="line">	PLARGE_INTEGER OriginalDueTime = Timeout; </span><br><span class="line">	LARGE_INTEGER DueTime, NewDueTime, InterruptTime; </span><br><span class="line">	ULONG Index, Hand = <span class="number">0</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!WaitBlockArray)<span class="comment">//没提供就使用内置的等待块数组(3个等待块+一个定时器等待块) </span></span><br><span class="line">	WaitBlockArray = &amp;Thread-&gt;WaitBlock[<span class="number">0</span>]; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!Thread-&gt;WaitNext) <span class="keyword">goto</span> WaitStart;<span class="comment">//首轮循环从WaitStart处开始 </span></span><br><span class="line">	Thread-&gt;WaitNext = FALSE; </span><br><span class="line">	KxMultiThreadWait();<span class="comment">//关键。与等待单个对象时使用的宏不相同 </span></span><br><span class="line">	<span class="keyword">for</span> (;;) </span><br><span class="line">		&#123; </span><br><span class="line">		Thread-&gt;Preempted = FALSE; </span><br><span class="line">		<span class="keyword">if</span> ((Thread-&gt;ApcState.KernelApcPending) &amp;&amp; !(Thread-&gt;SpecialApcDisable) &amp;&amp; (Thread-&gt;WaitIrql &lt; APC_LEVEL)) </span><br><span class="line">		&#123; </span><br><span class="line">			KiReleaseDispatcherLock(Thread-&gt;WaitIrql); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123; </span><br><span class="line">			Index = <span class="number">0</span>; </span><br><span class="line">		<span class="keyword">if</span> (WaitType == WaitAny) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">do</span> </span><br><span class="line">			&#123; </span><br><span class="line">				CurrentObject = (PKMUTANT)Object[Index]; </span><br><span class="line">				<span class="keyword">if</span> (CurrentObject-&gt;Header.Type == MutantObject) </span><br><span class="line">				&#123; </span><br><span class="line">					<span class="keyword">if</span> ((CurrentObject-&gt;Header.SignalState &gt; <span class="number">0</span>) || (Thread == CurrentObject-&gt;OwnerThread)) </span><br><span class="line">					&#123; </span><br><span class="line">						<span class="keyword">if</span> (CurrentObject-&gt;Header.SignalState != (LONG)MINLONG) </span><br><span class="line">						&#123; </span><br><span class="line">							KiSatisfyMutantWait(CurrentObject, Thread); </span><br><span class="line">							WaitStatus = Thread-&gt;WaitStatus | Index; </span><br><span class="line">							<span class="keyword">goto</span> DontWait;<span class="comment">//只要满足一个就退出函数 </span></span><br><span class="line">						&#125; </span><br><span class="line">						<span class="keyword">else</span> </span><br><span class="line">						&#123; </span><br><span class="line">							KiReleaseDispatcherLock(Thread-&gt;WaitIrql); </span><br><span class="line">							ExRaiseStatus(STATUS_MUTANT_LIMIT_EXCEEDED); </span><br><span class="line">						&#125; </span><br><span class="line">					&#125; </span><br><span class="line">				&#125; </span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (CurrentObject-&gt;Header.SignalState &gt; <span class="number">0</span>) </span><br><span class="line">				&#123; </span><br><span class="line">					KiSatisfyNonMutantWait(CurrentObject); </span><br><span class="line">					WaitStatus = Index; </span><br><span class="line">					<span class="keyword">goto</span> DontWait; <span class="comment">//只要满足一个就退出函数 </span></span><br><span class="line">				&#125; </span><br><span class="line">				Index++; </span><br><span class="line">			&#125; <span class="keyword">while</span> (Index &lt; Count); </span><br><span class="line">		&#125; </span><br><span class="line">		Else <span class="comment">//WaitAll </span></span><br><span class="line">		&#123; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123; </span><br><span class="line">			CurrentObject = (PKMUTANT)Object[Index]; </span><br><span class="line">			<span class="keyword">if</span> (CurrentObject-&gt;Header.Type == MutantObject) </span><br><span class="line">			&#123; </span><br><span class="line">			    <span class="keyword">if</span> ((Thread == CurrentObject-&gt;OwnerThread) &amp;&amp; </span><br><span class="line">			        (CurrentObject-&gt;Header.SignalState == (LONG)MINLONG)) </span><br><span class="line">			    &#123; </span><br><span class="line">			        KiReleaseDispatcherLock(Thread-&gt;WaitIrql); </span><br><span class="line">			        ExRaiseStatus(STATUS_MUTANT_LIMIT_EXCEEDED); </span><br><span class="line">			    &#125; </span><br><span class="line">			    <span class="keyword">else</span> <span class="keyword">if</span> ((CurrentObject-&gt;Header.SignalState &lt;= <span class="number">0</span>) &amp;&amp; </span><br><span class="line">			             (Thread != CurrentObject-&gt;OwnerThread)) </span><br><span class="line">			    &#123; </span><br><span class="line">			        <span class="keyword">break</span>;<span class="comment">//只要任有一个对象不满足,就要继续进入等待状态 </span></span><br><span class="line">			    &#125; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (CurrentObject-&gt;Header.SignalState &lt;= <span class="number">0</span>) </span><br><span class="line">			&#123; </span><br><span class="line">			    <span class="keyword">break</span>; <span class="comment">//只要任有一个对象不满足,就要继续进入等待状态 </span></span><br><span class="line">			&#125; </span><br><span class="line">			Index++; </span><br><span class="line">		&#125; <span class="keyword">while</span> (Index &lt; Count); </span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Index == Count)<span class="comment">//if 所有对象都有信号了 </span></span><br><span class="line">		&#123; </span><br><span class="line">			WaitBlock = WaitBlockArray; </span><br><span class="line">			<span class="keyword">do</span> </span><br><span class="line">			&#123; </span><br><span class="line">			    CurrentObject = (PKMUTANT)WaitBlock-&gt;Object; </span><br><span class="line">			    KiSatisfyObjectWait(CurrentObject, Thread); </span><br><span class="line">			    WaitBlock = WaitBlock-&gt;NextWaitBlock; </span><br><span class="line">			&#125; <span class="keyword">while</span>(WaitBlock != WaitBlockArray); </span><br><span class="line"></span><br><span class="line">			WaitStatus = Thread-&gt;WaitStatus;<span class="comment">//唤醒原因为‘真唤醒’类型 </span></span><br><span class="line">			<span class="keyword">goto</span> DontWait; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">		WaitStatus = KiCheckAlertability(Thread, Alertable, WaitMode); </span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (WaitStatus != STATUS_WAIT_0) <span class="keyword">break</span>; </span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (Timeout) </span><br><span class="line">		&#123; </span><br><span class="line">			InterruptTime.QuadPart = KeQueryInterruptTime(); </span><br><span class="line">			<span class="keyword">if</span> ((ULONGLONG)InterruptTime.QuadPart &gt;= Timer-&gt;DueTime.QuadPart) </span><br><span class="line">			&#123; </span><br><span class="line"></span><br><span class="line">			WaitStatus = STATUS_TIMEOUT; </span><br><span class="line">			<span class="keyword">goto</span> DontWait; </span><br><span class="line">			&#125; </span><br><span class="line">			Timer-&gt;Header.Inserted = TRUE; </span><br><span class="line">			WaitBlock-&gt;NextWaitBlock = TimerBlock; </span><br><span class="line">		&#125; </span><br><span class="line">		WaitBlock = WaitBlockArray; </span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123; </span><br><span class="line">			CurrentObject = WaitBlock-&gt;Object; </span><br><span class="line">			InsertTailList(&amp;CurrentObject-&gt;Header.WaitListHead,&amp;WaitBlock-&gt;WaitListEntry); </span><br><span class="line">			WaitBlock = WaitBlock-&gt;NextWaitBlock; </span><br><span class="line">		&#125; <span class="keyword">while</span> (WaitBlock != WaitBlockArray); </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (Thread-&gt;Queue) KiActivateWaiterQueue(Thread-&gt;Queue); </span><br><span class="line">		</span><br><span class="line">		Thread-&gt;State = Waiting; </span><br><span class="line">		KiAddThreadToWaitList(Thread, Swappable); </span><br><span class="line">		KiSetThreadSwapBusy(Thread); </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (Timeout) </span><br><span class="line">			KxInsertTimer(Timer, Hand); </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			KiReleaseDispatcherLockFromDpcLevel(); </span><br><span class="line">		WaitStatus = KiSwapThread(Thread, KeGetCurrentPrcb()); </span><br><span class="line"></span><br><span class="line">		----------------------------------------华丽的分割线--------------------------------------- </span><br><span class="line">		----------------------------------------华丽的分割线---------------------------------------</span><br><span class="line">		----------------------------------------华丽的分割线---------------------------------------</span><br><span class="line">		<span class="comment">//if 唤醒原因不是临时唤醒,直接退出整个函数,退出睡眠状态 </span></span><br><span class="line">		<span class="keyword">if</span> (WaitStatus != STATUS_KERNEL_APC) <span class="keyword">return</span> WaitStatus; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//否则,若是临时唤醒回来的,则进入下一轮循环,继续去测试等待对象的信号情况 </span></span><br><span class="line">		<span class="keyword">if</span> (Timeout) </span><br><span class="line">			Timeout = KiRecalculateDueTime(OriginalDueTime,&amp;DueTime,&amp;NewDueTime); </span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">WaitStart: </span><br><span class="line">		Thread-&gt;WaitIrql = KeRaiseIrqlToSynchLevel(); </span><br><span class="line">		KxMultiThreadWait(); </span><br><span class="line">		KiAcquireDispatcherLockAtDpcLevel(); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	KiReleaseDispatcherLock(Thread-&gt;WaitIrql); </span><br><span class="line">	<span class="keyword">return</span> WaitStatus; </span><br><span class="line"></span><br><span class="line">DontWait: </span><br><span class="line">	KiReleaseDispatcherLockFromDpcLevel(); </span><br><span class="line">	KiAdjustQuantumThread(Thread); </span><br><span class="line">	<span class="keyword">return</span> WaitStatus; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了以下宏 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KxMultiThreadWait()                                                                           </span></span><br><span class="line">	Thread-&gt;WaitBlockList = WaitBlockArray;</span><br><span class="line">	Index = <span class="number">0</span>;   </span><br><span class="line">	<span class="comment">//构造好本线程的等待块链表                                                                                  </span></span><br><span class="line">	<span class="keyword">do</span>                                                                       </span><br><span class="line">	&#123;                                                                                                        </span><br><span class="line">		WaitBlock = &amp;WaitBlockArray[Index];                                  </span><br><span class="line">		WaitBlock-&gt;Object = Object[Index];                                   </span><br><span class="line">		WaitBlock-&gt;WaitKey = (USHORT)Index;<span class="comment">//关键                                  </span></span><br><span class="line">		WaitBlock-&gt;WaitType = WaitType;<span class="comment">//所有等待块的等待类型都相同                                       </span></span><br><span class="line">		WaitBlock-&gt;Thread = Thread;                                                                             </span><br><span class="line">		WaitBlock-&gt;NextWaitBlock = &amp;WaitBlockArray[Index + <span class="number">1</span>];               </span><br><span class="line">		Index++;                                                             </span><br><span class="line">	&#125; <span class="keyword">while</span> (Index &lt; Count);                                                                                    </span><br><span class="line">	</span><br><span class="line">	WaitBlock-&gt;NextWaitBlock = WaitBlockArray; <span class="comment">//单循环链表                                                     </span></span><br><span class="line">	Thread-&gt;WaitStatus = STATUS_WAIT_0;                                                                         </span><br><span class="line">	<span class="keyword">if</span> (Timeout)                                                             </span><br><span class="line">	&#123;                                                                                                           </span><br><span class="line">		TimerBlock-&gt;NextWaitBlock = WaitBlockArray;                                                             </span><br><span class="line">		KxSetTimerForThreadWait(Timer, *Timeout, &amp;Hand);                                                 </span><br><span class="line">		DueTime.QuadPart = Timer-&gt;DueTime.QuadPart;                                                             </span><br><span class="line">		InitializeListHead(&amp;Timer-&gt;Header.WaitListHead);                     </span><br><span class="line">	&#125;                                                                                                           </span><br><span class="line">	Thread-&gt;Alertable = Alertable;<span class="comment">//是否可被强制唤醒                                           </span></span><br><span class="line">	Thread-&gt;WaitMode = WaitMode;<span class="comment">//来自用户模式/内核模式的等待请求                                             </span></span><br><span class="line">	Thread-&gt;WaitReason = WaitReason;<span class="comment">//上次被切原因                                                              </span></span><br><span class="line">	Thread-&gt;WaitListEntry.Flink = <span class="literal">NULL</span>;                                      </span><br><span class="line">	Swappable = KiCheckThreadStackSwap(Thread, WaitMode);                                                       </span><br><span class="line">	Thread-&gt;WaitTime = KeTickCount.LowPart;<span class="comment">//记录上次被切时间</span></span><br></pre></td></tr></table></figure>
<p>这段代码我想不用多解释了吧。唯一需要注意的是使用了不同的宏;</p>
<p><br></p>
<h2 id="同步对象"><a href="#同步对象" class="headerlink" title="同步对象"></a>同步对象</h2><p>弄懂了线程的等待唤醒机制后,下面我们看各种具体等待对象(又叫同步对象)的原理<br>同步对象：(互斥、事件、信号量、自旋锁)</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSEMAPHORE</span> &#123;</span> </span><br><span class="line">  DISPATCHER_HEADER Header;<span class="comment">//公共头部 </span></span><br><span class="line">  LONG Limit;<span class="comment">//信号量的最大信号个数 </span></span><br><span class="line">&#125; KSEMAPHORE, *PKSEMAPHORE;</span><br></pre></td></tr></table></figure>
<h4 id="NtCreateSemaphore"><a href="#NtCreateSemaphore" class="headerlink" title="NtCreateSemaphore"></a>NtCreateSemaphore</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtCreateSemaphore</span><span class="params">(OUT PHANDLE SemaphoreHandle,<span class="comment">//返回信号量对象的句柄 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                  IN ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="function"><span class="params">                  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,<span class="comment">//信号量的名称及其他属性 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                  IN LONG InitialCount,<span class="comment">//信号量的初始信号个数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                  IN LONG MaximumCount)</span><span class="comment">//支持的最大信号个数 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PKSEMAPHORE Semaphore; </span><br><span class="line">	HANDLE hSemaphore; </span><br><span class="line">	KPROCESSOR_MODE PreviousMode = ExGetPreviousMode(); </span><br><span class="line">	NTSTATUS Status; </span><br><span class="line">	<span class="keyword">if</span> (PreviousMode != KernelMode) </span><br><span class="line">	&#123; </span><br><span class="line">		_SEH2_TRY </span><br><span class="line">		&#123; </span><br><span class="line">			ProbeForWriteHandle(SemaphoreHandle); </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">		&#123; </span><br><span class="line">			_SEH2_YIELD(<span class="keyword">return</span> _SEH2_GetExceptionCode()); </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_END; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> ((MaximumCount &lt;= <span class="number">0</span>) || (InitialCount &lt; <span class="number">0</span>) || (InitialCount &gt; MaximumCount)) </span><br><span class="line">	<span class="keyword">return</span> STATUS_INVALID_PARAMETER; </span><br><span class="line">	<span class="comment">//信号量也是一种内核对象 </span></span><br><span class="line">	Status = ObCreateObject(PreviousMode,ExSemaphoreObjectType,ObjectAttributes,PreviousMode, </span><br><span class="line">	            <span class="literal">NULL</span>,<span class="keyword">sizeof</span>(KSEMAPHORE),<span class="number">0</span>,<span class="number">0</span>, (PVOID*)&amp;Semaphore); </span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//初始化对象结构 </span></span><br><span class="line">		KeInitializeSemaphore(Semaphore,InitialCount,MaximumCount); </span><br><span class="line">		<span class="comment">//插入对象目录和句柄表 </span></span><br><span class="line">		Status = ObInsertObject((PVOID)Semaphore,<span class="literal">NULL</span>,DesiredAccess,<span class="number">0</span>,<span class="literal">NULL</span>,&amp;hSemaphore); </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">		&#123; </span><br><span class="line">		_SEH2_TRY </span><br><span class="line">		&#123; </span><br><span class="line">			*SemaphoreHandle = hSemaphore; </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_EXCEPT(ExSystemExceptionFilter()) </span><br><span class="line">		&#123; </span><br><span class="line">			Status = _SEH2_GetExceptionCode(); </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_END; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KeInitializeSemaphore"><a href="#KeInitializeSemaphore" class="headerlink" title="KeInitializeSemaphore"></a>KeInitializeSemaphore</h4><p>关键看下面的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KeInitializeSemaphore</span><span class="params">(IN PKSEMAPHORE Semaphore,IN LONG Count,IN LONG Limit)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    KeInitializeDispatcherHeader(&amp;Semaphore-&gt;Header,SemaphoreObject, </span><br><span class="line">                                 <span class="keyword">sizeof</span>(KSEMAPHORE) / <span class="keyword">sizeof</span>(ULONG),Count); </span><br><span class="line">    Semaphore-&gt;Limit = Limit; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KeInitializeDispatcherHeader(Header, t, s, State)                  \ </span></span><br><span class="line">&#123;                                                                          \ </span><br><span class="line">    (Header)-&gt;Type = t;                                                    \ </span><br><span class="line">    (Header)-&gt;Absolute = <span class="number">0</span>;                                                \ </span><br><span class="line">    (Header)-&gt;Size = s;                                                    \ </span><br><span class="line">    (Header)-&gt;Inserted = <span class="number">0</span>;                                                \ </span><br><span class="line">    (Header)-&gt;SignalState = State;<span class="comment">//初始信号个数                           \ </span></span><br><span class="line">    InitializeListHead(&amp;((Header)-&gt;WaitListHead));<span class="comment">//初始化等待线程队列     \ </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号量对象可用于<code>WaitFor</code>系列函数中。<br>每得到一个信号量,<code>SignalState</code>就递减。 当<code>SignalState</code>减到 0 时,就需要等待其他线程释放信号量。 </p>
<h4 id="NtReleaseSemaphore"><a href="#NtReleaseSemaphore" class="headerlink" title="NtReleaseSemaphore"></a>NtReleaseSemaphore</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtReleaseSemaphore</span><span class="params">(IN HANDLE SemaphoreHandle, </span></span></span><br><span class="line"><span class="function"><span class="params">                   IN LONG ReleaseCount,<span class="comment">//一次可以释放多个信号量,这将一次唤醒多个线程 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   OUT PLONG PreviousCount OPTIONAL)</span><span class="comment">//返回之前的信号个数 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	KPROCESSOR_MODE PreviousMode = ExGetPreviousMode(); </span><br><span class="line">	PKSEMAPHORE Semaphore; </span><br><span class="line">	NTSTATUS Status; </span><br><span class="line">	<span class="keyword">if</span> ((PreviousCount) &amp;&amp; (PreviousMode != KernelMode)) </span><br><span class="line">	&#123; </span><br><span class="line">		_SEH2_TRY </span><br><span class="line">		&#123; </span><br><span class="line">			ProbeForWriteLong(PreviousCount); </span><br><span class="line">		 &#125; </span><br><span class="line">		_SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">		&#123; </span><br><span class="line">			_SEH2_YIELD(<span class="keyword">return</span> _SEH2_GetExceptionCode()); </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_END; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (ReleaseCount &lt;= <span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span> STATUS_INVALID_PARAMETER; </span><br><span class="line"></span><br><span class="line">	Status = ObReferenceObjectByHandle(SemaphoreHandle,SEMAPHORE_MODIFY_STATE, </span><br><span class="line">						ExSemaphoreObjectType,PreviousMode, </span><br><span class="line">						(PVOID*)&amp;Semaphore,<span class="literal">NULL</span>); </span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">		_SEH2_TRY </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">//实质函数 </span></span><br><span class="line">			LONG PrevCount = KeReleaseSemaphore(Semaphore,IO_NO_INCREMENT, ReleaseCount,FALSE); </span><br><span class="line">			<span class="keyword">if</span> (PreviousCount) *PreviousCount = PrevCount; </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_EXCEPT(ExSystemExceptionFilter()) </span><br><span class="line">		&#123; </span><br><span class="line">			Status = _SEH2_GetExceptionCode(); </span><br><span class="line">		&#125; </span><br><span class="line">		_SEH2_END; </span><br><span class="line">		ObDereferenceObject(Semaphore); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LONG <span class="title">KeReleaseSemaphore</span><span class="params">(IN PKSEMAPHORE Semaphore, </span></span></span><br><span class="line"><span class="function"><span class="params">                   IN KPRIORITY Increment,<span class="comment">//优先级增量 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   IN LONG Adjustment,<span class="comment">// 一次可以释放多个信号量,这将一次唤醒多个线程 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   IN BOOLEAN Wait)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	LONG InitialState, State; </span><br><span class="line">	KIRQL OldIrql; </span><br><span class="line">	PKTHREAD CurrentThread; </span><br><span class="line">	ASSERT_IRQL_LESS_OR_EQUAL(DISPATCH_LEVEL); </span><br><span class="line">	OldIrql = KiAcquireDispatcherLock(); </span><br><span class="line"></span><br><span class="line">	InitialState = Semaphore-&gt;Header.SignalState; </span><br><span class="line">	State = InitialState + Adjustment;<span class="comment">//一次增加N个信号 </span></span><br><span class="line">	<span class="keyword">if</span> ((Semaphore-&gt;Limit &lt; State) || Adjustment&lt; <span class="number">0</span>)) </span><br><span class="line">	&#123; </span><br><span class="line">		KiReleaseDispatcherLock(OldIrql); </span><br><span class="line">		ExRaiseStatus(STATUS_SEMAPHORE_LIMIT_EXCEEDED); </span><br><span class="line">	&#125; </span><br><span class="line">	Semaphore-&gt;Header.SignalState = State; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//没释放一次信号量,就会尝试唤醒在该信号量对象上等待的所有线程 </span></span><br><span class="line">	<span class="keyword">if</span> (!(InitialState) &amp;&amp; !(IsListEmpty(&amp;Semaphore-&gt;Header.WaitListHead))) </span><br><span class="line">		KiWaitTest(&amp;Semaphore-&gt;Header, Increment); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Wait == FALSE) </span><br><span class="line">		KiReleaseDispatcherLock(OldIrql); </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		CurrentThread = KeGetCurrentThread(); </span><br><span class="line">		CurrentThread-&gt;WaitNext = TRUE; </span><br><span class="line">		CurrentThread-&gt;WaitIrql = OldIrql; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> InitialState; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上如此简单而已。只是需要注意信号量对象一有信号,就会调用<code>KiWaitTest</code></p>
<p><br></p>
<h3 id="互斥对象"><a href="#互斥对象" class="headerlink" title="互斥对象"></a>互斥对象</h3><p>互斥对象的原理:互斥对象有点特殊,他有一个<code>拥有者线程</code>,并且同一时刻最多只能让一个线程拥有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KMUTANT</span> &#123;</span> </span><br><span class="line">	DISPATCHER_HEADER Header;<span class="comment">//公共头 </span></span><br><span class="line">	LIST_ENTRY MutantListEntry;<span class="comment">//用来挂入拥有者线程的互斥对象链表 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span> *<span class="title">RESTRICTED_POINTER</span> <span class="title">OwnerThread</span>;</span><span class="comment">//关键。当前拥有者线程 </span></span><br><span class="line">	BOOLEAN Abandoned;<span class="comment">//是否被拥有者线程因意外终止而抛弃了 </span></span><br><span class="line">	BOOL ApcDisable;<span class="comment">//表示获得互斥体,进入临界区前,是否需要禁用内核APC(用于用户模式的Mutex) </span></span><br><span class="line">&#125; KMUTANT, *PKMUTANT, KMUTEX, *PKMUTEX;</span><br></pre></td></tr></table></figure>
<h4 id="KeInitializeMutant"><a href="#KeInitializeMutant" class="headerlink" title="KeInitializeMutant"></a>KeInitializeMutant</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">VOID </span><br><span class="line">KeInitializeMutant(IN PKMUTANT Mutant, </span><br><span class="line">                   IN BOOLEAN InitialOwner)<span class="comment">//指当前线程是否初始为该互斥对象的拥有者 </span></span><br><span class="line">&#123; </span><br><span class="line">	PKTHREAD CurrentThread; </span><br><span class="line">	KIRQL OldIrql; </span><br><span class="line">	<span class="keyword">if</span> (InitialOwner) </span><br><span class="line">	&#123; </span><br><span class="line">		CurrentThread = KeGetCurrentThread(); </span><br><span class="line">		Mutant-&gt;OwnerThread = CurrentThread;<span class="comment">//看 </span></span><br><span class="line">		OldIrql = KiAcquireDispatcherLock(); </span><br><span class="line">		<span class="comment">//挂入本线程当前拥有的互斥对象链表 </span></span><br><span class="line">		InsertTailList(&amp;CurrentThread-&gt;MutantListHead,&amp;Mutant-&gt;MutantListEntry); </span><br><span class="line">		KiReleaseDispatcherLock(OldIrql); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		Mutant-&gt;OwnerThread = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line">	KeInitializeDispatcherHeader(&amp;Mutant-&gt;Header,MutantObject, <span class="keyword">sizeof</span>(KMUTANT) / <span class="keyword">sizeof</span>(ULONG), InitialOwner ? <span class="number">0</span>: <span class="number">1</span>);<span class="comment">//初始对外信号个数为0或者1 </span></span><br><span class="line">	</span><br><span class="line">	Mutant-&gt;Abandoned = FALSE; </span><br><span class="line"></span><br><span class="line">	Mutant-&gt;ApcDisable = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为互斥对象有一个拥有者线程,所以互斥对象是可以重入的,也即一个线程可以反复多次调用,等待同一个互斥对象</p>
<p>如:</p>
<ul>
<li>WaitForSingleObject(mutex1); //获得互斥对象,同时递增拥有计数其他代码; </li>
<li>WaitForSingleObject(mutex1);//递增拥有计数 其他代码; </li>
<li>ReleaseMutex(mutex1); //释放拥有计数 其他代码; </li>
<li>ReleaseMurex(mutex1);// 释放拥有计数 </li>
</ul>
<h4 id="NtReleaseMutant"><a href="#NtReleaseMutant" class="headerlink" title="NtReleaseMutant"></a>NtReleaseMutant</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtReleaseMutant</span><span class="params">(IN HANDLE MutantHandle, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN PLONG PreviousCount OPTIONAL)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PKMUTANT Mutant; </span><br><span class="line">    KPROCESSOR_MODE PreviousMode = ExGetPreviousMode(); </span><br><span class="line">    NTSTATUS Status; </span><br><span class="line">    <span class="keyword">if</span> ((PreviousCount) &amp;&amp; (PreviousMode != KernelMode)) </span><br><span class="line">    &#123; </span><br><span class="line">        _SEH2_TRY </span><br><span class="line">        &#123; </span><br><span class="line">            ProbeForWriteLong(PreviousCount); </span><br><span class="line">        &#125; </span><br><span class="line">        _SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">        &#123; </span><br><span class="line">            _SEH2_YIELD(<span class="keyword">return</span> _SEH2_GetExceptionCode()); </span><br><span class="line">        &#125; </span><br><span class="line">        _SEH2_END; </span><br><span class="line">    &#125; </span><br><span class="line">    Status = ObReferenceObjectByHandle(MutantHandle,MUTANT_QUERY_STATE,ExMutantObjectType, </span><br><span class="line">                                       PreviousMode, (PVOID*)&amp;Mutant,<span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">    &#123; </span><br><span class="line">        _SEH2_TRY </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//释放互斥对象,释放一次本线程对它的一个拥有计数 </span></span><br><span class="line">            LONG Prev = KeReleaseMutant(Mutant,MUTANT_INCREMENT,FALSE,FALSE); </span><br><span class="line">            <span class="keyword">if</span> (PreviousCount) *PreviousCount = Prev; </span><br><span class="line">        &#125; </span><br><span class="line">        _SEH2_EXCEPT(ExSystemExceptionFilter()) </span><br><span class="line">        &#123; </span><br><span class="line">            Status = _SEH2_GetExceptionCode(); </span><br><span class="line"> </span><br><span class="line">        &#125; </span><br><span class="line">        _SEH2_END; </span><br><span class="line">        ObDereferenceObject(Mutant); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> Status; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LONG <span class="title">KeReleaseMutant</span><span class="params">(IN PKMUTANT Mutant, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN KPRIORITY Increment, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN BOOLEAN Abandon,<span class="comment">//是否是因为线程意外终止而抛弃的 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN BOOLEAN Wait)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	KIRQL OldIrql; </span><br><span class="line">	LONG PreviousState; </span><br><span class="line">	PKTHREAD CurrentThread = KeGetCurrentThread(); </span><br><span class="line">	BOOLEAN EnableApc = FALSE; </span><br><span class="line">	ASSERT_IRQL_LESS_OR_EQUAL(DISPATCH_LEVEL); </span><br><span class="line">	OldIrql = KiAcquireDispatcherLock(); </span><br><span class="line">	PreviousState = Mutant-&gt;Header.SignalState;<span class="comment">//先前的拥有计数 </span></span><br><span class="line">	<span class="keyword">if</span> (Abandon == FALSE)<span class="comment">//最典型 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (Mutant-&gt;OwnerThread != CurrentThread) </span><br><span class="line">		&#123; </span><br><span class="line">			KiReleaseDispatcherLock(OldIrql); </span><br><span class="line">			ExRaiseStatus(Mutant-&gt;Abandoned ? STATUS_ABANDONED :STATUS_MUTANT_NOT_OWNED); </span><br><span class="line">		&#125; </span><br><span class="line">		Mutant-&gt;Header.SignalState++;<span class="comment">//递增对外(指对其他线程)的信号个数 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		Mutant-&gt;Header.SignalState = <span class="number">1</span>;<span class="comment">//复位成1,表示直接对外有信号 </span></span><br><span class="line">		Mutant-&gt;Abandoned = TRUE;<span class="comment">//标记为被拥有者线程意外抛弃了 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (Mutant-&gt;Header.SignalState == <span class="number">1</span>)<span class="comment">//如果该互斥对象变得对其他线程可用了 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (PreviousState &lt;= <span class="number">0</span>)<span class="comment">//若是正常释放的互斥对象(非意外终止原因) </span></span><br><span class="line">		&#123; </span><br><span class="line">			RemoveEntryList(&amp;Mutant-&gt;MutantListEntry);<span class="comment">//本线程不再拥有该互斥对象 </span></span><br><span class="line">			EnableApc = Mutant-&gt;ApcDisable; </span><br><span class="line">		&#125; </span><br><span class="line">		Mutant-&gt;OwnerThread = <span class="literal">NULL</span>; <span class="comment">//不再有拥有者线程了 </span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (!IsListEmpty(&amp;Mutant-&gt;Header.WaitListHead)) </span><br><span class="line">			KiWaitTest(&amp;Mutant-&gt;Header, Increment);<span class="comment">//关键。尝试唤醒其他线程 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (Wait == FALSE) </span><br><span class="line">		KiReleaseDispatcherLock(OldIrql); </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		CurrentThread-&gt;WaitNext = TRUE; </span><br><span class="line">		CurrentThread-&gt;WaitIrql = OldIrql; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (EnableApc) KeLeaveCriticalRegion(); </span><br><span class="line">	<span class="keyword">return</span> PreviousState; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>互斥对象的原理就这样,除了普通的互斥体,内核实际上还提供了一种快速互斥体,那种互斥体不再可重入。 互斥对象之所以设计成可重入的,可嵌套的,是有其原因的,有其好处的。<br>比如如果不能重入,那么在内层的<code>WaiFor</code>操作就会一直阻塞,等待外层的<code>WaitFor</code>操作释放互斥对象,这样就会死锁。</p>
<p><br></p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>事件对象的原理,事件分为两种事件</p>
<ul>
<li>1、 自动复位型,又叫<code>SynchronizationEvent</code> </li>
<li>2、 手动复位型事件,又叫<code>NotificationEvent</code></li>
</ul>
<p>前者类型由于事件有信号号,马上又自动复位,所以一次只能唤醒一个线程,后者类型则类似广播通知, 一次可以唤醒等待该事件的所有线程。</p>
<h4 id="KeSetEvent"><a href="#KeSetEvent" class="headerlink" title="KeSetEvent"></a>KeSetEvent</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">KeSetEvent</span><span class="params">(IN PKEVENT Event, </span></span></span><br><span class="line"><span class="function"><span class="params">           IN KPRIORITY Increment, </span></span></span><br><span class="line"><span class="function"><span class="params">           IN BOOLEAN Wait)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	KIRQL OldIrql; </span><br><span class="line">	LONG PreviousState; </span><br><span class="line">	PKTHREAD Thread; </span><br><span class="line">	ASSERT_IRQL_LESS_OR_EQUAL(DISPATCH_LEVEL); </span><br><span class="line">	<span class="keyword">if</span> ((Event-&gt;Header.Type == EventNotificationObject) &amp;&amp; (Event-&gt;Header.SignalState == <span class="number">1</span>) &amp;&amp; !(Wait)) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">return</span> TRUE; </span><br><span class="line">	&#125; </span><br><span class="line">	OldIrql = KiAcquireDispatcherLock(); </span><br><span class="line">	PreviousState = Event-&gt;Header.SignalState; </span><br><span class="line">	Event-&gt;Header.SignalState = <span class="number">1</span>;<span class="comment">//置为有信号状态 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(PreviousState) &amp;&amp; !(IsListEmpty(&amp;Event-&gt;Header.WaitListHead)))<span class="comment">//如果变得有信号 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (Event-&gt;Header.Type == EventNotificationObject) <span class="comment">//唤醒所有正在等待的线程 </span></span><br><span class="line">			KxUnwaitThread(&amp;Event-&gt;Header, Increment);  </span><br><span class="line">		Else <span class="comment">//唤醒队列中的第一个等待类型为WaitAny的线程 </span></span><br><span class="line">			KxUnwaitThreadForEvent(Event, Increment);  </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (!Wait) </span><br><span class="line">		KiReleaseDispatcherLock(OldIrql); </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		Thread = KeGetCurrentThread(); </span><br><span class="line">		Thread-&gt;WaitNext = TRUE; </span><br><span class="line">		Thread-&gt;WaitIrql = OldIrql; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> PreviousState; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KeResetEvent"><a href="#KeResetEvent" class="headerlink" title="KeResetEvent"></a>KeResetEvent</h4><p>手动复位型事件事件需要手动调用下面的函数复位事件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG  <span class="title">KeResetEvent</span><span class="params">(IN PKEVENT Event)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    KIRQL OldIrql; </span><br><span class="line">    LONG PreviousState; </span><br><span class="line">    ASSERT_IRQL_LESS_OR_EQUAL(DISPATCH_LEVEL); </span><br><span class="line"></span><br><span class="line">    OldIrql = KiAcquireDispatcherLock(); </span><br><span class="line">    PreviousState = Event-&gt;Header.SignalState; </span><br><span class="line">    </span><br><span class="line">    Event-&gt;Header.SignalState = <span class="number">0</span>;<span class="comment">//复位成无信号状态 </span></span><br><span class="line">    KiReleaseDispatcherLock(OldIrql); </span><br><span class="line">    <span class="keyword">return</span> PreviousState; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>互斥、事件、信号量的原理都这么简单。在此不多说了。     </p>
<p><br></p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p><code>#define KeAcquireSpinLock(SpinLock,OldIrql)  *(OldIrql) = KeAcquireSpinLockRaiseToDpc(SpinLock)</code></p>
<p>ReactOS 的实现原理与 Windows 的有出入,在此引用另外一位作者的分析成果:</p>
<blockquote>
<p>来源地址：<a href="http://bbs.pediy.com/showthread.php?t=74502" target="_blank" rel="noopener">http://bbs.pediy.com/showthread.php?t=74502</a></p>
</blockquote>
<p>总结下自旋锁的实现</p>
<ul>
<li>1、在单核系统中就是将cpu的irql提到<code>DISPATCH_LEVEL</code>,防止线程切换,从而达到同步的目的 </li>
<li>2、在多核系统中,先将当前cpu提到<code>DISPATCH_LEVEL</code>,防止当前cpu上发生线程切换。然后不停的使用lock 前缀指令,锁定内存总线,忙式测试自旋锁的最低位是否标记处于了空闲状态。 </li>
</ul>
<p>由此可以看出,在多cpu系统中,自旋锁可以用来实现多个cpu之间的同步。原理就是lock总线。<br>自旋锁的用途之一：内联钩子的多cpu同步问题。 </p>
<p>先讨论单cpu上的同步问题:<br>内联钩子一般修改了函数的前5B为<code>jmp xxxxxxxx</code>指令,共5个字节。<br>由于内联函数在hook的过程中,其他线程可能正在执行这个函数,因此必须确保同步,否则,极易引发蓝屏崩溃。</p>
<blockquote>
<p>为什么呢？</p>
</blockquote>
<p>巧就巧在hook 修改的是5个字节,若是&lt;=4B的话,由于32位系统是以4B为单位访问内存单元的,4B区域的修改必定能用一 条简单的MOV类似指令完成修改,就不会存在同步问题。</p>
<p>而现在要改的是5个字节,若不加同步措施,假设下面一种情形：正在进行hook的线程刚好使用了一条mov指令改完了前4B,正准备改下一个字节的时候结果 发生了线程切换,另外一个线程来到这个函数入口时,因为前4B已经被改成<code>jmp xxxxxxxx</code>指令的前4B内容, 而第5个字节尚未改变,于是此时的前5B就是<code>Jmp xxxxxx xx</code> 形式,这导致错误的构造了jmp指令的 操作码部分,将跳转到一个未知地方,引发不可预料的错误,常见现象就是蓝屏。</p>
<p>前面5B,实际上是指前面8B的修改操作必须作为原子过程完成。</p>
<blockquote>
<p>怎么让他原子呢？ </p>
</blockquote>
<p>第一步：修改前,将当前cpu的irql提升至<code>DISPATCH_LEVEL</code>,防止当前cpu上发生线程切换。<br>    然后讨论多cpu同步问题<br>    在多cpu机器上同步问题更复杂,除了需要保证同一个cpu上的线程同步,还需要保证各cpu之间同步<br>第二步：给其他各cpu发送一个DPC函数过去,DPC函数本身运行在<code>DISPATCH_LEVEL</code>即<br>    所以可以让其他cpu 始终运行在我们指定的DPC函数内,防止其他cpu上发生线程切换。<br>第三步：当确保了所有cpu都不会发生线程切换后,修改前5B进行hook,完事后通知其他cpu的DPC函数退出。 </p>
<p>在上面的过程中,当前cpu与其他cpu之间,必须使用自选锁方式,读取各个DPC函数的运行状态和hook 状态。(详见《Rootkit—Windows内核安全防护》) </p>
<p>附:<br>Lock指令前缀的用途：一句话用来将一条指令变成<code>原子</code>的 假设内存单元<code>0x11110000</code>处存放着一个公共的计时器变量,且初值为100<br>那么考虑两个cpu同时执行<code>inc [0x11110000]</code> 这条指令的情况。</p>
<p>本来想要的目标是两个cpu一前一后执行 这条指令,最终结果变成102的。但是如果不加lock前缀,直接执行的话,由于这条指令内部分为取指、 分析、取数、运算、回写这几个阶段,假设第一个cpu刚好取出了数据100,然后释放了内存总线(同时另 一个cpu在此时将获得内存总线,然后他也同样去取数据,取出的也是100)</p>
<p>然后计算得出101,然后占用内存总线,回写数据到<code>0x11110000</code>处,变成101,完事后,另外一个cpu也将进行同样的计算,得出101,回 写到<code>0x11110000</code>处。最终<code>0x11110000</code>处的值是101而不是102。</p>
<p>这就是一种典型的多cpu同步引起的问题, 其根源在于指令内部是分阶段占用内存总线的<br>而lock前缀指示cpu：在整个指令的执行过程中全程独占总线,直到指令执行完毕后才释放。 </p>
<p><br><br><br></p>
<h1 id="消息与钩子"><a href="#消息与钩子" class="headerlink" title="消息与钩子"></a>消息与钩子</h1><p>众所周知,Windows 系统是消息驱动的,现在我们就来看 Windows 的消息机制. </p>
<p>早期的 Windows 的窗口图形机制是在用户空间实现的,后来为了提高图形处理效率,将这部分移入内核空间, 在<code>Win32k.sys</code>模块中实现。<br>这个模块作为一个扩展的内核模块,提高了一个扩展额系统服务表,专用于窗口图形操作,相应的这个模块中添加了一个扩展系统调用服务表<code>Shadow SSDT</code><br>以及一个扩展的系统调用服务表描述符表：<code>KeServiceDescriptorTableShadow</code>(系统中不仅有两张 SSDT,还有两张系统服务表描述符表)。<br>当一个线程首次调用这个模块中的系统服务函数时,这个线程就自然变成了 GUI 线程。</p>
<p>GUI 线程结构的<code>ServiceTable</code>指向的就是这个<code>shadow</code>描述符表。 </p>
<blockquote>
<p>那么消息机制是如何运作的呢？</p>
</blockquote>
<p>当用户运行一个应用程序,通过对鼠标的点击或键盘按键,产生一些特定事件。由于Windows一直监控着I/O设备,该事件首先会被翻译成消息,由系统捕获,存放于系统消息队列。<br>经分析Windows知道该消息应由那个应用程序处理,则拷贝到相应的应用程序消息队列。<br>由于消息循环不断检索自身的消息队列,当发现应用程序消息队列里有消息,就用<code>GetMessage()</code>取出消息,封装成Msg()结构。如果该消息是由键盘按键产生的,用<code>TranslateMessage()</code>翻译为<code>WM_CHAR</code>消息,否则用<code>DisPatchMessage()</code>将取出的消息分发到相应的应用程序窗口,交由窗口处理程序处理。</p>
<p>Windows为每个窗体预留了过程窗口函数,该函数是一个回掉函数,由系统调用应用程序不能调用。<br>程序员可以通过重载该函数处理我们<code>感兴趣</code>的消息。<br>对于不感兴趣的消息,则由系统默认的窗口过程处理程序做出处理。</p>
<h2 id="转变GUI线程"><a href="#转变GUI线程" class="headerlink" title="转变GUI线程"></a>转变GUI线程</h2><p>指向这个表的系统服务号的 bit12 位(也即第 13 位)为 1,如<code>0x1XXX</code>表示使用的是<code>shadow</code>服务表。 每个线程创建时都是普通线程,但是只要那个线程在运行的过程中发起了一次对<code>win32k.sys</code>模块中的系统调用,就会转变成 GUI 线程</p>
<p>下面的函数就是这个用途。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">PsConvertToGuiThread</span><span class="params">(VOID)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	ULONG_PTR NewStack; </span><br><span class="line">	PVOID OldStack; </span><br><span class="line">	PETHREAD Thread = PsGetCurrentThread(); </span><br><span class="line">	PEPROCESS Process = PsGetCurrentProcess(); </span><br><span class="line">	NTSTATUS Status; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (KeGetPreviousMode() == KernelMode) </span><br><span class="line">		<span class="keyword">return</span> STATUS_INVALID_PARAMETER; </span><br><span class="line"></span><br><span class="line">	ASSERT(PspW32ProcessCallout != <span class="literal">NULL</span>);<span class="comment">//确保win32k.sys模块已加载到内存 </span></span><br><span class="line">	<span class="keyword">if</span> (Thread-&gt;Tcb.ServiceTable != KeServiceDescriptorTable) </span><br><span class="line">		<span class="keyword">return</span> STATUS_ALREADY_WIN32;<span class="comment">//表示先前已经转换为GUI线程了 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!Thread-&gt;Tcb.LargeStack)<span class="comment">//if 尚未换成大内核栈 </span></span><br><span class="line">	&#123; </span><br><span class="line">		NewStack = (ULONG_PTR)MmCreateKernelStack(TRUE, <span class="number">0</span>);<span class="comment">//分配一个64KB的大内核栈 </span></span><br><span class="line">		<span class="comment">//更为大内核栈 </span></span><br><span class="line">		OldStack = KeSwitchKernelStack(NewStack, (NewStack - KERNEL_STACK_SIZE)); </span><br><span class="line">		MmDeleteKernelStack(OldStack, FALSE);<span class="comment">//销毁原来的普通内核栈 </span></span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!Process-&gt;Win32Process)<span class="comment">//if 尚未分配W32PROCESS结构(也即if是该进程中的第一个GUI线程) </span></span><br><span class="line">		Status = PspW32ProcessCallout(Process, TRUE);<span class="comment">//分配Win32Process结构(表示GUI进程) </span></span><br><span class="line"></span><br><span class="line">	Thread-&gt;Tcb.ServiceTable = KeServiceDescriptorTableShadow;<span class="comment">//关键。更改描述符表 </span></span><br><span class="line">	<span class="comment">//为当前线程分配一个W32THREAD结构 </span></span><br><span class="line">	Status = PspW32ThreadCallout(Thread, PsW32ThreadCalloutInitialize); </span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(Status)) </span><br><span class="line">		Thread-&gt;Tcb.ServiceTable = KeServiceDescriptorTable;<span class="comment">//改为原来 的 </span></span><br><span class="line">	<span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上每个线程在转换为 GUI 线程时,必须换用<code>64KB</code>的大内核栈,因为普通的内核栈只有<code>12KB</code>大小,不能支持开销大的图形任务。<br>然后分配一个<code>W32PROCESS</code>结构,将进程转换为 GUI 进程,然后分配<code>W32THREAD</code>结构,更改系统服务表描述符表</p>
<p>上面的<code>PspW32ProcessCallout</code>和<code>PspW32ThreadCallout</code>函数都是回调函数<br>分别指向<code>win32k.sys</code>模块中的<code>Win32kProcessCallback</code>、<code>Win32kThreadCallback</code>函数。 </p>
<h3 id="Win32kProcessCallback"><a href="#Win32kProcessCallback" class="headerlink" title="Win32kProcessCallback"></a>Win32kProcessCallback</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">Win32kProcessCallback</span><span class="params">(struct _EPROCESS *Process, </span></span></span><br><span class="line"><span class="function"><span class="params">                      BOOLEAN Create)</span><span class="comment">//指是要创建还是要销毁 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PPROCESSINFO Win32Process; </span><br><span class="line">	Win32Process = PsGetProcessWin32Process(Process);<span class="comment">//获得当前进程的W32PROCESS结构指针 </span></span><br><span class="line">	<span class="keyword">if</span> (!Win32Process)<span class="comment">//if 尚未分配该结构,就分配一个 </span></span><br><span class="line">	&#123; </span><br><span class="line">		Win32Process = ExAllocatePoolWithTag(NonPagedPool,sizeof(PROCESSINFO),'p23W'); </span><br><span class="line">		RtlZeroMemory(Win32Process, <span class="keyword">sizeof</span>(PROCESSINFO)); </span><br><span class="line">		PsSetProcessWin32Process(Process, Win32Process); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (Create) </span><br><span class="line">	&#123; </span><br><span class="line">		SIZE_T ViewSize = <span class="number">0</span>; </span><br><span class="line">		LARGE_INTEGER Offset; </span><br><span class="line">		PVOID UserBase = <span class="literal">NULL</span>; </span><br><span class="line">		NTSTATUS Status; </span><br><span class="line">		<span class="keyword">extern</span> PSECTION_OBJECT GlobalUserHeapSection; </span><br><span class="line">		Offset.QuadPart = <span class="number">0</span>; </span><br><span class="line">		<span class="comment">//将全局用户堆映射到本进程的地址空间 </span></span><br><span class="line">		Status = MmMapViewOfSection(GlobalUserHeapSection,PsGetCurrentProcess(),&amp;UserBase, </span><br><span class="line">		                      <span class="number">0</span>,<span class="number">0</span>,&amp;Offset,&amp;ViewSize,ViewUnmap,SEC_NO_CHANGE, </span><br><span class="line">		                      PAGE_EXECUTE_READ); </span><br><span class="line">		Win32Process-&gt;HeapMappings.Next = <span class="literal">NULL</span>; </span><br><span class="line">		Win32Process-&gt;HeapMappings.KernelMapping = (PVOID)GlobalUserHeap; </span><br><span class="line">		Win32Process-&gt;HeapMappings.UserMapping = UserBase; </span><br><span class="line">		Win32Process-&gt;HeapMappings.Count = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">		InitializeListHead(&amp;Win32Process-&gt;ClassList); </span><br><span class="line">		InitializeListHead(&amp;Win32Process-&gt;MenuListHead); </span><br><span class="line">		InitializeListHead(&amp;Win32Process-&gt;GDIBrushAttrFreeList); </span><br><span class="line">		InitializeListHead(&amp;Win32Process-&gt;GDIDcAttrFreeList); </span><br><span class="line">		InitializeListHead(&amp;Win32Process-&gt;PrivateFontListHead); </span><br><span class="line">		ExInitializeFastMutex(&amp;Win32Process-&gt;PrivateFontListLock); </span><br><span class="line">		InitializeListHead(&amp;Win32Process-&gt;DriverObjListHead); </span><br><span class="line">		ExInitializeFastMutex(&amp;Win32Process-&gt;DriverObjListLock); </span><br><span class="line"></span><br><span class="line">		Win32Process-&gt;KeyboardLayout = W32kGetDefaultKeyLayout(); </span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(Process-&gt;Peb != <span class="literal">NULL</span>) </span><br><span class="line">		&#123; </span><br><span class="line"></span><br><span class="line">			<span class="comment">//映射全局的GDI对象句柄表到本进程的地址空间中 </span></span><br><span class="line">			Process-&gt;Peb-&gt;GdiSharedHandleTable = GDI_MapHandleTable(GdiTableSection, Process); </span><br><span class="line">			Process-&gt;Peb-&gt;GdiDCAttributeList = GDI_BATCH_LIMIT; </span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">		Win32Process-&gt;peProcess = Process; </span><br><span class="line">		Win32Process-&gt;W32PF_flags = <span class="number">0</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		IntCleanupMenus(Process, Win32Process); </span><br><span class="line">		IntCleanupCurIcons(Process, Win32Process); </span><br><span class="line">		CleanupMonitorImpl(); </span><br><span class="line">		DestroyProcessClasses(Win32Process); </span><br><span class="line">		GDI_CleanupForProcess(Process); </span><br><span class="line">		co_IntGraphicsCheck(FALSE); </span><br><span class="line">		<span class="keyword">if</span>(LogonProcess == Win32Process) </span><br><span class="line">			LogonProcess = <span class="literal">NULL</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个含有 GUI 线程的进程都是 GUI 进程,每个 GUI 进程的<code>EPROCESS</code>结构含有<code>W32PROCESS</code>结构 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">W32PROCESS</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  PEPROCESS    peProcess; </span><br><span class="line">  DWORD        RefCount; </span><br><span class="line">  ULONG        W32PF_flags; </span><br><span class="line">  PKEVENT      InputIdleEvent; </span><br><span class="line">  DWORD        StartCursorHideTime; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">W32PROCESS</span> * <span class="title">NextStart</span>;</span> </span><br><span class="line">  PVOID        pDCAttrList; </span><br><span class="line">  PVOID        pBrushAttrList; </span><br><span class="line">  DWORD        W32Pid; </span><br><span class="line">  LONG         GDIHandleCount; </span><br><span class="line">  LONG         UserHandleCount; </span><br><span class="line">  PEX_PUSH_LOCK GDIPushLock;  <span class="comment">/* Locking Process during access to structure. */</span> </span><br><span class="line">  RTL_AVL_TABLE GDIEngUserMemAllocTable;  <span class="comment">/* Process AVL Table. */</span> </span><br><span class="line">  LIST_ENTRY   GDIDcAttrFreeList; </span><br><span class="line">  LIST_ENTRY   GDIBrushAttrFreeList; </span><br><span class="line">&#125; W32PROCESS, *PW32PROCESS;</span><br></pre></td></tr></table></figure>
<h3 id="Win32kThreadCallback"><a href="#Win32kThreadCallback" class="headerlink" title="Win32kThreadCallback"></a>Win32kThreadCallback</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">Win32kThreadCallback</span><span class="params">(struct _ETHREAD *Thread, </span></span></span><br><span class="line"><span class="function"><span class="params">                     PSW32THREADCALLOUTTYPE Type)</span> <span class="comment">//指是初始化还是清理 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS</span> *<span class="title">Process</span>;</span> </span><br><span class="line">	PTHREADINFO Win32Thread; </span><br><span class="line">	DECLARE_RETURN(NTSTATUS); </span><br><span class="line">	Process = Thread-&gt;ThreadsProcess; </span><br><span class="line">	Win32Thread = PsGetThreadWin32Thread(Thread); </span><br><span class="line">	<span class="keyword">if</span> (!Win32Thread)<span class="comment">//if 尚未分配Win32Thread结构,就分配 </span></span><br><span class="line">	&#123; </span><br><span class="line">		Win32Thread = ExAllocatePoolWithTag(NonPagedPool,sizeof(THREADINFO),'t23W'); </span><br><span class="line">		RtlZeroMemory(Win32Thread, <span class="keyword">sizeof</span>(THREADINFO)); </span><br><span class="line">		PsSetThreadWin32Thread(Thread, Win32Thread); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (Type == PsW32ThreadCalloutInitialize)<span class="comment">//if 初始化 </span></span><br><span class="line">	&#123; </span><br><span class="line">		HWINSTA hWinSta = <span class="literal">NULL</span>; </span><br><span class="line">		PTEB pTeb; </span><br><span class="line">		HDESK hDesk = <span class="literal">NULL</span>; </span><br><span class="line">		NTSTATUS Status; </span><br><span class="line">		PUNICODE_STRING DesktopPath; </span><br><span class="line">		PRTL_USER_PROCESS_PARAMETERS ProcessParams = (Process-&gt;Peb ? Process-&gt;Peb-&gt;ProcessPara meters : <span class="literal">NULL</span>); </span><br><span class="line">		InitializeListHead(&amp;Win32Thread-&gt;WindowListHead); </span><br><span class="line">		InitializeListHead(&amp;Win32Thread-&gt;W32CallbackListHead); </span><br><span class="line">		InitializeListHead(&amp;Win32Thread-&gt;PtiLink); </span><br><span class="line"></span><br><span class="line">		DesktopPath = (ProcessParams ? ((ProcessParams-&gt;DesktopInfo.Length &gt; <span class="number">0</span>) ? &amp;ProcessPara</span><br><span class="line">		ms-&gt;DesktopInfo : <span class="literal">NULL</span>) : <span class="literal">NULL</span>); </span><br><span class="line">		Status = IntParseDesktopPath(Process,DesktopPath,&amp;hWinSta,&amp;hDesk); </span><br><span class="line">		<span class="keyword">if</span>(NT_SUCCESS(Status)) </span><br><span class="line">		&#123; </span><br><span class="line">			… </span><br><span class="line">			Win32Thread-&gt;MessageQueue = MsqCreateMessageQueue(Thread);<span class="comment">//关键。创建消息队列 </span></span><br><span class="line">			Win32Thread-&gt;KeyboardLayout = W32kGetDefaultKeyLayout(); </span><br><span class="line">			Win32Thread-&gt;pEThread = Thread; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	Else … </span><br><span class="line"></span><br><span class="line">    Return STATUS_SUCCESS; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">W32THREAD</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	PETHREAD pEThread; </span><br><span class="line">	ULONG RefCount; </span><br><span class="line">	PTL ptlW32; </span><br><span class="line">	PVOID pgdiDcattr; </span><br><span class="line">	PVOID pgdiBrushAttr; </span><br><span class="line">	PVOID pUMPDObjs; </span><br><span class="line">	PVOID pUMPDHeap; </span><br><span class="line">	DWORD dwEngAcquireCount; </span><br><span class="line">	PVOID pSemTable; </span><br><span class="line">	PVOID pUMPDObj; </span><br><span class="line">&#125; W32THREAD, *PW32THREAD; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">THREADINFO</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	W32THREAD; <span class="comment">//开头是一个W32THREAD结构 </span></span><br><span class="line">	PTL                ptl; </span><br><span class="line">	PPROCESSINFO       ppi; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">USER_MESSAGE_QUEUE</span>* <span class="title">MessageQueue</span>;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">KBL</span>*       <span class="title">KeyboardLayout</span>;</span> </span><br><span class="line">	PCLIENTTHREADINFO  pcti; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">DESKTOP</span>*   <span class="title">rpdesk</span>;</span> </span><br><span class="line">	PDESKTOPINFO       pDeskInfo; </span><br><span class="line">	PCLIENTINFO        pClientInfo; </span><br><span class="line">	FLONG              TIF_flags; </span><br><span class="line">	PUNICODE_STRING    pstrAppName; </span><br><span class="line">	LONG               timeLast; </span><br><span class="line">	ULONG_PTR          idLast; </span><br><span class="line">	INT                exitCode; </span><br><span class="line">	HDESK              hdesk; </span><br><span class="line">	UINT                cPaintsReady; <span class="comment">/* Count of paints pending. */</span> </span><br><span class="line">	UINT                cTimersReady; <span class="comment">/* Count of timers pending. */</span> </span><br><span class="line">	DWORD              dwExpWinVer; </span><br><span class="line">	DWORD              dwCompatFlags; </span><br><span class="line">	DWORD              dwCompatFlags2; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">USER_MESSAGE_QUEUE</span>* <span class="title">pqAttach</span>;</span> </span><br><span class="line">	PTHREADINFO        ptiSibling; </span><br><span class="line">	ULONG              fsHooks; </span><br><span class="line">	PHOOK              sphkCurrent; </span><br><span class="line">	LPARAM             lParamHkCurrent; </span><br><span class="line">	WPARAM             wParamHkCurrent; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagSBTRACK</span>* <span class="title">pSBTrack</span>;</span> </span><br><span class="line">	HANDLE             hEventQueueClient; </span><br><span class="line"></span><br><span class="line">	PKEVENT            pEventQueueServer; </span><br><span class="line">	LIST_ENTRY         PtiLink; </span><br><span class="line"></span><br><span class="line">	CLIENTTHREADINFO    cti;  <span class="comment">// Used only when no Desktop or pcti NULL. </span></span><br><span class="line">	<span class="comment">/* ReactOS */</span> </span><br><span class="line">	LIST_ENTRY WindowListHead; </span><br><span class="line">	LIST_ENTRY W32CallbackListHead; </span><br><span class="line">	SINGLE_LIST_ENTRY ReferencesList; </span><br><span class="line">&#125; THREADINFO; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//每个窗口对象的内部结构 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WINDOW_OBJECT</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	THRDESKHEAD head; </span><br><span class="line">	PWND Wnd;<span class="comment">//内部结构 </span></span><br><span class="line">	PTHREADINFO pti; <span class="comment">//所属线程 </span></span><br><span class="line">	HMENU SystemMenu;<span class="comment">//左上角的系统菜单 </span></span><br><span class="line">	HWND hSelf;<span class="comment">//窗口句柄是内核全局的 </span></span><br><span class="line">	ULONG state; </span><br><span class="line">	HANDLE hrgnUpdate;<span class="comment">//当前无效区域(指更新区域)的句柄 </span></span><br><span class="line">	HANDLE hrgnClip;<span class="comment">//剪裁区域的句柄 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">WINDOW_OBJECT</span>* <span class="title">spwndChild</span>;</span><span class="comment">//第一个子窗口 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">WINDOW_OBJECT</span>* <span class="title">spwndNext</span>;</span><span class="comment">//下一个兄弟窗口 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">WINDOW_OBJECT</span>* <span class="title">spwndPrev</span>;</span><span class="comment">//上一个兄弟窗口 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">WINDOW_OBJECT</span>* <span class="title">spwndParent</span>;</span><span class="comment">//父窗口 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">WINDOW_OBJECT</span>* <span class="title">spwndOwner</span>;</span><span class="comment">//拥有者窗口与父窗口是两码事 </span></span><br><span class="line">	PSBINFOEX pSBInfo;<span class="comment">//滚动条信息 </span></span><br><span class="line">	LIST_ENTRY ThreadListEntry;<span class="comment">//用来挂入线程的窗口链表 </span></span><br><span class="line">&#125; WINDOW_OBJECT; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WND</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	THRDESKHEAD head; </span><br><span class="line">	DWORD state; </span><br><span class="line">	DWORD state2; </span><br><span class="line">	DWORD ExStyle;<span class="comment">//扩展样式 </span></span><br><span class="line">	DWORD style;<span class="comment">//标准样式 </span></span><br><span class="line">	HINSTANCE hModule;<span class="comment">//创建本窗口的模块 </span></span><br><span class="line">	DWORD fnid; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">WND</span> *<span class="title">spwndNext</span>;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">WND</span> *<span class="title">spwndPrev</span>;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">WND</span> *<span class="title">spwndParent</span>;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">WND</span> *<span class="title">spwndChild</span>;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">WND</span> *<span class="title">spwndOwner</span>;</span> </span><br><span class="line">	RECT rcWindow;<span class="comment">//整个区域 </span></span><br><span class="line"></span><br><span class="line">	RECT rcClient;<span class="comment">//客户区域 </span></span><br><span class="line">	WNDPROC lpfnWndProc;<span class="comment">//关键。窗口过程 </span></span><br><span class="line">	PCLS pcls;<span class="comment">//窗口类 </span></span><br><span class="line">	HRGN hrgnUpdate; </span><br><span class="line">	LIST_ENTRY PropListHead;<span class="comment">//属性链表 </span></span><br><span class="line">	ULONG PropListItems; </span><br><span class="line">	PSBINFO pSBInfo;<span class="comment">//滚动条信息 </span></span><br><span class="line">	HMENU SystemMenu; </span><br><span class="line">	UINT IDMenu;  </span><br><span class="line">	HRGN hrgnClip; </span><br><span class="line">	HRGN hrgnNewFrame; </span><br><span class="line">	LARGE_UNICODE_STRING strName;<span class="comment">//窗口标题 </span></span><br><span class="line">	ULONG cbwndExtra;<span class="comment">//附加数据区的大小 </span></span><br><span class="line">	HWND hWndLastActive; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">WND</span> *<span class="title">spwndLastActive</span>;</span> </span><br><span class="line">	LONG dwUserData;<span class="comment">//用户自定义数据 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">WND</span> *<span class="title">spwndClipboardListener</span>;</span> </span><br><span class="line">	DWORD ExStyle2; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">	&#123;</span> </span><br><span class="line">		RECT NormalRect; </span><br><span class="line">		POINT IconPos; </span><br><span class="line">		POINT MaxPos; </span><br><span class="line">	&#125; InternalPos; </span><br><span class="line">	UINT Unicode : <span class="number">1</span>; <span class="comment">// !(WNDS_ANSICREATOR|WNDS_ANSIWINDOWPROC) ? </span></span><br><span class="line">	UINT InternalPosInitialized : <span class="number">1</span>; </span><br><span class="line">	UINT HideFocus : <span class="number">1</span>; <span class="comment">// WS_EX_UISTATEFOCUSRECTHIDDEN ? </span></span><br><span class="line">	UINT HideAccel : <span class="number">1</span>; <span class="comment">// WS_EX_UISTATEKBACCELHIDDEN ? </span></span><br><span class="line">&#125; WND, *PWND;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="消息循环机制重点函数"><a href="#消息循环机制重点函数" class="headerlink" title="消息循环机制重点函数"></a>消息循环机制重点函数</h2><p>下面重点讲述消息循环机制中的几个重点函数</p>
<ul>
<li><code>GetMessage</code></li>
<li><code>DispatchMessage</code></li>
<li><code>SendMessage</code></li>
<li><code>PostMessage</code> </li>
<li><code>PeekMessage</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(GetMessage(&amp;Msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    TranslateMessage(&amp;Msg);</span><br><span class="line">    DispatchMessage(&amp;Msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>当运行程序-&gt;事件操作引发消息-&gt;消息先存在系统消息队列-&gt;再存入到应用程序消息队列-&gt;用消息循环提取消息-&gt;处理消息-&gt;再返回消息队列....</code></p>
<p>上面代码的执行过程为</p>
<ul>
<li><ol>
<li>消息循环调用<code>GetMessage()</code>从消息队列中查找消息进行处理,如果消息队列为空,程序将停止执行并等待(程序阻塞)。</li>
</ol>
</li>
<li><ol start="2">
<li>事件发生时导致一个消息加入到消息队列(例如系统注册了一个鼠标点击事件)<br><code>GetMessage()</code>将返回一个正值,这表明有消息需要被处理,并且消息已经填充到传入的MSG参数中;<br>当传入<code>WM_QUIT</code>消息时返回0, 如果返回值为负表明发生了错误。</li>
</ol>
</li>
<li><ol start="3">
<li>取出消息(在Msg变量中)并将其传递给<code>TranslateMessage()</code>函数这个函数做一些额外的处理:将虚拟键值信息转换为字符信息。这一步实际上是可选的但有些地方需要用到这一步。</li>
</ol>
</li>
<li><ol start="4">
<li>上面的步骤执行完后,将消息传递给<code>DispatchMessage()</code>函数。<code>DispatchMessage()</code>函数将消息分发到消息的目标窗口,并且查找目标窗口过程函数,给<code>窗口过程函数</code>传递<code>窗口句柄、消息、wParam、lParam</code>等参数然后调用该函数。</li>
</ol>
</li>
<li><ol start="5">
<li>在窗口过程函数中检查消息和其他参数,你可以用它来实现你想要的操作。<br>如果不想处理某些特殊的消息,你应该总是调用<code>DefWindowProc()</code>函数,系统将按按默认的方式处理这些消息(通常认为是不做任何操作)。</li>
</ol>
</li>
<li><ol start="6">
<li>一旦一个消息处理完成,窗口过程函数返回<code>DispatchMessage()</code>函数返回,继续循环处理下一个消息。</li>
</ol>
</li>
</ul>
<h3 id="GetMessageW"><a href="#GetMessageW" class="headerlink" title="GetMessageW"></a>GetMessageW</h3><p>下面的函数从本线程的消息队列中取出一条符合指定过滤条件的消息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetMessageW</span><span class="params">(LPMSG lpMsg,<span class="comment">//返回从队列中摘下来的消息 </span></span></span></span><br><span class="line"><span class="function"><span class="params"> 	    HWND hWnd,<span class="comment">//过滤条件一：发给这个窗口的消息 </span></span></span></span><br><span class="line"><span class="function"><span class="params"> 	    UINT wMsgFilterMin, <span class="comment">//过滤条件二：最小值 </span></span></span></span><br><span class="line"><span class="function"><span class="params"> 	    UINT wMsgFilterMax)</span> <span class="comment">//过滤条件三：最大值 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BOOL Res; </span><br><span class="line">	MSGCONVERSION Conversion;<span class="comment">//用于内核消息、用户模式消息互转 </span></span><br><span class="line">	NTUSERGETMESSAGEINFO Info;<span class="comment">//一个专用于NtUserGetMessage函数的中间结构 </span></span><br><span class="line">	PUSER32_THREAD_DATA ThreadData = User32GetThreadData();<span class="comment">//每个线程的User32 tls数据 </span></span><br><span class="line"></span><br><span class="line">	MsgConversionCleanup(lpMsg, FALSE, FALSE, <span class="literal">NULL</span>); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//实质函数。从本线程的消息队列中寻找符合对应过滤条件的一条消息,摘下来。 </span></span><br><span class="line">	Res = NtUserGetMessage(&amp;Info, hWnd, wMsgFilterMin, wMsgFilterMax); </span><br><span class="line">	<span class="keyword">if</span> (<span class="number">-1</span> == (<span class="keyword">int</span>) Res)  <span class="keyword">return</span> Res; </span><br><span class="line">	Conversion.LParamSize = Info.LParamSize; </span><br><span class="line">	Conversion.KMMsg = Info.Msg; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将内核模式的消息格式转换为用户模式的消息格式 </span></span><br><span class="line">	<span class="keyword">if</span> (! MsgiKMToUMMessage(&amp;Conversion.KMMsg, &amp;Conversion.UnicodeMsg)) </span><br><span class="line">		<span class="keyword">return</span> (BOOL) <span class="number">-1</span>; </span><br><span class="line">	</span><br><span class="line">	*lpMsg = Conversion.UnicodeMsg;<span class="comment">//返回取得的转换后的消息 </span></span><br><span class="line">	Conversion.Ansi = FALSE; </span><br><span class="line">	Conversion.FinalMsg = lpMsg; </span><br><span class="line">	MsgConversionAdd(&amp;Conversion);<span class="comment">//加入全局的转换数组 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (Res &amp;&amp; lpMsg-&gt;message != WM_PAINT &amp;&amp; lpMsg-&gt;message != WM_QUIT) </span><br><span class="line">		ThreadData-&gt;LastMessage = Info.Msg;<span class="comment">//记录本线程上次取下来的消息 </span></span><br><span class="line">	<span class="keyword">return</span> Res; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagNTUSERGETMESSAGEINFO</span> //中间结构 </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	MSG Msg; </span><br><span class="line">	ULONG LParamSize;<span class="comment">//L参数附件包的长度(注意有的消息类型是带有L附件包的) </span></span><br><span class="line">&#125; NTUSERGETMESSAGEINFO, *PNTUSERGETMESSAGEINFO; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"> 	HWND hwnd; </span><br><span class="line"> 	UINT message; </span><br><span class="line"> 	WPARAM wParam; </span><br><span class="line"> 	LPARAM lParam;<span class="comment">//lparam有可能是个指针 </span></span><br><span class="line"> 	DWORD time;<span class="comment">//消息进队时间 </span></span><br><span class="line"> 	POINT pt;<span class="comment">//消息进队时,桌面光标的位置 </span></span><br><span class="line">&#125; MSG,*LPMSG,*PMSG;</span><br></pre></td></tr></table></figure>
<h4 id="NtUserGetMessage"><a href="#NtUserGetMessage" class="headerlink" title="NtUserGetMessage"></a>NtUserGetMessage</h4><p>我们看实质的内核函数:<code>NtUserGetMessage</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">NtUserGetMessage</span><span class="params">( PNTUSERGETMESSAGEINFO UnsafeInfo,<span class="comment">//用户空间中的不安全地址 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                  HWND hWnd, </span></span></span><br><span class="line"><span class="function"><span class="params">                  UINT MsgFilterMin, </span></span></span><br><span class="line"><span class="function"><span class="params">                  UINT MsgFilterMax )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BOOL GotMessage; </span><br><span class="line">	NTUSERGETMESSAGEINFO Info;<span class="comment">//内核中的安全缓冲 </span></span><br><span class="line">	NTSTATUS Status; </span><br><span class="line"></span><br><span class="line">	PWINDOW_OBJECT Window = <span class="literal">NULL</span>; </span><br><span class="line">	PMSGMEMORY MsgMemoryEntry; </span><br><span class="line">	PVOID UserMem; </span><br><span class="line">	UINT Size; </span><br><span class="line">	USER_MESSAGE Msg;<span class="comment">//消息队列中的原生消息结构 </span></span><br><span class="line">	DECLARE_RETURN(BOOL); </span><br><span class="line">	UserEnterExclusive(); </span><br><span class="line">	<span class="comment">//检测窗口句柄是否无效 </span></span><br><span class="line">	<span class="keyword">if</span> (hWnd &amp;&amp; !(Window = UserGetWindowObject(hWnd))) </span><br><span class="line">		RETURN(<span class="number">-1</span>); </span><br><span class="line"></span><br><span class="line">	<span class="comment">//过滤条件自相矛盾,就不过滤 </span></span><br><span class="line">	<span class="keyword">if</span> (MsgFilterMax &lt; MsgFilterMin) </span><br><span class="line">	&#123; </span><br><span class="line">		MsgFilterMin = <span class="number">0</span>; </span><br><span class="line">		MsgFilterMax = <span class="number">0</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//循环等待,直到取出一条符合指定条件的消息出来 </span></span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">	&#123; </span><br><span class="line">		GotMessage = co_IntPeekMessage(&amp;Msg, Window, MsgFilterMin, MsgFilterMax, PM_REMOVE); </span><br><span class="line">		<span class="keyword">if</span> (GotMessage)<span class="comment">//如果取出了 </span></span><br><span class="line">		&#123; </span><br><span class="line">			Info.Msg = Msg.Msg; </span><br><span class="line">			<span class="comment">//检测这种消息是否带有L参数附件包,若有,返回它的L附件包大小计算法 </span></span><br><span class="line">			MsgMemoryEntry = FindMsgMemory(Info.Msg.message);  </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (<span class="literal">NULL</span> == MsgMemoryEntry)<span class="comment">//若不带L附件包 </span></span><br><span class="line">				Info.LParamSize = <span class="number">0</span>; </span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123; </span><br><span class="line">				<span class="comment">//根据这种消息的L附件包长度计算法 计算出该消息的L附件包大小 </span></span><br><span class="line">				Size = MsgMemorySize(MsgMemoryEntry, Info.Msg.wParam,Info.Msg.lParam); </span><br><span class="line">				Info.LParamSize = Size; </span><br><span class="line">				UserMem = <span class="literal">NULL</span>;<span class="comment">//用户空间的L附件包地址 </span></span><br><span class="line">				<span class="comment">//在当前进程的用户空间分配一块L附件包大小的内存 </span></span><br><span class="line">				Status = ZwAllocateVirtualMemory(NtCurrentProcess(), &amp;UserMem, <span class="number">0</span>, </span><br><span class="line">				                             &amp;Info.LParamSize, MEM_COMMIT, PAGE_READWRITE); </span><br><span class="line">				<span class="comment">//关键。将内核中的L附件包转移到用户空间 </span></span><br><span class="line">				Status = MmCopyToCaller(UserMem, (PVOID) Info.Msg.lParam, Size); </span><br><span class="line">				Info.Msg.lParam = (LPARAM) UserMem;<span class="comment">//重定向指向用户空间中的地址 </span></span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">if</span> (Msg.FreeLParam &amp;&amp; <span class="literal">NULL</span> != Msg.Msg.lParam) </span><br><span class="line">				ExFreePool((<span class="keyword">void</span> *) Msg.Msg.lParam);<span class="comment">//释放内核中的L附件包 </span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//将取下来的消息上传给用户 </span></span><br><span class="line">			Status = MmCopyToCaller(UnsafeInfo, &amp;Info, <span class="keyword">sizeof</span>(NTUSERGETMESSAGEINFO)); </span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (! NT_SUCCESS(Status)) </span><br><span class="line">			&#123; </span><br><span class="line">				SetLastNtError(Status); </span><br><span class="line">				RETURN( (BOOL) <span class="number">-1</span>); </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">//一直等待消息队列中出现对应过滤条件的消息 </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (! co_IntWaitMessage(Window, MsgFilterMin, MsgFilterMax)) </span><br><span class="line">		&#123; </span><br><span class="line">			RETURN( (BOOL) <span class="number">-1</span>); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">while</span> (! GotMessage); </span><br><span class="line">		RETURN( WM_QUIT != Info.Msg.message); CLEANUP: </span><br><span class="line">	</span><br><span class="line">	UserLeave(); </span><br><span class="line">	END_CLEANUP; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数首先会判断窗口局部是否有效。它根据窗口句柄从内核中的全局用户对象句柄表中检索出对应的用户对象<br>(所谓用户对象指窗口、菜单、快捷键、光标、钩子等相对于内核对象的 GUI 对象),<br>由于该句柄表是全局的,所有用户对象的句柄因此也是全局的,各个进程通用,不像内核对象的句柄是局限在各个进程的句柄表中。</p>
<h4 id="UserGetWindowObject-找窗口对象"><a href="#UserGetWindowObject-找窗口对象" class="headerlink" title="UserGetWindowObject(找窗口对象)"></a>UserGetWindowObject(找窗口对象)</h4><p>下面的函数根据窗口句柄找到对应的窗口对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINDOW_OBJECT* FASTCALL <span class="title">UserGetWindowObject</span><span class="params">(HWND hWnd)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	THREADINFO* ti; </span><br><span class="line">	WINDOW_OBJECT* Window; </span><br><span class="line">	<span class="keyword">if</span> (PsGetCurrentProcess() != PsInitialSystemProcess)<span class="comment">//若不是’system’进程 </span></span><br><span class="line">	&#123; </span><br><span class="line">		ti = GetW32ThreadInfo(); </span><br><span class="line">		<span class="keyword">if</span> (ti == <span class="literal">NULL</span>) </span><br><span class="line">		&#123; </span><br><span class="line">			SetLastWin32Error(ERROR_ACCESS_DENIED); </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//实质函数,gHandleTable指向全局的GUI对象句柄表 </span></span><br><span class="line">	Window = (WINDOW_OBJECT*)UserGetObject(gHandleTable, hWnd, otWindow); </span><br><span class="line">	<span class="keyword">if</span> (!Window || <span class="number">0</span> != (Window-&gt;state &amp; WINDOWSTATUS_DESTROYED)) </span><br><span class="line">	&#123; </span><br><span class="line">		SetLastWin32Error(ERROR_INVALID_WINDOW_HANDLE); </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Window; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">PVOID <span class="title">UserGetObject</span><span class="params">(PUSER_HANDLE_TABLE ht,<span class="comment">//句柄表 </span></span></span></span><br><span class="line"><span class="function"><span class="params">		HANDLE handle,<span class="comment">//用户对象的句柄 </span></span></span></span><br><span class="line"><span class="function"><span class="params">		USER_OBJECT_TYPE type )</span><span class="comment">//用户对象类型 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PUSER_HANDLE_ENTRY entry = handle_to_entry(ht, handle);<span class="comment">//根据句柄值找到对应的句柄表项 </span></span><br><span class="line">	<span class="keyword">if</span> (entry == <span class="literal">NULL</span> || entry-&gt;type != type)<span class="comment">//若找不到或者类型不匹配 </span></span><br><span class="line">	&#123; </span><br><span class="line">		SetLastWin32Error(ERROR_INVALID_HANDLE); </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> entry-&gt;ptr;<span class="comment">//返回对应的对象 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">PUSER_HANDLE_ENTRY <span class="title">handle_to_entry</span><span class="params">(PUSER_HANDLE_TABLE ht, HANDLE handle )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> generation; </span><br><span class="line">	<span class="keyword">int</span> index = (((<span class="keyword">unsigned</span> <span class="keyword">int</span>)handle &amp; <span class="number">0xffff</span>) - FIRST_USER_HANDLE) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= ht-&gt;nb_handles) </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">	<span class="keyword">if</span> (!ht-&gt;handles[index].type) </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">	</span><br><span class="line">	generation = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)handle &gt;&gt; <span class="number">16</span>; </span><br><span class="line">	<span class="keyword">if</span> (generation == ht-&gt;handles[index].generation || !generation || generation == <span class="number">0xffff</span>) </span><br><span class="line">		<span class="keyword">return</span> &amp;ht-&gt;handles[index]; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上根据<code>handle</code>找到对应的句柄表项,有点类似内核对象的句柄,可以把 GUI 对象的句柄也看作是一个简单的数组索引值。<br>下面是具体的 GUI 对象句柄表项的结构 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USER_HANDLE_ENTRY</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="keyword">void</span> *ptr;<span class="comment">//指向对应的GUI对象 </span></span><br><span class="line">	<span class="keyword">union</span> </span><br><span class="line">	&#123; </span><br><span class="line">		PVOID pi; </span><br><span class="line">		PTHREADINFO pti;          <span class="comment">// 指向所属线程 </span></span><br><span class="line">		PPROCESSINFO ppi;         <span class="comment">// 指向所属进程 </span></span><br><span class="line">	&#125;; </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> type;          </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> flags; </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> generation;<span class="comment">//不明 </span></span><br><span class="line">&#125; USER_HANDLE_ENTRY, * PUSER_HANDLE_ENTRY;</span><br></pre></td></tr></table></figure>
<p>下面是 GUI 对象的句柄表 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USER_HANDLE_TABLE</span> //句柄表描述符 </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	PUSER_HANDLE_ENTRY handles;<span class="comment">//句表的地址 </span></span><br><span class="line">	PUSER_HANDLE_ENTRY freelist;<span class="comment">//空闲表项链表 </span></span><br><span class="line">	<span class="keyword">int</span> nb_handles;<span class="comment">//表的容量 </span></span><br><span class="line">	<span class="keyword">int</span> allocated_handles;<span class="comment">//表中实际已分配的表项个数 </span></span><br><span class="line">&#125; USER_HANDLE_TABLE, * PUSER_HANDLE_TABLE;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="FindMsgMemory-查找指定类型消息的L附件包"><a href="#FindMsgMemory-查找指定类型消息的L附件包" class="headerlink" title="FindMsgMemory(查找指定类型消息的L附件包)"></a>FindMsgMemory(查找指定类型消息的L附件包)</h4><p>前面的函数会将消息从队列取下来后,将<code>L</code>附件包转移到用户空间。<br>绝大多数消息都不带<code>L</code>附件包,有的消息则带有<code>L</code>附加包<br>内核中有一个全局表给出了所有含有<code>L</code>附件包的消息类型以及他们的<code>L</code>附件包大小的计算方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MSGMEMORY MsgMemory[] =    <span class="comment">//全局表 </span></span><br><span class="line">&#123; </span><br><span class="line">	&#123; WM_CREATE, MMS_SIZE_SPECIAL, MMS_FLAG_READWRITE &#125;, </span><br><span class="line">	&#123; WM_DDE_ACK, <span class="keyword">sizeof</span>(KMDDELPARAM), MMS_FLAG_READ &#125;, </span><br><span class="line">	&#123; WM_DDE_EXECUTE, MMS_SIZE_WPARAM, MMS_FLAG_READ &#125;, </span><br><span class="line">	&#123; WM_GETMINMAXINFO, <span class="keyword">sizeof</span>(MINMAXINFO), MMS_FLAG_READWRITE &#125;, </span><br><span class="line">	&#123; WM_GETTEXT, MMS_SIZE_WPARAMWCHAR, MMS_FLAG_WRITE &#125;, </span><br><span class="line">	&#123; WM_NCCALCSIZE, MMS_SIZE_SPECIAL, MMS_FLAG_READWRITE &#125;, </span><br><span class="line">	&#123; WM_NCCREATE, MMS_SIZE_SPECIAL, MMS_FLAG_READWRITE &#125;, </span><br><span class="line">	&#123; WM_SETTEXT, MMS_SIZE_LPARAMSZ, MMS_FLAG_READ &#125;, </span><br><span class="line">	&#123; WM_STYLECHANGED, <span class="keyword">sizeof</span>(STYLESTRUCT), MMS_FLAG_READ &#125;, </span><br><span class="line">	&#123; WM_STYLECHANGING, <span class="keyword">sizeof</span>(STYLESTRUCT), MMS_FLAG_READWRITE &#125;, </span><br><span class="line">	&#123; WM_COPYDATA, MMS_SIZE_SPECIAL, MMS_FLAG_READ &#125;, </span><br><span class="line">	&#123; WM_WINDOWPOSCHANGED, <span class="keyword">sizeof</span>(WINDOWPOS), MMS_FLAG_READ &#125;, </span><br><span class="line">	&#123; WM_WINDOWPOSCHANGING, <span class="keyword">sizeof</span>(WINDOWPOS), MMS_FLAG_READWRITE &#125;, </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSGMEMORY</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	UINT Message;<span class="comment">//消息ID,即消息类型 </span></span><br><span class="line">	UINT Size;<span class="comment">//该类消息的L附件包大小或计算方法 </span></span><br><span class="line">	INT Flags;<span class="comment">//数据流动方向 </span></span><br><span class="line">&#125; </span><br><span class="line">MSGMEMORY, *PMSGMEMORY;</span><br></pre></td></tr></table></figure>
<p>如上面<code>WM_GETTEXT</code>这种消息的L附件包大小计算方法是：蕴含在它的<code>wparam</code>参数中,<code>wparam</code>参数给定了<code>L</code>附件包的宽字符个数<br><code>MMS_FLAG_WRITE</code>标志则表示需要写用户空间,也即将L附件包回写复制到用户空间。 </p>
<p><code>WM_SETTEXT</code>这种消息的L附件包大小计算方法是：蕴含在它的<code>lparam</code>参数,<code>lparam</code>参数是一个以0结尾的字符串<br><code>MMS_FLAG_READ</code>标志则表示需要读用户空间,也即将用户空间中的文本复制到内核空间中。<br><code>MMS_SIZE_SPECIAL</code>则表示L附件包的大小特定于具体的消息。 </p>
<p>除开上面表中的那些消息,其他消息都不带L附件包。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PMSGMEMORY FASTCALL <span class="title">FindMsgMemory</span><span class="params">(UINT Msg)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   PMSGMEMORY MsgMemoryEntry; </span><br><span class="line">   <span class="keyword">for</span> (MsgMemoryEntry = MsgMemory; </span><br><span class="line">         MsgMemoryEntry &lt; MsgMemory + <span class="keyword">sizeof</span>(MsgMemory) / <span class="keyword">sizeof</span>(MSGMEMORY); </span><br><span class="line">         MsgMemoryEntry++) </span><br><span class="line">   &#123; </span><br><span class="line">      <span class="keyword">if</span> (Msg == MsgMemoryEntry-&gt;Message) </span><br><span class="line">         <span class="keyword">return</span> MsgMemoryEntry; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的函数根据计算的计算法计算对应消息的<code>L</code>附件包大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT FASTCALL <span class="title">MsgMemorySize</span><span class="params">(PMSGMEMORY MsgMemoryEntry, WPARAM wParam, LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	CREATESTRUCTW *Cs; </span><br><span class="line">	PUNICODE_STRING WindowName; </span><br><span class="line">	PUNICODE_STRING ClassName; </span><br><span class="line">	UINT Size = <span class="number">0</span>; </span><br><span class="line">	_SEH2_TRY </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (MMS_SIZE_WPARAM == MsgMemoryEntry-&gt;Size) </span><br><span class="line">			Size = (UINT)wParam; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (MMS_SIZE_WPARAMWCHAR == MsgMemoryEntry-&gt;Size) </span><br><span class="line">			Size = (UINT) (wParam * <span class="keyword">sizeof</span>(WCHAR)); </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (MMS_SIZE_LPARAMSZ == MsgMemoryEntry-&gt;Size) </span><br><span class="line">			Size = (UINT) ((wcslen((PWSTR) lParam) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(WCHAR)); </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (MMS_SIZE_SPECIAL == MsgMemoryEntry-&gt;Size)<span class="comment">//具体消息具体计算 </span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">switch</span>(MsgMemoryEntry-&gt;Message) </span><br><span class="line">			&#123; </span><br><span class="line">			… </span><br><span class="line">				<span class="keyword">case</span> WM_COPYDATA: </span><br><span class="line">				Size = <span class="keyword">sizeof</span>(COPYDATASTRUCT) + ((PCOPYDATASTRUCT)lParam)-&gt;cbData; </span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			… </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line"></span><br><span class="line">		Size = MsgMemoryEntry-&gt;Size; </span><br><span class="line">	&#125; </span><br><span class="line">	_SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">	&#123; </span><br><span class="line">		Size = <span class="number">0</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	_SEH2_END; </span><br><span class="line">	<span class="keyword">return</span> Size; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="co-IntPeekMessage"><a href="#co-IntPeekMessage" class="headerlink" title="co_IntPeekMessage"></a>co_IntPeekMessage</h4><p>前面的<code>NtUserGetMessage</code>函数实际上调用<code>co_IntPeekMessage</code>函数从消息队列中取下消息。</p>
<p>消息队列的结构如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程的消息队列描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USER_MESSAGE_QUEUE</span>  </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	LONG References;<span class="comment">//本队列的引用计数 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span> *<span class="title">Thread</span>;</span><span class="comment">//本队列的所属线程 </span></span><br><span class="line">	LIST_ENTRY SentMessagesListHead;<span class="comment">//通过SendMessage方式发来的消息进入这个队列(send队列) </span></span><br><span class="line">	LIST_ENTRY PostedMessagesListHead; <span class="comment">//通过PostMessage方式发来的消息进入这个队列(post队列) </span></span><br><span class="line">	LIST_ENTRY NotifyMessagesListHead;<span class="comment">//专用于存放SendMessage回调函数调用通知的消息队列 </span></span><br><span class="line">	LIST_ENTRY HardwareMessagesListHead;<span class="comment">//来自硬件设备的消息(指鼠标消息)队列 </span></span><br><span class="line">	KMUTEX HardwareLock; </span><br><span class="line">	PUSER_MESSAGE MouseMoveMsg;<span class="comment">//当前的MouseMove消息(所有MouseMove消息合并成一个消息) </span></span><br><span class="line">	BOOLEAN QuitPosted;<span class="comment">//指队列中是否收到了一个WM_QUIT消息正处于Pengding中 </span></span><br><span class="line">	ULONG QuitExitCode;<span class="comment">//收到的WM_QUIT消息的退出码(wparam) </span></span><br><span class="line">	PKEVENT NewMessages;<span class="comment">//一个标记队列中是否含有WakeMask掩码消息的事件 </span></span><br><span class="line">	HANDLE NewMessagesHandle;<span class="comment">//上面事件对象的句柄 </span></span><br><span class="line">	ULONG LastMsgRead;<span class="comment">//上次发出PeekMessage请求的时间 </span></span><br><span class="line">	HWND FocusWindow;<span class="comment">//当前键盘焦点窗口 </span></span><br><span class="line">	ULONG PaintCount;<span class="comment">//阻塞中的WM_PAINT消息计数 </span></span><br><span class="line">	HWND ActiveWindow; <span class="comment">//当前活动窗口 </span></span><br><span class="line">	HWND CaptureWindow;<span class="comment">//当前鼠标焦点窗口(一般是没有的,鼠标消息一般发给光标处所在窗口) </span></span><br><span class="line">	HWND MoveSize; <span class="comment">/* Current move/size window for this queue */</span> </span><br><span class="line">	HWND MenuOwner; <span class="comment">/* Current menu owner window for this queue */</span> </span><br><span class="line">	BYTE MenuState; <span class="comment">/* Identifes the menu state */</span> </span><br><span class="line">	PTHRDCARETINFO CaretInfo; <span class="comment">/* Caret information for this queue */</span> </span><br><span class="line">	PHOOKTABLE Hooks;<span class="comment">//每个线程局部的钩子表(还有一个全局的钩子表) </span></span><br><span class="line">	WORD WakeMask;<span class="comment">//唤醒消息掩码 </span></span><br><span class="line">	WORD QueueBits; </span><br><span class="line">	WORD ChangedBits; </span><br><span class="line">	LPARAM ExtraInfo; </span><br><span class="line">	LIST_ENTRY DispatchingMessagesHead;<span class="comment">//本线程已发送出去的,但尚未被目标线程处理的消息队列 </span></span><br><span class="line">	LIST_ENTRY LocalDispatchingMessagesHead;<span class="comment">//本线程正在进行Dispatching处理的消息队列 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">DESKTOP</span> *<span class="title">Desktop</span>;</span><span class="comment">//本队列所属的Desktop </span></span><br><span class="line">&#125; USER_MESSAGE_QUEUE, *PUSER_MESSAGE_QUEUE;</span><br></pre></td></tr></table></figure>
<p>消息队列按用途分类实际微观上包含好几种,只不过从宏观上我们理解每个线程一个消息队列。 微观上分为 4 个接收队列</p>
<p>当线程收到消息时会先从<code>接收队列</code>取下来,转入<code>处理中队列</code>,当处理完毕后再退出<code>处理中队列</code>。 </p>
<p>当一个线程通过<code>SendMesage</code>发送消息时,发出的消息会被放到<code>DispatchingMessagesHead</code>队列,当被接收方处理后,从中移出。</p>
<p>消息队列中的每个消息的结构定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USER_MESSAGE</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	LIST_ENTRY ListEntry;<span class="comment">//用来挂入消息队列 </span></span><br><span class="line">	BOOLEAN FreeLParam;<span class="comment">//表示本消息被取出后是否需要是否内核lparam </span></span><br><span class="line">	MSG Msg;<span class="comment">//消息主体 </span></span><br><span class="line">&#125; USER_MESSAGE, *PUSER_MESSAGE;</span><br></pre></td></tr></table></figure>
<p><code>PostMessage</code>与<code>SendMessage</code>的区别。<br>前者是异步的发生方直接把消息发送到接收方的消息队列中就返 回,不管消息有没有被处理完成。<br>而后者是同步的,要一直等到消息被接收方处理后才会返回。</p>
<p>回到<code>NtUserGetMessage</code>我们看到实际调用的正题函数是下面的这个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL FASTCALL <span class="title">co_IntPeekMessage</span><span class="params">( PUSER_MESSAGE Msg,<span class="comment">//返回取下来的原生消息 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   PWINDOW_OBJECT Window,<span class="comment">//过滤条件 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   UINT MsgFilterMin,<span class="comment">//过滤条件 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   UINT MsgFilterMax,<span class="comment">//过滤条件 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   UINT RemoveMsg )</span><span class="comment">//表示是否需要从队列中移除 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PTHREADINFO pti; </span><br><span class="line">	LARGE_INTEGER LargeTickCount; </span><br><span class="line">	PUSER_MESSAGE_QUEUE ThreadQueue; </span><br><span class="line">	PUSER_MESSAGE Message; </span><br><span class="line">	BOOL Present, RemoveMessages; </span><br><span class="line">	USER_REFERENCE_ENTRY Ref; </span><br><span class="line">	USHORT HitTest; </span><br><span class="line">	pti = PsGetCurrentThreadWin32Thread(); </span><br><span class="line">	ThreadQueue = pti-&gt;MessageQueue; </span><br><span class="line">	RemoveMessages = RemoveMsg &amp; PM_REMOVE;  </span><br><span class="line"></span><br><span class="line">CheckMessages: </span><br><span class="line">	HitTest = HTNOWHERE; </span><br><span class="line">	Present = FALSE;<span class="comment">//表示是否找到了对应的消息 </span></span><br><span class="line">	KeQueryTickCount(&amp;LargeTickCount); </span><br><span class="line">	ThreadQueue-&gt;LastMsgRead = LargeTickCount.u.LowPart;<span class="comment">//记录上次取消息请求的时间 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//在取消息前,先处理完所有其他线程send过来的消息(指SendMessage方式) </span></span><br><span class="line">	<span class="keyword">while</span> (co_MsqDispatchOneSentMessage(ThreadQueue)); </span><br><span class="line"></span><br><span class="line">	<span class="comment">//检测是否收到了WM_QUIT消息,特殊处理 </span></span><br><span class="line">	<span class="keyword">if</span> (ThreadQueue-&gt;QuitPosted) </span><br><span class="line">	&#123; </span><br><span class="line">		Msg-&gt;Msg.hwnd = <span class="literal">NULL</span>; </span><br><span class="line">		Msg-&gt;Msg.message = WM_QUIT; </span><br><span class="line">		Msg-&gt;Msg.wParam = ThreadQueue-&gt;QuitExitCode; </span><br><span class="line">		Msg-&gt;Msg.lParam = <span class="number">0</span>; </span><br><span class="line">		Msg-&gt;FreeLParam = FALSE; </span><br><span class="line">		<span class="keyword">if</span> (RemoveMessages) </span><br><span class="line">		ThreadQueue-&gt;QuitPosted = FALSE; </span><br><span class="line">		<span class="keyword">goto</span> MsgExit; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//先查找post队列中是否有对应的消息(注意键盘消息也是在post队列中) </span></span><br><span class="line">	Present = co_MsqFindMessage( ThreadQueue,FALSE,RemoveMessages, Window,MsgFilterMin,MsgFilterMax,&amp;Message);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Present) </span><br><span class="line">	&#123; </span><br><span class="line">		RtlCopyMemory(Msg, Message, <span class="keyword">sizeof</span>(USER_MESSAGE));<span class="comment">//取下来,返回给用户 </span></span><br><span class="line">		<span class="keyword">if</span> (RemoveMessages) </span><br><span class="line">			MsqDestroyMessage(Message); </span><br><span class="line">		<span class="keyword">goto</span> MessageFound; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//再检查硬件消息队列中是否有鼠标消息 </span></span><br><span class="line">	Present = co_MsqFindMessage( ThreadQueue,TRUE,RemoveMessages, Window,MsgFilterMin,MsgFilterMax,&amp;Message);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Present) </span><br><span class="line">	&#123; </span><br><span class="line">		RtlCopyMemory(Msg, Message, <span class="keyword">sizeof</span>(USER_MESSAGE)); <span class="comment">//取下来,返回给用户 </span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (RemoveMessages) </span><br><span class="line">			MsqDestroyMessage(Message); </span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> MessageFound; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//上面的查找过程会耗时一段时间,因此可能会又积累了send消息,处理掉 </span></span><br><span class="line">	<span class="keyword">while</span> (co_MsqDispatchOneSentMessage(ThreadQueue)); </span><br><span class="line"></span><br><span class="line">	<span class="comment">//检测是否有WM_PAINT消息 </span></span><br><span class="line">	<span class="keyword">if</span> ( IntGetPaintMessage( Window,MsgFilterMin,MsgFilterMax,pti,&amp;Msg-&gt;Msg,RemoveMessages)) </span><br><span class="line">	&#123; </span><br><span class="line">		Msg-&gt;FreeLParam = FALSE; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> MsgExit; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PostTimerMessages(Window))<span class="comment">//检测是否有WM_TIMER消息 </span></span><br><span class="line">		<span class="keyword">goto</span> CheckMessages; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(Present)<span class="comment">//如果在队列中找到了消息 </span></span><br><span class="line">	&#123; </span><br><span class="line"></span><br><span class="line">MessageFound: </span><br><span class="line">		<span class="keyword">if</span>(RemoveMessages) </span><br><span class="line">		&#123; </span><br><span class="line">			PWINDOW_OBJECT MsgWindow = <span class="literal">NULL</span>; </span><br><span class="line">			<span class="keyword">if</span>( Msg-&gt;Msg.hwnd &amp;&amp; ( MsgWindow = UserGetWindowObject(Msg-&gt;Msg.hwnd) ) </span><br><span class="line">				&amp;&amp; Msg-&gt;Msg.message &gt;= WM_MOUSEFIRST &amp;&amp; Msg-&gt;Msg.message &lt;= WM_MOUSELAST ) </span><br><span class="line">			&#123; </span><br><span class="line">				USHORT HitTest; </span><br><span class="line">				UserRefObjectCo(MsgWindow, &amp;Ref); </span><br><span class="line">				<span class="keyword">if</span> ( co_IntTranslateMouseMessage( ThreadQueue,&amp;Msg-&gt;Msg,&amp;HitTest,TRUE)) </span><br><span class="line">				&#123; </span><br><span class="line">					UserDerefObjectCo(MsgWindow); </span><br><span class="line">					<span class="keyword">goto</span> CheckMessages;<span class="comment">//丢弃该条消息,重新查找 </span></span><br><span class="line">				&#125; </span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(ThreadQueue-&gt;CaptureWindow == <span class="literal">NULL</span>) </span><br><span class="line">				&#123; </span><br><span class="line">					co_IntSendHitTestMessages(ThreadQueue, &amp;Msg-&gt;Msg); </span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (( Msg-&gt;Msg.message != WM_MOUSEMOVE &amp;&amp; Msg-&gt;Msg.message != WM_NCMOUSEMOVE) </span><br><span class="line">						&amp;&amp;  IS_BTN_MESSAGE(Msg-&gt;Msg.message, DOWN) </span><br><span class="line">						&amp;&amp; co_IntActivateWindowMouse(ThreadQueue, &amp;Msg-&gt;Msg, MsgWindow, &amp;HitTest)) </span><br><span class="line">					&#123; </span><br><span class="line">						UserDerefObjectCo(MsgWindow); </span><br><span class="line">						<span class="keyword">goto</span> CheckMessages; <span class="comment">//丢弃该条消息,重新查找 </span></span><br><span class="line">					&#125; </span><br><span class="line">				&#125; </span><br><span class="line">				UserDerefObjectCo(MsgWindow); </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				co_IntSendHitTestMessages(ThreadQueue, &amp;Msg-&gt;Msg); </span><br><span class="line">			<span class="keyword">goto</span> MsgExit; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span> ( ( Msg-&gt;Msg.hwnd &amp;&amp;  Msg-&gt;Msg.message &gt;= WM_MOUSEFIRST &amp;&amp; Msg-&gt;Msg.message &lt;= WM_MOUSELAST )</span><br><span class="line">			 &amp;&amp; co_IntTranslateMouseMessage( ThreadQueue,&amp;Msg-&gt;Msg,&amp;HitTest,FALSE) ) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">goto</span> CheckMessages; <span class="comment">//丢弃该条消息,重新查找 </span></span><br><span class="line"></span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">MsgExit: </span><br><span class="line">		<span class="keyword">if</span> ( ISITHOOKED(WH_MOUSE) &amp;&amp; IS_MOUSE_MESSAGE(Msg-&gt;Msg.message)) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span>(!ProcessMouseMessage(&amp;Msg-&gt;Msg, HitTest, RemoveMsg)) </span><br><span class="line">			<span class="keyword">return</span> FALSE; </span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( ISITHOOKED(WH_KEYBOARD) &amp;&amp; IS_KBD_MESSAGE(Msg-&gt;Msg.message)) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span>(!ProcessKeyboardMessage(&amp;Msg-&gt;Msg, RemoveMsg)) </span><br><span class="line">			<span class="keyword">return</span> FALSE; </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//每当取出一个消息后,都会调用WH_GETMESSAGE钩子 </span></span><br><span class="line">		<span class="keyword">if</span> (ISITHOOKED(WH_GETMESSAGE)) </span><br><span class="line">		&#123; </span><br><span class="line">			co_HOOK_CallHooks( WH_GETMESSAGE, HC_ACTION, RemoveMsg &amp; PM_REMOVE, (LPARAM)&amp;Msg-&gt;M sg); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> TRUE; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Present; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上这个函数会从<code>post</code>消息队列和硬件消息队列中查找,取出一个符合指定条件的消息出来。<br>不过在进行查找前,会优先处理掉<code>send</code>队列中其他线程发来的消息。<br>查找消息的顺序是：<code>send</code>队列、<code>post</code>队列、键盘鼠标消息、重绘消息、定时器消息【send、post、键鼠、 重、定时】 </p>
<h5 id="USER-SENT-MESSAGE"><a href="#USER-SENT-MESSAGE" class="headerlink" title="_USER_SENT_MESSAGE"></a><code>_USER_SENT_MESSAGE</code></h5><p>注意<code>send</code>队列中的消息结构与<code>post</code>队列、硬件队列中的消息结构不同,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USER_SENT_MESSAGE</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	LIST_ENTRY ListEntry;<span class="comment">//用来挂入接收方的Dispatching处理队列 </span></span><br><span class="line">	MSG Msg;<span class="comment">//主体 </span></span><br><span class="line">	PKEVENT CompletionEvent;<span class="comment">//完成处理后,用于通知发送方的事件 </span></span><br><span class="line">	LRESULT* Result;<span class="comment">//处理结果 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">USER_MESSAGE_QUEUE</span>* <span class="title">SenderQueue</span>;</span><span class="comment">//发送方的消息队列(方便用) </span></span><br><span class="line">	SENDASYNCPROC CompletionCallback;<span class="comment">//发送方提供的消息处理完成例程 </span></span><br><span class="line">	ULONG_PTR CompletionCallbackContext; </span><br><span class="line">	LIST_ENTRY DispatchingListEntry;<span class="comment">//用来挂入发送方的Dispatching未完成队列 </span></span><br><span class="line">	INT HookMessage;<span class="comment">//钩子相关 </span></span><br><span class="line">	BOOL HasPackedLParam;<span class="comment">//表示L附件包是否打包到用户空间了 </span></span><br><span class="line">&#125; USER_SENT_MESSAGE, *PUSER_SENT_MESSAGE;</span><br></pre></td></tr></table></figure>
<h5 id="send队列处理"><a href="#send队列处理" class="headerlink" title="send队列处理"></a>send队列处理</h5><h6 id="co-MsqDispatchOneSentMessage"><a href="#co-MsqDispatchOneSentMessage" class="headerlink" title="co_MsqDispatchOneSentMessage"></a>co_MsqDispatchOneSentMessage</h6><p>下面的函数用于处理<code>send</code>队列中的一条消息 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN FASTCALL <span class="title">co_MsqDispatchOneSentMessage</span><span class="params">(PUSER_MESSAGE_QUEUE MessageQueue)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PUSER_SENT_MESSAGE Message; </span><br><span class="line">	PLIST_ENTRY Entry; </span><br><span class="line">	LRESULT Result; </span><br><span class="line">	<span class="keyword">if</span> (IsListEmpty(&amp;MessageQueue-&gt;SentMessagesListHead)) </span><br><span class="line">		<span class="keyword">return</span>(FALSE); </span><br><span class="line">	</span><br><span class="line">	Entry = RemoveHeadList(&amp;MessageQueue-&gt;SentMessagesListHead); </span><br><span class="line">	Message = CONTAINING_RECORD(Entry, USER_SENT_MESSAGE, ListEntry); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//转入接收方线程的正在Dispatching处理队列 </span></span><br><span class="line">	InsertTailList(&amp;MessageQueue-&gt;LocalDispatchingMessagesHead,&amp;Message-&gt;ListEntry); </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if 这个消息本身就是‘请求执行钩子过程’,那么message表示HookId,hwnd表示code </span></span><br><span class="line">	<span class="comment">//其他线程在调用底层键盘鼠标钩子时,会给钩子的原创建者线程发一个消息,请求执行钩子过程 </span></span><br><span class="line">	<span class="keyword">if</span> (Message-&gt;HookMessage == MSQ_ISHOOK)  </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//检查、调用指定类型的钩子  </span></span><br><span class="line">		Result = co_HOOK_CallHooks(Message-&gt;Msg.message,Message-&gt;Msg.hwnd, </span><br><span class="line">		             Message-&gt;Msg.wParam,Message-&gt;Msg.lParam); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Message-&gt;HookMessage == MSQ_ISEVENT) </span><br><span class="line">	&#123; </span><br><span class="line">		Result = co_EVENT_CallEvents( Message-&gt;Msg.message,Message-&gt;Msg.hwnd, </span><br><span class="line">		                Message-&gt;Msg.wParam,Message-&gt;Msg.lParam); </span><br><span class="line">	&#125; </span><br><span class="line">	Else <span class="comment">//最典型 </span></span><br><span class="line">	&#123; </span><br><span class="line"></span><br><span class="line">		<span class="comment">//关键。将消息派遣到目标窗口的窗口过程,处理消息,返回处理结果 </span></span><br><span class="line">		Result = co_IntSendMessage(Message-&gt;Msg.hwnd,Message-&gt;Msg.message, </span><br><span class="line">		             Message-&gt;Msg.wParam,Message-&gt;Msg.lParam); </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	RemoveEntryList(&amp;Message-&gt;ListEntry);<span class="comment">//处理完后从接收方的Dispatching队列移除 </span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(Message-&gt;HookMessage &amp; MSQ_SENTNOWAIT)) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (Message-&gt;DispatchingListEntry.Flink != <span class="literal">NULL</span>) </span><br><span class="line">		RemoveEntryList(&amp;Message-&gt;DispatchingListEntry);<span class="comment">//从发送方的Dispatching队列移除 </span></span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (Message-&gt;Result != <span class="literal">NULL</span>) </span><br><span class="line">		*Message-&gt;Result = Result;<span class="comment">//返回处理结果 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Message-&gt;HasPackedLParam == TRUE &amp;&amp; Message-&gt;Msg.lParam) </span><br><span class="line">		ExFreePool((PVOID)Message-&gt;Msg.lParam); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (Message-&gt;CompletionEvent != <span class="literal">NULL</span>)<span class="comment">//唤醒发送方 </span></span><br><span class="line">		KeSetEvent(Message-&gt;CompletionEvent, IO_NO_INCREMENT, FALSE); </span><br><span class="line"></span><br><span class="line">	<span class="comment">//发送方可以调用SendMessageCallback这个API设置一个完成回调函数 </span></span><br><span class="line">	<span class="keyword">if</span> (Message-&gt;CompletionCallback != <span class="literal">NULL</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//给发送方发送一个通知消息,通知它调用这个回调函数 </span></span><br><span class="line">		<span class="comment">//为什么不直接执行回调函数？因为回调函数是发送方提供的,是在发送方进程地址空间中 </span></span><br><span class="line">		co_IntCallSentMessageCallback(Message-&gt;CompletionCallback,Message-&gt;Msg.hwnd, </span><br><span class="line">		                Message-&gt;Msg.message,Message-&gt;CompletionCallbackContext, </span><br><span class="line">		                Result); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (!(Message-&gt;HookMessage &amp; MSQ_SENTNOWAIT)) </span><br><span class="line">	&#123; </span><br><span class="line">		IntDereferenceMessageQueue(Message-&gt;SenderQueue); </span><br><span class="line">		IntDereferenceMessageQueue(MessageQueue); </span><br><span class="line">	&#125; </span><br><span class="line">	ExFreePoolWithTag(Message, TAG_USRMSG); </span><br><span class="line">	<span class="keyword">return</span>(TRUE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="post消息队列处理"><a href="#post消息队列处理" class="headerlink" title="post消息队列处理"></a>post消息队列处理</h5><h6 id="co-MsqFindMessage"><a href="#co-MsqFindMessage" class="headerlink" title="co_MsqFindMessage"></a>co_MsqFindMessage</h6><p>下面的函数用于在硬件消息队列或<code>post</code>消息队列中查找消息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN APIENTRY <span class="title">co_MsqFindMessage</span><span class="params">(IN PUSER_MESSAGE_QUEUE MessageQueue, </span></span></span><br><span class="line"><span class="function"><span class="params">                  IN BOOLEAN Hardware,<span class="comment">//指是在硬件消息队列还是post消息队列中查找 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                  IN BOOLEAN Remove,<span class="comment">//是否移除队列 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                  IN PWINDOW_OBJECT Window,<span class="comment">//过滤条件 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                  IN UINT MsgFilterLow,<span class="comment">//过滤条件 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                  IN UINT MsgFilterHigh,<span class="comment">//过滤条件 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                  OUT PUSER_MESSAGE* Message)</span><span class="comment">//返回找到的消息 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PLIST_ENTRY CurrentEntry; </span><br><span class="line">	PUSER_MESSAGE CurrentMessage; </span><br><span class="line">	PLIST_ENTRY ListHead; </span><br><span class="line">	<span class="keyword">if</span> (Hardware)<span class="comment">//硬件消息(鼠标消息)需要特殊处理 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">return</span>(co_MsqPeekHardwareMessage( MessageQueue,Window,MsgFilterLow,MsgFilterHigh, Remove,Message)); </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	CurrentEntry = MessageQueue-&gt;PostedMessagesListHead.Flink; </span><br><span class="line">	ListHead = &amp;MessageQueue-&gt;PostedMessagesListHead; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (CurrentEntry != ListHead) </span><br><span class="line">	&#123; </span><br><span class="line">		CurrentMessage = CONTAINING_RECORD(CurrentEntry, USER_MESSAGE,ListEntry); </span><br><span class="line">		<span class="keyword">if</span> ( ( !Window ||PtrToInt(Window) == <span class="number">1</span> || Window-&gt;hSelf == CurrentMessage-&gt;Msg.hwnd ) </span><br><span class="line">			&amp;&amp; ((MsgFilterLow == <span class="number">0</span> &amp;&amp; MsgFilterHigh == <span class="number">0</span>) </span><br><span class="line">			|| (MsgFilterLow &lt;= CurrentMessage-&gt;Msg.message </span><br><span class="line">				&amp;&amp; MsgFilterHigh &gt;= CurrentMessage-&gt;Msg.message ) ) ) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> (Remove) </span><br><span class="line">				RemoveEntryList(&amp;CurrentMessage-&gt;ListEntry); </span><br><span class="line">			</span><br><span class="line">			*Message = CurrentMessage; </span><br><span class="line">			<span class="keyword">return</span>(TRUE); </span><br><span class="line">		&#125; </span><br><span class="line">		CurrentEntry = CurrentEntry-&gt;Flink; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(FALSE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码我想不用解释了。 </p>
<p>由此可以看到在<code>GetMessage</code>、<code>PeekMessage</code>函数内部,会一直等待到消息队列中出现符合指定条件的消息,这就是为什么<code>GUI</code>线程绝大多数时刻都处于睡眠状态的原因, 因为它在等待消息。<br>另外在<code>GetMessage</code>、<code>PeekMessage</code>内部,即使因为队列中一直没有符合指定条件的消息而等待,也为在内部不断的处理别的线程通过<code>SendMessage</code> 方式发来的消息,以尽快完成这种消息的处理。</p>
<p>回到<code>NtUserGetMessage</code>内部继续执行<code>co_IntPeekMessage</code>函数。这个函数前面看过,它会两次调用<code>co_MsqFindMessage</code>,先查找线程<code>post</code>队列,然后查找硬件消息队列。<br>当时因为硬件消息处理特殊,省略没看,现在我们可以看他是如何查找硬件消息队列的。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">co_MsqPeekHardwareMessage</span><span class="params">(PUSER_MESSAGE_QUEUE MessageQueue, PWINDOW_OBJECT Window, </span></span></span><br><span class="line"><span class="function"><span class="params">                          UINT FilterLow, UINT FilterHigh, BOOL Remove,PUSER_MESSAGE* Message)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   PWINDOW_OBJECT DesktopWindow = <span class="literal">NULL</span>; </span><br><span class="line">   PDESKTOPINFO Desk = <span class="literal">NULL</span>; </span><br><span class="line">WaitObjects[<span class="number">0</span>] = &amp;HardwareMessageQueueLock; </span><br><span class="line">   WaitObjects[<span class="number">1</span>] = MessageQueue-&gt;NewMessages;<span class="comment">//主要是等待这个事件 </span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">do</span> </span><br><span class="line">   &#123; </span><br><span class="line">      IdlePing(); </span><br><span class="line">      UserLeaveCo(); </span><br><span class="line">      WaitStatus = KeWaitForMultipleObjects(<span class="number">2</span>, WaitObjects, WaitAny, UserRequest, </span><br><span class="line">                                            UserMode, FALSE, <span class="literal">NULL</span>, <span class="literal">NULL</span>); </span><br><span class="line">      UserEnterCo(); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">while</span> (NT_SUCCESS(WaitStatus) &amp;&amp; STATUS_WAIT_0 != WaitStatus); </span><br><span class="line">   <span class="comment">//上面的循环一直等到NewMessages事件触发后,才来到这里 </span></span><br><span class="line">   DesktopWindow = UserGetWindowObject(IntGetDesktopWindow()); </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (DesktopWindow) </span><br><span class="line"> </span><br><span class="line">   &#123; </span><br><span class="line">       UserRefObjectCo(DesktopWindow, &amp;Ref); </span><br><span class="line">       Desk = DesktopWindow-&gt;pti-&gt;pDeskInfo; </span><br><span class="line">   &#125; </span><br><span class="line">   IntLockHardwareMessageQueue(MessageQueue);<span class="comment">//锁定线程的硬件消息队列 </span></span><br><span class="line">   CurrentEntry = MessageQueue-&gt;HardwareMessagesListHead.Flink; </span><br><span class="line">   <span class="keyword">while</span> (CurrentEntry != &amp;MessageQueue-&gt;HardwareMessagesListHead)<span class="comment">//遍历线程的硬件消息队列 </span></span><br><span class="line">   &#123; </span><br><span class="line">      PUSER_MESSAGE Current = CONTAINING_RECORD(CurrentEntry, USER_MESSAGE, ListEntry); </span><br><span class="line">      CurrentEntry = CurrentEntry-&gt;Flink; </span><br><span class="line">      <span class="comment">//我们只要鼠标消息 </span></span><br><span class="line">      <span class="keyword">if</span> (Current-&gt;Msg.message &gt;= WM_MOUSEFIRST &amp;&amp; Current-&gt;Msg.message &lt;= WM_MOUSELAST) </span><br><span class="line">      &#123; </span><br><span class="line">         <span class="comment">//判断这个鼠标消息是不是我们需要的消息(即是否满足3个过滤条件) </span></span><br><span class="line">         Accept = co_MsqTranslateMouseMessage(MessageQueue, Window, FilterLow, FilterHigh, </span><br><span class="line">                                              Current, Remove, &amp;Freed,DesktopWindow, &amp;ScreenPoint, FALSE, &amp;CurrentEntry); </span><br><span class="line">         <span class="keyword">if</span> (Accept)<span class="comment">//如果是,也即如果找到了一个需要的消息 </span></span><br><span class="line">         &#123; </span><br><span class="line">            <span class="keyword">if</span> (Remove)  RemoveEntryList(&amp;Current-&gt;ListEntry); </span><br><span class="line">            IntUnLockHardwareMessageQueue(MessageQueue); </span><br><span class="line">            IntUnLockSystemHardwareMessageQueueLock(FALSE); </span><br><span class="line">            *Message = Current;<span class="comment">//返回找到的消息 </span></span><br><span class="line">            <span class="keyword">if</span> (Desk)  Desk-&gt;LastInputWasKbd = FALSE; </span><br><span class="line">            RETURN(TRUE); </span><br><span class="line">         &#125; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   IntUnLockHardwareMessageQueue(MessageQueue); </span><br><span class="line">   IntLockSystemMessageQueue(OldIrql);<span class="comment">//锁定系统的环形缓冲消息队列 </span></span><br><span class="line">   <span class="keyword">while</span> (SystemMessageQueueCount &gt; <span class="number">0</span>)<span class="comment">//将环形缓冲消息队列中的消息全部转入系统硬件消息队列 </span></span><br><span class="line">   &#123; </span><br><span class="line">      PUSER_MESSAGE UserMsg; </span><br><span class="line">      MSG Msg; </span><br><span class="line">      Msg = SystemMessageQueue[SystemMessageQueueHead]; </span><br><span class="line">      SystemMessageQueueHead = (SystemMessageQueueHead + <span class="number">1</span>) % SYSTEM_MESSAGE_QUEUE_SIZE; </span><br><span class="line">      SystemMessageQueueCount--; </span><br><span class="line">      IntUnLockSystemMessageQueue(OldIrql); </span><br><span class="line">      <span class="comment">//系统硬件消息队列中的消息结构 与 环形缓冲消息队列中的消息结构不相同,要转换 </span></span><br><span class="line">      UserMsg = ExAllocateFromPagedLookasideList(&amp;MessageLookasideList); </span><br><span class="line">      UserMsg-&gt;FreeLParam = FALSE; </span><br><span class="line">      UserMsg-&gt;Msg = Msg; </span><br><span class="line">      InsertTailList(&amp;HardwareMessageQueueHead, &amp;UserMsg-&gt;ListEntry);<span class="comment">//转入系统硬件消息队列 </span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">      IntLockSystemMessageQueue(OldIrql); </span><br><span class="line">   &#125; </span><br><span class="line">   HardwareMessageQueueStamp++; </span><br><span class="line">   IntUnLockSystemMessageQueue(OldIrql); </span><br><span class="line"> </span><br><span class="line">   <span class="comment">//转移所有缓冲消息到系统硬件消息队列后,现在开始扫描查找 </span></span><br><span class="line">   CurrentEntry = HardwareMessageQueueHead.Flink; </span><br><span class="line">   <span class="keyword">while</span> (CurrentEntry != &amp;HardwareMessageQueueHead) </span><br><span class="line">   &#123; </span><br><span class="line">      PUSER_MESSAGE Current = CONTAINING_RECORD(CurrentEntry, USER_MESSAGE, ListEntry); </span><br><span class="line">      CurrentEntry = CurrentEntry-&gt;Flink; </span><br><span class="line">      RemoveEntryList(&amp;Current-&gt;ListEntry);<span class="comment">//不管如何,先从系统硬件消息队列中取下来 </span></span><br><span class="line">      HardwareMessageQueueStamp++; </span><br><span class="line">      <span class="keyword">if</span> (Current-&gt;Msg.message &gt;= WM_MOUSEFIRST &amp;&amp; Current-&gt;Msg.message &lt;= WM_MOUSELAST) </span><br><span class="line">      &#123; </span><br><span class="line">         <span class="keyword">const</span> ULONG ActiveStamp = HardwareMessageQueueStamp; </span><br><span class="line">         <span class="comment">//判断是不是我们需要的消息(根据三个过滤条件) </span></span><br><span class="line">         Accept = co_MsqTranslateMouseMessage(MessageQueue, Window, FilterLow, FilterHigh, </span><br><span class="line">                                              Current, Remove, &amp;Freed, </span><br><span class="line">                                              DesktopWindow, &amp;ScreenPoint, TRUE, <span class="literal">NULL</span>); </span><br><span class="line">         <span class="keyword">if</span> (Accept)<span class="comment">//如果是我们需要的消息,也即如果找到了 </span></span><br><span class="line">         &#123;       </span><br><span class="line">            IntLockSystemMessageQueue(OldIrql); </span><br><span class="line">            <span class="keyword">if</span> (SystemMessageQueueCount == <span class="number">0</span> &amp;&amp; IsListEmpty(&amp;HardwareMessageQueueHead)) </span><br><span class="line">               KeClearEvent(&amp;HardwareMessageEvent);<span class="comment">//若两个队列都空了,复位事件 </span></span><br><span class="line">            IntUnLockSystemMessageQueue(OldIrql); </span><br><span class="line">            <span class="keyword">if</span> (!Remove)<span class="comment">//将取下来的消息插回线程的硬件消息队列中 </span></span><br><span class="line">            &#123; </span><br><span class="line">               IntLockHardwareMessageQueue(MessageQueue); </span><br><span class="line">               <span class="keyword">if</span>(Current-&gt;Msg.message == WM_MOUSEMOVE)<span class="comment">//不过MouseMove特殊处理 </span></span><br><span class="line">               &#123; </span><br><span class="line">                  <span class="keyword">if</span>(MessageQueue-&gt;MouseMoveMsg) </span><br><span class="line">                  &#123; </span><br><span class="line">                     RemoveEntryList(&amp;MessageQueue-&gt;MouseMoveMsg-&gt;ListEntry); </span><br><span class="line">                     ExFreePool(MessageQueue-&gt;MouseMoveMsg);<span class="comment">//销毁原来的MouseMove消息 </span></span><br><span class="line">                  &#125; </span><br><span class="line">                  MessageQueue-&gt;MouseMoveMsg = Current;<span class="comment">//修改替换成现在刚取下的MouseMove消息 </span></span><br><span class="line">               &#125; </span><br><span class="line">               <span class="comment">//插入到线程的硬件消息队列中,体现为NoRemove </span></span><br><span class="line">               InsertTailList(&amp;MessageQueue-&gt;HardwareMessagesListHead,&amp;Current-&gt;ListEntry); </span><br><span class="line">               IntUnLockHardwareMessageQueue(MessageQueue); </span><br><span class="line">            &#125; </span><br><span class="line">            IntUnLockSystemHardwareMessageQueueLock(FALSE); </span><br><span class="line">            *Message = Current;<span class="comment">//返回找到的消息 </span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            RETURN(TRUE); </span><br><span class="line">         &#125; </span><br><span class="line">         <span class="comment">//if 队列的内容改变了,重新从头开始处理 </span></span><br><span class="line">         <span class="keyword">if</span> (HardwareMessageQueueStamp != ActiveStamp) </span><br><span class="line">         &#123; </span><br><span class="line">            CurrentEntry = HardwareMessageQueueHead.Flink; </span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">         &#125; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   IntLockSystemMessageQueue(OldIrql); </span><br><span class="line">   <span class="keyword">if</span> (SystemMessageQueueCount == <span class="number">0</span> &amp;&amp; IsListEmpty(&amp;HardwareMessageQueueHead)) </span><br><span class="line">      KeClearEvent(&amp;HardwareMessageEvent); </span><br><span class="line">   IntUnLockSystemMessageQueue(OldIrql); </span><br><span class="line">   IntUnLockSystemHardwareMessageQueueLock(FALSE); </span><br><span class="line">   RETURN(FALSE); CLEANUP: </span><br><span class="line">   <span class="keyword">if</span> (DesktopWindow) UserDerefObjectCo(DesktopWindow); </span><br><span class="line">   END_CLEANUP; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="co-IntWaitMessage"><a href="#co-IntWaitMessage" class="headerlink" title="co_IntWaitMessage"></a>co_IntWaitMessage</h4><p>具体的<code>ntUserGetMessage</code>我们看过,内部会调用<code>co_IntPeekMessage</code>接收消息,如果找不到,就调用<code>co_IntWaitMessage</code>等待。<br>我们看这个函数的实现。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL FASTCALL <span class="title">co_IntWaitMessage</span><span class="params">( PWINDOW_OBJECT Window,UINT MsgFilterMin,UINT MsgFilterMax )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   PTHREADINFO pti; </span><br><span class="line">   PUSER_MESSAGE_QUEUE ThreadQueue; </span><br><span class="line">   NTSTATUS Status = STATUS_SUCCESS; </span><br><span class="line">   USER_MESSAGE Msg; </span><br><span class="line">   pti = PsGetCurrentThreadWin32Thread(); </span><br><span class="line">   ThreadQueue = pti-&gt;MessageQueue; </span><br><span class="line">   <span class="keyword">do</span> </span><br><span class="line">   &#123; </span><br><span class="line">      <span class="comment">//if 有消息,返回 </span></span><br><span class="line">      <span class="keyword">if</span> ( co_IntPeekMessage( &amp;Msg,Window,MsgFilterMin,MsgFilterMax,PM_NOREMOVE))<span class="comment">//不移除 </span></span><br><span class="line">         <span class="keyword">return</span> TRUE; </span><br><span class="line">      <span class="comment">//否则,等待 </span></span><br><span class="line"> </span><br><span class="line">      Status = co_MsqWaitForNewMessages( ThreadQueue,Window,MsgFilterMin,MsgFilterMax); </span><br><span class="line">   &#125;<span class="keyword">while</span> ( (STATUS_WAIT_0 &lt;= Status &amp;&amp; Status &lt;= STATUS_WAIT_63)); </span><br><span class="line">   </span><br><span class="line">   <span class="comment">//上面的循环,每次一个新消息进队后,就回头去检测队列中是否有需要的消息 </span></span><br><span class="line">   <span class="keyword">if</span> (!NT_SUCCESS(Status)) </span><br><span class="line">      SetLastNtError(Status); </span><br><span class="line">   <span class="keyword">return</span> FALSE; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS FASTCALL <span class="title">co_MsqWaitForNewMessages</span><span class="params">(PUSER_MESSAGE_QUEUE MessageQueue, PWINDOW_OBJECT WndFilter, </span></span></span><br><span class="line"><span class="function"><span class="params">                                               UINT MsgFilterMin, UINT MsgFilterMax)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="comment">//等待线程的消息队列,全局的硬件消息队列两个队列的新消息事件 </span></span><br><span class="line">   PVOID WaitObjects[<span class="number">2</span>] = &#123;MessageQueue-&gt;NewMessages, &amp;HardwareMessageEvent&#125;; </span><br><span class="line">   NTSTATUS ret; </span><br><span class="line">   ret = KeWaitForMultipleObjects(<span class="number">2</span>,WaitObjects,WaitAny,Executive,UserMode,FALSE, </span><br><span class="line">                                  <span class="literal">NULL</span>,<span class="literal">NULL</span>); </span><br><span class="line">   <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面个函数先在本地线程的硬件消息队列中查找,找不到就再去全局的系统硬件消息队列中查找</p>
<p><br></p>
<h3 id="co-MsqTranslateMouseMessage"><a href="#co-MsqTranslateMouseMessage" class="headerlink" title="co_MsqTranslateMouseMessage"></a>co_MsqTranslateMouseMessage</h3><p>具体的查找判定函数看下面：(这个函数专用于判定鼠标消息是否符合过滤条件)<br>关键的判断比较操作就是比较光标处窗口是不是我们的窗口。<br>另外从以上可以看出鼠标消息的流动方向是：<code>系统环形缓冲消息队列</code>-&gt;<code>系统硬件消息队列</code>-&gt;<code>目标线程硬件消息队列</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">co_MsqTranslateMouseMessage</span><span class="params">(PUSER_MESSAGE_QUEUE MessageQueue, </span></span></span><br><span class="line"><span class="function"><span class="params">                            PWINDOW_OBJECT Window, UINT FilterLow, UINT FilterHigh,<span class="comment">//过滤条件 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                            PUSER_MESSAGE Message,<span class="comment">//IN\OUT,返回该消息的目标窗口 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                            BOOL Remove,<span class="comment">//没用 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                            PBOOL Freed,<span class="comment">//返回是否需要释放L附件包 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                            PWINDOW_OBJECT ScopeWin, <span class="comment">//一般就是桌面窗口 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                            PPOINT ScreenPoint,<span class="comment">//返回鼠标消息的产生位置 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                            BOOL FromGlobalQueue)</span><span class="comment">//指Message参数是否是全局硬件消息队列中的 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   USHORT Msg = Message-&gt;Msg.message; </span><br><span class="line">   PWINDOW_OBJECT CaptureWindow = <span class="literal">NULL</span>; <span class="comment">//鼠标消息发往的目标窗口 HWND hCaptureWin;//鼠标消息发往的目标窗口 </span></span><br><span class="line">   hCaptureWin = IntGetCaptureWindow();<span class="comment">//当前的鼠标焦点窗口(很少有鼠标焦点) </span></span><br><span class="line">   <span class="keyword">if</span> (hCaptureWin == <span class="literal">NULL</span>)<span class="comment">//一般总是NULL </span></span><br><span class="line">   &#123; </span><br><span class="line">      <span class="keyword">if</span> (Msg == WM_MOUSEWHEEL)<span class="comment">//滚轮消息总是发给键盘焦点窗口的 </span></span><br><span class="line">      &#123; </span><br><span class="line"> </span><br><span class="line">         CaptureWindow = UserGetWindowObject(IntGetFocusWindow());<span class="comment">//键盘焦点窗口 </span></span><br><span class="line">         <span class="keyword">if</span> (CaptureWindow) UserReferenceObject(CaptureWindow); </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">      &#123; </span><br><span class="line">         <span class="comment">//关键。计算鼠标消息产生时,当时光标处的窗口 </span></span><br><span class="line">         co_WinPosWindowFromPoint(ScopeWin, <span class="literal">NULL</span>, &amp;Message-&gt;Msg.pt, &amp;CaptureWindow); </span><br><span class="line">         <span class="keyword">if</span>(CaptureWindow == <span class="literal">NULL</span>) </span><br><span class="line">         &#123; </span><br><span class="line">            CaptureWindow = ScopeWin;<span class="comment">//如果光标处没有窗口,就是桌面窗口 </span></span><br><span class="line">            <span class="keyword">if</span> (CaptureWindow) UserReferenceObject(CaptureWindow); </span><br><span class="line">         &#125; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   Else <span class="comment">//很少见。若有鼠标焦点窗口,所有鼠标消息都发给当前鼠标焦点窗口 </span></span><br><span class="line">   &#123; </span><br><span class="line">      CaptureWindow = UserGetWindowObject(hCaptureWin); </span><br><span class="line">      <span class="keyword">if</span> (CaptureWindow) UserReferenceObject(CaptureWindow); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">if</span> (CaptureWindow == <span class="literal">NULL</span>) … </span><br><span class="line"> </span><br><span class="line">   <span class="comment">//如果现在的光标处窗口 与 当初鼠标消息刚产生时的光标处窗口不同了,将消息从消息队列中移除, 转发给现在的光标处窗口的所属线程 </span></span><br><span class="line">   <span class="keyword">if</span> (CaptureWindow-&gt;pti-&gt;MessageQueue != MessageQueue) </span><br><span class="line">   &#123; </span><br><span class="line">      <span class="keyword">if</span> (! FromGlobalQueue) </span><br><span class="line">      &#123; </span><br><span class="line">         RemoveEntryList(&amp;Message-&gt;ListEntry); </span><br><span class="line">         <span class="keyword">if</span>(MessageQueue-&gt;MouseMoveMsg == Message) </span><br><span class="line">            MessageQueue-&gt;MouseMoveMsg = <span class="literal">NULL</span>; </span><br><span class="line">      &#125; </span><br><span class="line">      IntLockHardwareMessageQueue(CaptureWindow-&gt;pti-&gt;MessageQueue); </span><br><span class="line">      <span class="comment">//转入新的目标线程 </span></span><br><span class="line">      InsertTailList(&amp;CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;HardwareMessagesListHead, </span><br><span class="line">                     &amp;Message-&gt;ListEntry); </span><br><span class="line">      <span class="keyword">if</span>(Message-&gt;Msg.message == WM_MOUSEMOVE) <span class="comment">// WM_MOUSEMOV需要特殊处理 </span></span><br><span class="line">      &#123; </span><br><span class="line">         <span class="keyword">if</span>(CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;MouseMoveMsg) </span><br><span class="line">         &#123; </span><br><span class="line">            RemoveEntryList(&amp;CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;MouseMoveMsg-&gt;ListEntry); </span><br><span class="line">            ExFreePool(CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;MouseMoveMsg); </span><br><span class="line">         &#125; </span><br><span class="line">         CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;MouseMoveMsg = Message; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">         CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;QueueBits |= QS_MOUSEMOVE; </span><br><span class="line">         CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;ChangedBits |= QS_MOUSEMOVE; </span><br><span class="line">         <span class="keyword">if</span> (CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;WakeMask &amp; QS_MOUSEMOVE) </span><br><span class="line">            KeSetEvent(CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;NewMessages, <span class="number">0</span>, FALSE); </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">      &#123; </span><br><span class="line">         CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;QueueBits |= QS_MOUSEBUTTON; </span><br><span class="line">         CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;ChangedBits |= QS_MOUSEBUTTON; </span><br><span class="line">         <span class="keyword">if</span> (CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;WakeMask &amp; QS_MOUSEBUTTON) </span><br><span class="line">            KeSetEvent(CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;NewMessages, <span class="number">0</span>, FALSE); </span><br><span class="line">      &#125; </span><br><span class="line">      IntUnLockHardwareMessageQueue(CaptureWindow-&gt;pti-&gt;MessageQueue); </span><br><span class="line">      *Freed = FALSE; </span><br><span class="line">      UserDereferenceObject(CaptureWindow); </span><br><span class="line">      <span class="keyword">return</span>(FALSE); </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   <span class="comment">//否则为同一个消息队列(也即光标处的窗口没发生变化)  </span></span><br><span class="line">   *ScreenPoint = Message-&gt;Msg.pt;<span class="comment">//返回鼠标消息产生时的光标位置 </span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//关键。当计算出该鼠标消息发往的目标窗口后,现在比较判断这条消息是不是我们想要的消息 </span></span><br><span class="line">   <span class="comment">//if 不是我们想要的消息,简单转入线程的硬件消息队列 </span></span><br><span class="line">   <span class="keyword">if</span>((Window != <span class="literal">NULL</span> &amp;&amp; PtrToInt(Window) != <span class="number">1</span> &amp;&amp; CaptureWindow-&gt;hSelf != Window-&gt;hSelf) || </span><br><span class="line">         ((FilterLow != <span class="number">0</span> || FilterHigh != <span class="number">0</span>) &amp;&amp; (Msg &lt; FilterLow || Msg &gt; FilterHigh))) </span><br><span class="line">   &#123; </span><br><span class="line">      <span class="keyword">if</span>(FromGlobalQueue)<span class="comment">//if 是系统硬件消息队列中的消息 </span></span><br><span class="line">      &#123; </span><br><span class="line">         IntLockHardwareMessageQueue(CaptureWindow-&gt;pti-&gt;MessageQueue); </span><br><span class="line">         <span class="comment">//转入线程的硬件消息队列 </span></span><br><span class="line">         InsertTailList(&amp;CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;HardwareMessagesListHead, </span><br><span class="line">                        &amp;Message-&gt;ListEntry); </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">if</span> (Message-&gt;Msg.message == WM_MOUSEMOVE) <span class="comment">//特殊处理 </span></span><br><span class="line">      &#123; </span><br><span class="line">         <span class="keyword">if</span>(CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;MouseMoveMsg &amp;&amp; </span><br><span class="line">               (CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;MouseMoveMsg != Message)) </span><br><span class="line">         &#123; </span><br><span class="line">            RemoveEntryList(&amp;CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;MouseMoveMsg-&gt;ListEntry); </span><br><span class="line">            ExFreePool(CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;MouseMoveMsg); </span><br><span class="line">         &#125; </span><br><span class="line">         CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;MouseMoveMsg = Message; </span><br><span class="line">      &#125; </span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span>(FromGlobalQueue) </span><br><span class="line">         IntUnLockHardwareMessageQueue(CaptureWindow-&gt;pti-&gt;MessageQueue); </span><br><span class="line">      UserDereferenceObject(CaptureWindow); </span><br><span class="line">      *Freed = FALSE; </span><br><span class="line">      <span class="keyword">return</span>(FALSE); </span><br><span class="line">   &#125; </span><br><span class="line">   </span><br><span class="line">   <span class="comment">//关键。If是我们想要的消息,返回这条消息 </span></span><br><span class="line">   Message-&gt;Msg.hwnd = CaptureWindow-&gt;hSelf;<span class="comment">//返回目标窗口 </span></span><br><span class="line">   Message-&gt;Msg.lParam = MAKELONG(Message-&gt;Msg.pt.x, Message-&gt;Msg.pt.y);<span class="comment">//构造好l参数 </span></span><br><span class="line">   <span class="keyword">if</span> (Message-&gt;Msg.message == WM_MOUSEMOVE || Message-&gt;Msg.message == WM_NCMOUSEMOVE) </span><br><span class="line">   &#123; </span><br><span class="line">      <span class="keyword">if</span>(FromGlobalQueue) <span class="comment">//销毁原MouseMove消息 </span></span><br><span class="line">      &#123; </span><br><span class="line">         IntLockHardwareMessageQueue(CaptureWindow-&gt;pti-&gt;MessageQueue); </span><br><span class="line">         <span class="keyword">if</span>(CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;MouseMoveMsg)  </span><br><span class="line">         &#123; </span><br><span class="line">            RemoveEntryList(&amp;CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;MouseMoveMsg-&gt;ListEntry); </span><br><span class="line">            ExFreePool(CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;MouseMoveMsg); </span><br><span class="line">            CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;MouseMoveMsg = <span class="literal">NULL</span>; </span><br><span class="line">         &#125; </span><br><span class="line">         IntUnLockHardwareMessageQueue(CaptureWindow-&gt;pti-&gt;MessageQueue); </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;MouseMoveMsg == Message) </span><br><span class="line">           CaptureWindow-&gt;pti-&gt;MessageQueue-&gt;MouseMoveMsg = <span class="literal">NULL</span>; </span><br><span class="line">   &#125; </span><br><span class="line">   UserDereferenceObject(CaptureWindow); </span><br><span class="line">   *Freed = FALSE; </span><br><span class="line">   <span class="keyword">return</span>(TRUE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="DispatchMessageW"><a href="#DispatchMessageW" class="headerlink" title="DispatchMessageW"></a>DispatchMessageW</h3><p>Windows 消息的产生来源(也即发送方的类型) </p>
<ul>
<li>1、 一个线程调用<code>SendMessage</code>、<code>PostMessage</code>等函数给自己或别的线程发消息,它就是一个发送方线程 </li>
<li>2、 内核中键盘输入守护线程(每当得到一个按键后就发送到当时键盘焦点线程的消息队列)</li>
<li>3、 内核中的鼠标输入守护线程(每当得到一个鼠标消息后就发送到系统的环形缓冲消息队列)</li>
<li>4、 系统<code>win32k.sys</code>模块自己生成、发送消息到目标线程的队列(如定时器消息)</li>
</ul>
<p>当应用程序的消息循环中,通过<code>GetMessage</code>/<code>PeekMessage</code>从消息队列中取出来得到一个消息后,会调用<code>TranslateMessage</code>将键盘按键消息转为字符消息,然后调用<code>DispatchMessage</code>将消息派遣到目标窗口的窗口过程进行处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT  <span class="title">DispatchMessageW</span><span class="params">(CONST MSG *lpmsg)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	LRESULT Ret = <span class="number">0</span>; </span><br><span class="line">	PWND Wnd; </span><br><span class="line">	<span class="keyword">if</span> (lpmsg-&gt;hwnd != <span class="literal">NULL</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		Wnd = ValidateHwnd(lpmsg-&gt;hwnd); </span><br><span class="line">		<span class="keyword">if</span> (!Wnd || Wnd-&gt;head.pti != GetW32ThreadInfo()) </span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		Wnd = <span class="literal">NULL</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((lpmsg-&gt;message == WM_TIMER || lpmsg-&gt;message == WM_SYSTIMER) &amp;&amp; lpmsg-&gt;lParam != <span class="number">0</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> ( lpmsg-&gt;message == WM_SYSTIMER ) </span><br><span class="line">			<span class="keyword">return</span> NtUserDispatchMessage( (PMSG) lpmsg ); </span><br><span class="line">		</span><br><span class="line">		WNDPROC WndProc = (WNDPROC)lpmsg-&gt;lParam;<span class="comment">//有回调函数类型的定时器就在此直接调用了 </span></span><br><span class="line">		Ret = WndProc(lpmsg-&gt;hwnd,lpmsg-&gt;message,lpmsg-&gt;wParam,GetTickCount()); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Wnd != <span class="literal">NULL</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> ( (lpmsg-&gt;message != WM_PAINT) &amp;&amp; !(Wnd-&gt;state &amp; WNDS_SERVERSIDEWINDOWPROC) ) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">//调用窗口过程 </span></span><br><span class="line">			Ret = IntCallMessageProc(Wnd,lpmsg-&gt;hwnd,lpmsg-&gt;message, </span><br><span class="line">			lpmsg-&gt;wParam,lpmsg-&gt;lParam,FALSE); </span><br><span class="line"></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			Ret = NtUserDispatchMessage( (PMSG) lpmsg ); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Ret; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT <span class="title">IntCallMessageProc</span><span class="params">(IN PWND Wnd, IN HWND hWnd, IN UINT Msg, IN WPARAM wParam, IN LPARAM lParam, IN BOOL Ansi)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	WNDPROC WndProc; </span><br><span class="line">	BOOL IsAnsi; </span><br><span class="line">	PCLS Class; </span><br><span class="line">	Class = DesktopPtrToUser(Wnd-&gt;pcls);  </span><br><span class="line">	WndProc = <span class="literal">NULL</span>; </span><br><span class="line">	<span class="keyword">if</span> (Class-&gt;fnid &lt;= FNID_GHOST &amp;&amp; Class-&gt;fnid &gt;= FNID_FIRST ) … </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		IsAnsi = !Wnd-&gt;Unicode; </span><br><span class="line">		WndProc = Wnd-&gt;lpfnWndProc; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!Ansi) </span><br><span class="line">		<span class="keyword">return</span> IntCallWindowProcW(IsAnsi, WndProc, Wnd, hWnd, Msg, wParam, lParam); </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> IntCallWindowProcA(IsAnsi, WndProc, Wnd, hWnd, Msg, wParam, lParam); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IntCallWindowProcW"><a href="#IntCallWindowProcW" class="headerlink" title="IntCallWindowProcW"></a>IntCallWindowProcW</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT FASTCALL <span class="title">IntCallWindowProcW</span><span class="params">(BOOL IsAnsiProc,WNDPROC WndProc,PWND pWnd, </span></span></span><br><span class="line"><span class="function"><span class="params"> 	 	 	 	HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	MSG AnsiMsg; </span><br><span class="line">	MSG UnicodeMsg; </span><br><span class="line">	BOOL Hook = FALSE, MsgOverride = FALSE, Dialog; </span><br><span class="line">	LRESULT Result = <span class="number">0</span>, PreResult = <span class="number">0</span>; </span><br><span class="line">	DWORD Data = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">if</span> (pWnd) </span><br><span class="line">		Dialog = (pWnd-&gt;fnid == FNID_DIALOG);<span class="comment">//检查是否是个对话框 </span></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		Dialog = FALSE; </span><br><span class="line"></span><br><span class="line">	Hook = BeginIfHookedUserApiHook(); </span><br><span class="line">	<span class="keyword">if</span> (Hook) </span><br><span class="line">	&#123; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!Dialog) </span><br><span class="line">			MsgOverride = IsMsgOverride( Msg, &amp;guah.WndProcArray); </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			MsgOverride = IsMsgOverride( Msg, &amp;guah.DlgProcArray); </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (IsAnsiProc) … </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (Hook &amp;&amp; MsgOverride)<span class="comment">//先预处理 </span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> (!Dialog) </span><br><span class="line">			 	PreResult = guah.PreWndProc(hWnd, Msg, wParam, lParam, &amp;Result, &amp;Data ); </span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			 	PreResult = guah.PreDefDlgProc(hWnd, Msg, wParam, lParam, &amp;Result, &amp;Data); </span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (PreResult) <span class="keyword">goto</span> Exit;<span class="comment">//若预处理完成了处理,直接退出 </span></span><br><span class="line">			Result = WndProc(hWnd, Msg, wParam, lParam);<span class="comment">//关键。调用目标窗口过程 </span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (Hook &amp;&amp; MsgOverride)<span class="comment">//后处理 </span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> (!Dialog) </span><br><span class="line">				guah.PostWndProc(hWnd, Msg, wParam, lParam, &amp;Result, &amp;Data ); </span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				guah.PostDefDlgProc(hWnd, Msg, wParam, lParam, &amp;Result, &amp;Data );   </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">Exit: </span><br><span class="line">	<span class="keyword">if</span> (Hook) </span><br><span class="line">		EndUserApiHook(); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PostMessageW"><a href="#PostMessageW" class="headerlink" title="PostMessageW"></a>PostMessageW</h3><p>下面看看消息的发送  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PostMessageW</span><span class="params">(HWND hWnd, </span></span></span><br><span class="line"><span class="function"><span class="params"> 	 	 	 UINT Msg, </span></span></span><br><span class="line"><span class="function"><span class="params"> 	 	 	 WPARAM wParam, </span></span></span><br><span class="line"><span class="function"><span class="params"> 	 	 	 LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	LRESULT Ret; </span><br><span class="line">	<span class="keyword">if</span> (Msg == CB_DIR || Msg == LB_DIR) … </span><br><span class="line">	<span class="comment">//最典型 </span></span><br><span class="line">	<span class="keyword">if</span> ((Msg != WM_DROPFILES) || (NtUserQueryWindow( hWnd, QUERY_WINDOW_UNIQUE_PROCESS_ID) == PtrToUint(NtCurrentTeb()-&gt;ClientId.UniqueProcess) ) ) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">return</span> PostMessageWorker(hWnd, Msg, wParam, lParam); </span><br><span class="line">	&#125; </span><br><span class="line">	… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PostMessageWorker"><a href="#PostMessageWorker" class="headerlink" title="PostMessageWorker"></a>PostMessageWorker</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL FASTCALL <span class="title">PostMessageWorker</span><span class="params">(  HWND Wnd, </span></span></span><br><span class="line"><span class="function"><span class="params"> 	 	 	 	  UINT Msg, </span></span></span><br><span class="line"><span class="function"><span class="params"> 	 	 	 	  WPARAM wParam, </span></span></span><br><span class="line"><span class="function"><span class="params"> 	 	 	 	  LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	MSG UMMsg, KMMsg; </span><br><span class="line">	LRESULT Result; </span><br><span class="line">	UMMsg.hwnd = Wnd; </span><br><span class="line">	UMMsg.message = Msg; </span><br><span class="line">	UMMsg.wParam = wParam; </span><br><span class="line">	UMMsg.lParam = lParam; MsgiUMToKMMessage(&amp;UMMsg, &amp;KMMsg, TRUE); </span><br><span class="line">	<span class="comment">//调用这个系统服务 </span></span><br><span class="line">	Result = NtUserPostMessage( Wnd,KMMsg.message,KMMsg.wParam,KMMsg.lParam); </span><br><span class="line">	MsgiUMToKMCleanup(&amp;UMMsg, &amp;KMMsg); </span><br><span class="line">	<span class="keyword">return</span> Result; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//系统服务</span></span><br><span class="line"><span class="function">BOOL <span class="title">NtUserPostMessage</span><span class="params">(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   RETURN(UserPostMessage(hWnd, Msg, wParam, lParam)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="UserPostMessage"><a href="#UserPostMessage" class="headerlink" title="UserPostMessage"></a>UserPostMessage</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL FASTCALL <span class="title">UserPostMessage</span><span class="params">( HWND Wnd,UINT Msg,WPARAM wParam,LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PTHREADINFO pti; </span><br><span class="line">	MSG Message; </span><br><span class="line">	LARGE_INTEGER LargeTickCount; </span><br><span class="line">	<span class="keyword">if</span> (FindMsgMemory(Msg) != <span class="number">0</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		SetLastWin32Error(ERROR_MESSAGE_SYNC_ONLY ); </span><br><span class="line">		<span class="keyword">return</span> FALSE; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Wnd==<span class="literal">NULL</span>)  </span><br><span class="line">	<span class="keyword">return</span> UserPostThreadMessage(PtrToInt(PsGetCurrentThreadId()),Msg,wParam,lParam); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Wnd == HWND_BROADCAST) …    <span class="comment">//广播给桌面所有顶层窗口,略 </span></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		PWINDOW_OBJECT Window; </span><br><span class="line">		Window = UserGetWindowObject(Wnd); </span><br><span class="line">		pti = Window-&gt;Wnd-&gt;head.pti; </span><br><span class="line">		<span class="keyword">if</span> ( Window-&gt;state &amp; WINDOWSTATUS_DESTROYING ) </span><br><span class="line">			<span class="keyword">return</span> FALSE; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (WM_QUIT == Msg)<span class="comment">//这种消息的发送特殊处理 </span></span><br><span class="line">			MsqPostQuitMessage(Window-&gt;pti-&gt;MessageQueue, wParam); </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123; </span><br><span class="line">			Message.hwnd = Wnd; </span><br><span class="line">			Message.message = Msg; </span><br><span class="line">			Message.wParam = wParam; </span><br><span class="line">			Message.lParam = lParam; </span><br><span class="line">			Message.pt = gpsi-&gt;ptCursor; </span><br><span class="line">			KeQueryTickCount(&amp;LargeTickCount); </span><br><span class="line">			pti-&gt;timeLast = Message.time = MsqCalculateMessageTime(&amp;LargeTickCount); </span><br><span class="line">			<span class="comment">//实质函数 </span></span><br><span class="line">			MsqPostMessage(Window-&gt;pti-&gt;MessageQueue, &amp;Message, FALSE, QS_POSTMESSAGE); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> TRUE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MsqPostMessage"><a href="#MsqPostMessage" class="headerlink" title="MsqPostMessage"></a>MsqPostMessage</h4><p><code>WM_QUIT</code>消息特殊处理,实际上这种消息不进队,会被接收方优先处理。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">MsqPostQuitMessage</span><span class="params">(PUSER_MESSAGE_QUEUE MessageQueue, ULONG ExitCode)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	MessageQueue-&gt;QuitPosted = TRUE; </span><br><span class="line">	MessageQueue-&gt;QuitExitCode = ExitCode; </span><br><span class="line">	MessageQueue-&gt;QueueBits |= QS_POSTMESSAGE; </span><br><span class="line">	MessageQueue-&gt;ChangedBits |= QS_POSTMESSAGE; </span><br><span class="line">	<span class="keyword">if</span> (MessageQueue-&gt;WakeMask &amp; QS_POSTMESSAGE) <span class="comment">//符合唤醒条件,就唤醒目标线程 </span></span><br><span class="line">		KeSetEvent(MessageQueue-&gt;NewMessages, IO_NO_INCREMENT, FALSE); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">VOID FASTCALL <span class="title">MsqPostMessage</span><span class="params">(PUSER_MESSAGE_QUEUE MessageQueue, MSG* Msg, BOOLEAN FreeLParam, </span></span></span><br><span class="line"><span class="function"><span class="params">               DWORD MessageBits)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PUSER_MESSAGE Message; </span><br><span class="line">	Message = MsqCreateMessage(Msg, FreeLParam);<span class="comment">//分配一个队列中的消息结构</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//关键。将消息挂入目标线程的post队列 </span></span><br><span class="line">	InsertTailList(&amp;MessageQueue-&gt;PostedMessagesListHead,&amp;Message-&gt;ListEntry); </span><br><span class="line">	MessageQueue-&gt;QueueBits |= MessageBits; </span><br><span class="line">	MessageQueue-&gt;ChangedBits |= MessageBits; </span><br><span class="line">	<span class="keyword">if</span> (MessageQueue-&gt;WakeMask &amp; MessageBits) </span><br><span class="line">		KeSetEvent(MessageQueue-&gt;NewMessages, IO_NO_INCREMENT, FALSE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上可以看出<code>PostMesage</code>的处理是很简单的,它仅仅将消息挂入目标线程的<code>post</code>消息队列,唤醒目标线程后立即返回。<br>因此我们说它是异步的。</p>
<p><br></p>
<h3 id="SendMessage"><a href="#SendMessage" class="headerlink" title="SendMessage"></a>SendMessage</h3><p>下面看<code>SendMessage</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">SendMessageW</span><span class="params">(HWND Wnd,UINT Msg,WPARAM wParam,LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	MSG UMMsg, KMMsg; </span><br><span class="line">	NTUSERSENDMESSAGEINFO Info; </span><br><span class="line">	LRESULT Result; </span><br><span class="line">	PWND Window; </span><br><span class="line">	PTHREADINFO ti = GetW32ThreadInfo(); </span><br><span class="line">	</span><br><span class="line">	Window = ValidateHwnd(Wnd);<span class="comment">//验证窗口句柄是否有效 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (Window==<span class="literal">NULL</span>) <span class="keyword">return</span> FALSE; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Wnd != HWND_BROADCAST &amp;&amp; (Msg &lt; WM_DDE_FIRST || Msg &gt; WM_DDE_LAST)) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (Window != <span class="literal">NULL</span> &amp;&amp; Window-&gt;head.pti == ti &amp;&amp; !IsThreadHooked(GetWin32ClientInfo())) </span><br><span class="line">			<span class="keyword">return</span> IntCallMessageProc(Window, Wnd, Msg, wParam, lParam, FALSE); </span><br><span class="line">	&#125; </span><br><span class="line">	UMMsg.hwnd = Wnd; </span><br><span class="line">	UMMsg.message = Msg; </span><br><span class="line">	UMMsg.wParam = wParam; </span><br><span class="line">	UMMsg.lParam = lParam; </span><br><span class="line"></span><br><span class="line">	MsgiUMToKMMessage(&amp;UMMsg, &amp;KMMsg, FALSE); </span><br><span class="line">	Info.Ansi = FALSE; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用这个系统服务 </span></span><br><span class="line">	Result = NtUserSendMessage( KMMsg.hwnd,KMMsg.message,KMMsg.wParam,KMMsg.lParam,&amp;Info); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!Info.HandledByKernel)<span class="comment">//if内部没有执行这条消息(因为同一个线程),就自己处理 </span></span><br><span class="line">	&#123; </span><br><span class="line">		MsgiUMToKMCleanup(&amp;UMMsg, &amp;KMMsg); </span><br><span class="line">		Result = IntCallWindowProcW( Info.Ansi, Info.Proc,<span class="comment">//NtUserSendMessage返回的proc </span></span><br><span class="line">		Window,UMMsg.hwnd,UMMsg.message,UMMsg.wParam,UMMsg.lParam); </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	MsgiUMToKMReply(&amp;UMMsg, &amp;KMMsg, &amp;Result); </span><br><span class="line">	<span class="keyword">return</span> Result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数真正调用<code>NtUserSendMessage</code>这个系统服务完成消息的发送<br>不过若是要发到同一线程的话,就不用发了,直接回到下面</p>
<p>在本线程中直接调用窗口过程就 OK 了。 </p>
<h4 id="NtUserSendMessage"><a href="#NtUserSendMessage" class="headerlink" title="NtUserSendMessage"></a>NtUserSendMessage</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">NtUserSendMessage</span><span class="params">(HWND Wnd,UINT Msg,WPARAM wParam,LPARAM lParam, </span></span></span><br><span class="line"><span class="function"><span class="params">                   PNTUSERSENDMESSAGEINFO UnsafeInfo )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	RETURN(co_IntDoSendMessage(Wnd, Msg, wParam, lParam, <span class="literal">NULL</span>, UnsafeInfo)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="co-IntDoSendMessage"><a href="#co-IntDoSendMessage" class="headerlink" title="co_IntDoSendMessage"></a>co_IntDoSendMessage</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT FASTCALL <span class="title">co_IntDoSendMessage</span><span class="params">(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam, </span></span></span><br><span class="line"><span class="function"><span class="params">                     PDOSENDMESSAGE dsm,<span class="comment">//一般为NULL </span></span></span></span><br><span class="line"><span class="function"><span class="params">                     PNTUSERSENDMESSAGEINFO UnsafeInfo )</span><span class="comment">//返回处理情况 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	LRESULT Result = TRUE; </span><br><span class="line">	PWINDOW_OBJECT Window = <span class="literal">NULL</span>; </span><br><span class="line">	NTUSERSENDMESSAGEINFO Info; </span><br><span class="line">	RtlZeroMemory(&amp;Info, <span class="keyword">sizeof</span>(NTUSERSENDMESSAGEINFO)); </span><br><span class="line">	pti = PsGetCurrentThreadWin32Thread(); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (HWND_BROADCAST != hWnd &amp;&amp; <span class="literal">NULL</span> != pti &amp;&amp; </span><br><span class="line">		Window-&gt;pti-&gt;MessageQueue == pti-&gt;MessageQueue &amp;&amp; <span class="comment">//同一个线程 </span></span><br><span class="line">		!ISITHOOKED(WH_CALLWNDPROC) &amp;&amp; !ISITHOOKED(WH_CALLWNDPROCRET) &amp;&amp; </span><br><span class="line">		(Msg &lt; WM_DDE_FIRST || Msg &gt; WM_DDE_LAST ) ) </span><br><span class="line">	&#123; </span><br><span class="line">		Info.HandledByKernel = FALSE;<span class="comment">//内部就不发送了,直接由本线程调用窗口过程自己处理 </span></span><br><span class="line">		Status = MmCopyFromCaller(&amp;(Info.Ansi), &amp;(UnsafeInfo-&gt;Ansi),<span class="keyword">sizeof</span>(BOOL)); </span><br><span class="line">		Info.Ansi = !Window-&gt;Wnd-&gt;Unicode; </span><br><span class="line">		Info.Proc = Window-&gt;Wnd-&gt;lpfnWndProc; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; </span><br><span class="line">		Info.HandledByKernel = TRUE;<span class="comment">//内部处理 </span></span><br><span class="line">		UserModeMsg.hwnd = hWnd; </span><br><span class="line">		UserModeMsg.message = Msg; </span><br><span class="line">		UserModeMsg.wParam = wParam; </span><br><span class="line">		UserModeMsg.lParam = lParam; </span><br><span class="line">		MsgMemoryEntry = FindMsgMemory(UserModeMsg.message); </span><br><span class="line">		Status = CopyMsgToKernelMem(&amp;KernelModeMsg, &amp;UserModeMsg, MsgMemoryEntry); </span><br><span class="line">		<span class="keyword">if</span>(!dsm)<span class="comment">//典型 </span></span><br><span class="line">		&#123; </span><br><span class="line">			Result = co_IntSendMessage( KernelModeMsg.hwnd,KernelModeMsg.message, </span><br><span class="line">		                         KernelModeMsg.wParam,KernelModeMsg.lParam ); </span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123; </span><br><span class="line">		Result = co_IntSendMessageTimeout( KernelModeMsg.hwnd,KernelModeMsg.message, </span><br><span class="line">		                                KernelModeMsg.wParam,KernelModeMsg.lParam, </span><br><span class="line">		                                dsm-&gt;uFlags,dsm-&gt;uTimeout,&amp;dsm-&gt;Result ); </span><br><span class="line">		&#125; </span><br><span class="line">		Status = CopyMsgToUserMem(&amp;UserModeMsg, &amp;KernelModeMsg); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	Status = MmCopyToCaller(UnsafeInfo, &amp;Info, <span class="keyword">sizeof</span>(NTUSERSENDMESSAGEINFO)); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (! NT_SUCCESS(Status)) </span><br><span class="line">		SetLastWin32Error(ERROR_INVALID_PARAMETER); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (LRESULT)Result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数,发现窗口所属的目标线程就是当前现成的额话,就不用发送了,直接由本线程自己处理<br>否则调用<code>co_IntSendMessage</code>发送该消息到目标线程的<code>send</code>消息队列</p>
<h5 id="co-IntSendMessage"><a href="#co-IntSendMessage" class="headerlink" title="co_IntSendMessage"></a>co_IntSendMessage</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT FASTCALL <span class="title">co_IntSendMessage</span><span class="params">( HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	ULONG_PTR Result = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">if</span>(co_IntSendMessageTimeout(hWnd, Msg, wParam, lParam, <span class="number">0</span>, <span class="number">0</span>, &amp;Result)) </span><br><span class="line">		<span class="keyword">return</span> (LRESULT)Result; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT FASTCALL <span class="title">co_IntSendMessageTimeout</span><span class="params">( HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam, </span></span></span><br><span class="line"><span class="function"><span class="params">                          UINT uFlags,UINT uTimeout,ULONG_PTR *uResult )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PWINDOW_OBJECT DesktopWindow; </span><br><span class="line">	HWND *Children; </span><br><span class="line">	HWND *Child; </span><br><span class="line">	<span class="keyword">if</span> (HWND_BROADCAST != hWnd) </span><br><span class="line">		<span class="keyword">return</span> co_IntSendMessageTimeoutSingle(hWnd, Msg, wParam, lParam, uFlags, uTimeout, uResult); </span><br><span class="line">	</span><br><span class="line">	DesktopWindow = UserGetWindowObject(IntGetDesktopWindow()); </span><br><span class="line">	Children = IntWinListChildren(DesktopWindow); </span><br><span class="line">	<span class="keyword">for</span> (Child = Children; <span class="literal">NULL</span> != *Child; Child++)<span class="comment">//广播消息处理 </span></span><br><span class="line">		co_IntSendMessageTimeoutSingle(*Child, Msg, wParam, lParam, uFlags, uTimeout, uResult); </span><br><span class="line">	</span><br><span class="line">	ExFreePool(Children); </span><br><span class="line">	<span class="keyword">return</span> (LRESULT) TRUE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="co-IntSendMessageTimeoutSingle"><a href="#co-IntSendMessageTimeoutSingle" class="headerlink" title="co_IntSendMessageTimeoutSingle"></a>co_IntSendMessageTimeoutSingle</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT FASTCALL <span class="title">co_IntSendMessageTimeoutSingle</span><span class="params">( HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam, </span></span></span><br><span class="line"><span class="function"><span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">                                UINT uFlags,UINT uTimeout,ULONG_PTR *uResult )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PWINDOW_OBJECT Window = <span class="literal">NULL</span>; </span><br><span class="line">	<span class="keyword">if</span> (!(Window = UserGetWindowObject(hWnd))) </span><br><span class="line">		RETURN( FALSE); </span><br><span class="line">	</span><br><span class="line">	UserRefObjectCo(Window, &amp;Ref); </span><br><span class="line">	Win32Thread = PsGetCurrentThreadWin32Thread(); </span><br><span class="line">	IntCallWndProc( Window, hWnd, Msg, wParam, lParam);<span class="comment">//调用钩子 </span></span><br><span class="line">	<span class="comment">//再次检查是否是同一消息队列(因为可能前面是广播窗口的原因),若是,就地处理 </span></span><br><span class="line">	<span class="keyword">if</span> ( <span class="literal">NULL</span> != Win32Thread &amp;&amp; Window-&gt;pti-&gt;MessageQueue == Win32Thread-&gt;MessageQueue) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (Win32Thread-&gt;TIF_flags &amp; TIF_INCLEANUP) </span><br><span class="line">			RETURN( FALSE); </span><br><span class="line">		</span><br><span class="line">		MsgMemoryEntry = FindMsgMemory(Msg); </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == MsgMemoryEntry) </span><br><span class="line">			lParamBufferSize = <span class="number">-1</span>; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			lParamBufferSize = MsgMemorySize(MsgMemoryEntry, wParam, lParam); </span><br><span class="line"></span><br><span class="line">		PackParam(&amp;lParamPacked, Msg, wParam, lParam, FALSE);<span class="comment">//L附件打包到用户空间 </span></span><br><span class="line">		Result = co_IntCallWindowProc(Window-&gt;Wnd-&gt;lpfnWndProc,!Window-&gt;Wnd-&gt;Unicode, hWnd,Msg,wParam,lParamPacked,lParamBufferSize); </span><br><span class="line">		<span class="keyword">if</span>(uResult) </span><br><span class="line">			*uResult = Result; </span><br><span class="line">	</span><br><span class="line">		IntCallWndProcRet( Window, hWnd, Msg, wParam, lParam, (LRESULT *)uResult);<span class="comment">//调用钩子 </span></span><br><span class="line"></span><br><span class="line">		UnpackParam(lParamPacked, Msg, wParam, lParam, FALSE); </span><br><span class="line">		RETURN( TRUE); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//若不是同一线程,就真的发送了 </span></span><br><span class="line">	<span class="keyword">if</span> (uFlags &amp; SMTO_ABORTIFHUNG &amp;&amp; MsqIsHung(Window-&gt;pti-&gt;MessageQueue)) </span><br><span class="line">		RETURN( FALSE); </span><br><span class="line">	<span class="keyword">if</span> (Window-&gt;state &amp; WINDOWSTATUS_DESTROYING) </span><br><span class="line">		RETURN( FALSE); </span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">	&#123; </span><br><span class="line">		Status = co_MsqSendMessage( Window-&gt;pti-&gt;MessageQueue,hWnd,Msg,wParam,lParam, uTimeout, (uFlags &amp; SMTO_BLOCK),MSQ_NORMAL,uResult); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> ((STATUS_TIMEOUT == Status) &amp;&amp; (uFlags &amp; SMTO_NOTIMEOUTIFNOTHUNG) &amp;&amp; !MsqIsHung(Window-&gt;pti-&gt;MessageQueue)); </span><br><span class="line"></span><br><span class="line">	IntCallWndProcRet( Window, hWnd, Msg, wParam, lParam, (LRESULT *)uResult); </span><br><span class="line">	<span class="keyword">if</span> (STATUS_TIMEOUT == Status) </span><br><span class="line">	&#123; </span><br><span class="line">		SetLastWin32Error(ERROR_TIMEOUT); </span><br><span class="line">		RETURN( FALSE); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (! NT_SUCCESS(Status)) </span><br><span class="line">	&#123; </span><br><span class="line">		SetLastNtError(Status); </span><br><span class="line">		RETURN( FALSE); 		</span><br><span class="line">	&#125; </span><br><span class="line">	RETURN( TRUE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="co-MsqSendMessage"><a href="#co-MsqSendMessage" class="headerlink" title="co_MsqSendMessage"></a>co_MsqSendMessage</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS FASTCALL <span class="title">co_MsqSendMessage</span><span class="params">(PUSER_MESSAGE_QUEUE MessageQueue,HWND Wnd, UINT Msg, WPARAM wParam, </span></span></span><br><span class="line"><span class="function"><span class="params">		LPARAM lParam,UINT uTimeout, </span></span></span><br><span class="line"><span class="function"><span class="params">		BOOL Block,<span class="comment">//指是否一直要等到消息被接收方处理 </span></span></span></span><br><span class="line"><span class="function"><span class="params">		INT HookMessage,<span class="comment">//指是否是那个专用的‘底层键盘鼠标钩子调用请求’消息 </span></span></span></span><br><span class="line"><span class="function"><span class="params">		ULONG_PTR *uResult)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PTHREADINFO pti; </span><br><span class="line">	PUSER_SENT_MESSAGE Message;<span class="comment">//send队列中的消息结构 </span></span><br><span class="line">	KEVENT CompletionEvent; </span><br><span class="line">	NTSTATUS WaitStatus; </span><br><span class="line">	LRESULT Result; </span><br><span class="line">	PUSER_MESSAGE_QUEUE ThreadQueue; </span><br><span class="line">	LARGE_INTEGER Timeout; </span><br><span class="line">	PLIST_ENTRY Entry; </span><br><span class="line">	</span><br><span class="line">	Message = ExAllocatePoolWithTag(PagedPool, <span class="keyword">sizeof</span>(USER_SENT_MESSAGE), TAG_USRMSG) </span><br><span class="line">	KeInitializeEvent(&amp;CompletionEvent, NotificationEvent, FALSE); </span><br><span class="line">	</span><br><span class="line">	pti = PsGetCurrentThreadWin32Thread(); </span><br><span class="line">	ThreadQueue = pti-&gt;MessageQueue;<span class="comment">//本线程的消息队列 </span></span><br><span class="line">	ASSERT(ThreadQueue != MessageQueue);<span class="comment">//可以肯定 </span></span><br><span class="line">	</span><br><span class="line">	Timeout.QuadPart = (LONGLONG) uTimeout * (LONGLONG) <span class="number">-10000</span>; </span><br><span class="line">	</span><br><span class="line">	Result = <span class="number">0</span>; </span><br><span class="line">	Message-&gt;Msg.hwnd = Wnd; </span><br><span class="line">	Message-&gt;Msg.message = Msg; </span><br><span class="line">	Message-&gt;Msg.wParam = wParam; </span><br><span class="line">	Message-&gt;Msg.lParam = lParam; </span><br><span class="line">	Message-&gt;CompletionEvent = &amp;CompletionEvent;<span class="comment">//关键字段 </span></span><br><span class="line">	Message-&gt;Result = &amp;Result; </span><br><span class="line">	Message-&gt;SenderQueue = ThreadQueue;<span class="comment">//发送发线程的消息队列 </span></span><br><span class="line">	IntReferenceMessageQueue(ThreadQueue); </span><br><span class="line">	Message-&gt;CompletionCallback = <span class="literal">NULL</span>; </span><br><span class="line">	Message-&gt;HookMessage = HookMessage; </span><br><span class="line">	Message-&gt;HasPackedLParam = FALSE; </span><br><span class="line">	IntReferenceMessageQueue(MessageQueue); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//关键。一头插入本线程的Dispatching阻塞队列中 </span></span><br><span class="line">	InsertTailList(&amp;ThreadQueue-&gt;DispatchingMessagesHead, &amp;Message-&gt;DispatchingListEntry); </span><br><span class="line">	<span class="comment">//关键。一头插入目标线程的send队列中 </span></span><br><span class="line">	InsertTailList(&amp;MessageQueue-&gt;SentMessagesListHead, &amp;Message-&gt;ListEntry); </span><br><span class="line">	MessageQueue-&gt;QueueBits |= QS_SENDMESSAGE; </span><br><span class="line">	MessageQueue-&gt;ChangedBits |= QS_SENDMESSAGE; </span><br><span class="line">	<span class="keyword">if</span> (MessageQueue-&gt;WakeMask &amp; QS_SENDMESSAGE) </span><br><span class="line">		KeSetEvent(MessageQueue-&gt;NewMessages, IO_NO_INCREMENT, FALSE); </span><br><span class="line">	<span class="comment">//下面的等待操作单独括起来 </span></span><br><span class="line">	&#123; </span><br><span class="line">		PVOID WaitObjects[<span class="number">2</span>]; </span><br><span class="line">		WaitObjects[<span class="number">0</span>] = &amp;CompletionEvent; </span><br><span class="line">		WaitObjects[<span class="number">1</span>] = ThreadQueue-&gt;NewMessages; </span><br><span class="line">		Int count = Block? <span class="number">1</span> : <span class="number">2</span><span class="comment">//等待的对象个数不同 </span></span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123; </span><br><span class="line">			WaitStatus = KeWaitForMultipleObjects(count, WaitObjects, WaitAny, UserRequest, </span><br><span class="line">			      UserMode, FALSE, (uTimeout ? &amp;Timeout : <span class="literal">NULL</span>), <span class="literal">NULL</span>); </span><br><span class="line">			<span class="keyword">if</span>(WaitStatus == STATUS_TIMEOUT) </span><br><span class="line">			&#123; </span><br><span class="line">				<span class="comment">//超时醒来的第一件事：清除目标线程send队列中这个消息的完成事件 </span></span><br><span class="line">				Entry = MessageQueue-&gt;SentMessagesListHead.Flink; </span><br><span class="line">				<span class="keyword">while</span> (Entry != &amp;MessageQueue-&gt;SentMessagesListHead) </span><br><span class="line">				&#123; </span><br><span class="line">					<span class="keyword">if</span> (CONTAINING_RECORD(Entry, USER_SENT_MESSAGE, ListEntry)== Message) </span><br><span class="line">					&#123; </span><br><span class="line">						Message-&gt;CompletionEvent = <span class="literal">NULL</span>; </span><br><span class="line">						Message-&gt;Result = <span class="literal">NULL</span>; </span><br><span class="line">						<span class="keyword">break</span>; </span><br><span class="line">					&#125; </span><br><span class="line">					Entry = Entry-&gt;Flink; </span><br><span class="line">				&#125; </span><br><span class="line">				<span class="comment">//超时醒来的第二件事：清除本线程Disatching队列中的这个消息 </span></span><br><span class="line">				Entry = ThreadQueue-&gt;DispatchingMessagesHead.Flink; </span><br><span class="line">				<span class="keyword">while</span> (Entry != &amp;ThreadQueue-&gt;DispatchingMessagesHead) </span><br><span class="line">				&#123; </span><br><span class="line">					<span class="keyword">if</span> (CONTAINING_RECORD(Entry, USER_SENT_MESSAGE, DispatchingListEntry) == Message) </span><br><span class="line">					&#123; </span><br><span class="line">						Message-&gt;CompletionEvent = <span class="literal">NULL</span>; </span><br><span class="line">						Message-&gt;Result = <span class="literal">NULL</span>; </span><br><span class="line">						RemoveEntryList(&amp;Message-&gt;DispatchingListEntry);<span class="comment">//关键 </span></span><br><span class="line">						Message-&gt;DispatchingListEntry.Flink = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line">						<span class="keyword">break</span>; </span><br><span class="line">					&#125; </span><br><span class="line">					Entry = Entry-&gt;Flink; </span><br><span class="line">				&#125; </span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">while</span> (co_MsqDispatchOneSentMessage(ThreadQueue));<span class="comment">//扫描执行本线程send队列中的消息 </span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">while</span> (NT_SUCCESS(WaitStatus) &amp;&amp; STATUS_WAIT_0 != WaitStatus); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span>(WaitStatus != STATUS_TIMEOUT) </span><br><span class="line">		*uResult = (STATUS_WAIT_0 == WaitStatus ? Result : <span class="number">-1</span>); </span><br><span class="line">	<span class="keyword">return</span> WaitStatus; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="消息钩子"><a href="#消息钩子" class="headerlink" title="消息钩子"></a>消息钩子</h2><p>消息钩子：(相信这是大家最感兴趣的了) </p>
<h3 id="SetWindowsHookExW"><a href="#SetWindowsHookExW" class="headerlink" title="SetWindowsHookExW"></a>SetWindowsHookExW</h3><p>下面这个函数用来为指定线程安装一个指定类型的钩子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HHOOK <span class="title">SetWindowsHookExW</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> idHook,<span class="comment">//钩子类型 </span></span></span></span><br><span class="line"><span class="function"><span class="params">    HOOKPROC lpfn,<span class="comment">//钩子函数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hMod,<span class="comment">//钩子函数所在模块 </span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwThreadId)</span><span class="comment">//为0就表示全局钩子 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> IntSetWindowsHook(idHook, lpfn, hMod, dwThreadId, FALSE); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function">HHOOK FASTCALL <span class="title">IntSetWindowsHook</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> idHook, </span></span></span><br><span class="line"><span class="function"><span class="params">    HOOKPROC lpfn, </span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hMod, </span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwThreadId, </span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bAnsi)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	WCHAR ModuleName[MAX_PATH]; </span><br><span class="line">	UNICODE_STRING USModuleName; </span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != hMod) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == GetModuleFileNameW(hMod, ModuleName, MAX_PATH)) </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">		RtlInitUnicodeString(&amp;USModuleName, ModuleName); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		RtlInitUnicodeString(&amp;USModuleName, <span class="literal">NULL</span>); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用系统服务 </span></span><br><span class="line">	<span class="keyword">return</span> NtUserSetWindowsHookEx(hMod, &amp;USModuleName, dwThreadId, idHook, lpfn, bAnsi); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NtUserSetWindowsHookEx"><a href="#NtUserSetWindowsHookEx" class="headerlink" title="NtUserSetWindowsHookEx"></a>NtUserSetWindowsHookEx</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HHOOK <span class="title">NtUserSetWindowsHookEx</span><span class="params">(HINSTANCE Mod, </span></span></span><br><span class="line"><span class="function"><span class="params">                       PUNICODE_STRING UnsafeModuleName, </span></span></span><br><span class="line"><span class="function"><span class="params">                       DWORD ThreadId,<span class="comment">//指定线程,0表示全局 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> HookId,<span class="comment">//钩子类型 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                       HOOKPROC HookProc, </span></span></span><br><span class="line"><span class="function"><span class="params">                       BOOL Ansi)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BOOLEAN ThreadReferenced = FALSE; </span><br><span class="line">	ClientInfo = GetWin32ClientInfo(); </span><br><span class="line">	<span class="keyword">if</span> (ThreadId!=<span class="number">0</span>)<span class="comment">//if 特定线程 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//这些钩子本就是全局的,不支持局部线程 </span></span><br><span class="line">		<span class="keyword">if</span> (HookId == WH_JOURNALRECORD ||HookId == WH_JOURNALPLAYBACK || HookId == WH_KEYBOARD_LL ||HookId == WH_MOUSE_LL ||HookId == WH_SYSMSGFILTER) </span><br><span class="line">		&#123; </span><br><span class="line">			SetLastWin32Error(ERROR_INVALID_PARAMETER); </span><br><span class="line">			RETURN( <span class="literal">NULL</span>); </span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">		Mod = <span class="literal">NULL</span>; </span><br><span class="line">		Global = FALSE; </span><br><span class="line">		PsLookupThreadByThreadId(ThreadId, &amp;Thread);<span class="comment">//根据线程ID找到对应的线程对象 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		ThreadReferenced = TRUE; </span><br><span class="line">		<span class="keyword">if</span> (Thread-&gt;ThreadsProcess != PsGetCurrentProcess())<span class="comment">//只能是当前进程中的其他线程 </span></span><br><span class="line">		&#123; </span><br><span class="line">			ObDereferenceObject(Thread); </span><br><span class="line">			SetLastWin32Error(ERROR_INVALID_PARAMETER); </span><br><span class="line"></span><br><span class="line">			RETURN( <span class="literal">NULL</span>); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//if全局钩子 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (HookId == WH_KEYBOARD_LL || HookId == WH_MOUSE_LL) </span><br><span class="line">		&#123; </span><br><span class="line">			Mod = <span class="literal">NULL</span>; </span><br><span class="line">			Thread = PsGetCurrentThread(); </span><br><span class="line">			Status = ObReferenceObjectByPointer(Thread,THREAD_ALL_ACCESS, </span><br><span class="line">			                        PsThreadType,KernelMode); </span><br><span class="line">			<span class="keyword">if</span> (!NT_SUCCESS(Status))<span class="comment">//if权限检查失败 </span></span><br><span class="line">			&#123; </span><br><span class="line">				SetLastNtError(Status); </span><br><span class="line">				RETURN( (HANDLE) <span class="literal">NULL</span>); </span><br><span class="line">			&#125; </span><br><span class="line">			</span><br><span class="line">			ThreadReferenced = TRUE; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">NULL</span> == Mod)<span class="comment">//全局钩子必须指定模块 </span></span><br><span class="line">		&#123; </span><br><span class="line">			SetLastWin32Error(ERROR_HOOK_NEEDS_HMOD); </span><br><span class="line">			RETURN( <span class="literal">NULL</span>); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			Thread = <span class="literal">NULL</span>;<span class="comment">//全局钩子的目标线程等于NULL,但是底层键盘鼠标类钩子除外 </span></span><br><span class="line">		Global = TRUE; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	Status = IntValidateWindowStationHandle(PsGetCurrentProcess()-&gt;Win32WindowStation, </span><br><span class="line">	                    KernelMode,<span class="number">0</span>,&amp;WinStaObj); </span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(Status)) … </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关键。在对应类型的钩子队列中挂入一个钩子 </span></span><br><span class="line">	Hook = IntAddHook(Thread, HookId, Global, WinStaObj); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == Hook) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (ThreadReferenced) </span><br><span class="line">			ObDereferenceObject(Thread); </span><br><span class="line">		</span><br><span class="line">		ObDereferenceObject(WinStaObj); </span><br><span class="line">		RETURN( <span class="literal">NULL</span>); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (ThreadReferenced) </span><br><span class="line">		Hook-&gt;Flags |= HOOK_THREAD_REFERENCED; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != Mod) <span class="comment">//如果提供了模块,那HookProc就是模块内的相对偏移 </span></span><br><span class="line">	&#123; </span><br><span class="line">		Status = MmCopyFromCaller(&amp;ModuleName, UnsafeModuleName, <span class="keyword">sizeof</span>(UNICODE_STRING)); </span><br><span class="line"></span><br><span class="line">		Hook-&gt;ModuleName.Buffer = ExAllocatePoolWithTag(PagedPool, </span><br><span class="line">		                                ModuleName.MaximumLength,TAG_HOOK); </span><br><span class="line">		Hook-&gt;ModuleName.MaximumLength = ModuleName.MaximumLength; </span><br><span class="line">		Status = MmCopyFromCaller(Hook-&gt;ModuleName.Buffer,ModuleName.Buffer, </span><br><span class="line">		          ModuleName.MaximumLength); </span><br><span class="line">		Hook-&gt;ModuleName.Length = ModuleName.Length; </span><br><span class="line">		Hook-&gt;Proc = (<span class="keyword">void</span> *)((<span class="keyword">char</span> *)HookProc - (<span class="keyword">char</span> *)Mod);<span class="comment">//相对偏移 </span></span><br><span class="line">	&#125; </span><br><span class="line">	Else <span class="comment">//否则,就是直接的地址 </span></span><br><span class="line">	Hook-&gt;Proc = HookProc; </span><br><span class="line">	Hook-&gt;Ansi = Ansi; </span><br><span class="line">	Handle = UserHMGetHandle(Hook);<span class="comment">//钩子句柄 </span></span><br><span class="line"></span><br><span class="line">	ClientInfo-&gt;phkCurrent = <span class="number">0</span>; </span><br><span class="line">	UserDereferenceObject(Hook); </span><br><span class="line">	ObDereferenceObject(WinStaObj); </span><br><span class="line">	RETURN( Handle); </span><br><span class="line"></span><br><span class="line">	CLEANUP:… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IntAddHook"><a href="#IntAddHook" class="headerlink" title="IntAddHook"></a>IntAddHook</h4><p>实质函数是<code>IntAddHook</code>,这个函数将指定钩子插入指定钩子表的对应类型的钩子队列中。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PHOOK <span class="title">IntAddHook</span><span class="params">(PETHREAD Thread, <span class="keyword">int</span> HookId, BOOLEAN Global, PWINSTATION_OBJECT WinStaObj)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PTHREADINFO W32Thread; </span><br><span class="line">	PHOOK Hook; </span><br><span class="line">	HANDLE Handle; </span><br><span class="line">	<span class="comment">//全局的钩子表或每个线程局部的钩子表 </span></span><br><span class="line">	PHOOKTABLE Table = Global ? GlobalHooks : </span><br><span class="line">	MsqGetHooks(((PTHREADINFO)Thread-&gt;Tcb.Win32Thread)-&gt;MessageQueue); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == Table)<span class="comment">//分配钩子表 </span></span><br><span class="line">	&#123; </span><br><span class="line">		Table = IntAllocHookTable(); </span><br><span class="line">		<span class="keyword">if</span> (Global) </span><br><span class="line">			GlobalHooks = Table; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			MsqSetHooks(((PTHREADINFO)Thread-&gt;Tcb.Win32Thread)-&gt;MessageQueue, Table);   </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建钩子对象(钩子像窗口一样,也是一种GUI对象,放在全局的GUI对象句柄表中) </span></span><br><span class="line">	Hook = UserCreateObject(gHandleTable, <span class="literal">NULL</span>, &amp;Handle, otHook, <span class="keyword">sizeof</span>(HOOK)); </span><br><span class="line">	Hook-&gt;Thread = Thread; </span><br><span class="line">	Hook-&gt;HookId = HookId; </span><br><span class="line">	<span class="keyword">if</span> (Thread)<span class="comment">//局部钩子 </span></span><br><span class="line">	&#123; </span><br><span class="line">		W32Thread = ((PTHREADINFO)Thread-&gt;Tcb.Win32Thread); </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//fsHooks表示钩子掩码 </span></span><br><span class="line">		W32Thread-&gt;fsHooks |= HOOKID_TO_FLAG(HookId); </span><br><span class="line">		<span class="keyword">if</span> (W32Thread-&gt;pClientInfo) </span><br><span class="line">			W32Thread-&gt;pClientInfo-&gt;fsHooks = W32Thread-&gt;fsHooks; </span><br><span class="line">		<span class="keyword">if</span> (W32Thread-&gt;pDeskInfo)  </span><br><span class="line">			W32Thread-&gt;pDeskInfo-&gt;fsHooks= W32Thread-&gt;fsHooks; </span><br><span class="line">		</span><br><span class="line">		Hook-&gt;head.pti = W32Thread; </span><br><span class="line">		Hook-&gt;head.rpdesk = W32Thread-&gt;rpdesk; </span><br><span class="line">	&#125; </span><br><span class="line">	RtlInitUnicodeString(&amp;Hook-&gt;ModuleName, <span class="literal">NULL</span>);<span class="comment">//不需要模块 </span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关键。将钩子挂入钩子表中对应类型的钩子队列中。注意是插在队列头部,这就是为什么后安装的钩子优先得到处理的原因 </span></span><br><span class="line">	InsertHeadList(&amp;Table-&gt;Hooks[HOOKID_TO_INDEX(HookId)], &amp;Hook-&gt;Chain); </span><br><span class="line">	<span class="keyword">return</span> Hook; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagHOOKTABLE</span> //钩子表(全局的或每个线程句柄的钩子表) </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	LIST_ENTRY Hooks[<span class="number">16</span>];<span class="comment">//对应16种钩子的16个队列 </span></span><br><span class="line">	UINT     Counts[<span class="number">16</span>];<span class="comment">//各队列的引用计数(注意不是钩子个数) </span></span><br><span class="line">&#125; HOOKTABLE, *PHOOKTABLE; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagHOOK</span> //钩子对象的结构 </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	THRDESKHEAD   head; </span><br><span class="line">	LIST_ENTRY     Chain; <span class="comment">//用来挂入相应类型的钩子队列 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span>* <span class="title">Thread</span>;</span><span class="comment">//钩子的目标线程,注意底层键盘鼠标类钩子的这个字段表示原创建者线程 </span></span><br><span class="line">	<span class="keyword">int</span>           HookId;<span class="comment">//钩子的类型 </span></span><br><span class="line">	HOOKPROC      Proc;<span class="comment">//若给定了模块名,就是相对偏移,否则就是地址 </span></span><br><span class="line">	BOOLEAN       Ansi;  </span><br><span class="line">	ULONG         Flags; </span><br><span class="line">	UNICODE_STRING ModuleName;<span class="comment">//全局钩子的模块名 </span></span><br><span class="line">&#125; HOOK, *PHOOK;</span><br></pre></td></tr></table></figure>
<p>通过以上函数的展示我们知道<code>SetWindowsHookEx</code>这个 API 最终就是在相应类型的钩子队列中挂入一个钩 子,如此简单而已。</p>
<h3 id="co-HOOK-CallHooks"><a href="#co-HOOK-CallHooks" class="headerlink" title="co_HOOK_CallHooks"></a>co_HOOK_CallHooks</h3><blockquote>
<p>那么钩子是如何得到调用的呢？</p>
</blockquote>
<p>当在<code>Dispatching</code>消息时,系统会检查相应类型的钩 子队列中有没有钩子,除此之外在其它每一个可能有钩子的地方也都会调用钩子,如取下消息后会检查调用<code>WH_GETMESSAGE</code> 钩子。<br>系统通过下面的函数检查、调用钩子。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT FASTCALL <span class="title">co_HOOK_CallHooks</span><span class="params">(INT HookId, INT Code, WPARAM wParam, LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	pti = PsGetCurrentThreadWin32Thread(); </span><br><span class="line">	<span class="comment">//先检查局部钩子表和全局钩子表中是否安装有HookId这种类型的钩子 </span></span><br><span class="line">	Table = MsqGetHooks(pti-&gt;MessageQueue);<span class="comment">//当前线程的局部钩子表 </span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == Table || ! (Hook = IntGetFirstValidHook(Table, HookId))) </span><br><span class="line">	&#123; </span><br><span class="line">		Table = GlobalHooks; </span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == Table || ! (Hook = IntGetFirstValidHook(Table, HookId))) </span><br><span class="line">		    <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//底层键盘鼠标钩子需要特殊方式调用(发一个内部消息通知原钩子创建者线程去调用钩子,注意原 线程必须提供一个消息循环) </span></span><br><span class="line">	<span class="keyword">if</span> ((Hook-&gt;Thread != PsGetCurrentThread()) &amp;&amp; (Hook-&gt;Thread != <span class="literal">NULL</span>)) </span><br><span class="line">		<span class="keyword">return</span> IntCallLowLevelHook(Hook, Code, wParam, lParam); </span><br><span class="line"></span><br><span class="line">	<span class="comment">//每次调用钩子时,递增相应钩子队列(即钩子类型)的引用计数 </span></span><br><span class="line">	Table-&gt;Counts[HOOKID_TO_INDEX(HookId)]++; </span><br><span class="line">	<span class="keyword">if</span> (Table != GlobalHooks &amp;&amp; GlobalHooks != <span class="literal">NULL</span>) </span><br><span class="line">	GlobalHooks-&gt;Counts[HOOKID_TO_INDEX(HookId)]++; </span><br><span class="line"></span><br><span class="line">	ClientInfo = GetWin32ClientInfo(); </span><br><span class="line">	SaveHook = ClientInfo-&gt;phkCurrent; </span><br><span class="line">	ClientInfo-&gt;phkCurrent = Hook;<span class="comment">//记录当前正在调用的钩子,为调用下一个钩子做准备 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//关键。调用队列中的第一个钩子(也即最后安装的钩子,可以在你面调用CallNextHookEx) </span></span><br><span class="line">	Result = co_IntCallHookProc(HookId,Code,wParam,lParam,Hook-&gt;Proc,Hook-&gt;Ansi, </span><br><span class="line">	                        &amp;Hook-&gt;ModuleName); </span><br><span class="line">	ClientInfo-&gt;phkCurrent = SaveHook; </span><br><span class="line">	Status = IntValidateWindowStationHandle(PsGetCurrentProcess()-&gt;Win32WindowStation, </span><br><span class="line">	                                    KernelMode,<span class="number">0</span>,&amp;WinStaObj); </span><br><span class="line"></span><br><span class="line">	<span class="comment">//递减钩子类型的引用计数,减到0后,就销毁那些已经撤销了,但尚未销毁的钩子 </span></span><br><span class="line">	IntReleaseHookChain(MsqGetHooks(pti-&gt;MessageQueue), HookId, WinStaObj); </span><br><span class="line">	IntReleaseHookChain(GlobalHooks, HookId, WinStaObj); </span><br><span class="line">	ObDereferenceObject(WinStaObj); </span><br><span class="line">	<span class="keyword">return</span> Result; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">LRESULT FASTCALL <span class="title">IntCallLowLevelHook</span><span class="params">(PHOOK Hook, INT Code, WPARAM wParam, LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    NTSTATUS Status; </span><br><span class="line">    ULONG_PTR uResult; </span><br><span class="line"> </span><br><span class="line">    Timeout = HKEY_CURRENT_USER\Control Panel\Desktop\LowLevelHooksTimeout键的值 </span><br><span class="line">    Status = co_MsqSendMessage(((PTHREADINFO)Hook-&gt;Thread-&gt;Tcb.Win32Thread)-&gt;MessageQueue, </span><br><span class="line">                                IntToPtr(Code),Hook-&gt;HookId,wParam,lParam,<span class="number">5000</span>, </span><br><span class="line">                                TRUE,<span class="comment">//HookMesage=TRUE,表示这是一条专用的‘钩子调用请求’消息 </span></span><br><span class="line">                                MSQ_ISHOOK,&amp;uResult); </span><br><span class="line">    <span class="keyword">return</span> NT_SUCCESS(Status) ? uResult : <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">VOID FASTCALL <span class="title">IntReleaseHookChain</span><span class="params">(PHOOKTABLE Table, <span class="keyword">int</span> HookId, PWINSTATION_OBJECT WinStaObj)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PLIST_ENTRY Elem; </span><br><span class="line">	PHOOK HookObj; </span><br><span class="line">	ASSERT(<span class="number">0</span> != Table-&gt;Counts[HOOKID_TO_INDEX(HookId)]); </span><br><span class="line">	<span class="comment">//递减钩子类型的引用计数,减到0后,销毁那些已经撤销了的钩子 </span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == --Table-&gt;Counts[HOOKID_TO_INDEX(HookId)]) </span><br><span class="line">	&#123; </span><br><span class="line">		Elem = Table-&gt;Hooks[HOOKID_TO_INDEX(HookId)].Flink; </span><br><span class="line">		<span class="keyword">while</span> (Elem != &amp;Table-&gt;Hooks[HOOKID_TO_INDEX(HookId)]) </span><br><span class="line">		&#123; </span><br><span class="line">			HookObj = CONTAINING_RECORD(Elem, HOOK, Chain); </span><br><span class="line">			Elem = Elem-&gt;Flink; </span><br><span class="line">			<span class="keyword">if</span> (<span class="literal">NULL</span> == HookObj-&gt;Proc)  </span><br><span class="line">				IntFreeHook(Table, HookObj, WinStaObj); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UnHookWindowsHookEx</code>函数用来撤销钩子,它将钩子对象的<code>HookProc</code>置为 NULL,并检查该钩子是否正在被调用,若是就立即返回。否则销毁钩子后再返回。</p>
<h2 id="键盘消息的产生、处理"><a href="#键盘消息的产生、处理" class="headerlink" title="键盘消息的产生、处理"></a>键盘消息的产生、处理</h2><p>熟悉了消息机制的原理后,我们看看具体键盘鼠标消息的处理流程。<br>系统在初始化时会创建两个内核守护线程,分别用来监视、处理键盘输入和鼠标输入</p>
<h3 id="InitInputImpl"><a href="#InitInputImpl" class="headerlink" title="InitInputImpl"></a>InitInputImpl</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS FASTCALL <span class="title">InitInputImpl</span><span class="params">(VOID)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	NTSTATUS Status; </span><br><span class="line">	KeInitializeEvent(&amp;InputThreadsStart, NotificationEvent, FALSE); </span><br><span class="line">	MasterTimer = ExAllocatePoolWithTag(NonPagedPool, <span class="keyword">sizeof</span>(KTIMER), TAG_INPUT); </span><br><span class="line">	KeInitializeTimer(MasterTimer); </span><br><span class="line">	Status = PsCreateSystemThread(&amp;RawInputThreadHandle,THREAD_ALL_ACCESS,<span class="literal">NULL</span>,<span class="literal">NULL</span>, </span><br><span class="line">	                             &amp;RawInputThreadId,RawInputThreadMain,<span class="literal">NULL</span>); </span><br><span class="line">	<span class="comment">//键盘输入线程：KeyboardThreadMain </span></span><br><span class="line">	Status = PsCreateSystemThread(&amp;KeyboardThreadHandle,THREAD_ALL_ACCESS,<span class="literal">NULL</span>,<span class="literal">NULL</span>, </span><br><span class="line">	                             &amp;KeyboardThreadId,KeyboardThreadMain,<span class="literal">NULL</span>); </span><br><span class="line">	<span class="comment">//鼠标输入线程：MouseThreadMain </span></span><br><span class="line">	Status = PsCreateSystemThread(&amp;MouseThreadHandle,THREAD_ALL_ACCESS,<span class="literal">NULL</span>,<span class="literal">NULL</span>, </span><br><span class="line">	                             &amp;MouseThreadId,MouseThreadMain,<span class="literal">NULL</span>); </span><br><span class="line">	InputThreadsRunning = TRUE;<span class="comment">//标志现在可以开始读取键盘鼠标输入 </span></span><br><span class="line">	KeSetEvent(&amp;InputThreadsStart, IO_NO_INCREMENT, FALSE); </span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KeyboardThreadMain"><a href="#KeyboardThreadMain" class="headerlink" title="KeyboardThreadMain"></a>KeyboardThreadMain</h3><p>我们看键盘输入线程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID  <span class="title">KeyboardThreadMain</span><span class="params">(PVOID StartContext)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//键盘类驱动中的键盘类设备 </span></span><br><span class="line">	UNICODE_STRING KeyboardDeviceName = RTL_CONSTANT_STRING(<span class="string">L"\\Device\\KeyboardClass0"</span>); </span><br><span class="line">	PKEYBOARD_INDICATOR_TRANSLATION IndicatorTrans = <span class="literal">NULL</span>;<span class="comment">//LED指示灯状态 </span></span><br><span class="line">	UINT ModifierState = <span class="number">0</span>;<span class="comment">//ctrl、shift、alt、win四个修正键的按住状态 </span></span><br><span class="line">	USHORT LastMakeCode = <span class="number">0</span>; </span><br><span class="line">	USHORT LastFlags = <span class="number">0</span>; </span><br><span class="line">	UINT RepeatCount = <span class="number">0</span>;<span class="comment">//后续的重复计数(按住不放引起的) </span></span><br><span class="line">	InitializeObjectAttributes(&amp;KeyboardObjectAttributes,&amp;KeyboardDeviceName,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>); </span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">	&#123; </span><br><span class="line">		LARGE_INTEGER DueTime; </span><br><span class="line">		KEVENT Event; </span><br><span class="line">		DueTime.QuadPart = (LONGLONG)(<span class="number">-10000000</span>);<span class="comment">//1秒 </span></span><br><span class="line">		KeInitializeEvent(&amp;Event, NotificationEvent, FALSE); </span><br><span class="line">		Status = KeWaitForSingleObject(&amp;Event, Executive, KernelMode, FALSE, &amp;DueTime); </span><br><span class="line">		Status = NtOpenFile(&amp;KeyboardDeviceHandle,FILE_ALL_ACCESS,&amp;KeyboardObjectAttributes, </span><br><span class="line">		&amp;Iosb,<span class="number">0</span>,FILE_SYNCHRONOUS_IO_ALERT); </span><br><span class="line">	&#125; <span class="keyword">while</span> (!NT_SUCCESS(Status)); </span><br><span class="line"></span><br><span class="line">	<span class="comment">//上面的循环尝试打开键盘类设备,直到成功为止 </span></span><br><span class="line">	Status = Win32kInitWin32Thread(PsGetCurrentThread()); </span><br><span class="line">	<span class="comment">//键盘输入和鼠标输入线程是一种实时性较高的内核线程,比普通应用程序的线程的优先级高 </span></span><br><span class="line">	KeSetPriorityThread(&amp;PsGetCurrentThread()-&gt;Tcb,LOW_REALTIME_PRIORITY + <span class="number">3</span>); </span><br><span class="line">	<span class="comment">//获取键盘初始的LED指示灯状态 </span></span><br><span class="line">	IntKeyboardGetIndicatorTrans(KeyboardDeviceHandle,&amp;IndicatorTrans); </span><br><span class="line">	<span class="keyword">for</span> (;;) </span><br><span class="line">	&#123; </span><br><span class="line">		Status = KeWaitForSingleObject(&amp;InputThreadsStart,<span class="number">0</span>,KernelMode,TRUE,<span class="literal">NULL</span>); </span><br><span class="line">		<span class="comment">//每轮循环读取、处理一个键或者两个键(复合键：修正键+普通键) </span></span><br><span class="line">		<span class="keyword">while</span> (InputThreadsRunning)<span class="comment">// InputThreadsRunning一般总是TRUE </span></span><br><span class="line">		&#123; </span><br><span class="line">			BOOLEAN NumKeys = <span class="number">1</span>; </span><br><span class="line">			BOOLEAN bLeftAlt; </span><br><span class="line">			KEYBOARD_INPUT_DATA KeyInput; </span><br><span class="line">			KEYBOARD_INPUT_DATA NextKeyInput; </span><br><span class="line">			LPARAM lParam = <span class="number">0</span>; </span><br><span class="line">			UINT fsModifiers, fsNextModifiers; </span><br><span class="line">			<span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span> *<span class="title">Thread</span>;</span> </span><br><span class="line">			HWND hWnd; </span><br><span class="line">			<span class="keyword">int</span> id; </span><br><span class="line"></span><br><span class="line">			<span class="comment">//先读一个键 </span></span><br><span class="line">			Status = NtReadFile (KeyboardDeviceHandle,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;Iosb, &amp;KeyInput,<span class="keyword">sizeof</span>(KEYBOARD_INPUT_DATA),<span class="literal">NULL</span>,<span class="literal">NULL</span>); </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(Status == STATUS_ALERTED &amp;&amp; !InputThreadsRunning) <span class="keyword">break</span>; </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(Status == STATUS_PENDING) </span><br><span class="line">			&#123; </span><br><span class="line">				NtWaitForSingleObject(KeyboardDeviceHandle, FALSE, <span class="literal">NULL</span>); </span><br><span class="line">				Status = Iosb.Status; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">if</span> (Status == STATUS_ALERTED &amp;&amp; !InputThreadsRunning) <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">			IntLastInputTick(TRUE);<span class="comment">//记录上次读得输入的时间 </span></span><br><span class="line">			<span class="comment">//判断这个键是否是个修正键,若是,返回修正键ID </span></span><br><span class="line">			fsModifiers = IntKeyboardGetModifiers(&amp;KeyInput); </span><br><span class="line">			<span class="keyword">if</span> (fsModifiers)<span class="comment">//if 是个修正键 </span></span><br><span class="line">			&#123; </span><br><span class="line">				<span class="keyword">if</span> (KeyInput.Flags &amp; KEY_BREAK)<span class="comment">//if 弹起,修改状态 </span></span><br><span class="line">				&#123; </span><br><span class="line">					ModifierState &amp;= ~fsModifiers;<span class="comment">//去掉这个键 </span></span><br><span class="line">					<span class="keyword">if</span>(fsModifiers == MOD_ALT) </span><br><span class="line">					&#123; </span><br><span class="line">						<span class="keyword">if</span>(KeyInput.Flags &amp; KEY_E0)<span class="comment">//if 弹起的是右边alt </span></span><br><span class="line">						gQueueKeyStateTable[VK_RMENU] = <span class="number">0</span>;<span class="comment">//修改右alt键状态 </span></span><br><span class="line">						<span class="keyword">else</span> </span><br><span class="line"></span><br><span class="line">						gQueueKeyStateTable[VK_LMENU] = <span class="number">0</span>; </span><br><span class="line">						<span class="comment">//修改alt键状态 </span></span><br><span class="line">						<span class="keyword">if</span> (gQueueKeyStateTable[VK_RMENU] == <span class="number">0</span> &amp;&amp;gQueueKeyStateTable[VK_LMENU] == <span class="number">0</span>) </span><br><span class="line">						gQueueKeyStateTable[VK_MENU] = <span class="number">0</span>; </span><br><span class="line">					&#125; </span><br><span class="line">				&#125; </span><br><span class="line">				Else <span class="comment">//if 按下 </span></span><br><span class="line">				&#123; </span><br><span class="line">					ModifierState |= fsModifiers;<span class="comment">//加上这个修正键 </span></span><br><span class="line">					<span class="comment">//if 当前仅仅按着ALT或WIN键,特殊处理 </span></span><br><span class="line">					<span class="keyword">if</span> (ModifierState == fsModifiers &amp;&amp; (fsModifiers == MOD_ALT || fsModifiers == MOD_WIN)) </span><br><span class="line">					&#123; </span><br><span class="line">						bLeftAlt = FALSE; </span><br><span class="line">						<span class="keyword">if</span>(fsModifiers == MOD_ALT)<span class="comment">//if alt键,修改alt键的状态 </span></span><br><span class="line">						&#123; </span><br><span class="line">							<span class="keyword">if</span>(KeyInput.Flags &amp; KEY_E0) </span><br><span class="line">								gQueueKeyStateTable[VK_RMENU] = <span class="number">0x80</span>;<span class="comment">//最高位为1表示处于按着状态 </span></span><br><span class="line">							<span class="keyword">else</span> </span><br><span class="line">							&#123; </span><br><span class="line">								gQueueKeyStateTable[VK_LMENU] = <span class="number">0x80</span>; </span><br><span class="line">								bLeftAlt = TRUE; </span><br><span class="line">							&#125; </span><br><span class="line">							gQueueKeyStateTable[VK_MENU] = <span class="number">0x80</span>;<span class="comment">//标记有个alt键按着 </span></span><br><span class="line">						&#125; </span><br><span class="line">						<span class="keyword">do</span> </span><br><span class="line">						&#123; </span><br><span class="line">							Status = NtReadFile (KeyboardDeviceHandle,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;Iosb, </span><br><span class="line">							&amp;NextKeyInput,<span class="keyword">sizeof</span>(KEYBOARD_INPUT_DATA), </span><br><span class="line">							<span class="literal">NULL</span>,<span class="literal">NULL</span>); </span><br><span class="line">							<span class="keyword">if</span> (Status == STATUS_ALERTED &amp;&amp; !InputThreadsRunning) </span><br><span class="line">								<span class="keyword">goto</span> KeyboardEscape; </span><br><span class="line">						&#125; </span><br><span class="line">						<span class="keyword">while</span> ((!(NextKeyInput.Flags &amp; KEY_BREAK)) &amp;&amp; </span><br><span class="line">						    NextKeyInput.MakeCode == KeyInput.MakeCode); </span><br><span class="line">						<span class="comment">//上面的循环,跳过因按住alt、win不放产生的那些重复按键,直到读到一个原按键 弹起输入或者另外一个键为止 </span></span><br><span class="line">						<span class="comment">//判断读到的下一个键是否为修正键 </span></span><br><span class="line">						fsNextModifiers = IntKeyboardGetModifiers(&amp;NextKeyInput); </span><br><span class="line">						<span class="keyword">if</span> (fsNextModifiers) </span><br><span class="line">							ModifierState ^= fsNextModifiers;<span class="comment">//状态切换 </span></span><br><span class="line">						<span class="keyword">if</span> (ModifierState == <span class="number">0</span>)<span class="comment">//也即if读到的下个键是原按键的弹起 </span></span><br><span class="line">						&#123; </span><br><span class="line">							<span class="keyword">if</span> (fsModifiers == MOD_WIN) </span><br><span class="line">							IntKeyboardSendWinKeyMsg();<span class="comment">//生成单个win键单击消息 </span></span><br><span class="line">							<span class="keyword">else</span> <span class="keyword">if</span> (fsModifiers == MOD_ALT) </span><br><span class="line">							&#123; </span><br><span class="line">								gQueueKeyStateTable[VK_MENU] = <span class="number">0</span>; </span><br><span class="line">								</span><br><span class="line">								<span class="keyword">if</span>(bLeftAlt) </span><br><span class="line">									gQueueKeyStateTable[VK_LMENU] = <span class="number">0</span>; </span><br><span class="line">								<span class="keyword">else</span> </span><br><span class="line">									gQueueKeyStateTable[VK_RMENU] = <span class="number">0</span>; </span><br><span class="line">								</span><br><span class="line">								co_IntKeyboardSendAltKeyMsg();<span class="comment">//生成单个alt键单击消息 </span></span><br><span class="line">							&#125; </span><br><span class="line">							<span class="keyword">continue</span>;<span class="comment">//继续读取下个输入 </span></span><br><span class="line">						&#125; </span><br><span class="line">						<span class="comment">//若下个输入是另外某个键按下 </span></span><br><span class="line">						NumKeys = <span class="number">2</span>;<span class="comment">//表示alt+x或win+x的复合键 </span></span><br><span class="line">					&#125; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//处理本轮循环读到的键(一个键或者复合键) </span></span><br><span class="line">			<span class="keyword">for</span> (;NumKeys;<span class="built_in">memcpy</span>(&amp;KeyInput, &amp;NextKeyInput, <span class="keyword">sizeof</span>(KeyInput)),NumKeys--) </span><br><span class="line">			&#123; </span><br><span class="line">				PKBL keyboardLayout = <span class="literal">NULL</span>; </span><br><span class="line">				lParam = <span class="number">0</span>; </span><br><span class="line">				<span class="comment">//修正对应的指示灯 </span></span><br><span class="line">				IntKeyboardUpdateLeds(KeyboardDeviceHandle,&amp;KeyInput,IndicatorTrans); </span><br><span class="line">				<span class="comment">//下面构造该KeyDown/KeyUp消息的lparam,其格式如下:</span></span><br><span class="line">				*  <span class="number">0</span><span class="number">-15</span>: 重复计数 </span><br><span class="line">				* <span class="number">16</span><span class="number">-23</span>: 扫描码 </span><br><span class="line">				*    <span class="number">24</span>: 修正键标志 </span><br><span class="line">				*    <span class="number">29</span>: alt键是否按着标志 </span><br><span class="line">				*    <span class="number">30</span>: 标志是否与上次的按键状态相同 </span><br><span class="line">				*    <span class="number">31</span>: 标志当前按键状态是按下还是弹起 </span><br><span class="line">				<span class="keyword">if</span> (!(KeyInput.Flags &amp; KEY_BREAK))<span class="comment">//if 按下 </span></span><br><span class="line">				&#123; </span><br><span class="line">					<span class="comment">//也即是同一按键后续的重复KeyDown </span></span><br><span class="line">					<span class="keyword">if</span> (((KeyInput.Flags &amp; (KEY_E0 | KEY_E1)) == LastFlags) &amp;&amp; </span><br><span class="line">					       (KeyInput.MakeCode == LastMakeCode)) </span><br><span class="line">					&#123; </span><br><span class="line">						RepeatCount++;<span class="comment">//递增重复按键计数 </span></span><br><span class="line">						lParam |= (<span class="number">1</span> &lt;&lt; <span class="number">30</span>);<span class="comment">//bit30标记为与上次的按键状态的相同 </span></span><br><span class="line">					&#125; </span><br><span class="line">					Else<span class="comment">//首次按下某键 </span></span><br><span class="line">					&#123; </span><br><span class="line">						RepeatCount = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">						LastFlags = KeyInput.Flags &amp; (KEY_E0 | KEY_E1); </span><br><span class="line">						LastMakeCode = KeyInput.MakeCode; </span><br><span class="line">					&#125; </span><br><span class="line">				&#125; </span><br><span class="line">				Else <span class="comment">//if 弹起 </span></span><br><span class="line">				&#123; </span><br><span class="line">					LastFlags = <span class="number">0</span>; </span><br><span class="line">					LastMakeCode = <span class="number">0</span>; </span><br><span class="line">					lParam |= (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">31</span>); </span><br><span class="line">				&#125; </span><br><span class="line">				lParam |= RepeatCount; </span><br><span class="line">				lParam |= (KeyInput.MakeCode &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>; </span><br><span class="line">				<span class="keyword">if</span> (KeyInput.Flags &amp; KEY_E0) </span><br><span class="line">					lParam |= (<span class="number">1</span> &lt;&lt; <span class="number">24</span>); </span><br><span class="line">				<span class="keyword">if</span> (ModifierState &amp; MOD_ALT)<span class="comment">//如果按着alt键,那就是WM_SYSKEYDOWN、WM_SYSKEYUP </span></span><br><span class="line">				&#123; </span><br><span class="line">					lParam |= (<span class="number">1</span> &lt;&lt; <span class="number">29</span>); </span><br><span class="line">					<span class="keyword">if</span> (!(KeyInput.Flags &amp; KEY_BREAK)) </span><br><span class="line">						msg.message = WM_SYSKEYDOWN; </span><br><span class="line">					<span class="keyword">else</span> </span><br><span class="line">						msg.message = WM_SYSKEYUP; </span><br><span class="line">				&#125; </span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">				&#123; </span><br><span class="line">					<span class="keyword">if</span> (!(KeyInput.Flags &amp; KEY_BREAK)) </span><br><span class="line">						msg.message = WM_KEYDOWN; </span><br><span class="line">					<span class="keyword">else</span> </span><br><span class="line">						msg.message = WM_KEYUP; </span><br><span class="line">				&#125; </span><br><span class="line">				<span class="comment">//获得当前的‘键盘焦点线程’(注意不是焦点窗口) </span></span><br><span class="line">				FocusQueue = IntGetFocusMessageQueue(); </span><br><span class="line">				<span class="keyword">if</span> (FocusQueue) </span><br><span class="line">				&#123; </span><br><span class="line">					msg.hwnd = FocusQueue-&gt;FocusWindow; </span><br><span class="line">					FocusThread = FocusQueue-&gt;Thread; </span><br><span class="line">					<span class="keyword">if</span> (FocusThread &amp;&amp; FocusThread-&gt;Tcb.Win32Thread) </span><br><span class="line">						keyboardLayout = (FocusThread-&gt;Tcb.Win32Thread)-&gt;KeyboardLayout; </span><br><span class="line">				&#125; </span><br><span class="line">				msg.lParam = lParam; </span><br><span class="line">				<span class="keyword">if</span> (!keyboardLayout) </span><br><span class="line">					keyboardLayout = W32kGetDefaultKeyLayout(); </span><br><span class="line">				<span class="comment">//将扫描码转为虚拟码保存在wparam中 </span></span><br><span class="line">				W32kKeyProcessMessage(&amp;msg,keyboardLayout-&gt;KBTables, KeyInput.Flags &amp; KEY_E0 ? <span class="number">0xE0</span> : (KeyInput.Flags &amp; KEY_E1 ? <span class="number">0xE1</span> : <span class="number">0</span>)); </span><br><span class="line"></span><br><span class="line">				<span class="comment">//检查是否这个键被注册为了热键 </span></span><br><span class="line">				<span class="keyword">if</span> (GetHotKey(ModifierState,msg.wParam,&amp;Thread,&amp;hWnd,&amp;id)) </span><br><span class="line">				&#123; </span><br><span class="line">					<span class="keyword">if</span> (!(KeyInput.Flags &amp; KEY_BREAK)) </span><br><span class="line">					&#123; </span><br><span class="line">						MsqPostHotKeyMessage (Thread,hWnd, (WPARAM)id, </span><br><span class="line">						MAKELPARAM((WORD)ModifierState, (WORD)msg.wParam)); </span><br><span class="line">					&#125; </span><br><span class="line">					<span class="keyword">continue</span>;<span class="comment">//看到没,热键会阻断正常的按键分派流程 </span></span><br><span class="line">				&#125; </span><br><span class="line">				<span class="keyword">if</span> (!FocusQueue) </span><br><span class="line">					<span class="keyword">continue</span>; </span><br><span class="line">				<span class="comment">//关键。将消息发送给当前键盘焦点线程 </span></span><br><span class="line">				co_MsqPostKeyboardMessage(msg.message,msg.wParam,msg.lParam); </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上这个函数会循环从键盘驱动读取键盘输入,然后生成<code>WM_HotKey/KeyDown/KeyUp</code>消息,发给应用线 程。</p>
<p>读到的每个输入是一个结构,是由键盘驱动提交上来的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KEYBOARD_INPUT_DATA</span> &#123;</span> </span><br><span class="line">  USHORT UnitId;<span class="comment">//键盘ID,一台机器可以安装多个键盘 </span></span><br><span class="line">  USHORT MakeCode;<span class="comment">//扫描码 </span></span><br><span class="line">  USHORT Flags;<span class="comment">//E0、E1、Up等标志 </span></span><br><span class="line">  USHORT Reserved; </span><br><span class="line">  ULONG ExtraInformation; </span><br><span class="line">&#125; KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA;</span><br></pre></td></tr></table></figure>
<p>其中 Flags 包含的常见三个标志位:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define KEY_MAKE                       0x000  //表示按下 </span><br><span class="line">#define KEY_BREAK                      0x001  //表示弹起 </span><br><span class="line">#define KEY_E0                         0x010  //表示win键或右边的ctrl、lt </span><br><span class="line">#define KEY_E1                         0x100  //表示普通键(非修正键</span><br></pre></td></tr></table></figure></p>
<h3 id="IntKeyboardGetModifiers"><a href="#IntKeyboardGetModifiers" class="headerlink" title="IntKeyboardGetModifiers"></a>IntKeyboardGetModifiers</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">UINT  IntKeyboardGetModifiers(KEYBOARD_INPUT_DATA *InputData) </span><br><span class="line">&#123; </span><br><span class="line">   if (InputData-&gt;Flags &amp; KEY_E1)//普通键 </span><br><span class="line">      return 0;//返回FALSE </span><br><span class="line">   if (!(InputData-&gt;Flags &amp; KEY_E0))//if 不是win键和右边的ctrl、lt </span><br><span class="line">   &#123; </span><br><span class="line">      switch (InputData-&gt;MakeCode) </span><br><span class="line">      &#123; </span><br><span class="line"> </span><br><span class="line">         case 0x2a: /* left shift */ </span><br><span class="line">         case 0x36: /* right shift */ </span><br><span class="line">            return MOD_SHIFT; </span><br><span class="line">         case 0x1d: /* left control */ </span><br><span class="line">            return MOD_CONTROL; </span><br><span class="line">         case 0x38: /* left alt */ </span><br><span class="line">            return MOD_ALT; </span><br><span class="line">         default: </span><br><span class="line">            return 0; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   else </span><br><span class="line">   &#123; </span><br><span class="line">      switch (InputData-&gt;MakeCode) </span><br><span class="line">      &#123; </span><br><span class="line">         case 0x1d: /* right control */ </span><br><span class="line">            return MOD_CONTROL; </span><br><span class="line">         case 0x38: /* right alt */ </span><br><span class="line">            return MOD_ALT; </span><br><span class="line">         case 0x5b: /* left gui (windows) */ </span><br><span class="line">         case 0x5c: /* right gui (windows) */ </span><br><span class="line">            return MOD_WIN; </span><br><span class="line">         default: </span><br><span class="line">            return 0; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户可以调用<code>RegisterHotkey</code>api 注册热键,它内部调用下面的系统服务:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">NtUserRegisterHotKey</span><span class="params">(HWND hWnd,<span class="keyword">int</span> id,UINT fsModifiers,UINT vk)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   PHOT_KEY_ITEM HotKeyItem; </span><br><span class="line">   PWINDOW_OBJECT Window; </span><br><span class="line">   PETHREAD HotKeyThread; </span><br><span class="line">   DECLARE_RETURN(BOOL); </span><br><span class="line">   <span class="keyword">if</span> (IsHotKey (fsModifiers, vk))<span class="comment">//如果这个热键组合已被抢占了,注册失败 </span></span><br><span class="line">      RETURN( FALSE); </span><br><span class="line">   <span class="keyword">if</span> (hWnd == <span class="literal">NULL</span>)<span class="comment">//可为NULL,热键消息发给当前线程 </span></span><br><span class="line">      HotKeyThread = PsGetCurrentThread(); </span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">   &#123; </span><br><span class="line">      <span class="keyword">if</span>(!(Window = UserGetWindowObject(hWnd))) </span><br><span class="line">         RETURN( FALSE); </span><br><span class="line"> </span><br><span class="line">      HotKeyThread = Window-&gt;pti-&gt;pEThread;<span class="comment">//热键消息将发给的目标线程 </span></span><br><span class="line">   &#125; </span><br><span class="line">   HotKeyItem = ExAllocatePoolWithTag (PagedPool, <span class="keyword">sizeof</span>(HOT_KEY_ITEM), TAG_HOTKEY); </span><br><span class="line">   HotKeyItem-&gt;Thread = HotKeyThread;<span class="comment">//目标线程 </span></span><br><span class="line">   HotKeyItem-&gt;hWnd = hWnd;<span class="comment">//目标窗口 </span></span><br><span class="line">   HotKeyItem-&gt;id = id;<span class="comment">//热键id </span></span><br><span class="line">   HotKeyItem-&gt;fsModifiers = fsModifiers;<span class="comment">//修正键组合 </span></span><br><span class="line">   HotKeyItem-&gt;vk = vk;<span class="comment">//虚拟码 </span></span><br><span class="line">   InsertHeadList (&amp;gHotkeyList, &amp;HotKeyItem-&gt;ListEntry);<span class="comment">//插入全局的热键表 </span></span><br><span class="line">   RETURN( TRUE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当读到的按键被发现注册为了热键的话,就发给热键注册的目标线程 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测是不是热键,若是,再返回该热键的目标线程、窗口和id </span></span><br><span class="line"><span class="function">BOOL FASTCALL <span class="title">GetHotKey</span> <span class="params">(UINT fsModifiers,UINT vk,struct _ETHREAD **Thread,HWND *hWnd,<span class="keyword">int</span> *id)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   PHOT_KEY_ITEM HotKeyItem; </span><br><span class="line">   LIST_FOR_EACH(HotKeyItem, &amp;gHotkeyList, HOT_KEY_ITEM, ListEntry) </span><br><span class="line">   &#123; </span><br><span class="line">      <span class="keyword">if</span> (HotKeyItem-&gt;fsModifiers == fsModifiers &amp;&amp; HotKeyItem-&gt;vk == vk) </span><br><span class="line">      &#123; </span><br><span class="line">         <span class="keyword">if</span> (Thread != <span class="literal">NULL</span>) </span><br><span class="line">            *Thread = HotKeyItem-&gt;Thread; </span><br><span class="line">         <span class="keyword">if</span> (hWnd != <span class="literal">NULL</span>) </span><br><span class="line">            *hWnd = HotKeyItem-&gt;hWnd; </span><br><span class="line">         <span class="keyword">if</span> (id != <span class="literal">NULL</span>) </span><br><span class="line">            *id = HotKeyItem-&gt;id; </span><br><span class="line">         <span class="keyword">return</span> TRUE; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> FALSE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的函数将热键消息以<code>Post</code>方式发给目标线程</p>
<h3 id="MsqPostHotKeyMessage"><a href="#MsqPostHotKeyMessage" class="headerlink" title="MsqPostHotKeyMessage"></a>MsqPostHotKeyMessage</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">MsqPostHotKeyMessage</span><span class="params">(PVOID Thread, HWND hWnd, WPARAM wParam, LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   PWINDOW_OBJECT Window; </span><br><span class="line">   PTHREADINFO Win32Thread; </span><br><span class="line">   MSG Mesg; </span><br><span class="line">   LARGE_INTEGER LargeTickCount; </span><br><span class="line">   NTSTATUS Status; </span><br><span class="line">   Status = ObReferenceObjectByPointer (Thread,THREAD_ALL_ACCESS,PsThreadType,KernelMode); </span><br><span class="line">   Win32Thread = ((PETHREAD)Thread)-&gt;Tcb.Win32Thread; </span><br><span class="line"> </span><br><span class="line">   Window = IntGetWindowObject(hWnd); </span><br><span class="line">   Mesg.hwnd = hWnd; </span><br><span class="line">   Mesg.message = WM_HOTKEY; </span><br><span class="line">   Mesg.wParam = wParam; </span><br><span class="line">   Mesg.lParam = lParam; </span><br><span class="line">   KeQueryTickCount(&amp;LargeTickCount); </span><br><span class="line">   Mesg.time = MsqCalculateMessageTime(&amp;LargeTickCount);<span class="comment">//消息的产生时间 </span></span><br><span class="line">   Mesg.pt = gpsi-&gt;ptCursor; <span class="comment">//消息产生时的光标位置 </span></span><br><span class="line">   </span><br><span class="line">   MsqPostMessage(Window-&gt;pti-&gt;MessageQueue, &amp;Mesg, FALSE, QS_HOTKEY);<span class="comment">//发给目标线程 </span></span><br><span class="line">   UserDereferenceObject(Window); </span><br><span class="line">   ObDereferenceObject (Thread); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="co-MsqPostKeyboardMessage"><a href="#co-MsqPostKeyboardMessage" class="headerlink" title="co_MsqPostKeyboardMessage"></a>co_MsqPostKeyboardMessage</h3><p>普通的按键消息都会发给当前键盘焦点线程(注意可能当前没有键盘焦点窗口) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">co_MsqPostKeyboardMessage</span><span class="params">(UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   PUSER_MESSAGE_QUEUE FocusMessageQueue; </span><br><span class="line">   MSG Msg; </span><br><span class="line">   LARGE_INTEGER LargeTickCount; </span><br><span class="line">   KBDLLHOOKSTRUCT KbdHookData; </span><br><span class="line">   BOOLEAN Entered = FALSE; </span><br><span class="line">   FocusMessageQueue = IntGetFocusMessageQueue();<span class="comment">//当前焦点线程的消息队列 </span></span><br><span class="line">   Msg.hwnd = <span class="literal">NULL</span>; </span><br><span class="line">   Msg.message = uMsg; </span><br><span class="line">   Msg.wParam = wParam; </span><br><span class="line">   Msg.lParam = lParam; </span><br><span class="line">   KeQueryTickCount(&amp;LargeTickCount); </span><br><span class="line">   Msg.time = MsqCalculateMessageTime(&amp;LargeTickCount); </span><br><span class="line">   KbdHookData.vkCode = Msg.wParam; </span><br><span class="line">   KbdHookData.scanCode = (Msg.lParam &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>; </span><br><span class="line">   KbdHookData.flags = (<span class="number">0</span> == (Msg.lParam &amp; <span class="number">0x01000000</span>) ? <span class="number">0</span> : LLKHF_EXTENDED) | </span><br><span class="line">                       (<span class="number">0</span> == (Msg.lParam &amp; <span class="number">0x20000000</span>) ? <span class="number">0</span> : LLKHF_ALTDOWN) | </span><br><span class="line">                       (<span class="number">0</span> == (Msg.lParam &amp; <span class="number">0x80000000</span>) ? <span class="number">0</span> : LLKHF_UP); </span><br><span class="line">   KbdHookData.time = Msg.time; </span><br><span class="line">   KbdHookData.dwExtraInfo = <span class="number">0</span>; </span><br><span class="line">   </span><br><span class="line">   <span class="comment">//进队前,先检查、调用底层键盘钩子,若钩子处理结果返回非0值,则不再继续发送 </span></span><br><span class="line">   <span class="keyword">if</span> (co_HOOK_CallHooks(WH_KEYBOARD_LL, HC_ACTION, Msg.message, (LPARAM) &amp;KbdHookData)) </span><br><span class="line">      <span class="keyword">return</span>; </span><br><span class="line">   <span class="keyword">if</span> (FocusMessageQueue-&gt;FocusWindow != <span class="literal">NULL</span>) </span><br><span class="line">   &#123; </span><br><span class="line">         Msg.hwnd = FocusMessageQueue-&gt;FocusWindow; </span><br><span class="line">         FocusMessageQueue-&gt;Desktop-&gt;pDeskInfo-&gt;LastInputWasKbd = TRUE; </span><br><span class="line">         Msg.pt = gpsi-&gt;ptCursor;<span class="comment">//光标位置 </span></span><br><span class="line"> </span><br><span class="line">         MsqPostMessage(FocusMessageQueue, &amp;Msg, FALSE, QS_KEY);<span class="comment">//发给焦点线程 </span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="鼠标消息的产生、处理"><a href="#鼠标消息的产生、处理" class="headerlink" title="鼠标消息的产生、处理"></a>鼠标消息的产生、处理</h2><h3 id="MouseThreadMain"><a href="#MouseThreadMain" class="headerlink" title="MouseThreadMain"></a>MouseThreadMain</h3><p>这个线程会不断的从<code>鼠标驱动</code>读取<code>鼠标输入</code>-<code>处理</code>-<code>读取鼠标输入</code>-<code>处理</code>…<br>看看是怎么处理鼠标输入的 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID  <span class="title">MouseThreadMain</span><span class="params">(PVOID StartContext)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="comment">//鼠标类设备 </span></span><br><span class="line">   UNICODE_STRING MouseDeviceName = RTL_CONSTANT_STRING(<span class="string">L"\\Device\\PointerClass0"</span>); </span><br><span class="line">   OBJECT_ATTRIBUTES MouseObjectAttributes; </span><br><span class="line">   IO_STATUS_BLOCK Iosb; </span><br><span class="line">   NTSTATUS Status; </span><br><span class="line">   MOUSE_ATTRIBUTES MouseAttr; </span><br><span class="line"> </span><br><span class="line">   Status = Win32kInitWin32Thread(PsGetCurrentThread()); </span><br><span class="line">   KeSetPriorityThread(&amp;PsGetCurrentThread()-&gt;Tcb,LOW_REALTIME_PRIORITY + <span class="number">3</span>); </span><br><span class="line">   InitializeObjectAttributes(&amp;MouseObjectAttributes,&amp;MouseDeviceName,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>); </span><br><span class="line">   <span class="keyword">do</span> </span><br><span class="line">   &#123; </span><br><span class="line">      LARGE_INTEGER DueTime; </span><br><span class="line">      KEVENT Event; </span><br><span class="line">      DueTime.QuadPart = (LONGLONG)(<span class="number">-10000000</span>); </span><br><span class="line">      KeInitializeEvent(&amp;Event, NotificationEvent, FALSE); </span><br><span class="line">      Status = KeWaitForSingleObject(&amp;Event, Executive, KernelMode, FALSE, &amp;DueTime); </span><br><span class="line">      Status = NtOpenFile(&amp;MouseDeviceHandle,FILE_ALL_ACCESS,&amp;MouseObjectAttributes, </span><br><span class="line">                       &amp;Iosb,<span class="number">0</span>,FILE_SYNCHRONOUS_IO_ALERT); </span><br><span class="line">   &#125; <span class="keyword">while</span> (!NT_SUCCESS(Status)); </span><br><span class="line">   </span><br><span class="line">   <span class="comment">//上面的循环尝试打开鼠标类设备,直到成功 </span></span><br><span class="line">   <span class="keyword">for</span>(;;) </span><br><span class="line">   &#123; </span><br><span class="line">      Status = KeWaitForSingleObject(&amp;InputThreadsStart,<span class="number">0</span>,KernelMode,TRUE,<span class="literal">NULL</span>); </span><br><span class="line">      Status = NtDeviceIoControlFile(MouseDeviceHandle,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;Iosb, </span><br><span class="line">                                     IOCTL_MOUSE_QUERY_ATTRIBUTES, </span><br><span class="line">                                     &amp;MouseAttr, <span class="keyword">sizeof</span>(MOUSE_ATTRIBUTES), </span><br><span class="line">                                     <span class="literal">NULL</span>, <span class="number">0</span>); </span><br><span class="line">      <span class="keyword">while</span>(InputThreadsRunning) </span><br><span class="line">      &#123; </span><br><span class="line">         MOUSE_INPUT_DATA MouseInput; </span><br><span class="line">         Status = NtReadFile(MouseDeviceHandle,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;Iosb, </span><br><span class="line">                             &amp;MouseInput,<span class="keyword">sizeof</span>(MOUSE_INPUT_DATA),<span class="literal">NULL</span>,<span class="literal">NULL</span>); </span><br><span class="line">         <span class="keyword">if</span>(Status == STATUS_ALERTED &amp;&amp; !InputThreadsRunning) <span class="keyword">break</span>; </span><br><span class="line">         <span class="keyword">if</span>(Status == STATUS_PENDING) </span><br><span class="line">         &#123; </span><br><span class="line"> </span><br><span class="line">            NtWaitForSingleObject(MouseDeviceHandle, FALSE, <span class="literal">NULL</span>); </span><br><span class="line">            Status = Iosb.Status; </span><br><span class="line">         &#125; </span><br><span class="line"> 	     </span><br><span class="line"> 	     IntLastInputTick(TRUE);<span class="comment">//记录上次得到输入的时间 </span></span><br><span class="line">         UserEnterExclusive(); </span><br><span class="line">         </span><br><span class="line">         <span class="comment">//处理得到的鼠标输入 </span></span><br><span class="line">         ProcessMouseInputData(&amp;MouseInput, Iosb.Information / <span class="keyword">sizeof</span>(MOUSE_INPUT_DATA)); </span><br><span class="line">         UserLeave(); </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">ProcessMouseInputData</span><span class="params">(PMOUSE_INPUT_DATA Data, ULONG InputCount)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   PMOUSE_INPUT_DATA mid;<span class="comment">//当前鼠标输入 </span></span><br><span class="line">   MOUSEINPUT mi; </span><br><span class="line">   ULONG i; </span><br><span class="line">   ClearMouseInput(mi);<span class="comment">//全部清0 </span></span><br><span class="line">   mi.time = <span class="number">0</span>; </span><br><span class="line">   mi.dwExtraInfo = <span class="number">0</span>; </span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; InputCount; i++)<span class="comment">//遍历每个鼠标输入 </span></span><br><span class="line">   &#123; </span><br><span class="line">      mid = (Data + i); </span><br><span class="line">      mi.dx += mid-&gt;LastX;<span class="comment">//X方向移动距离 </span></span><br><span class="line">      mi.dy += mid-&gt;LastY;<span class="comment">//Y方向移动距离 </span></span><br><span class="line">      <span class="keyword">if</span> (mid-&gt;Flags == MOUSE_MOVE_ABSOLUTE)<span class="comment">//指LastX、LastY是绝对值 </span></span><br><span class="line">         mi.dwFlags |= MOUSEEVENTF_ABSOLUTE; </span><br><span class="line">      <span class="keyword">if</span>(mid-&gt;ButtonFlags) </span><br><span class="line">      &#123; </span><br><span class="line">         <span class="keyword">if</span>(mid-&gt;ButtonFlags &amp; MOUSE_LEFT_BUTTON_DOWN) </span><br><span class="line">         &#123; </span><br><span class="line">            mi.dwFlags |= MOUSEEVENTF_LEFTDOWN; </span><br><span class="line">            SendMouseEvent(mi); </span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">if</span>(mid-&gt;ButtonFlags &amp; MOUSE_LEFT_BUTTON_UP) </span><br><span class="line">         &#123; </span><br><span class="line">            mi.dwFlags |= MOUSEEVENTF_LEFTUP; </span><br><span class="line">            SendMouseEvent(mi); </span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">if</span>(mid-&gt;ButtonFlags &amp; MOUSE_MIDDLE_BUTTON_DOWN) </span><br><span class="line">         &#123; </span><br><span class="line"> </span><br><span class="line">            mi.dwFlags |= MOUSEEVENTF_MIDDLEDOWN; </span><br><span class="line">            SendMouseEvent(mi); </span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">if</span>(mid-&gt;ButtonFlags &amp; MOUSE_MIDDLE_BUTTON_UP) </span><br><span class="line">         &#123; </span><br><span class="line">            mi.dwFlags |= MOUSEEVENTF_MIDDLEUP; </span><br><span class="line">            SendMouseEvent(mi); </span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">if</span>(mid-&gt;ButtonFlags &amp; MOUSE_RIGHT_BUTTON_DOWN) </span><br><span class="line">         &#123; </span><br><span class="line">            mi.dwFlags |= MOUSEEVENTF_RIGHTDOWN; </span><br><span class="line">            SendMouseEvent(mi); </span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">if</span>(mid-&gt;ButtonFlags &amp; MOUSE_RIGHT_BUTTON_UP) </span><br><span class="line">         &#123; </span><br><span class="line">            mi.dwFlags |= MOUSEEVENTF_RIGHTUP; </span><br><span class="line">            SendMouseEvent(mi); </span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">if</span>(mid-&gt;ButtonFlags &amp; MOUSE_WHEEL) </span><br><span class="line">         &#123; </span><br><span class="line">            mi.mouseData = mid-&gt;ButtonData; </span><br><span class="line">            mi.dwFlags |= MOUSEEVENTF_WHEEL; </span><br><span class="line">            SendMouseEvent(mi); </span><br><span class="line">         &#125; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125;<span class="comment">// end for </span></span><br><span class="line">   SendMouseEvent(mi); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SendMouseEvent 是个宏 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SendMouseEvent(mi) \ </span></span><br><span class="line">  <span class="keyword">if</span>(mi.dx != <span class="number">0</span> || mi.dy != <span class="number">0</span>) \     <span class="comment">//if鼠标有移动 </span></span><br><span class="line">    mi.dwFlags |= MOUSEEVENTF_MOVE; \ </span><br><span class="line">  <span class="keyword">if</span>(mi.dwFlags) \ </span><br><span class="line">    IntMouseInput(&amp;mi); \ <span class="comment">//生成相应的鼠标消息,放入系统的环形缓冲队列 </span></span><br><span class="line">  ClearMouseInput(mi);<span class="comment">//又清 0</span></span><br></pre></td></tr></table></figure>
<h3 id="IntMouseInput"><a href="#IntMouseInput" class="headerlink" title="IntMouseInput"></a>IntMouseInput</h3><p>可以看出,第一个满足的 if 条件语句,在调用<code>SendMouseEvent</code>时,才可能含有标志 <code>MOUSEEVENTF_MOVE</code>。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL FASTCALL <span class="title">IntMouseInput</span><span class="params">(MOUSEINPUT *mi)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="comment">//鼠标的左右按键可以互换 </span></span><br><span class="line">   <span class="keyword">const</span> UINT SwapBtnMsg[<span class="number">2</span>][<span class="number">2</span>] = </span><br><span class="line">               &#123;  &#123;WM_LBUTTONDOWN, WM_RBUTTONDOWN&#125;,&#123;WM_LBUTTONUP, WM_RBUTTONUP&#125; &#125;; </span><br><span class="line">   <span class="keyword">const</span> WPARAM SwapBtn[<span class="number">2</span>] =&#123;MK_LBUTTON, MK_RBUTTON&#125;; </span><br><span class="line"> </span><br><span class="line">   POINT MousePos; </span><br><span class="line">   PSYSTEM_CURSORINFO CurInfo; </span><br><span class="line">   BOOL SwapButtons; </span><br><span class="line">   MSG Msg; </span><br><span class="line">   CurInfo = IntGetSysCursorInfo();<span class="comment">//光标的一些属性 </span></span><br><span class="line">   SwapButtons = gspv.bMouseBtnSwap;<span class="comment">//全局变量,表示鼠标左右按键是否互换 </span></span><br><span class="line">   MousePos = gpsi-&gt;ptCursor; <span class="comment">//当前光标的位置 </span></span><br><span class="line">   <span class="keyword">if</span>(mi-&gt;dwFlags &amp; MOUSEEVENTF_MOVE)<span class="comment">//前面讲了,第一个满足条件的if块才可能带有这个标志 </span></span><br><span class="line">   &#123; </span><br><span class="line">      <span class="keyword">if</span>(mi-&gt;dwFlags &amp; MOUSEEVENTF_ABSOLUTE) </span><br><span class="line">      &#123; </span><br><span class="line">         MousePos.x = mi-&gt;dx * UserGetSystemMetrics(SM_CXVIRTUALSCREEN) &gt;&gt; <span class="number">16</span>; </span><br><span class="line">         MousePos.y = mi-&gt;dy * UserGetSystemMetrics(SM_CYVIRTUALSCREEN) &gt;&gt; <span class="number">16</span>; </span><br><span class="line">      &#125; </span><br><span class="line">      Else <span class="comment">//计算新的光标位置 </span></span><br><span class="line">      &#123; </span><br><span class="line">         MousePos.x += mi-&gt;dx; </span><br><span class="line">         MousePos.y += mi-&gt;dy; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">if</span>(mi-&gt;dwFlags &amp; MOUSEEVENTF_MOVE) </span><br><span class="line">      UserSetCursorPos(MousePos.x, MousePos.y, TRUE);<span class="comment">//系统会自动物理移动桌面上的光标位置 </span></span><br><span class="line">   Msg.wParam = <span class="number">0</span>; </span><br><span class="line">   Msg.lParam = MAKELPARAM(MousePos.x, MousePos.y); </span><br><span class="line">   Msg.pt = MousePos; </span><br><span class="line">   <span class="comment">//上面构造了一个鼠标消息(注意这个消息尚未确定目标窗口) </span></span><br><span class="line">   <span class="keyword">if</span> (gQueueKeyStateTable[VK_SHIFT] &amp; <span class="number">0xc0</span>) </span><br><span class="line">      Msg.wParam |= MK_SHIFT; </span><br><span class="line">   <span class="keyword">if</span> (gQueueKeyStateTable[VK_CONTROL] &amp; <span class="number">0xc0</span>) </span><br><span class="line">      Msg.wParam |= MK_CONTROL; </span><br><span class="line">   <span class="keyword">if</span>(mi-&gt;dwFlags &amp; MOUSEEVENTF_LEFTDOWN) </span><br><span class="line">   &#123; </span><br><span class="line">      gQueueKeyStateTable[VK_LBUTTON] |= <span class="number">0xc0</span>; </span><br><span class="line">      Msg.message = SwapBtnMsg[<span class="number">0</span>][SwapButtons]; </span><br><span class="line">      CurInfo-&gt;ButtonsDown |= SwapBtn[SwapButtons]; </span><br><span class="line">      Msg.wParam |= CurInfo-&gt;ButtonsDown; </span><br><span class="line">      MsqInsertSystemMessage(&amp;Msg);<span class="comment">//关键。系统生成鼠标消息后,插入到系统的环形缓冲消息队列 </span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(mi-&gt;dwFlags &amp; MOUSEEVENTF_LEFTUP) </span><br><span class="line">   &#123; </span><br><span class="line">      gQueueKeyStateTable[VK_LBUTTON] &amp;= ~<span class="number">0x80</span>; </span><br><span class="line">      Msg.message = SwapBtnMsg[<span class="number">1</span>][SwapButtons]; </span><br><span class="line">      CurInfo-&gt;ButtonsDown &amp;= ~SwapBtn[SwapButtons]; </span><br><span class="line">      Msg.wParam |= CurInfo-&gt;ButtonsDown; </span><br><span class="line"> </span><br><span class="line">      MsqInsertSystemMessage(&amp;Msg); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">if</span>(mi-&gt;dwFlags &amp; MOUSEEVENTF_MIDDLEDOWN) </span><br><span class="line">   &#123; </span><br><span class="line">      gQueueKeyStateTable[VK_MBUTTON] |= <span class="number">0xc0</span>; </span><br><span class="line">      Msg.message = WM_MBUTTONDOWN; </span><br><span class="line">      CurInfo-&gt;ButtonsDown |= MK_MBUTTON; </span><br><span class="line">      Msg.wParam |= CurInfo-&gt;ButtonsDown; </span><br><span class="line">      MsqInsertSystemMessage(&amp;Msg); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(mi-&gt;dwFlags &amp; MOUSEEVENTF_MIDDLEUP) </span><br><span class="line">   &#123; </span><br><span class="line">      gQueueKeyStateTable[VK_MBUTTON] &amp;= ~<span class="number">0x80</span>; </span><br><span class="line">      Msg.message = WM_MBUTTONUP; </span><br><span class="line">      CurInfo-&gt;ButtonsDown &amp;= ~MK_MBUTTON; </span><br><span class="line">      Msg.wParam |= CurInfo-&gt;ButtonsDown; </span><br><span class="line">      MsqInsertSystemMessage(&amp;Msg); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">if</span>(mi-&gt;dwFlags &amp; MOUSEEVENTF_RIGHTDOWN) </span><br><span class="line">   &#123; </span><br><span class="line">      gQueueKeyStateTable[VK_RBUTTON] |= <span class="number">0xc0</span>; </span><br><span class="line">      Msg.message = SwapBtnMsg[<span class="number">0</span>][!SwapButtons]; </span><br><span class="line">      CurInfo-&gt;ButtonsDown |= SwapBtn[!SwapButtons]; </span><br><span class="line">      Msg.wParam |= CurInfo-&gt;ButtonsDown; </span><br><span class="line">      MsqInsertSystemMessage(&amp;Msg); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(mi-&gt;dwFlags &amp; MOUSEEVENTF_RIGHTUP) </span><br><span class="line">   &#123; </span><br><span class="line">      gQueueKeyStateTable[VK_RBUTTON] &amp;= ~<span class="number">0x80</span>; </span><br><span class="line">      Msg.message = SwapBtnMsg[<span class="number">1</span>][!SwapButtons]; </span><br><span class="line">      CurInfo-&gt;ButtonsDown &amp;= ~SwapBtn[!SwapButtons]; </span><br><span class="line">      Msg.wParam |= CurInfo-&gt;ButtonsDown; </span><br><span class="line">      MsqInsertSystemMessage(&amp;Msg); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">if</span>((mi-&gt;dwFlags &amp; (MOUSEEVENTF_XDOWN | MOUSEEVENTF_XUP)) &amp;&amp; </span><br><span class="line">          	 	 	 	 	 	 	(mi-&gt;dwFlags &amp; MOUSEEVENTF_WHEEL)) </span><br><span class="line">   &#123; </span><br><span class="line">      <span class="comment">/* fail because both types of events use the mouseData field */</span> </span><br><span class="line">      <span class="keyword">return</span> FALSE;<span class="comment">//两种消息的mouseData字段意思不一样 </span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">if</span>(mi-&gt;dwFlags &amp; MOUSEEVENTF_WHEEL) </span><br><span class="line">   &#123; </span><br><span class="line">      Msg.message = WM_MOUSEWHEEL; </span><br><span class="line">      Msg.wParam = MAKEWPARAM(CurInfo-&gt;ButtonsDown, mi-&gt;mouseData); </span><br><span class="line"> </span><br><span class="line">      MsqInsertSystemMessage(&amp;Msg); </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> TRUE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MsqInsertSystemMessage"><a href="#MsqInsertSystemMessage" class="headerlink" title="MsqInsertSystemMessage"></a>MsqInsertSystemMessage</h3><p>如上这个函数就是把鼠标输入转为一个鼠标消息,插入到系统的环形缓冲消息队列中。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">MsqInsertSystemMessage</span><span class="params">(MSG* Msg)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   LARGE_INTEGER LargeTickCount; </span><br><span class="line">   KIRQL OldIrql; </span><br><span class="line">   ULONG Prev; </span><br><span class="line">   MSLLHOOKSTRUCT MouseHookData; </span><br><span class="line">   KeQueryTickCount(&amp;LargeTickCount); </span><br><span class="line">   Msg-&gt;time = MsqCalculateMessageTime(&amp;LargeTickCount);<span class="comment">//计算消息的进队时间 </span></span><br><span class="line">   MouseHookData.pt.x = LOWORD(Msg-&gt;lParam); </span><br><span class="line">   MouseHookData.pt.y = HIWORD(Msg-&gt;lParam); </span><br><span class="line">   <span class="keyword">switch</span>(Msg-&gt;message) </span><br><span class="line">   &#123; </span><br><span class="line">      <span class="keyword">case</span> WM_MOUSEWHEEL: </span><br><span class="line">         MouseHookData.mouseData = MAKELONG(<span class="number">0</span>, GET_WHEEL_DELTA_WPARAM(Msg-&gt;wParam)); </span><br><span class="line">         <span class="keyword">break</span>; </span><br><span class="line">      <span class="keyword">case</span> WM_XBUTTONDOWN: </span><br><span class="line">      <span class="keyword">case</span> WM_XBUTTONUP: </span><br><span class="line">      <span class="keyword">case</span> WM_XBUTTONDBLCLK: </span><br><span class="line">      <span class="keyword">case</span> WM_NCXBUTTONDOWN: </span><br><span class="line">      <span class="keyword">case</span> WM_NCXBUTTONUP: </span><br><span class="line">      <span class="keyword">case</span> WM_NCXBUTTONDBLCLK: </span><br><span class="line">         MouseHookData.mouseData = MAKELONG(<span class="number">0</span>, HIWORD(Msg-&gt;wParam)); </span><br><span class="line">         <span class="keyword">break</span>; </span><br><span class="line">      <span class="keyword">default</span>: </span><br><span class="line">         MouseHookData.mouseData = <span class="number">0</span>; </span><br><span class="line">         <span class="keyword">break</span>; </span><br><span class="line">   &#125; </span><br><span class="line">   MouseHookData.flags = <span class="number">0</span>; </span><br><span class="line">   MouseHookData.time = Msg-&gt;time;<span class="comment">//消息的进队时间 </span></span><br><span class="line">   MouseHookData.dwExtraInfo = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">//检查、调用底层鼠标钩子,如果钩子过程返回非0值,那么不再处理该鼠标消息 </span></span><br><span class="line">   <span class="keyword">if</span> (co_HOOK_CallHooks(WH_MOUSE_LL, HC_ACTION, Msg-&gt;message, (LPARAM) &amp;MouseHookData)) </span><br><span class="line">      <span class="keyword">return</span>; </span><br><span class="line"> </span><br><span class="line">   IntLockSystemMessageQueue(OldIrql); </span><br><span class="line"> </span><br><span class="line">   <span class="comment">//由此可以看出,鼠标消息可能会因缓冲区满而丢失 </span></span><br><span class="line">   <span class="keyword">if</span> (SystemMessageQueueCount == SYSTEM_MESSAGE_QUEUE_SIZE)<span class="comment">//缓冲容量：256个消息 </span></span><br><span class="line">   &#123; </span><br><span class="line">      IntUnLockSystemMessageQueue(OldIrql); </span><br><span class="line">      <span class="keyword">return</span>; </span><br><span class="line">   &#125; </span><br><span class="line">    </span><br><span class="line">   <span class="keyword">if</span> (Msg-&gt;message == WM_MOUSEMOVE &amp;&amp; SystemMessageQueueCount !=<span class="number">0</span>) </span><br><span class="line">   &#123; </span><br><span class="line">      <span class="keyword">if</span> (SystemMessageQueueTail == <span class="number">0</span>) </span><br><span class="line">         Prev = SYSTEM_MESSAGE_QUEUE_SIZE - <span class="number">1</span>; </span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">         Prev = SystemMessageQueueTail - <span class="number">1</span>; </span><br><span class="line">		</span><br><span class="line">      <span class="comment">//若环形缓冲队列中的上一个消息也是WM_MOUSEMOVE,就更新替换(相当于合并MouseMove消息) </span></span><br><span class="line">      <span class="keyword">if</span> (SystemMessageQueue[Prev].message == WM_MOUSEMOVE) </span><br><span class="line">      &#123; </span><br><span class="line">         SystemMessageQueueTail = Prev; </span><br><span class="line">         SystemMessageQueueCount--; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   SystemMessageQueue[SystemMessageQueueTail] = *Msg; <span class="comment">//关键。插入到环形缓冲队列尾部 </span></span><br><span class="line">   SystemMessageQueueTail = (SystemMessageQueueTail + <span class="number">1</span>) % SYSTEM_MESSAGE_QUEUE_SIZE; </span><br><span class="line">   SystemMessageQueueCount++; </span><br><span class="line">   IntUnLockSystemMessageQueue(OldIrql); </span><br><span class="line">   KeSetEvent(&amp;HardwareMessageEvent, IO_NO_INCREMENT, FALSE);<span class="comment">//触发事件,唤醒其他线程 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当键盘按键消息插入到系统环形缓冲队列中后,会触发事件<code>HardwareMessageEvent</code>。<code>GetMessage</code>、<code>PeekMessage</code>内部会等待这个事件。</p>
<h2 id="模拟键盘鼠标动作"><a href="#模拟键盘鼠标动作" class="headerlink" title="模拟键盘鼠标动作"></a>模拟键盘鼠标动作</h2><p>除了由真实的硬件(键盘、鼠标)产生键盘消息外,用户也可以模拟键盘鼠标动作。<br><code>keybd_event</code>、<code>mouse_event</code>、<code>SendInput</code>这几个 API 都是用来模拟鼠标键盘的</p>
<h3 id="keybd-event-amp-mouse-event"><a href="#keybd-event-amp-mouse-event" class="headerlink" title="keybd_event&amp;mouse_event"></a>keybd_event&amp;mouse_event</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">keybd_event</span><span class="params">(BYTE bVk,BYTE bScan,DWORD dwFlags,ULONG_PTR dwExtraInfo)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  INPUT Input; </span><br><span class="line">  Input.type = INPUT_KEYBOARD; </span><br><span class="line">  Input.ki.wVk = bVk; </span><br><span class="line">  Input.ki.wScan = bScan; </span><br><span class="line">  Input.ki.dwFlags = dwFlags; </span><br><span class="line"> </span><br><span class="line">  Input.ki.time = <span class="number">0</span>; </span><br><span class="line">  Input.ki.dwExtraInfo = dwExtraInfo; </span><br><span class="line">  NtUserSendInput(<span class="number">1</span>, &amp;Input, <span class="keyword">sizeof</span>(INPUT)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function">VOID <span class="title">mouse_event</span><span class="params">(DWORD dwFlags,DWORD dx,DWORD dy,DWORD dwData,ULONG_PTR dwExtraInfo)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  INPUT Input; </span><br><span class="line">  Input.type = INPUT_MOUSE; </span><br><span class="line">  Input.mi.dx = dx; </span><br><span class="line">  Input.mi.dy = dy; </span><br><span class="line">  Input.mi.mouseData = dwData; </span><br><span class="line">  Input.mi.dwFlags = dwFlags; </span><br><span class="line">  Input.mi.time = <span class="number">0</span>; </span><br><span class="line">  Input.mi.dwExtraInfo = dwExtraInfo; </span><br><span class="line">  NtUserSendInput(<span class="number">1</span>, &amp;Input, <span class="keyword">sizeof</span>(INPUT)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SendInput"><a href="#SendInput" class="headerlink" title="SendInput"></a>SendInput</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">SendInput</span><span class="params">(UINT nInputs, LPINPUT pInputs, <span class="keyword">int</span> cbSize)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> NtUserSendInput(nInputs, pInputs, cbSize); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这几个 API 都是通过调用 NtUserSendInput 这个系统服务实现的。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">NtUserSendInput</span><span class="params">(UINT nInputs,LPINPUT pInput,INT cbSize)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   PTHREADINFO W32Thread; </span><br><span class="line">   UINT cnt; </span><br><span class="line">   DECLARE_RETURN(UINT); </span><br><span class="line">   UserEnterExclusive(); </span><br><span class="line">   W32Thread = PsGetCurrentThreadWin32Thread(); </span><br><span class="line">   <span class="keyword">if</span>(!W32Thread-&gt;rpdesk) </span><br><span class="line">      RETURN( <span class="number">0</span>); </span><br><span class="line">   <span class="keyword">if</span>(!nInputs || !pInput || (cbSize != <span class="keyword">sizeof</span>(INPUT))) </span><br><span class="line">   &#123; </span><br><span class="line">      SetLastWin32Error(ERROR_INVALID_PARAMETER); </span><br><span class="line">      RETURN( <span class="number">0</span>); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">//检查权限和活动桌面 </span></span><br><span class="line">   <span class="keyword">if</span>(!ThreadHasInputAccess(W32Thread) || !IntIsActiveDesktop(W32Thread-&gt;rpdesk)) </span><br><span class="line">   &#123; </span><br><span class="line">      SetLastWin32Error(ERROR_ACCESS_DENIED); </span><br><span class="line">      RETURN( <span class="number">0</span>); </span><br><span class="line"> </span><br><span class="line">   &#125; </span><br><span class="line">   cnt = <span class="number">0</span>; </span><br><span class="line">   <span class="keyword">while</span>(nInputs--)<span class="comment">//处理每个输入 </span></span><br><span class="line">   &#123; </span><br><span class="line">      INPUT SafeInput; </span><br><span class="line">      NTSTATUS Status; </span><br><span class="line">      Status = MmCopyFromCaller(&amp;SafeInput, pInput++, <span class="keyword">sizeof</span>(INPUT)); </span><br><span class="line">      <span class="keyword">switch</span>(SafeInput.type) </span><br><span class="line">      &#123; </span><br><span class="line">         <span class="keyword">case</span> INPUT_MOUSE: </span><br><span class="line">            <span class="keyword">if</span>(IntMouseInput(&amp;SafeInput.mi))<span class="comment">//将模拟的鼠标消息插入系统的环形缓冲队列 </span></span><br><span class="line">               cnt++; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">         <span class="keyword">case</span> INPUT_KEYBOARD:<span class="comment">//将模拟的键盘消息发给当前键盘焦点线程的post队列 </span></span><br><span class="line">            <span class="keyword">if</span>(IntKeyboardInput(&amp;SafeInput.ki)) </span><br><span class="line">               cnt++; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">         <span class="keyword">case</span> INPUT_HARDWARE: </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   RETURN( cnt); CLEANUP: </span><br><span class="line">   UserLeave(); </span><br><span class="line">   END_CLEANUP; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="DPC"><a href="#DPC" class="headerlink" title="DPC"></a>DPC</h1><p>DPC 不同 APC,DPC 的全名是<code>延迟过程调用</code>。 </p>
<p>DPC 最初作用是设计为中断服务程序的一部分。<br>因为每次触发中断,都会关中断,然后执行中断服务例程。<br>由于关中断了,所以中断服务例程必须短小精悍,不能消耗过多时间,否则会导致系统丢失大量其他中断。</p>
<blockquote>
<p>但是有的中断,其中断服务例程要做的事情本来就很多,那怎么办？<br>于是可以在中断服务例程中先执行最紧迫的那部分工作,然后把剩余的相对来说不那么重要的工作移入到 DPC 函数中去执行。<br>因此,DPC 又叫 ISR 的后半部。(比如每次时钟中断后,其 isr 会扫描系统中的所有定时器是否到点,若到点就调用各定时器的函数。<br>但是这个扫描过程比较耗时,因此时钟中断的 isr 会将扫描工作纳入 dpc 中进行)<br>每当触发一个中断时,中断服务例程可以在当前 cpu 中插入一个 DPC,当执行完 isr,退出 isr 后, cpu 就会扫描它的 dpc 队列,依次执行里面的每个 dpc,<br>当执行完 dpc 后,才又回到当前线程的中断处继续执行</p>
</blockquote>
<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KDPC</span> &#123;</span> </span><br><span class="line">  UCHAR Type; <span class="comment">//DPC类型(分为普通DPC和线程化DPC) </span></span><br><span class="line">  UCHAR Importance;<span class="comment">//该DPC的重要性,将决定挂在队列头还是尾 </span></span><br><span class="line">  <span class="keyword">volatile</span> USHORT Number;<span class="comment">//第5位为0就表示当前cpu,否则,最低4位表示目标cpu号 </span></span><br><span class="line">  LIST_ENTRY DpcListEntry;<span class="comment">//用来挂入dpc链表 </span></span><br><span class="line">  PKDEFERRED_ROUTINE DeferredRoutine;<span class="comment">//dpc函数 </span></span><br><span class="line">  PVOID DeferredContext;<span class="comment">//dpc函数的参数 </span></span><br><span class="line">  PVOID SystemArgument1;<span class="comment">//挂入时的系统附加参数1 </span></span><br><span class="line">  PVOID SystemArgument2;<span class="comment">//挂入时的系统附加参数2 </span></span><br><span class="line">  <span class="keyword">volatile</span> PVOID DpcData;<span class="comment">//所在的dpc队列 </span></span><br><span class="line">&#125; KDPC, *PKDPC, *RESTRICTED_POINTER PRKDPC;</span><br></pre></td></tr></table></figure>
<h2 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h2><h3 id="KeInitializeDpc"><a href="#KeInitializeDpc" class="headerlink" title="KeInitializeDpc"></a>KeInitializeDpc</h3><p>这个函数将 dpc 挂入目标 cpu 的指定 dpc 队列(每个 cpu 有两个 dpc 队列,一个普通的,一个线程化的)。<br>然后检查当前是否可以立即向目标 cpu 发出一个 dpc 软中断,这样以在下次降低到<code>DISPATCH_LEVEL</code>以下时扫描执行 dpc<br>其实上面的这个函数一般用于在 isr 中调用,但用户也可以随时手动调用<br>一般来说,挂入的都是中等重要性的 dpc,一般在 dpc 进队的同时就会顺势发出一个 dpc 中断 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KeInitializeDpc</span><span class="params">(IN PKDPC Dpc,<span class="comment">//DPC对象(DPC也是一种内核对象) </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN PKDEFERRED_ROUTINE DeferredRoutine, <span class="comment">//DPC函数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN PVOID DeferredContext)</span><span class="comment">//DPC函数的参数 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    KiInitializeDpc(Dpc, DeferredRoutine, DeferredContext, DpcObject); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">KiInitializeDpc</span><span class="params">(IN PKDPC Dpc, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN PKDEFERRED_ROUTINE DeferredRoutine, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN PVOID DeferredContext, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN KOBJECTS Type)</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Dpc-&gt;Type = Type; </span><br><span class="line">    Dpc-&gt;Number = <span class="number">0</span>;<span class="comment">//初始的目标cpu为当前cpu </span></span><br><span class="line">    Dpc-&gt;Importance= MediumImportance; </span><br><span class="line">    Dpc-&gt;DeferredRoutine = DeferredRoutine; </span><br><span class="line">    Dpc-&gt;DeferredContext = DeferredContext; </span><br><span class="line">    Dpc-&gt;DpcData = <span class="literal">NULL</span>;<span class="comment">//表示该DPC尚未挂入任何DPC队列 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化构造时的目标 cpu 默认都是当前 cpu。 </span></span><br><span class="line"><span class="function">DPC BOOLEAN  <span class="title">KeInsertQueueDpc</span><span class="params">(IN PKDPC Dpc,IN PVOID SystemArgument1,IN PVOID SystemArgument2)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    KIRQL OldIrql; </span><br><span class="line">    PKPRCB Prcb, CurrentPrcb; </span><br><span class="line">    ULONG Cpu; </span><br><span class="line">    PKDPC_DATA DpcData; </span><br><span class="line">    BOOLEAN DpcConfigured = FALSE, DpcInserted = FALSE; </span><br><span class="line">    KeRaiseIrql(HIGH_LEVEL, &amp;OldIrql);<span class="comment">//插入过程的中断级是最高的,这个过程不会被打断。 </span></span><br><span class="line">    CurrentPrcb = KeGetCurrentPrcb(); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//检查目标cpu号的第5位为1(32 = 00100000),就表示其它cpu,低4位表示cpu号 </span></span><br><span class="line">    <span class="keyword">if</span> (Dpc-&gt;Number &gt;= <span class="number">32</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        Cpu = Dpc-&gt;Number - <span class="number">32</span>; </span><br><span class="line">        Prcb = KiProcessorBlock[Cpu]; </span><br><span class="line">    &#125; </span><br><span class="line">    Else <span class="comment">//否则,表示当前cpu </span></span><br><span class="line">    &#123; </span><br><span class="line">        Cpu = Prcb-&gt;Number; </span><br><span class="line">        Prcb = CurrentPrcb;<span class="comment">//目标cpu就是当前cpu </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//if 要插入的是一个线程化dpc并且那个cpu启用了线程化dpc机制 </span></span><br><span class="line">    <span class="keyword">if</span> ((Dpc-&gt;Type == ThreadedDpcObject) &amp;&amp; (Prcb-&gt;ThreadDpcEnable)) </span><br><span class="line">        DpcData = &amp;Prcb-&gt;DpcData[DPC_THREADED]; <span class="comment">//目标cpu的线程化dpc队列 </span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        DpcData = &amp;Prcb-&gt;DpcData[DPC_NORMAL];<span class="comment">//目标cpu的普通dpc队列 KiAcquireSpinLock(&amp;DpcData-&gt;DpcLock); </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//if 尚未挂入任何dpc队列 </span></span><br><span class="line">    <span class="keyword">if</span> (!InterlockedCompareExchangePointer(&amp;Dpc-&gt;DpcData, DpcData, <span class="literal">NULL</span>)) </span><br><span class="line">    &#123; </span><br><span class="line">        Dpc-&gt;SystemArgument1 = SystemArgument1; </span><br><span class="line">        Dpc-&gt;SystemArgument2 = SystemArgument2; </span><br><span class="line">        DpcData-&gt;DpcQueueDepth++; </span><br><span class="line">        DpcData-&gt;DpcCount++; </span><br><span class="line">        DpcConfigured = TRUE; </span><br><span class="line">        <span class="comment">//不管如何,先把dpc挂到目标cpu的dpc队列中 </span></span><br><span class="line">        <span class="keyword">if</span> (Dpc-&gt;Importance == HighImportance) </span><br><span class="line">            InsertHeadList(&amp;DpcData-&gt;DpcListHead, &amp;Dpc-&gt;DpcListEntry); </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            InsertTailList(&amp;DpcData-&gt;DpcListHead, &amp;Dpc-&gt;DpcListEntry); </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (&amp;Prcb-&gt;DpcData[DPC_THREADED] == DpcData) </span><br><span class="line">        &#123; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (!(Prcb-&gt;DpcThreadActive) &amp;&amp; !(Prcb-&gt;DpcThreadRequested)) </span><br><span class="line">                线程化DPC,ReactOS目前尚不支持,略 </span><br><span class="line">          </span><br><span class="line">        &#125; </span><br><span class="line">        Else <span class="comment">//若挂入的是一个普通dpc(最常见),检查是否需要立即发出一个dpc软中断给cpu </span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//if 目标cpu当前没在执行dpc,并且它尚未收到dpc中断请求 </span></span><br><span class="line">            <span class="keyword">if</span> (!(Prcb-&gt;DpcRoutineActive) &amp;&amp; !(Prcb-&gt;DpcInterruptRequested)) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> (Prcb != CurrentPrcb)<span class="comment">//if 目标cpu是其它cpu </span></span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="keyword">if</span> (((Dpc-&gt;Importance == HighImportance) || </span><br><span class="line">                        (DpcData-&gt;DpcQueueDepth &gt;= Prcb-&gt;MaximumDpcQueueDepth)) &amp;&amp; </span><br><span class="line">                        (!(AFFINITY_MASK(Cpu) &amp; KiIdleSummary) || (Prcb-&gt;Sleeping))) </span><br><span class="line">                    &#123; </span><br><span class="line">                        Prcb-&gt;DpcInterruptRequested = TRUE;  </span><br><span class="line">                        DpcInserted = TRUE; <span class="comment">//表示需要立即给cpu发出dpc软中断 </span></span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                Else <span class="comment">//if 目标cpu就是自身cpu,最常见 </span></span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="comment">//一般插入的都是中等重要性的dpc,因此,一般会立即发出一个dpc中断。 </span></span><br><span class="line">                    <span class="keyword">if</span> ((Dpc-&gt;Importance != LowImportance) || </span><br><span class="line">                        (DpcData-&gt;DpcQueueDepth &gt;= Prcb-&gt;MaximumDpcQueueDepth) || </span><br><span class="line">                        (Prcb-&gt;DpcRequestRate &lt; Prcb-&gt;MinimumDpcRate)) </span><br><span class="line">                    &#123; </span><br><span class="line">                        Prcb-&gt;DpcInterruptRequested = TRUE;  </span><br><span class="line">                        DpcInserted = TRUE; <span class="comment">//表示需要立即给cpu发出dpc软中断 </span></span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    KiReleaseSpinLock(&amp;DpcData-&gt;DpcLock); </span><br><span class="line">    <span class="keyword">if</span> (DpcInserted)<span class="comment">//if 需要立即发出一个dpc软中断 </span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (Prcb != CurrentPrcb) </span><br><span class="line">            KiIpiSend(AFFINITY_MASK(Cpu), IPI_DPC); </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            HalRequestSoftwareInterrupt(DISPATCH_LEVEL);<span class="comment">//给当前cpu发出一个dpc软中断 </span></span><br><span class="line">    &#125; </span><br><span class="line">    KeLowerIrql(OldIrql);<span class="comment">//降低irql </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> DpcConfigured; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="HalRequestSoftwareInterrupt-1"><a href="#HalRequestSoftwareInterrupt-1" class="headerlink" title="HalRequestSoftwareInterrupt"></a>HalRequestSoftwareInterrupt</h3><p>下面的函数可用于模拟硬件,向 cpu 发出任意<code>irql</code>级别的软中断,请求 cpu 处理执行那种中断。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Irql一般是APC_LEVEL/DPC_LEVEL </span></span><br><span class="line"><span class="function">VOID FASTCALL <span class="title">HalRequestSoftwareInterrupt</span><span class="params">(IN KIRQL Irql)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ULONG EFlags; </span><br><span class="line">    PKPCR Pcr = KeGetPcr(); </span><br><span class="line">    KIRQL PendingIrql; </span><br><span class="line">    EFlags =  readeflags();<span class="comment">//保存老的eflags寄存器 </span></span><br><span class="line">    </span><br><span class="line">    _disable();<span class="comment">//关中断 </span></span><br><span class="line"></span><br><span class="line">    Pcr-&gt;IRR |= (<span class="number">1</span> &lt;&lt; Irql);<span class="comment">//关键。标志向cpu发出了一个对应irql级的软中断 </span></span><br><span class="line">    </span><br><span class="line">    PendingIrql = SWInterruptLookUpTable[Pcr-&gt;IRR &amp; <span class="number">3</span>];<span class="comment">//IRR后两位表示是否有阻塞的apc中断 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若有阻塞的apc中断,并且当前irql是PASSIVE_LEVEL,立即执行apc。</span></span><br><span class="line">    <span class="comment">//也即在PASSIVE_LEVEL级时发出 任意软中断后,会立即检查执行现有的apc中断。 </span></span><br><span class="line">    <span class="keyword">if</span> (PendingIrql &gt; Pcr-&gt;Irql) </span><br><span class="line">      SWInterruptHandlerTable[PendingIrql]();<span class="comment">//调用执行apc中断的isr,处理apc中断 </span></span><br><span class="line">      writeeflags(EFlags);<span class="comment">//恢复原eflags寄存器 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DPC-函数的执行时机"><a href="#DPC-函数的执行时机" class="headerlink" title="DPC 函数的执行时机"></a>DPC 函数的执行时机</h2><h3 id="KfLowerIrql"><a href="#KfLowerIrql" class="headerlink" title="KfLowerIrql"></a>KfLowerIrql</h3><p>windows内核什么时候会扫描DPC请求队列,执行这些DPC函数呢？<br>答案是每当CPU的运行级别从<code>DISPATCH_LEVEL</code>或以上降低到<code>DISPATCH_LEVEL</code>以下时,如果有扫描DPC请求队列的要求存在,内核就会扫描DPC请求队列并执行DPC函数(如果队列非空的话)。</p>
<p>为此不妨从<code>KfLowerIrql</code>开始往下看。</p>
<p><code>[KfLowerIrql() &gt; HalpLowerIrql() &gt; KiDispatchInterrupt() &gt; KiRetireDpcList()]</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">KfLowerIrql</span><span class="params">(IN KIRQL OldIrql)</span><span class="comment">//降回到原irql </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ULONG EFlags; </span><br><span class="line">    ULONG PendingIrql, PendingIrqlMask; </span><br><span class="line">    PKPCR Pcr = KeGetPcr(); </span><br><span class="line">    PIC_MASK Mask; </span><br><span class="line">    EFlags =  readeflags();<span class="comment">//保存老的eflags寄存器 </span></span><br><span class="line">    _disable();<span class="comment">//关中断 </span></span><br><span class="line">    Pcr-&gt;Irql = OldIrql;<span class="comment">//降低到指定irql </span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//检查是否有在目标irql以上的阻塞中的软中断 </span></span><br><span class="line">    PendingIrqlMask = Pcr-&gt;IRR &amp; FindHigherIrqlMask[OldIrql]; </span><br><span class="line">    <span class="keyword">if</span> (PendingIrqlMask) </span><br><span class="line">    &#123;    </span><br><span class="line">    <span class="comment">//从高位到低位扫描,找到阻塞中的最高irql级的软中断 </span></span><br><span class="line"> </span><br><span class="line">        BitScanReverse(&amp;PendingIrql, PendingIrqlMask);  </span><br><span class="line">        <span class="keyword">if</span> (PendingIrql &gt; DISPATCH_LEVEL) … </span><br><span class="line">            SWInterruptHandlerTable[PendingIrql]();<span class="comment">//处理那个软中断,似乎这儿有问题,应该是 </span></span><br><span class="line">            SWInterruptHandlerTable[<span class="number">31</span>-PendingIrql](); </span><br><span class="line">    &#125; </span><br><span class="line">    writeeflags(EFlags);<span class="comment">//恢复原eflags寄存器 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">BitScanReverse</span><span class="params">(ULONG * <span class="keyword">const</span> Index, <span class="keyword">unsigned</span> <span class="keyword">long</span> Mask)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    *Index = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (Mask &amp;&amp; ((Mask &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)) == <span class="number">0</span>)) </span><br><span class="line">    &#123; </span><br><span class="line">        Mask &lt;&lt;= <span class="number">1</span>; </span><br><span class="line">        ++(*Index); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> Mask ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">各个软中断的处理函数如下(怀疑这个表的布局有问题) </span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">PHAL_SW_INTERRUPT_HANDLER SWInterruptHandlerTable[<span class="number">20</span>] = </span><br><span class="line">&#123; </span><br><span class="line">    KiUnexpectedInterrupt,<span class="comment">//PASSIVE_LEVEL最低了,永远不会中断别的irql </span></span><br><span class="line">    HalpApcInterrupt,<span class="comment">//APC中断的isr </span></span><br><span class="line">    HalpDispatchInterrupt2,<span class="comment">//DPC中断的isr </span></span><br><span class="line">    KiUnexpectedInterrupt, </span><br><span class="line">    HalpHardwareInterrupt0, </span><br><span class="line">    HalpHardwareInterrupt1, </span><br><span class="line">    HalpHardwareInterrupt2, </span><br><span class="line">    HalpHardwareInterrupt3, </span><br><span class="line">    HalpHardwareInterrupt4, </span><br><span class="line">    HalpHardwareInterrupt5, </span><br><span class="line">    HalpHardwareInterrupt6, </span><br><span class="line">    HalpHardwareInterrupt7, </span><br><span class="line">    HalpHardwareInterrupt8, </span><br><span class="line">    HalpHardwareInterrupt9, </span><br><span class="line">    HalpHardwareInterrupt10, </span><br><span class="line">    HalpHardwareInterrupt11, </span><br><span class="line">    HalpHardwareInterrupt12, </span><br><span class="line">    HalpHardwareInterrupt13, </span><br><span class="line">    HalpHardwareInterrupt14, </span><br><span class="line">    HalpHardwareInterrupt15 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是处理 DPC 软中断的 isr </p>
<h3 id="HalpDispatchInterrupt2"><a href="#HalpDispatchInterrupt2" class="headerlink" title="HalpDispatchInterrupt2"></a>HalpDispatchInterrupt2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">HalpDispatchInterrupt2</span><span class="params">(VOID)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ULONG PendingIrqlMask, PendingIrql; </span><br><span class="line">    KIRQL OldIrql; </span><br><span class="line">    PIC_MASK Mask; </span><br><span class="line">    PKPCR Pcr = KeGetPcr(); </span><br><span class="line">    <span class="comment">//这个函数里面会提高irql到DISPACH_LEVEL去扫描执行dpc队列中的所有dpc </span></span><br><span class="line">    OldIrql = _HalpDispatchInterruptHandler();<span class="comment">//关键函数 Pcr-&gt;Irql = OldIrql;//恢复成原来的irql </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再去检测是否仍有更高irql的阻塞软中断 </span></span><br><span class="line">    PendingIrqlMask = Pcr-&gt;IRR &amp; FindHigherIrqlMask[OldIrql]; </span><br><span class="line">    <span class="keyword">if</span> (PendingIrqlMask) </span><br><span class="line">    &#123; </span><br><span class="line">        BitScanReverse(&amp;PendingIrql, PendingIrqlMask); </span><br><span class="line">        <span class="keyword">if</span> (PendingIrql &gt; DISPATCH_LEVEL) … </span><br><span class="line">            SWInterruptHandlerTable[PendingIrql]();<span class="comment">//应该是[31 - PendingIrql] </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">KIRQL _HalpDispatchInterruptHandler(VOID) </span><br><span class="line">&#123; </span><br><span class="line">    KIRQL CurrentIrql; </span><br><span class="line">    PKPCR Pcr = KeGetPcr(); </span><br><span class="line">    CurrentIrql = Pcr-&gt;Irql; </span><br><span class="line">    Pcr-&gt;Irql = DISPATCH_LEVEL;<span class="comment">//将irql临时提高到DISPATCH_LEVEL </span></span><br><span class="line">    Pcr-&gt;IRR &amp;= ~(<span class="number">1</span> &lt;&lt; DISPATCH_LEVEL);<span class="comment">//清除对应的软中断位 </span></span><br><span class="line">    _enable();<span class="comment">//开中断 </span></span><br><span class="line">    KiDispatchInterrupt();<span class="comment">//关键函数。开中断后扫描执行所有dpc </span></span><br><span class="line">    _disable(); </span><br><span class="line">    <span class="keyword">return</span> CurrentIrql;<span class="comment">//返回原irql </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KiDispatchInterrupt"><a href="#KiDispatchInterrupt" class="headerlink" title="KiDispatchInterrupt"></a>KiDispatchInterrupt</h3><p>下面的函数扫描当前 cpu 的 dpc 队列执行所有 </p>
<p>此函数在执行 dpc 前会先将内核栈切换为 dpc 函数专用栈。<br>因为 dpc 函数运行在任意线程的上下文中, 而 dpc 函数可能太大,局部变量太多而占用了过多的内核栈<br>所以需要为 dpc 函数的执行专门配备一个栈。 </p>
<p>这个函数还有一个注意地方,就是在扫描 dpc 队列执行完所有 dpc 函数后,会检查当前线程的时间片是否 耗尽,若耗尽就进行线程切换,若尚未耗尽,就检查当前是否有一个抢占者线程,若有也进行线程切换。<br>【总之: 系统在每次扫描执行完 dpc 队列后,都会尝试进行线程切换】 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">dpc KiDispatchInterrupt </span><br><span class="line">&#123; </span><br><span class="line">    push ebx </span><br><span class="line">    mov ebx, PCR[KPCR_SELF]  <span class="comment">//ebc = kpcr* </span></span><br><span class="line">    cli <span class="comment">//关中断 </span></span><br><span class="line">    <span class="comment">//检查dpc队列是否为空 </span></span><br><span class="line">    mov eax, [ebx+KPCR_PRCB_DPC_QUEUE_DEPTH] </span><br><span class="line">    <span class="keyword">or</span> eax, [ebx+KPCR_PRCB_TIMER_REQUEST] </span><br><span class="line">    <span class="keyword">or</span> eax, [ebx+KPCR_PRCB_DEFERRED_READY_LIST_HEAD] </span><br><span class="line">    jz CheckQuantum </span><br><span class="line"> </span><br><span class="line">    push ebp <span class="comment">//保存 </span></span><br><span class="line">    push dword ptr [ebx+KPCR_EXCEPTION_LIST] <span class="comment">//保存原seh </span></span><br><span class="line">    mov dword ptr [ebx+KPCR_EXCEPTION_LIST], <span class="number">-1</span> <span class="comment">//将当前色seh置空 </span></span><br><span class="line">    <span class="comment">/* Save the stack and switch to the DPC Stack */</span> </span><br><span class="line">    mov edx, esp </span><br><span class="line">    mov esp, [ebx+KPCR_PRCB_DPC_STACK] <span class="comment">//切换为DPC函数专用的内核栈 </span></span><br><span class="line">    push edx <span class="comment">//保存原来的内核栈顶位置 </span></span><br><span class="line"> </span><br><span class="line">    mov ecx, [ebx+KPCR_PRCB] </span><br><span class="line">    call @KiRetireDpcList@<span class="number">4</span>     <span class="comment">//关键。扫描执行dpc </span></span><br><span class="line">    pop esp <span class="comment">//恢复成原来的内核栈顶 </span></span><br><span class="line">    pop dword ptr [ebx+KPCR_EXCEPTION_LIST] <span class="comment">//恢复 </span></span><br><span class="line">    pop ebp <span class="comment">//恢复 </span></span><br><span class="line">  CheckQuantum: </span><br><span class="line">    Sti <span class="comment">//开中断 </span></span><br><span class="line">    cmp byte ptr [ebx+KPCR_PRCB_QUANTUM_END], <span class="number">0</span> <span class="comment">//现在回头检查当前线程的时间片是否耗尽 </span></span><br><span class="line">    jnz QuantumEnd <span class="comment">//若已耗尽,直接跳到QuantumEnd处执行线程切换 </span></span><br><span class="line">    cmp byte ptr [ebx+KPCR_PRCB_NEXT_THREAD], <span class="number">0</span> <span class="comment">//再检查当前是否有一个抢占者线程 </span></span><br><span class="line">    je Return </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Make space on the stack to save registers */</span> </span><br><span class="line">    sub esp, <span class="number">3</span> * <span class="number">4</span> </span><br><span class="line">    mov [esp+<span class="number">8</span>], esi <span class="comment">//保存 </span></span><br><span class="line">    mov [esp+<span class="number">4</span>], edi <span class="comment">//保存 </span></span><br><span class="line">    mov [esp+<span class="number">0</span>], ebp <span class="comment">//保存 </span></span><br><span class="line">    mov edi, [ebx+KPCR_CURRENT_THREAD] </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP <span class="comment">//if多处理器 </span></span></span><br><span class="line">    call _KeRaiseIrqlToSynchLevel@<span class="number">0</span> <span class="comment">//提升irql到SynchLevel </span></span><br><span class="line">    mov byte ptr [edi+KTHREAD_SWAP_BUSY], <span class="number">1</span> <span class="comment">//标记该线程正在进行切换 </span></span><br><span class="line">    <span class="comment">/* Acquire the PRCB Lock */</span> </span><br><span class="line">    lock bts dword ptr [ebx+KPCR_PRCB_PRCB_LOCK], <span class="number">0</span> </span><br><span class="line">    jnb GetNext </span><br><span class="line">    lea ecx, [ebx+KPCR_PRCB_PRCB_LOCK] </span><br><span class="line">    call @KefAcquireSpinLockAtDpcLevel@<span class="number">4</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">  GetNext: </span><br><span class="line">    mov esi, [ebx+KPCR_PRCB_NEXT_THREAD] </span><br><span class="line">    <span class="keyword">and</span> dword ptr [ebx+KPCR_PRCB_NEXT_THREAD], <span class="number">0</span> </span><br><span class="line">    mov [ebx+KPCR_CURRENT_THREAD], esi </span><br><span class="line">    mov byte ptr [esi+KTHREAD_STATE_], Running </span><br><span class="line">    mov byte ptr [edi+KTHREAD_WAIT_REASON], WrDispatchInt </span><br><span class="line"> </span><br><span class="line">    mov ecx, edi </span><br><span class="line">    lea edx, [ebx+KPCR_PRCB_DATA] </span><br><span class="line">    call @KiQueueReadyThread@<span class="number">8</span> </span><br><span class="line">    mov cl, APC_LEVEL </span><br><span class="line">    call @KiSwapContextInternal@<span class="number">0</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP </span></span><br><span class="line">    mov cl, DISPATCH_LEVEL </span><br><span class="line">    call @KfLowerIrql@<span class="number">4</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">    mov ebp, [esp+<span class="number">0</span>] <span class="comment">//恢复 </span></span><br><span class="line">    mov edi, [esp+<span class="number">4</span>] <span class="comment">//恢复 </span></span><br><span class="line">    mov esi, [esp+<span class="number">8</span>] <span class="comment">//恢复 </span></span><br><span class="line">    add esp, <span class="number">3</span>*<span class="number">4</span> Return: </span><br><span class="line">    pop ebx </span><br><span class="line">    ret QuantumEnd: </span><br><span class="line">    mov byte ptr [ebx+KPCR_PRCB_QUANTUM_END], <span class="number">0</span> </span><br><span class="line">    call _KiQuantumEnd@<span class="number">0</span> <span class="comment">//调用这个函数切换线程 </span></span><br><span class="line">    pop ebx </span><br><span class="line">    ret </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KiRetireDpcList"><a href="#KiRetireDpcList" class="headerlink" title="KiRetireDpcList"></a>KiRetireDpcList</h3><p>下面的函数才是最终扫描执行 dpc 的 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">KiRetireDpcList</span><span class="params">(IN PKPRCB Prcb)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PKDPC_DATA DpcData; </span><br><span class="line">    PLIST_ENTRY ListHead, DpcEntry; </span><br><span class="line">    PKDPC Dpc; </span><br><span class="line">    PKDEFERRED_ROUTINE DeferredRoutine; </span><br><span class="line">    PVOID DeferredContext, SystemArgument1, SystemArgument2; </span><br><span class="line">    ULONG_PTR TimerHand; </span><br><span class="line">    DpcData = &amp;Prcb-&gt;DpcData[DPC_NORMAL];<span class="comment">//当前cpu的普通dpc队列 </span></span><br><span class="line">    ListHead = &amp;DpcData-&gt;DpcListHead; </span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123; </span><br><span class="line"> </span><br><span class="line">        Prcb-&gt;DpcRoutineActive = TRUE;<span class="comment">//标记当前cpu正在执行dpc </span></span><br><span class="line">        <span class="keyword">if</span> (Prcb-&gt;TimerRequest) <span class="comment">//if收到有定时器到期dpc中断(定时器是一种特殊的dpc) </span></span><br><span class="line">        &#123; </span><br><span class="line">            TimerHand = Prcb-&gt;TimerHand; </span><br><span class="line">            Prcb-&gt;TimerRequest = <span class="number">0</span>; </span><br><span class="line">            _enable(); </span><br><span class="line">            KiTimerExpiration(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (PVOID)TimerHand, <span class="literal">NULL</span>);<span class="comment">//处理定时器队列 </span></span><br><span class="line">            _disable(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span> (DpcData-&gt;DpcQueueDepth != <span class="number">0</span>)<span class="comment">//遍历dpc队列 </span></span><br><span class="line">        &#123; </span><br><span class="line">            KeAcquireSpinLockAtDpcLevel(&amp;DpcData-&gt;DpcLock); </span><br><span class="line">            DpcEntry = ListHead-&gt;Flink; </span><br><span class="line">            <span class="keyword">if</span> (DpcEntry != ListHead) </span><br><span class="line">            &#123; </span><br><span class="line">                RemoveEntryList(DpcEntry);<span class="comment">//取下来 </span></span><br><span class="line">                Dpc = CONTAINING_RECORD(DpcEntry, KDPC, DpcListEntry); </span><br><span class="line">                Dpc-&gt;DpcData = <span class="literal">NULL</span>; </span><br><span class="line">                DeferredRoutine = Dpc-&gt;DeferredRoutine; </span><br><span class="line">                DeferredContext = Dpc-&gt;DeferredContext; </span><br><span class="line">                SystemArgument1 = Dpc-&gt;SystemArgument1; </span><br><span class="line">                SystemArgument2 = Dpc-&gt;SystemArgument2; </span><br><span class="line">                DpcData-&gt;DpcQueueDepth--; </span><br><span class="line">                Prcb-&gt;DebugDpcTime = <span class="number">0</span>; </span><br><span class="line">                KeReleaseSpinLockFromDpcLevel(&amp;DpcData-&gt;DpcLock); </span><br><span class="line">                _enable();<span class="comment">//开中断 </span></span><br><span class="line">                <span class="comment">//关键。执行DPC例程 </span></span><br><span class="line">                DeferredRoutine(Dpc,DeferredContext,SystemArgument1,SystemArgument2); </span><br><span class="line">                ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL); </span><br><span class="line">                _disable();<span class="comment">//关中断 </span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123; </span><br><span class="line">                ASSERT(DpcData-&gt;DpcQueueDepth == <span class="number">0</span>);<span class="comment">//肯定执行完了所有dpc </span></span><br><span class="line">                KeReleaseSpinLockFromDpcLevel(&amp;DpcData-&gt;DpcLock); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        Prcb-&gt;DpcRoutineActive = FALSE;<span class="comment">//当前不再用dpc正在执行 </span></span><br><span class="line">        Prcb-&gt;DpcInterruptRequested = FALSE; </span><br><span class="line">    &#125; <span class="keyword">while</span> (DpcData-&gt;DpcQueueDepth != <span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：DPC 函数运行在<code>DISPATCH_LEVEL</code>,并且开中断,因此 dpc 函数本身又可能被其他中断给中断。<br>因为 dpc 函数本身就是一种软中断,因此它支持中断嵌套。 </p>
<p>【总之：在降低过程中检查是否有 dpc 中断,若有执行之】</p>
<blockquote>
<p>一句口诀：【降低、检断、DPC】 不像 APC 的执行时机有很多,DPC 的执行时机就一处。 </p>
</blockquote>
<p>那么在什么时候系统会降低 irql 呢？<br>除了用户显式调用这个内核函数外, isr 一般工作在比<code>DISPATCH_LEVEL</code>高的 irql,当 isr 退出时,必然会降低 irql 到原来的 irql。<br>因此常常在 isr 中插入一 个 dpc 到 dpc 队列,发出一个 dpc 中断给 cpu,然后退出 isr 时,降低 irql,顺理成章的执行 dpc。 </p>
<p><br></p>
<h2 id="DPC切目标CPU"><a href="#DPC切目标CPU" class="headerlink" title="DPC切目标CPU"></a>DPC切目标CPU</h2><h3 id="KeSetTargetProcessorDpc"><a href="#KeSetTargetProcessorDpc" class="headerlink" title="KeSetTargetProcessorDpc"></a>KeSetTargetProcessorDpc</h3><p><code>KeInitializeDpc</code> 初始化的 dpc,默认的目标 cpu 都是当前 cpu,如果需要将 dpc 发给其他 cpu,让其在其他 cpu 上运行的话</p>
<p>可以采用下面的函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KeSetTargetProcessorDpc</span><span class="params">(IN PKDPC Dpc,IN CCHAR Number)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Dpc-&gt;Number = Number + <span class="number">32</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个非常有用的函数,因为他可以使你的代码运行在你想要的 cpu 上。比如,你写了一个函数,你只想那个函数运行在 3 号 cpu 上,那么你可以构造一个在 3 号 cpu 上运行的 dpc,然后在 dpc 里调用你自己的函数。<br>这种技术常用于保障内联 hook 的多 cpu 线程安全 和 IDT hook。 </p>
<p>当然也可使用<code>KeSetSystemAffinityThread</code>这个内核函数,修改当前线程的 cpu 亲缘性为<code>只能运行在目标 cpu</code>上,这样也会立即导致当前线程立刻挪到其它 cpu 上去运行,<code>KeSetSystemAffinityThread</code>的代码,有兴趣的读者自己看。 </p>
<p><br></p>
<h2 id="系统工作者线程"><a href="#系统工作者线程" class="headerlink" title="系统工作者线程"></a>系统工作者线程</h2><p>本篇既然谈到了 DPC,那就要讲下与之紧密相关的另一个话题：<code>系统工作者线程</code>。 </p>
<p>DPC 函数是运行在<code>DISPATCH_LEVEL</code>的,而内核中的绝大多数函数的运行时 irql 都不能处在这个中断级别<br>如<code>ZwCreateFie</code>ddk文档规定了,这个内核函数必须运行在<code>PASSIVE_LEVEL</code></p>
<p>如果我们需要在某个 DPC 函 数中调用<code>ZwCreateFie</code>,怎么办呢？<br>一个办法便是将这个工作打包成一条工作项委派给<code>系统工作者线程</code>去执行。<br>内核中有一个守护线程(其实分成 9 个线程),运行在<code>PASSIVE_LEVEL</code>,专门用来提供服务执行别的线 程委派给它的工作,这个守护线程就是<code>系统工作者线程</code>。 </p>
<p>按照工作项的紧迫程度,分成三种。系统中相应的有三种工作项队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _WORK_QUEUE_TYPE &#123; </span><br><span class="line">  CriticalWorkQueue,<span class="comment">//较紧迫 </span></span><br><span class="line">  DelayedWorkQueue,<span class="comment">//最常见 </span></span><br><span class="line">  HyperCriticalWorkQueue,<span class="comment">//最紧迫 </span></span><br><span class="line">&#125; WORK_QUEUE_TYPE;</span><br></pre></td></tr></table></figure>
<p><code>CriticalWorkQueue</code>工作项队列上配有 5 个服务线程,<code>DelayedWorkQueue</code>队列上配有 3 个服务线程,<code>HyperCriticalWorkQueue</code>上配有 1 个服务线程。 </p>
<h3 id="ExInitializeWorkItem"><a href="#ExInitializeWorkItem" class="headerlink" title="ExInitializeWorkItem"></a>ExInitializeWorkItem</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ExInitializeWorkItem(Item,Routine,Context) \ </span></span><br><span class="line">&#123; \ </span><br><span class="line">   Item-&gt;WorkRoutine=Routine;\ </span><br><span class="line">   Item-&gt;Parameter=Context;\ </span><br><span class="line">   Item-&gt;List.Flink=<span class="literal">NULL</span>;\ </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ExQueueWorkItem"><a href="#ExQueueWorkItem" class="headerlink" title="ExQueueWorkItem"></a>ExQueueWorkItem</h3><p>构造好一条工作项后,就可以把这条工作项挂入指定紧迫程度的系统工作项队列中。    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ExQueueWorkItem</span><span class="params">(IN PWORK_QUEUE_ITEM WorkItem, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN WORK_QUEUE_TYPE QueueType)</span><span class="comment">//工作项紧迫程度类型 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PEX_WORK_QUEUE WorkQueue = &amp;ExWorkerQueue[QueueType];<span class="comment">//相应的工作项队列 </span></span><br><span class="line">    <span class="keyword">if</span> ((ULONG_PTR)WorkItem-&gt;WorkerRoutine &lt; MmUserProbeAddress)<span class="comment">//必须位于内核空间 </span></span><br><span class="line">    &#123; </span><br><span class="line">        KeBugCheckEx(WORKER_INVALID,<span class="number">1</span>, (ULONG_PTR)WorkItem, </span><br><span class="line">                     (ULONG_PTR)WorkItem-&gt;WorkerRoutine,<span class="number">0</span>); </span><br><span class="line">	&#125; </span><br><span class="line"> </span><br><span class="line">	KeInsertQueue(&amp;WorkQueue-&gt;WorkerQueue, &amp;WorkItem-&gt;List);<span class="comment">//关键。 </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((WorkQueue-&gt;Info.MakeThreadsAsNecessary) &amp;&amp; </span><br><span class="line">        (!IsListEmpty(&amp;WorkQueue-&gt;WorkerQueue.EntryListHead)) &amp;&amp; </span><br><span class="line">        (WorkQueue-&gt;WorkerQueue.CurrentCount &lt; WorkQueue-&gt;WorkerQueue.MaximumCount) &amp;&amp; </span><br><span class="line">        (WorkQueue-&gt;DynamicThreadCount &lt; <span class="number">16</span>)) </span><br><span class="line">    &#123; </span><br><span class="line">        KeSetEvent(&amp;ExpThreadSetManagerEvent, <span class="number">0</span>, FALSE); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当把工作项插入到系统对应的工作项队列后,系统中的某个服务线程便会在某一时刻处理该工作项。<br>9个服务线程的函数都是同一个函数,只是参数不同。我们看:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ExpWorkerThreadEntryPoint</span><span class="params">(IN PVOID Context)</span><span class="comment">//context参数主要表示工作项队列类型 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PLARGE_INTEGER TimeoutPointer = <span class="literal">NULL</span>; </span><br><span class="line">    PETHREAD Thread = PsGetCurrentThread(); </span><br><span class="line">    <span class="keyword">if</span> ((ULONG_PTR)Context &amp; EX_DYNAMIC_WORK_THREAD) </span><br><span class="line">    &#123; </span><br><span class="line"> </span><br><span class="line">        Timeout.QuadPart = Int32x32To64(<span class="number">10</span>, <span class="number">-10000000</span> * <span class="number">60</span>);<span class="comment">//1分钟 </span></span><br><span class="line">        TimeoutPointer = &amp;Timeout; </span><br><span class="line">    &#125; </span><br><span class="line">    WorkQueueType = (WORK_QUEUE_TYPE)((ULONG_PTR)Context &amp;~ EX_DYNAMIC_WORK_THREAD); </span><br><span class="line">    WorkQueue = &amp;ExWorkerQueue[WorkQueueType]; </span><br><span class="line">    WaitMode = (UCHAR)WorkQueue-&gt;Info.WaitMode; </span><br><span class="line">    ASSERT(Thread-&gt;ExWorkerCanWaitUser == FALSE); </span><br><span class="line">    <span class="keyword">if</span> (WaitMode == UserMode) Thread-&gt;ExWorkerCanWaitUser = TRUE; </span><br><span class="line">    <span class="keyword">if</span> (!ExpWorkersCanSwap) KeSetKernelStackSwapEnable(FALSE); </span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (WorkQueue-&gt;Info.QueueDisabled) </span><br><span class="line">        &#123; </span><br><span class="line">            KeSetKernelStackSwapEnable(TRUE); </span><br><span class="line">            PsTerminateSystemThread(STATUS_SYSTEM_SHUTDOWN);<span class="comment">//立即终止 </span></span><br><span class="line">        &#125; </span><br><span class="line">        OldValue = WorkQueue-&gt;Info; </span><br><span class="line">        NewValue = OldValue; </span><br><span class="line">        NewValue.WorkerCount++;<span class="comment">//递增该队列上的工作线程计数 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">while</span> (InterlockedCompareExchange((PLONG)&amp;WorkQueue-&gt;Info,*(PLONG)&amp;NewValue, </span><br><span class="line">                                      *(PLONG)&amp;OldValue) != *(PLONG)&amp;OldValue); </span><br><span class="line">    Thread-&gt;ActiveExWorker = TRUE;<span class="comment">//标记正式成为一个工作者线程了 ProcessLoop: </span></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123; </span><br><span class="line">    <span class="comment">//等待本服务线程的工作项队列中出现工作项,然后取下来 </span></span><br><span class="line">        QueueEntry = KeRemoveQueue(&amp;WorkQueue-&gt;WorkerQueue,WaitMode,TimeoutPointer); </span><br><span class="line">        <span class="keyword">if</span> ((NTSTATUS)(ULONG_PTR)QueueEntry == STATUS_TIMEOUT) </span><br><span class="line">             <span class="keyword">break</span>;<span class="comment">//等待超时就退出for循环 </span></span><br><span class="line">        </span><br><span class="line">        InterlockedIncrement((PLONG)&amp;WorkQueue-&gt;WorkItemsProcessed);<span class="comment">//递增已处理计数 </span></span><br><span class="line">        WorkItem = CONTAINING_RECORD(QueueEntry, WORK_QUEUE_ITEM, List); </span><br><span class="line"> </span><br><span class="line">        WorkItem-&gt;WorkerRoutine(WorkItem-&gt;Parameter);<span class="comment">//关键。调用执行工作项 </span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (Thread-&gt;Tcb.SpecialApcDisable)  Thread-&gt;Tcb.SpecialApcDisable = FALSE; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//我们的工作项函数运行在PASSIVE_LEVEL,内部不要修改irql,否则蓝屏 </span></span><br><span class="line">        <span class="keyword">if</span> (KeGetCurrentIrql() != PASSIVE_LEVEL) </span><br><span class="line">        &#123; </span><br><span class="line">            KeBugCheckEx(WORKER_THREAD_RETURNED_AT_BAD_IRQL, </span><br><span class="line">                         (ULONG_PTR)WorkItem-&gt;WorkerRoutine,KeGetCurrentIrql(), </span><br><span class="line">                         (ULONG_PTR)WorkItem-&gt;Parameter, (ULONG_PTR)WorkItem); </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (Thread-&gt;ActiveImpersonationInfo)<span class="comment">//工作项函数内部不能冒用令牌 </span></span><br><span class="line">        &#123; </span><br><span class="line">            KeBugCheckEx(IMPERSONATING_WORKER_THREAD, (ULONG_PTR)WorkItem-&gt;WorkerRoutine, </span><br><span class="line">                         (ULONG_PTR)WorkItem-&gt;Parameter, (ULONG_PTR)WorkItem,<span class="number">0</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!IsListEmpty(&amp;Thread-&gt;IrpList)) <span class="keyword">goto</span> ProcessLoop; <span class="comment">//继续服务 </span></span><br><span class="line">    <span class="keyword">if</span> (WorkQueue-&gt;Info.QueueDisabled) <span class="keyword">goto</span> ProcessLoop;  <span class="comment">//继续服务 </span></span><br><span class="line">    <span class="comment">//下面退出服务线程 </span></span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123; </span><br><span class="line">        OldValue = WorkQueue-&gt;Info; </span><br><span class="line">        NewValue = OldValue; </span><br><span class="line">        NewValue.WorkerCount--;<span class="comment">//递减该队列上的服务线程计数 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">while</span> (InterlockedCompareExchange((PLONG)&amp;WorkQueue-&gt;Info,*(PLONG)&amp;NewValue, </span><br><span class="line">                                      *(PLONG)&amp;OldValue) != *(PLONG)&amp;OldValue); </span><br><span class="line">    InterlockedDecrement(&amp;WorkQueue-&gt;DynamicThreadCount); </span><br><span class="line">    Thread-&gt;ActiveExWorker = FALSE; </span><br><span class="line">    KeSetKernelStackSwapEnable(TRUE); </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码想必不用过多解释了 </p>
<p><br><br><br></p>
<h1 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h1><p>每个 cpu 有一张中断表,简称<code>IDT</code>。 </p>
<blockquote>
<p>IDT的整体布局：【异常-&gt;空白-&gt;5 系-&gt;硬】(推荐采用 7 字口诀的方式重点记忆) </p>
</blockquote>
<ul>
<li>异常：前 20 个表项存放着各个异常的描述符(IDT 表不仅可以放中断描述符,还放置了所有异常的异常处理描述符0x00-0x13) </li>
<li>保留：0x14-0x1F,忽略这块号段 </li>
<li>空白：接下来存放一组空闲的保留项(0x20-0x29),供系统和程序员自己分配注册使用 </li>
<li>5 系：然后是系统自己注册的 5 个预定义的软中断向量(软中断指手动的 INT 指令) <blockquote>
<p>0x2A-0x2E 5 个系统预注册的中断向量</p>
<ul>
<li>0x2A:KiGetTickCount,</li>
<li>0x2B:KiCallbaclReturn </li>
<li>0x2C:KiRaiseAssertion</li>
<li>0x2D:KiDebugService</li>
<li>0x2E:KiSystemService </li>
</ul>
</blockquote>
</li>
<li>硬:最后的表项供驱动程序注册硬件中断使用和自定义注册其他软中断使用(0x30-0xFF) </li>
</ul>
<p>下面是中断号的具体的分配情况: </p>
<ul>
<li>0x00-0x13 固定分配给异常:</li>
<li>0x14-0x1f：Intel 保留给他公司将来自己使用(OS 和用户都不要试图去使用这个号段,不安全)</li>
</ul>
<p>———————-以下的号段可用于自由分配给 OS、硬件、用户使用———————–   </p>
<p>linux 等其他系统是怎么划分这块号段的,不管我们只看 Windows 的情况 </p>
<ul>
<li>0x20-0x29:Windows 没占用,因此这块号段我们也可以自由使用 </li>
<li>0x2A-0x2E:Windows 自己本身使用的 5 个中断号 </li>
<li>0x30-0xFF:Windows 决定把这块剩余的号段让给硬件和用户使用 </li>
</ul>
<p>参见《寒江独钓》一书 P93 页注册键盘中断时,搜索空闲未用表项是从<code>0x20</code>开始,到<code>0x29</code>结束的;<br>就知道为什么寒江独钓是在这段范围内搜索空白表项了(其实我们也完全可以从 0x14 开始搜索) </p>
<p>Windows 系统中,<code>0x30-0xFF</code>这块号段让给了硬件和用户自己使用。事实上这块号段的开头部分默认都是让给硬件<code>IRQ</code>使用的,也即是分配给硬件<code>IRQ</code>的。<br><code>IRQ N</code>默认映射到中断号<code>0x30+N</code><br>如<code>IRQ0</code>用于系统时钟,系统时钟中断号默认对应就是<code>0x30</code>。<br>当然程序员也可以修改<code>APIC(可编程中断控制器)</code>将<code>IRQ</code>映射到自定义的中断号。 </p>
<p>IRQ 对外部设备分配,但 IRQ0,IRQ2,IRQ13 必须如下分配:  </p>
<ul>
<li>IRQ0 —-&gt;间隔定时设备   </li>
<li>IRQ2 —-&gt;8259A 芯片 </li>
<li>IRQ13 —-&gt;外部数学协处理器     </li>
<li>其余的 IRQ 可以任意分配给外部设备。   </li>
</ul>
<p>虽然一个 IRQ 只对应一个中断号,但是由于 IRQ 数量有限,而设备种类成千上万,因此多个设备可以使用同一个 IRQ,进而多个设备可以分配同一个中断号。<br>因此一个中断号可以共享给多个设备同时使用。 </p>
<p><br></p>
<h2 id="IoConnectInterrupt"><a href="#IoConnectInterrupt" class="headerlink" title="IoConnectInterrupt"></a>IoConnectInterrupt</h2><p><code>Pnp</code>设备在插入系统后,相应的总线驱动会自动为其创建一个用作栈底基石的<code>pdo</code>,然后给这个<code>pdo</code>发出一个<code>IRP_MN_QUERY_RESOURCE_REQUIREMENTS</code>查询得到初步的资源需求。<br>然后<code>pnp</code>管理器会找到相应的硬件端口驱动,调用其<code>AddDevice</code>函数,当这个函数返回后该硬件设备的设备栈已经建立起立了</p>
<p><code>pnp</code>管理器就给栈顶设备发出一个<code>IRP_MN_FILTER_RESOURCE_REQUIREMENTS</code>再次询问该硬件需要的资源(功能驱动此时可以拦截处理这个 irp,修改资源需求)<br>当确定好最终的资源需求后,系统就协调分配端口号、 中断号、DIRQL等硬件资源给它。分配完后就发出一个<code>IRP_MN_START_DEVICE</code>给栈顶设备请求启动该硬件设备。<br>当该 irp 下发来到端口驱动(指真正的硬件驱动)时, 端口驱动这时就需要在分配的中断号上注册一个中断服务例程,以处理硬件中断,与设备进行交互。</p>
<p>下面的函数就是用来注册中断服务例程的(准确的说法叫<code>挂接中断</code>) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoConnectInterrupt</span><span class="params">(OUT PKINTERRUPT *InterruptObject,<span class="comment">//返回创建的中断对象(一般是一个数组) </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   IN PKSERVICE_ROUTINE ServiceRoutine,<span class="comment">//我们的isr(our isr) </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   IN PVOID ServiceContext,<span class="comment">//isr的参数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   IN PKSPIN_LOCK SpinLock,<span class="comment">//我们isr的自旋锁,用于多cpu互斥(一般传NULL即可) </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   IN ULONG Vector,<span class="comment">//分配到的中断号 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   IN KIRQL Irql,<span class="comment">//isr对应的irql </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   IN KIRQL SynchronizeIrql,<span class="comment">//必须&gt;=Irql,一般=Irql即可(isr实际运行在这个irql) </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   IN KINTERRUPT_MODE InterruptMode,<span class="comment">//表示是否允许执行本中断的下一个中断 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   IN BOOLEAN ShareVector,<span class="comment">//表示本中断对象是否想要共享中断号以及是否允许共享 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   IN KAFFINITY ProcessorEnableMask,<span class="comment">//本isr的cpu亲缘性,一般全部cpu都亲缘。 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                   IN BOOLEAN FloatingSave)</span><span class="comment">//一般为FALSE </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PKINTERRUPT Interrupt; </span><br><span class="line">    PKINTERRUPT InterruptUsed;<span class="comment">//当前的中断对象 </span></span><br><span class="line">    PIO_INTERRUPT IoInterrupt;<span class="comment">//中断对象数组的头部 </span></span><br><span class="line">    PKSPIN_LOCK SpinLockUsed;<span class="comment">//实际使用的自旋锁 </span></span><br><span class="line">    BOOLEAN FirstRun; </span><br><span class="line">    CCHAR Count = <span class="number">0</span>;<span class="comment">//cpu号 </span></span><br><span class="line">    KAFFINITY Affinity;<span class="comment">//cpu亲缘性掩码 </span></span><br><span class="line">    PAGED_CODE(); </span><br><span class="line">    *InterruptObject = <span class="literal">NULL</span>; </span><br><span class="line">    Affinity = ProcessorEnableMask &amp; KeActiveProcessors;<span class="comment">//本isr的cpu亲缘性与实有cpu的交集 </span></span><br><span class="line">    <span class="keyword">while</span> (Affinity) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (Affinity &amp; <span class="number">1</span>) Count++; </span><br><span class="line">        Affinity &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面的循环根据本isr可以在哪些cpu上运行,得出可运行的cpu个数 if (!Count) return STATUS_INVALID_PARAMETER; </span></span><br><span class="line">    <span class="comment">//分配一个中断对象数组 </span></span><br><span class="line">    IoInterrupt = ExAllocatePoolWithTag(NonPagedPool, (Count - <span class="number">1</span>) * <span class="keyword">sizeof</span>(KINTERRUPT) + </span><br><span class="line">                                        <span class="keyword">sizeof</span>(IO_INTERRUPT),TAG_KINTERRUPT); </span><br><span class="line">    <span class="keyword">if</span> (!IoInterrupt) <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES; </span><br><span class="line">    *InterruptObject = &amp;IoInterrupt-&gt;FirstInterrupt; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if 用户没提供自旋锁,就使用内置的自旋锁。一般用户不需自己提供自旋锁 </span></span><br><span class="line">    SpinLockUsed = SpinLock ? SpinLock : &amp;IoInterrupt-&gt;SpinLock;  </span><br><span class="line">    Interrupt = (PKINTERRUPT)(IoInterrupt + <span class="number">1</span>);<span class="comment">//后面的中断对象数组地址 </span></span><br><span class="line">    FirstRun = TRUE; </span><br><span class="line">    RtlZeroMemory(IoInterrupt, <span class="keyword">sizeof</span>(IO_INTERRUPT)); </span><br><span class="line">    Affinity = ProcessorEnableMask &amp; KeActiveProcessors; </span><br><span class="line">    <span class="keyword">for</span> (Count = <span class="number">0</span>; Affinity; Count++, Affinity &gt;&gt;= <span class="number">1</span>) <span class="comment">//Count其实表示cpu号 </span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (Affinity &amp; <span class="number">1</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//第一次使用头部中的那个内置中断对象 </span></span><br><span class="line">            InterruptUsed = FirstRun ? &amp;IoInterrupt-&gt;FirstInterrupt : Interrupt; </span><br><span class="line">            <span class="comment">//构造一个中断对象 </span></span><br><span class="line">            KeInitializeInterrupt(InterruptUsed,ServiceRoutine,ServiceContext, </span><br><span class="line">                                  SpinLockUsed,Vector,Irql,SynchronizeIrql, </span><br><span class="line">                                  InterruptMode,ShareVector,Count,FloatingSave); </span><br><span class="line">            <span class="keyword">if</span> (!KeConnectInterrupt(InterruptUsed))<span class="comment">//关键,挂接中断对象到目标cpu的指定中断号 </span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">//if 挂接失败 </span></span><br><span class="line">                <span class="keyword">if</span> (FirstRun) </span><br><span class="line">                    ExFreePool(IoInterrupt); </span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    IoDisconnectInterrupt(&amp;IoInterrupt-&gt;FirstInterrupt); </span><br><span class="line">                <span class="keyword">return</span> STATUS_INVALID_PARAMETER; </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (FirstRun) </span><br><span class="line">                FirstRun = FALSE; </span><br><span class="line">            Else <span class="comment">//记录各cpu的那个中断号上挂接的中断对象地址 </span></span><br><span class="line">                IoInterrupt-&gt;Interrupt[(UCHAR)Count] = Interrupt++;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上这个函数用来将指定 isr 挂接到各个 cpu 的指定中断号上。<br>因为在多 cpu 系统中,一个设备可以向每个 cpu 都发出中断,因此必须在每个 cpu 的 IDT 中都要挂接登记那个中断的 isr。</p>
<blockquote>
<p>具体是怎么挂接的呢？<br>这个函数会创建一个中断对象数组,然后将各个中断对象对应挂接到各 cpu 的同一中断号上。</p>
</blockquote>
<h3 id="KeInitializeInterrupt"><a href="#KeInitializeInterrupt" class="headerlink" title="KeInitializeInterrupt"></a>KeInitializeInterrupt</h3><p>由于老式机器是单 cpu 的,因此早期的中断对象结构<code>IO_INTERRUPT</code>就包含一个中断对象任意,后来的机器对其 进行了扩展,在这个结构后面是一个中断对象数组,用来挂接到其他 cpu 上。 另外由于多个设备可以共用同一中断号,所以每个中断号需要一个自己的链表来记录所有挂接在此中断号上的所有中断对象。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_INTERRUPT</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    KINTERRUPT FirstInterrupt;<span class="comment">//内置的中断对象 </span></span><br><span class="line">    PKINTERRUPT Interrupt[MAXIMUM_PROCESSORS];<span class="comment">//记录各cpu上挂接的中断对象地址 </span></span><br><span class="line">    KSPIN_LOCK SpinLock;<span class="comment">//内置的isr自旋锁,如果用户没提供,就默认使用这个公共的自旋锁。 </span></span><br><span class="line">&#125; IO_INTERRUPT, *PIO_INTERRUPT; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 该结构体后面紧跟一个 INTERRUPT 结构体数组 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KINTERRUPT</span> //中断对象 </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    CSHORT Type; </span><br><span class="line"> </span><br><span class="line">    CSHORT Size; </span><br><span class="line">    LIST_ENTRY InterruptListEntry;<span class="comment">//用来挂入中断对象链表 </span></span><br><span class="line">    PKSERVICE_ROUTINE ServiceRoutine;<span class="comment">//我们的isr(用户的isr) </span></span><br><span class="line">    PVOID ServiceContext;<span class="comment">//isr 参数 </span></span><br><span class="line">    KSPIN_LOCK SpinLock; <span class="comment">//一般无用 </span></span><br><span class="line">    ULONG TickCount;<span class="comment">//没用 </span></span><br><span class="line">    PKSPIN_LOCK ActualLock;<span class="comment">//我们isr实际使用的自旋锁 PKINTERRUPT_ROUTINE DispatchAddress;//中间的Dispatch isr函数地址 CCHAR Number;//要挂往的目标cpu </span></span><br><span class="line">    ULONG Vector;<span class="comment">//要挂往的目标中断号 </span></span><br><span class="line">    KIRQL Irql;<span class="comment">//isr对应的isr </span></span><br><span class="line">    KIRQL SynchronizeIrql;<span class="comment">//isr实际运行在的irql </span></span><br><span class="line">    BOOLEAN FloatingSave;<span class="comment">//一般为FALSE </span></span><br><span class="line">    BOOLEAN Connected;<span class="comment">//表示本中断对象是否挂上去了 </span></span><br><span class="line">    BOOLEAN ShareVector;<span class="comment">//是否想要共享中断号,以及是否允许后来的中断对象共享 </span></span><br><span class="line">    KINTERRUPT_MODE Mode;<span class="comment">//是否允许继续执行本中断对象后面的中断对象的isr </span></span><br><span class="line">    ULONG ServiceCount;<span class="comment">//没用 </span></span><br><span class="line">    ULONG DispatchCount;<span class="comment">//没用 </span></span><br><span class="line">    ULONG DispatchCode[DISPATCH_LENGTH];<span class="comment">//这不是数组,而是一段代码,表示本中断对象的模板isr </span></span><br><span class="line">&#125; KINTERRUPT;</span><br></pre></td></tr></table></figure>
<p>下面的函数用来构造、初始化一个中断对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KeInitializeInterrupt</span><span class="params">(IN PKINTERRUPT Interrupt, </span></span></span><br><span class="line"><span class="function"><span class="params">                      IN PKSERVICE_ROUTINE ServiceRoutine,IN PVOID ServiceContext, </span></span></span><br><span class="line"><span class="function"><span class="params">                      IN PKSPIN_LOCK SpinLock,IN ULONG Vector,IN KIRQL Irql, </span></span></span><br><span class="line"><span class="function"><span class="params">                      IN KIRQL SynchronizeIrql,IN KINTERRUPT_MODE InterruptMode, </span></span></span><br><span class="line"><span class="function"><span class="params">                      IN BOOLEAN ShareVector,IN CHAR ProcessorNumber,IN BOOLEAN FloatingSave)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ULONG i; </span><br><span class="line">    PULONG DispatchCode = &amp;Interrupt-&gt;DispatchCode[<span class="number">0</span>],Patch = DispatchCode;<span class="comment">//patch表示补丁处 </span></span><br><span class="line">    Interrupt-&gt;Type = InterruptObject; </span><br><span class="line">    Interrupt-&gt;Size = <span class="keyword">sizeof</span>(KINTERRUPT); </span><br><span class="line">    <span class="keyword">if</span> (SpinLock)<span class="comment">//由于这个函数未导出,由系统内部调用,传的SpinLock参数很少为NULL </span></span><br><span class="line">        Interrupt-&gt;ActualLock = SpinLock;<span class="comment">//使用头部中公共的自旋锁或者我们提供的自旋锁 </span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        KeInitializeSpinLock(&amp;Interrupt-&gt;SpinLock); </span><br><span class="line">        Interrupt-&gt;ActualLock = &amp;Interrupt-&gt;SpinLock; </span><br><span class="line">    &#125; </span><br><span class="line">    Interrupt-&gt;ServiceRoutine = ServiceRoutine; </span><br><span class="line">    Interrupt-&gt;ServiceContext = ServiceContext; </span><br><span class="line">    Interrupt-&gt;Vector = Vector; </span><br><span class="line">    Interrupt-&gt;Irql = Irql; </span><br><span class="line"> </span><br><span class="line">    Interrupt-&gt;SynchronizeIrql = SynchronizeIrql; </span><br><span class="line">    Interrupt-&gt;Mode = InterruptMode; </span><br><span class="line">    Interrupt-&gt;ShareVector = ShareVector; </span><br><span class="line">    Interrupt-&gt;Number = ProcessorNumber; </span><br><span class="line">    Interrupt-&gt;FloatingSave = FloatingSave; </span><br><span class="line">    Interrupt-&gt;TickCount = MAXULONG; Interrupt-&gt;DispatchCount = MAXULONG; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先拷贝模板isr的字节码到中断对象内部 </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DISPATCH_LENGTH; i++) </span><br><span class="line">        *DispatchCode++ = ((PULONG)KiInterruptTemplate)[i]; </span><br><span class="line">    <span class="comment">//patch 指向模板isr中的mov edx,0指令的操作数部分 Patch = (PULONG)((ULONG)Patch + </span></span><br><span class="line">                    ((ULONG)&amp;KiInterruptTemplateObject <span class="number">-4</span> - (ULONG)KiInterruptTemplate)); </span><br><span class="line">    *Patch = PtrToUlong(Interrupt);<span class="comment">//也即将原mov edx,0 改为 mov edx,本中断对象的地址 </span></span><br><span class="line">    Interrupt-&gt;Connected = FALSE;<span class="comment">//尚未挂入 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是系统的模板 isr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_KiInterruptTemplate: </span><br><span class="line">    KiEnterTrap KI_PUSH_FAKE_ERROR_CODE </span><br><span class="line"></span><br><span class="line">_KiInterruptTemplate2ndDispatch: </span><br><span class="line">    mov edx, <span class="number">0</span> <span class="comment">//这条指令的操作数0将被动态修改成具体中断对象的地址 </span></span><br><span class="line"></span><br><span class="line">_KiInterruptTemplateObject: </span><br><span class="line">    mov eax, offset @KiInterruptTemplateHandler@<span class="number">8</span> <span class="comment">//KiInterruptTemplateHandler函数 </span></span><br><span class="line">    jmp eax </span><br><span class="line">_KiInterruptTemplateDispatch:</span><br></pre></td></tr></table></figure>
<p>上面就是系统的模板 isr,每个中断对象的模板 isr 就是从系统的模板 isr 复制过来的,然后稍作修改。 </p>
<h3 id="KeConnectInterrupt"><a href="#KeConnectInterrupt" class="headerlink" title="KeConnectInterrupt"></a>KeConnectInterrupt</h3><p>当构造好中断对象后,就需要把它挂接到目标 cpu 的目标中断号上。</p>
<p>下面的函数就这个用途 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值表示是否挂接成功 </span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">KeConnectInterrupt</span><span class="params">(IN PKINTERRUPT Interrupt)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    BOOLEAN Connected, Error, Status; </span><br><span class="line">    KIRQL Irql, OldIrql; </span><br><span class="line">    UCHAR Number; </span><br><span class="line">    ULONG Vector; </span><br><span class="line">    DISPATCH_INFO Dispatch; </span><br><span class="line">    Number = Interrupt-&gt;Number;<span class="comment">//目标cpu </span></span><br><span class="line">    Vector = Interrupt-&gt;Vector;<span class="comment">//目标中断号 Irql = Interrupt-&gt;Irql; </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// SynchronizeIrql 必须 &gt;= Irql </span></span><br><span class="line">    <span class="keyword">if</span> ((Irql &gt; HIGH_LEVEL) || (Number &gt;= KeNumberProcessors) || </span><br><span class="line">        (Interrupt-&gt;SynchronizeIrql &lt; Irql) || (Interrupt-&gt;FloatingSave)) </span><br><span class="line">    &#123; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125; </span><br><span class="line">    Connected = FALSE; </span><br><span class="line">    Error = FALSE; </span><br><span class="line">    KeSetSystemAffinityThread(<span class="number">1</span> &lt;&lt; Number);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//改变当前线程的cpu亲缘性先,挪到目标cpu上去运行 </span></span><br><span class="line">    <span class="comment">//------------------------------------华丽的分割线-------------------------------------- </span></span><br><span class="line">    <span class="comment">//------------------------------------华丽的分割线-------------------------------------- </span></span><br><span class="line">    <span class="comment">//------------------------------------华丽的分割线-------------------------------------- </span></span><br><span class="line">	<span class="comment">//下面的这些代码已经处在目标cpu上运行了 </span></span><br><span class="line">    OldIrql = KiAcquireDispatcherLock(); </span><br><span class="line">    <span class="keyword">if</span> (!Interrupt-&gt;Connected)<span class="comment">//if尚未挂接 </span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//查询当前cpu这个中断号上的最近一次(也即上一次)的挂接情况 </span></span><br><span class="line">        KiGetVectorDispatch(Vector, &amp;Dispatch);  </span><br><span class="line">        <span class="keyword">if</span> (Dispatch.Type == NoConnect)<span class="comment">//如果这个中断号尚未挂接有任何中断对象 </span></span><br><span class="line">        &#123; </span><br><span class="line">            Interrupt-&gt;Connected = Connected = TRUE; </span><br><span class="line">            InitializeListHead(&amp;Interrupt-&gt;InterruptListEntry);<span class="comment">//独立 </span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//NormalConnect表示以普通方式挂上去(非链接方式),相当于覆盖方式 </span></span><br><span class="line">            KiConnectVectorToInterrupt(Interrupt, NormalConnect);  </span><br><span class="line">            Status = HalEnableSystemInterrupt(Vector, Irql, Interrupt-&gt;Mode);<span class="comment">//APIC相关 </span></span><br><span class="line">            <span class="keyword">if</span> (!Status) Error = TRUE; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((Dispatch.Type != UnknownConnect) &amp;&amp; <span class="comment">//已挂接有中断对象 </span></span><br><span class="line">                (Interrupt-&gt;ShareVector) &amp;&amp;  <span class="comment">//本中断对象想要共享这个中断号 </span></span><br><span class="line">                (Dispatch.Interrupt-&gt;ShareVector) &amp;&amp; <span class="comment">//并且上次挂接的那个中断对象允许共享 </span></span><br><span class="line">                (Dispatch.Interrupt-&gt;Mode == Interrupt-&gt;Mode)) </span><br><span class="line">        &#123; </span><br><span class="line">            Interrupt-&gt;Connected = Connected = TRUE; </span><br><span class="line">            <span class="comment">//if 上一个中断对象不是以链接方式挂上去的,就改为链接方式挂上去 </span></span><br><span class="line">            <span class="keyword">if</span> (Dispatch.Type != ChainConnect) </span><br><span class="line">            &#123; </span><br><span class="line">                ASSERT(Dispatch.Interrupt-&gt;Mode != Latched); </span><br><span class="line">                KiConnectVectorToInterrupt(Dispatch.Interrupt, ChainConnect); </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//关键。挂在上一个中断对象的后面 </span></span><br><span class="line">            InsertTailList(&amp;Dispatch.Interrupt-&gt;InterruptListEntry, </span><br><span class="line">                           &amp;Interrupt-&gt;InterruptListEntry); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KiReleaseDispatcherLock(OldIrql); </span><br><span class="line">    KeRevertToUserAffinityThread(); </span><br><span class="line">    <span class="keyword">if</span> ((Connected) &amp;&amp; (Error)) </span><br><span class="line">    &#123; </span><br><span class="line">        KeDisconnectInterrupt(Interrupt); </span><br><span class="line"> </span><br><span class="line">        Connected = FALSE; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> Connected; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KiGetVectorDispatch"><a href="#KiGetVectorDispatch" class="headerlink" title="KiGetVectorDispatch"></a>KiGetVectorDispatch</h3><p>下面的函数用于查询当前 cpu 指定中断号上的最近一次挂接情况(查询最近一次挂上去的中断对象,以及它当时是怎么挂上去的) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID  <span class="title">KiGetVectorDispatch</span><span class="params">(IN ULONG Vector,IN PDISPATCH_INFO Dispatch)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PKINTERRUPT_ROUTINE Handler; </span><br><span class="line">    PVOID Current; </span><br><span class="line">    UCHAR Type; </span><br><span class="line">    UCHAR Entry; </span><br><span class="line">    Entry = HalVectorToIDTEntry(Vector);<span class="comment">//这个宏将中断向量号转换为IDT表项索引(一般相同) </span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//固定为KiUnexpectedInterruptN函数的地址,N表示IRQ </span></span><br><span class="line">    Dispatch-&gt;NoDispatch = (PVOID)(((ULONG_PTR)&amp;KiStartUnexpectedRange) + </span><br><span class="line">                                   (Entry –  <span class="number">0x30</span>) *KiUnexpectedEntrySize); </span><br><span class="line">    Dispatch-&gt;InterruptDispatch = (PVOID)KiInterruptDispatch;<span class="comment">//这个字段固定 </span></span><br><span class="line">    Dispatch-&gt;FloatingDispatch = <span class="literal">NULL</span>; <span class="comment">//尚不支持 </span></span><br><span class="line">    Dispatch-&gt;ChainedDispatch = (PVOID)KiChainedDispatch;<span class="comment">//这个字段固定 </span></span><br><span class="line">    Dispatch-&gt;FlatDispatch = <span class="literal">NULL</span>; </span><br><span class="line"> </span><br><span class="line">    Current = KeQueryInterruptHandler(Vector);<span class="comment">//获得这个中断向量处当前存放的isr函数地址 </span></span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((PKINTERRUPT_ROUTINE)Current == Dispatch-&gt;NoDispatch) </span><br><span class="line">    &#123; </span><br><span class="line">        Dispatch-&gt;Interrupt = <span class="literal">NULL</span>;<span class="comment">//表示尚未挂接有任何中断对象 </span></span><br><span class="line">        Dispatch-&gt;Type = NoConnect; <span class="comment">//表示尚未挂接有任何中断对象 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键,可有isr(其实是个模板isr)反推出当前的中断对象(即最近一次挂上去的对象) Dispatch-&gt;Interrupt = CONTAINING_RECORD(Current,KINTERRUPT,DispatchCode); </span></span><br><span class="line">        Handler = Dispatch-&gt;Interrupt-&gt;DispatchAddress; </span><br><span class="line">        <span class="keyword">if</span> (Handler == Dispatch-&gt;ChainedDispatch) </span><br><span class="line">            Dispatch-&gt;Type = ChainConnect;<span class="comment">//上次的中断对象是以链接方式挂上去的 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((Handler == Dispatch-&gt;InterruptDispatch) || </span><br><span class="line">            (Handler == Dispatch-&gt;FloatingDispatch)) </span><br><span class="line">        &#123; </span><br><span class="line">            Dispatch-&gt;Type = NormalConnect;<span class="comment">//上次的中断对象是以普通方式挂上去的 </span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line"> </span><br><span class="line">            Dispatch-&gt;Type = UnknownConnect;<span class="comment">//不确定上次的中断对象是怎么挂上去的 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KeQueryInterruptHandler"><a href="#KeQueryInterruptHandler" class="headerlink" title="KeQueryInterruptHandler"></a>KeQueryInterruptHandler</h3><p>下面这个函数返回当前 cpu 上指定中断向量处的 isr。<br>注意：任一时刻,每个 isr 可能是个模板 isr,可能是个用户自定义的 isr,也可能没有isr(即以<code>KiUnexpectedInterruptN</code>函数占位)。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">KeQueryInterruptHandler</span><span class="params">(IN ULONG Vector)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PKIPCR Pcr = (PKIPCR)KeGetPcr(); </span><br><span class="line">    UCHAR Entry; </span><br><span class="line">    Entry = HalVectorToIDTEntry(Vector); </span><br><span class="line">    <span class="keyword">return</span> (PVOID)(((Pcr-&gt;IDT[Entry].ExtendedOffset &lt;&lt; <span class="number">16</span>) &amp; <span class="number">0xFFFF0000</span>) | </span><br><span class="line">                    (Pcr-&gt;IDT[Entry].Offset &amp; <span class="number">0xFFFF</span>)); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//真正的挂接操作是调用下面的函数完成的 </span></span><br><span class="line"><span class="function">VOID <span class="title">KiConnectVectorToInterrupt</span><span class="params">(IN PKINTERRUPT Interrupt,IN CONNECT_TYPE Type)</span><span class="comment">//挂接类型 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    DISPATCH_INFO Dispatch; </span><br><span class="line">    PKINTERRUPT_ROUTINE Handler;<span class="comment">//将要填到IDT表项中的最直接isr </span></span><br><span class="line">    KiGetVectorDispatch(Interrupt-&gt;Vector, &amp;Dispatch); </span><br><span class="line">    <span class="keyword">if</span> (Type == NoConnect)<span class="comment">//if用户要撤销挂接 </span></span><br><span class="line">        Handler = Dispatch.NoDispatch; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//填好本中断对象的dispatch isr </span></span><br><span class="line">        Interrupt-&gt;DispatchAddress = (Type == NormalConnect) ? Dispatch.InterruptDispatch: </span><br><span class="line">                                                               Dispatch.ChainedDispatch; </span><br><span class="line">        Handler = (PVOID)&amp;Interrupt-&gt;DispatchCode;<span class="comment">//本中断对象的模板isr </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//将本中断对象的模板isr或者KiUnexpectedInterruptN填写到IDT的对应表项处。 </span></span><br><span class="line">    <span class="comment">//可以看出,通过IoConnectInterrupt函数,IDT中的每个isr都是最后一次挂接的中断对象的模板isr </span></span><br><span class="line">    KeRegisterInterruptHandler(Interrupt-&gt;Vector, Handler); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function">VOID <span class="title">KeRegisterInterruptHandler</span><span class="params">(IN ULONG Vector,IN PVOID Handler)</span> </span></span><br><span class="line"><span class="function"></span>&#123;                            </span><br><span class="line">    UCHAR Entry; </span><br><span class="line">    ULONG_PTR Address; </span><br><span class="line">    PKIPCR Pcr = (PKIPCR)KeGetPcr(); </span><br><span class="line">    Entry = HalVectorToIDTEntry(Vector); </span><br><span class="line"> </span><br><span class="line">    Address = PtrToUlong(Handler); </span><br><span class="line">    <span class="comment">//将isr填写到相应的表项中 </span></span><br><span class="line">    Pcr-&gt;IDT[Entry].ExtendedOffset = (USHORT)(Address &gt;&gt; <span class="number">16</span>); </span><br><span class="line">    Pcr-&gt;IDT[Entry].Offset = (USHORT)Address; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="KiInterruptTemplateHandler"><a href="#KiInterruptTemplateHandler" class="headerlink" title="KiInterruptTemplateHandler"></a>KiInterruptTemplateHandler</h2><p>通过<code>IoConnectInterrupt</code>函数挂接的中断对象,都是将其模板 isr 填写到 IDT 表项中,这样谁最后挂接, 谁的模板 isr 就会最后覆写到那个表项处。<br>如果使用了同一中断号的各个中断对象都是以链接方式挂接上去的,那么这些中断对象将组成一个链表。<br>这样当 cpu 收到对应的中断号时,会找到 IDT 中对应表项的 isr 给予执行。<br>而那个 isr 就是最后挂接的中断对象的模板 isr,这个模板 isr 的代码前面已看过,它将跳转进入下面的函数 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">KiInterruptTemplateHandler</span><span class="params">(IN PKTRAP_FRAME TrapFrame, <span class="comment">//ecx </span></span></span></span><br><span class="line"><span class="function"><span class="params">                           IN PKINTERRUPT Interrupt)</span> <span class="comment">//edx </span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    KiEnterInterruptTrap(TrapFrame); </span><br><span class="line">    ((PKI_INTERRUPT_DISPATCH)Interrupt-&gt;DispatchAddress)(TrapFrame, Interrupt);<span class="comment">//关键 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到没每个中断对象的模板 isr,会调用它的<code>dispatch isr</code>。<br>以链接方式挂上去的中断对象的<code>dispatch isr</code>都是<code>KiChainedDispatch</code>,反之则是<code>KiInterruptDispatch</code>。</p>
<h3 id="KiChainedDispatch"><a href="#KiChainedDispatch" class="headerlink" title="KiChainedDispatch"></a>KiChainedDispatch</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">KiChainedDispatch</span><span class="params">(IN PKTRAP_FRAME TrapFrame,IN PKINTERRUPT Interrupt)</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    KIRQL OldIrql; </span><br><span class="line">    BOOLEAN Handled; </span><br><span class="line">    PLIST_ENTRY NextEntry, ListHead; </span><br><span class="line">    KeGetCurrentPrcb()-&gt;InterruptCount++;<span class="comment">//递增中断计数 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//HalBeginSystemInterrupt会提升irql至指定irql,以准备执行我们的isr </span></span><br><span class="line">    <span class="keyword">if</span> (HalBeginSystemInterrupt(Interrupt-&gt;Irql,Interrupt-&gt;Vector,&amp;OldIrql))<span class="comment">//APIC相关 </span></span><br><span class="line">    &#123; </span><br><span class="line">        ListHead = &amp;Interrupt-&gt;InterruptListEntry; </span><br><span class="line">        NextEntry = ListHead; </span><br><span class="line">        <span class="keyword">while</span> (TRUE) <span class="comment">//遍历中断对象链表,直至找到一个能处理这个中断的中断对象为止 </span></span><br><span class="line">        &#123;             </span><br><span class="line">            <span class="keyword">if</span> (Interrupt-&gt;SynchronizeIrql &gt; Interrupt-&gt;Irql)<span class="comment">//再次提升irql </span></span><br><span class="line">                OldIrql = KfRaiseIrql(Interrupt-&gt;SynchronizeIrql);   </span><br><span class="line">            KxAcquireSpinLock(Interrupt-&gt;ActualLock);<span class="comment">//加锁,保障多cpu互斥 </span></span><br><span class="line">            <span class="comment">//执行我们的isr(即用户自己提供的isr),注意返回值 </span></span><br><span class="line">            Handled = Interrupt-&gt;ServiceRoutine(Interrupt,Interrupt-&gt;ServiceContext); </span><br><span class="line">            KxReleaseSpinLock(Interrupt-&gt;ActualLock); </span><br><span class="line">            <span class="keyword">if</span> (Interrupt-&gt;SynchronizeIrql &gt; Interrupt-&gt;Irql) </span><br><span class="line">                KfLowerIrql(OldIrql); </span><br><span class="line">            <span class="comment">//if本中断对象认领了,且不许执行下一个中断对象就退出查找循环。 </span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">//(LevelSensitive即FALSE,一般的中断对象都这样) </span></span><br><span class="line">            <span class="keyword">if</span> ((Handled) &amp;&amp; (Interrupt-&gt;Mode == LevelSensitive)) <span class="keyword">break</span>; </span><br><span class="line">            NextEntry = NextEntry-&gt;Flink; </span><br><span class="line">            <span class="keyword">if</span> (NextEntry == ListHead)<span class="comment">//if链表中的最后一个中断对象 </span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> (Interrupt-&gt;Mode == LevelSensitive) <span class="keyword">break</span>; </span><br><span class="line">                <span class="keyword">if</span> (!Handled) <span class="keyword">break</span>;<span class="comment">//if没能处理这个中断,退出循环 </span></span><br><span class="line">            &#125; </span><br><span class="line">            Interrupt = CONTAINING_RECORD(NextEntry, KINTERRUPT, InterruptListEntry); </span><br><span class="line">        &#125; </span><br><span class="line">        KiExitInterrupt(TrapFrame, OldIrql, FALSE); </span><br><span class="line">    &#125; </span><br><span class="line">    Else <span class="comment">//清理中断Trap帧,恢复中断现场,回到原断点处继续执行 </span></span><br><span class="line">        KiExitInterrupt(TrapFrame, OldIrql, TRUE);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户自己的 isr 的原型是:<code>BOOLEAN InterruptService(in struct _KINTERRUPT *Interrupt, in PVOID ServiceContex);</code><br>我们的这个 isr 应该根据<code>ServiceContex</code>判断这个中断是不是我们驱动中的设备发出的,若是才能处理,返回<code>TRUE</code>, 否则应返回<code>FALSE</code><br>让系统继续寻找中断对象链表中的下一个中断对象去认领。 </p>
<h3 id="KiInterruptDispatch"><a href="#KiInterruptDispatch" class="headerlink" title="KiInterruptDispatch"></a>KiInterruptDispatch</h3><p>而对于以普通覆写方式挂上去的中断对象,它的 dispatch isr 是<code>KiInterruptDispatch</code>,我们看</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">KiInterruptDispatch</span><span class="params">(IN PKTRAP_FRAME TrapFrame,IN PKINTERRUPT Interrupt)</span> </span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    KIRQL OldIrql; </span><br><span class="line">    KeGetCurrentPrcb()-&gt;InterruptCount++;<span class="comment">//递增中断计数 </span></span><br><span class="line">    <span class="keyword">if</span> (HalBeginSystemInterrupt(Interrupt-&gt;SynchronizeIrql,Interrupt-&gt;Vector,&amp;OldIrql)) </span><br><span class="line">    &#123; </span><br><span class="line">        KxAcquireSpinLock(Interrupt-&gt;ActualLock); </span><br><span class="line">        <span class="comment">//调用其自己的isr </span></span><br><span class="line">        Interrupt-&gt;ServiceRoutine(Interrupt, Interrupt-&gt;ServiceContext); </span><br><span class="line">        KxReleaseSpinLock(Interrupt-&gt;ActualLock); </span><br><span class="line">        KiExitInterrupt(TrapFrame, OldIrql, FALSE); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        KiExitInterrupt(TrapFrame, OldIrql, TRUE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到没普通方式挂上去的中断对象,它独占中断号,当发生相应中断时,系统简单执行一下它自己的 isr 后就返回了,不会有在链表中查找的过程。 </p>
<p><br></p>
<h2 id="IoDisconnectInterrupt"><a href="#IoDisconnectInterrupt" class="headerlink" title="IoDisconnectInterrupt"></a>IoDisconnectInterrupt</h2><p>底层驱动在卸载时,往往要撤销挂接的那些中断,我们看下中断对象如如何撤销挂接的。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">IoDisconnectInterrupt</span><span class="params">(PKINTERRUPT InterruptObject)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    LONG i; </span><br><span class="line">    PIO_INTERRUPT IoInterrupt; </span><br><span class="line">    PAGED_CODE(); </span><br><span class="line">    IoInterrupt = CONTAINING_RECORD(InterruptObject,IO_INTERRUPT,FirstInterrupt); </span><br><span class="line">    KeDisconnectInterrupt(&amp;IoInterrupt-&gt;FirstInterrupt);<span class="comment">//撤销第一个中断对象的挂接 </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KeNumberProcessors; i++)<span class="comment">//撤销其它中断对象的挂接 </span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (IoInterrupt-&gt;Interrupt[i]) </span><br><span class="line">            KeDisconnectInterrupt(&amp;InterruptObject[i]); </span><br><span class="line">    &#125; </span><br><span class="line">    ExFreePool(IoInterrupt);<span class="comment">//释放整个中断对象数组加头部占用的那块内存 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function">BOOLEAN <span class="title">KeDisconnectInterrupt</span><span class="params">(IN PKINTERRUPT Interrupt)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    KIRQL OldIrql, Irql; </span><br><span class="line">    ULONG Vector; </span><br><span class="line">    DISPATCH_INFO Dispatch; </span><br><span class="line">    PKINTERRUPT NextInterrupt; </span><br><span class="line">    BOOLEAN State; </span><br><span class="line">    KeSetSystemAffinityThread(<span class="number">1</span> &lt;&lt; Interrupt-&gt;Number); </span><br><span class="line">    OldIrql = KiAcquireDispatcherLock(); </span><br><span class="line">    State = Interrupt-&gt;Connected; </span><br><span class="line">    <span class="keyword">if</span> (State) </span><br><span class="line">    &#123; </span><br><span class="line">        Irql = Interrupt-&gt;Irql; </span><br><span class="line">        Vector = Interrupt-&gt;Vector; </span><br><span class="line">        KiGetVectorDispatch(Vector, &amp;Dispatch);<span class="comment">//获取上次的挂接信息 </span></span><br><span class="line">        <span class="keyword">if</span> (Dispatch.Type == ChainConnect) </span><br><span class="line">        &#123; </span><br><span class="line">            ASSERT(Irql &lt;= SYNCH_LEVEL); </span><br><span class="line">            <span class="keyword">if</span> (Interrupt == Dispatch.Interrupt)<span class="comment">//if 要撤销挂接的中断对象就是最近挂接的那个 </span></span><br><span class="line">            &#123; </span><br><span class="line">                Dispatch.Interrupt = CONTAINING_RECORD(Dispatch.Interrupt-&gt; InterruptListEntry.Flink,KINTERRUPT,InterruptListEntry); </span><br><span class="line">                KiConnectVectorToInterrupt(Dispatch.Interrupt, ChainConnect); </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//关键。脱出链表 </span></span><br><span class="line">            RemoveEntryList(&amp;Interrupt-&gt;InterruptListEntry); </span><br><span class="line">            NextInterrupt = CONTAINING_RECORD(Dispatch.Interrupt-&gt;InterruptListEntry.Flink, </span><br><span class="line">                                              KINTERRUPT,InterruptListEntry); </span><br><span class="line">            <span class="keyword">if</span> (Dispatch.Interrupt == NextInterrupt)<span class="comment">//也即if 链表中就剩下一个中断对象了 </span></span><br><span class="line"> </span><br><span class="line">            &#123; </span><br><span class="line">                KiConnectVectorToInterrupt(Dispatch.Interrupt, NormalConnect);<span class="comment">//改为普通方式 </span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        Else <span class="comment">//if原来本身就只挂着一个中断对象 </span></span><br><span class="line">        &#123; </span><br><span class="line">            HalDisableSystemInterrupt(Interrupt-&gt;Vector, Irql); </span><br><span class="line">            KiConnectVectorToInterrupt(Interrupt, NoConnect);<span class="comment">//改为KiUnexpectedInterruptN </span></span><br><span class="line">        &#125; </span><br><span class="line">        Interrupt-&gt;Connected = FALSE; </span><br><span class="line">    &#125; </span><br><span class="line">    KiReleaseDispatcherLock(OldIrql); </span><br><span class="line">    KeRevertToUserAffinityThread(); </span><br><span class="line">    <span class="keyword">return</span> State; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>IoConnectInterrupt</code>函数挂接注册中断,确实为程序员减轻了大量负担。<br>通过这种方式注册的 isr分三层。</p>
<ul>
<li>第一层是中断对象的模板 isr</li>
<li>第二层是中断对象的 dispatch isr</li>
<li>第三层才是用户自己提供的 isr。</li>
</ul>
<p>每当发生中断时系统逐层调用这三层 isr。因此也可以说,我们提供的那个 isr 被系统托管了,IDT 表项中的 isr 是系统的托管 isr。<br>当然程序员,也可以直接修改 IDT 中的表项,改成自己的 isr,这就是所谓的 isr hook(注意要进行 isr hook 的话,必须每个 cpu 都要 hook) </p>
<p><br></p>
<h2 id="HalpClockInterruptHandler"><a href="#HalpClockInterruptHandler" class="headerlink" title="HalpClockInterruptHandler"></a>HalpClockInterruptHandler</h2><p>最后我们看一下典型的系统时钟中断是怎么处理的。<br>系统每隔 10ms 产生一次时钟中断,时钟中断的 IRQ 固定是 0,中断号默认映射到<code>0x30</code>,时钟中断的 isr 最终进入下面的函数。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID FASTCALL <span class="title">HalpClockInterruptHandler</span><span class="params">(IN PKTRAP_FRAME TrapFrame)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    KIRQL Irql; </span><br><span class="line">    KiEnterInterruptTrap(TrapFrame); </span><br><span class="line">    <span class="comment">//提升irql至CLOCK2_LEVEL </span></span><br><span class="line">    <span class="keyword">if</span> (HalBeginSystemInterrupt(CLOCK2_LEVEL, <span class="number">0x30</span>, &amp;Irql))<span class="comment">//0x30就是时钟中断的中断号 </span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">/* Update the performance counter */</span> </span><br><span class="line">        HalpPerfCounter.QuadPart += HalpCurrentRollOver; </span><br><span class="line">        HalpPerfCounterCutoff = KiEnableTimerWatchdog; </span><br><span class="line">        KeUpdateSystemTime(TrapFrame, HalpCurrentTimeIncrement, Irql);<span class="comment">//关键函数 </span></span><br><span class="line">    &#125; </span><br><span class="line">    KiEoiHelper(TrapFrame); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">VOID FASTCALL <span class="title">KeUpdateSystemTime</span><span class="params">(IN PKTRAP_FRAME TrapFrame,IN ULONG Increment,IN KIRQL Irql)</span>                    </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PKPRCB Prcb = KeGetCurrentPrcb(); </span><br><span class="line">    ULARGE_INTEGER CurrentTime, InterruptTime; </span><br><span class="line">    ULONG Hand, OldTickCount; </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//更新启动以来的运行时间计数 </span></span><br><span class="line">    InterruptTime.HighPart = SharedUserData-&gt;InterruptTime.High1Time; </span><br><span class="line">    InterruptTime.LowPart = SharedUserData-&gt;InterruptTime.LowPart; </span><br><span class="line">    InterruptTime.QuadPart += Increment;<span class="comment">//Increment一般为10ms </span></span><br><span class="line">    SharedUserData-&gt;InterruptTime.High1Time = InterruptTime.HighPart; </span><br><span class="line">    SharedUserData-&gt;InterruptTime.LowPart = InterruptTime.LowPart; SharedUserData-&gt;InterruptTime.High2Time = InterruptTime.HighPart; </span><br><span class="line"> </span><br><span class="line">    OldTickCount = KeTickCount.LowPart; </span><br><span class="line">    InterlockedExchangeAdd(&amp;KiTickOffset, -(LONG)Increment);<span class="comment">//递减 </span></span><br><span class="line">    <span class="comment">/* Check for incomplete tick */</span> </span><br><span class="line">    <span class="keyword">if</span> (KiTickOffset &lt;= <span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//更新系统时间 </span></span><br><span class="line">        CurrentTime.HighPart = SharedUserData-&gt;SystemTime.High1Time; </span><br><span class="line">        CurrentTime.LowPart = SharedUserData-&gt;SystemTime.LowPart; </span><br><span class="line">        CurrentTime.QuadPart += KeTimeAdjustment; </span><br><span class="line">        SharedUserData-&gt;SystemTime.High2Time = CurrentTime.HighPart; </span><br><span class="line">        SharedUserData-&gt;SystemTime.LowPart = CurrentTime.LowPart; </span><br><span class="line">        SharedUserData-&gt;SystemTime.High1Time = CurrentTime.HighPart; </span><br><span class="line">         </span><br><span class="line">        <span class="comment">//更新Tick计数 </span></span><br><span class="line">        CurrentTime.HighPart = KeTickCount.High1Time; </span><br><span class="line">        CurrentTime.LowPart = OldTickCount; </span><br><span class="line">        CurrentTime.QuadPart += <span class="number">1</span>;<span class="comment">//递增Tick计数 </span></span><br><span class="line">        KeTickCount.High2Time = CurrentTime.HighPart; </span><br><span class="line">        KeTickCount.LowPart = CurrentTime.LowPart; </span><br><span class="line">        KeTickCount.High1Time = CurrentTime.HighPart; </span><br><span class="line">         </span><br><span class="line">        <span class="comment">//更新Tick计数(供应用程序GetTickCount访问) </span></span><br><span class="line">        SharedUserData-&gt;TickCount.High2Time = CurrentTime.HighPart; </span><br><span class="line">        SharedUserData-&gt;TickCount.LowPart = CurrentTime.LowPart; </span><br><span class="line">        SharedUserData-&gt;TickCount.High1Time = CurrentTime.HighPart; </span><br><span class="line">         </span><br><span class="line">        Hand = OldTickCount &amp; (TIMER_TABLE_SIZE - <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">if</span> (KiTimerTableListHead[Hand].Time.QuadPart &lt;= InterruptTime.QuadPart) </span><br><span class="line"> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (!Prcb-&gt;TimerRequest) </span><br><span class="line">            &#123;                         </span><br><span class="line">                Prcb-&gt;TimerRequest = (ULONG_PTR)TrapFrame; </span><br><span class="line">                Prcb-&gt;TimerHand = Hand; </span><br><span class="line">                HalRequestSoftwareInterrupt(DISPATCH_LEVEL); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        OldTickCount++; </span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//下面是关键。检查是否有到点的定时器 </span></span><br><span class="line">    Hand = OldTickCount &amp; (TIMER_TABLE_SIZE - <span class="number">1</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if有到点的定时器 </span></span><br><span class="line">    <span class="keyword">if</span> (KiTimerTableListHead[Hand].Time.QuadPart &lt;= InterruptTime.QuadPart) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (!Prcb-&gt;TimerRequest) </span><br><span class="line">        &#123;                         </span><br><span class="line">            Prcb-&gt;TimerRequest = (ULONG_PTR)TrapFrame;<span class="comment">//关键。插入一个定时器dpc </span></span><br><span class="line">            Prcb-&gt;TimerHand = Hand; </span><br><span class="line">            HalRequestSoftwareInterrupt(DISPATCH_LEVEL);<span class="comment">//发出一个DPC中断请求 </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (KiTickOffset &lt;= <span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        KiTickOffset += KeMaximumIncrement; </span><br><span class="line">        KeUpdateRunTime(TrapFrame, Irql); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        Prcb-&gt;InterruptCount++; </span><br><span class="line">    &#125; </span><br><span class="line">    KiEndInterrupt(Irql, TrapFrame); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数在发现有定时器到点后,就会发出一个 DPC,然后在系统定时器中断退出后,就会扫描执行 DPC 队列,调用<code>KiTimerExpiration</code>函数扫描所有到点的定时器,然后唤醒在那些定时器上等待的线程。<br><code>KiTimerExpiration</code>函数的代码,有兴趣的读者自己看。</p>
<p><br><br><br></p>
<h1 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h1><p>设备栈从上层到下层的顺序依次是:过滤设备、类设备、过滤设备、小端口设备【过、类、过滤、小端口】<br>驱动栈：因设备堆栈原因而建立起来的一种堆栈<br>老式驱动：指不提供<code>AddDevice</code>的驱动,又叫<code>NT</code>式驱动<br>Wdm 驱动：指提供了<code>AddDevice</code>的驱动 </p>
<p>驱动初始化：指 IO 管理器加载驱动后,调用驱动的<code>DriverEntry</code>、<code>AddDevice</code>函数<br>设备栈中上层设备与下层设备的绑定关系不是一对一,而是一对多。<br>一个设备可以同时绑定到 N 个下层设备上去,而一个下层设备,也可以同时被 N 个上层设备绑定,但注意形式上只可被一个上层设备绑定,因 为设备对象的<code>AttachedDevice</code>字段指的就是那个形式上绑定在它上面的设备。</p>
<h2 id="相关结构定义"><a href="#相关结构定义" class="headerlink" title="相关结构定义"></a>相关结构定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> &#123;</span> </span><br><span class="line">  CSHORT Type;<span class="comment">//本结构的类型 </span></span><br><span class="line">  CSHORT Size;<span class="comment">//本结构的实际长度 </span></span><br><span class="line">  PDEVICE_OBJECT DeviceObject;<span class="comment">//设备对象链(第一个设备对象) </span></span><br><span class="line">  ULONG Flags;<span class="comment">//驱动标志 </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//下面两个字段经常用于检测SSDT hook、DispactcRoutine hook等 </span></span><br><span class="line">  PVOID DriverStart;<span class="comment">//本驱动的sys模块在内存中的起始地址 </span></span><br><span class="line">  ULONG DriverSize;<span class="comment">//长度 </span></span><br><span class="line">  PVOID DriverSection;<span class="comment">//实际上是一个LDR_DATA_TABLE_ENTRY*指针,指向它的模块描述符结构 </span></span><br><span class="line">  PEXTENDED_DRIVER_EXTENSION DriverExtension;<span class="comment">//标准驱动扩展(所有驱动都有一个标准驱动扩准) </span></span><br><span class="line">  UNICODE_STRING DriverName;<span class="comment">//`Driver\服务名` 或 `FileSystem\服务名`(也在对象头中保存) </span></span><br><span class="line">  PUNICODE_STRING HardwareDatabase;<span class="comment">//注册表硬件配置键路径 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">FAST_IO_DISPATCH</span> *<span class="title">FastIoDispatch</span>;</span><span class="comment">//用于文件系统的一组快速IO例程 </span></span><br><span class="line">  PDRIVER_INITIALIZE DriverInit;<span class="comment">//sys文件的oep(一般就是DriverEntry,当然可以是其他名字) </span></span><br><span class="line">  PDRIVER_STARTIO DriverStartIo;<span class="comment">//StartIO irp队列机制专用函数 </span></span><br><span class="line">  PDRIVER_UNLOAD DriverUnload;<span class="comment">//驱动的卸载例程 </span></span><br><span class="line">  PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + <span class="number">1</span>];<span class="comment">//各irp的派遣函数 </span></span><br><span class="line">&#125; DRIVER_OBJECT, *PDRIVER_OBJECT;</span><br></pre></td></tr></table></figure>
<p>每个驱动对象都有一个标准的驱动扩展,且紧跟在驱动对象后面。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXTENDED_DRIVER_EXTENSION</span>  </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> *<span class="title">DriverObject</span>;</span> <span class="comment">//所属驱动对象 </span></span><br><span class="line">    PDRIVER_ADD_DEVICE AddDevice; <span class="comment">//本驱动的AddDevice例程 </span></span><br><span class="line">    ULONG Count; <span class="comment">//本驱动注册的重初始化例程的历史调用次数 </span></span><br><span class="line">    UNICODE_STRING ServiceKeyName; <span class="comment">//`Driver\服务名` 或 `FileSystem\服务名` </span></span><br><span class="line">    PIO_CLIENT_EXTENSION ClientDriverExtension;<span class="comment">//用户提供的自定义驱动扩展 </span></span><br><span class="line">    PFS_FILTER_CALLBACKS FsFilterCallbacks; </span><br><span class="line">&#125; EXTENDED_DRIVER_EXTENSION, *PEXTENDED_DRIVER_EXTENSION;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span> &#123;</span> </span><br><span class="line">  CSHORT Type; <span class="comment">//本结构的类型 </span></span><br><span class="line"> </span><br><span class="line">  USHORT Size; <span class="comment">//本结构的实际长度 </span></span><br><span class="line">  LONG ReferenceCount;<span class="comment">//引用计数 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> *<span class="title">DriverObject</span>;</span><span class="comment">//所属驱动对象 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span> *<span class="title">NextDevice</span>;</span><span class="comment">//在所属驱动的设备链中的下一个设备 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span> *<span class="title">AttachedDevice</span>;</span><span class="comment">//绑定的上层设备 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span> *<span class="title">CurrentIrp</span>;</span><span class="comment">//用于StartIO机制,表示当前正在处理中的irp </span></span><br><span class="line">  PIO_TIMER Timer;<span class="comment">//一个内置的秒级精度定时器(定时器例程运行在DISPACH_LEVEL) </span></span><br><span class="line">  ULONG Flags;<span class="comment">//设备标志 </span></span><br><span class="line">  ULONG Characteristics;<span class="comment">//设备特征 </span></span><br><span class="line">  <span class="keyword">volatile</span> PVPB Vpb;<span class="comment">//卷参数块。文件卷设备、物理卷设备都有一个Vpb,指向关联的卷信息 </span></span><br><span class="line">  PVOID DeviceExtension;<span class="comment">//关键。自定义设备扩展部分(紧跟在本结构体后面) </span></span><br><span class="line">  DEVICE_TYPE DeviceType;<span class="comment">//设备类型,与绑定的下层设备的设备类型相同 </span></span><br><span class="line">  CCHAR StackSize;<span class="comment">//设备栈中自本设备以下的栈层数(包含本层设备) </span></span><br><span class="line">  <span class="keyword">union</span> &#123; </span><br><span class="line">    LIST_ENTRY ListEntry;<span class="comment">//用来挂入全局的‘文件系统驱动cdo链表’ </span></span><br><span class="line">    WAIT_CONTEXT_BLOCK Wcb; </span><br><span class="line">  &#125; Queue; </span><br><span class="line">  ULONG AlignmentRequirement;<span class="comment">//对齐粒度 </span></span><br><span class="line">  KDEVICE_QUEUE DeviceQueue;<span class="comment">//本设备内置的irp队列,用于异步irp </span></span><br><span class="line">  KDPC Dpc; </span><br><span class="line">  ULONG ActiveThreadCount;<span class="comment">//用于卷设备,表示当前打开线程计数 </span></span><br><span class="line">  PSECURITY_DESCRIPTOR SecurityDescriptor;<span class="comment">//SD安全描述符 </span></span><br><span class="line">  KEVENT DeviceLock;<span class="comment">//  </span></span><br><span class="line">  USHORT SectorSize;<span class="comment">//扇区大小,用于卷设备(磁盘卷设备一般为512B,关盘卷设备为2048B) </span></span><br><span class="line">  <span class="comment">//内置的标准设备扩展部分(紧跟在自定义设备扩展后面) </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">EXTENDED_DEVOBJ_EXTENSION</span> *<span class="title">DeviceObjectExtension</span>;</span>  </span><br><span class="line">  PVOID Reserved; </span><br><span class="line">&#125; DEVICE_OBJECT, *PDEVICE_OBJECT; </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXTENDED_DEVOBJ_EXTENSION</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    CSHORT Type;<span class="comment">//结构类型 </span></span><br><span class="line">    USHORT Size;<span class="comment">//总设备扩展(自定义设备扩展+标准设备扩展)的长度 </span></span><br><span class="line">    PDEVICE_OBJECT DeviceObject;<span class="comment">//所属设备对象 </span></span><br><span class="line">    ULONG PowerFlags; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DEVICE_OBJECT_POWER_EXTENSION</span> *<span class="title">Dope</span>;</span> </span><br><span class="line">    ULONG ExtensionFlags; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_NODE</span> *<span class="title">DeviceNode</span>;</span><span class="comment">//设备节点(只有最底层的pdo才有设备节点) </span></span><br><span class="line">    PDEVICE_OBJECT AttachedTo;<span class="comment">//关键。最近一次绑到的下层设备 </span></span><br><span class="line">    LONG StartIoCount; </span><br><span class="line">    LONG StartIoKey; </span><br><span class="line">    ULONG StartIoFlags; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">VPB</span> *<span class="title">Vpb</span>;</span><span class="comment">//文件卷参数块 </span></span><br><span class="line">&#125; EXTENDED_DEVOBJ_EXTENSION, *PEXTENDED_DEVOBJ_EXTENSION;</span><br></pre></td></tr></table></figure>
<p>注意设备扩展由两部分组成：自定义设备扩展、标准设备扩展,共同构成设备扩展信息。 </p>
<h3 id="IRP"><a href="#IRP" class="headerlink" title="IRP"></a>IRP</h3><p>每个irp结构体后面紧跟一个数组,那就是irp的设备栈。<br>设备栈中的每一层叫栈层,数组中每个元素的类型为<code>IO_SATCK_LOCATION</code>表示的就是一个栈空间、一个栈层。</p>
<p>实际上我们可以把IRP结构理解为irp的头部,后面的额数组理解为irp的身体。<br>一个irp就是由一个irp头部和一个栈空间数组组成。<br>Irp头部中的<code>CurrentLocation</code>字段记录了该irp在各层驱动的处理进度。<br>该数组中第一个元素表示设备栈的栈底,最后一个元素表示栈顶。</p>
<p>每当将irp转发到下层设备时,irp头部中的<code>CurrentLocation</code>字段递减,而不是递增,就是因为这个缘故。 </p>
<p>每个栈空间用来主要用来记录该irp的主功能码,次功能码,参数,以及各层的完成函数<br>因为在应用程序一次宏观的irp请求中,各层的请求可能不尽相同。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span> &#123;</span> </span><br><span class="line">  CSHORT Type;<span class="comment">//结构类型 </span></span><br><span class="line">  USHORT Size;<span class="comment">//本irp的实际分配长度(包含后面的栈空间数组) </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">MDL</span> *<span class="title">MdlAddress</span>;</span><span class="comment">//关联的MDL链表 </span></span><br><span class="line">  ULONG Flags;<span class="comment">//irp标志 </span></span><br><span class="line">  <span class="keyword">union</span> &#123; </span><br><span class="line">    <span class="comment">//(一个irp可以分成n个子irp发给下层的驱动) </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span> *<span class="title">MasterIrp</span>;</span><span class="comment">//当该irp是子irp时表示所属的主irp </span></span><br><span class="line">    <span class="keyword">volatile</span> LONG IrpCount;<span class="comment">//当该irp是主irp时,表示子irp个数 </span></span><br><span class="line">    PVOID SystemBuffer;<span class="comment">//关联的系统缓冲 </span></span><br><span class="line">  &#125; AssociatedIrp; </span><br><span class="line">  </span><br><span class="line">  LIST_ENTRY ThreadListEntry;<span class="comment">//用来挂入线程的未决(指Pending)irp链表 </span></span><br><span class="line">  IO_STATUS_BLOCK IoStatus;<span class="comment">//该irp的完成结果(内置的) </span></span><br><span class="line">  KPROCESSOR_MODE RequestorMode;<span class="comment">//表示是来自用户模式还是内核模式的irp请求 </span></span><br><span class="line">  BOOLEAN PendingReturned;<span class="comment">//表示下层设备当初处理该irp时是否是Pending异步方式处理的 </span></span><br><span class="line">  CHAR StackCount;<span class="comment">//本irp的栈层数,也即本结构体后面的数组元素个数 </span></span><br><span class="line">  CHAR CurrentLocation;<span class="comment">//从上往下数,当前的栈空间位置序号(每个栈层就是一个栈空间) </span></span><br><span class="line">  BOOLEAN Cancel;<span class="comment">//表示用户是否发出了取消该irp的命令 </span></span><br><span class="line">  KIRQL CancelIrql;<span class="comment">//取消时的irql </span></span><br><span class="line">  CCHAR ApcEnvironment;<span class="comment">//该irp当初分配时,线程的apc状态(挂靠态/常态) </span></span><br><span class="line">  UCHAR AllocationFlags;<span class="comment">//用于保存当初分配该irp结构时的分配标志 </span></span><br><span class="line">  PIO_STATUS_BLOCK UserIosb;<span class="comment">//可为空。表示用户自己提供的一个结构,用来将完成结果返回给用户 </span></span><br><span class="line">  PKEVENT UserEvent;<span class="comment">//可为空。表示用户自己提供的irp完成事件 </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">union</span> &#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">      _ANONYMOUS_UNION <span class="keyword">union</span> &#123; </span><br><span class="line">        PIO_APC_ROUTINE UserApcRoutine;<span class="comment">//用户提供的APC例程 </span></span><br><span class="line">        PVOID IssuingProcess; </span><br><span class="line">      &#125; DUMMYUNIONNAME; </span><br><span class="line">      PVOID UserApcContext;<span class="comment">//APC例程的参数 </span></span><br><span class="line">    &#125; AsynchronousParameters; </span><br><span class="line">    LARGE_INTEGER AllocationSize;<span class="comment">//本结构当初分配时总的分配长度(包含后面的数组) </span></span><br><span class="line">  &#125; Overlay; </span><br><span class="line">  <span class="keyword">volatile</span> PDRIVER_CANCEL CancelRoutine;<span class="comment">//本irp关联的取消例程(取消时将执行这个函数) </span></span><br><span class="line">  PVOID UserBuffer;<span class="comment">//关联的用户空间缓冲区地址(直接使用可能不安全) </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">union</span> &#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">      _ANONYMOUS_UNION <span class="keyword">union</span> &#123; </span><br><span class="line">        KDEVICE_QUEUE_ENTRY DeviceQueueEntry;<span class="comment">//用来挂入设备对象内置的irp队列 </span></span><br><span class="line">        _ANONYMOUS_STRUCT <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">          PVOID DriverContext[<span class="number">4</span>]; </span><br><span class="line">        &#125; DUMMYSTRUCTNAME; </span><br><span class="line"> </span><br><span class="line">      &#125; DUMMYUNIONNAME; </span><br><span class="line">      PETHREAD Thread;<span class="comment">//该irp的发起者线程 </span></span><br><span class="line">      PCHAR AuxiliaryBuffer;<span class="comment">//关联的辅助缓冲 </span></span><br><span class="line">      _ANONYMOUS_STRUCT <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">        LIST_ENTRY ListEntry; </span><br><span class="line">        _ANONYMOUS_UNION <span class="keyword">union</span> &#123; </span><br><span class="line">          <span class="comment">//这个字段与CurrentLocation的作用一样,只是一个表示指针,一个表示序号 </span></span><br><span class="line">          <span class="class"><span class="keyword">struct</span> _<span class="title">IO_STACK_LOCATION</span> *<span class="title">CurrentStackLocation</span>;</span><span class="comment">//当前的栈空间位置 </span></span><br><span class="line">          ULONG PacketType; </span><br><span class="line">        &#125; DUMMYUNIONNAME; </span><br><span class="line">      &#125; DUMMYSTRUCTNAME; </span><br><span class="line">     <span class="comment">//irp本来是发给设备的,但是我们也可以看做是发给文件对象(各栈层可能有变动) </span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">FILE_OBJECT</span> *<span class="title">OriginalFileObject</span>;</span><span class="comment">//本irp最初发往的文件对象 </span></span><br><span class="line">    &#125; Overlay; </span><br><span class="line">    KAPC Apc;<span class="comment">//与本次irp相关的APC例程 </span></span><br><span class="line">    PVOID CompletionKey; </span><br><span class="line">  &#125; Tail; </span><br><span class="line">&#125; IRP, *PIRP;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_STACK_LOCATION</span> &#123;</span> </span><br><span class="line">  UCHAR MajorFunction;<span class="comment">//当irp下发到本层时的主功能码(下发过程一般维持不变) </span></span><br><span class="line">  UCHAR MinorFunction; <span class="comment">//当irp下发到本层时的次功能码(下发过程一般维持不变) </span></span><br><span class="line">  UCHAR Flags;<span class="comment">//本栈层的标志 </span></span><br><span class="line">  UCHAR Control;<span class="comment">//控制标志 </span></span><br><span class="line">  <span class="keyword">union</span> &#123; </span><br><span class="line">    … </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">      ULONG Length;<span class="comment">//读请求的长度 </span></span><br><span class="line">      ULONG POINTER_ALIGNMENT Key; </span><br><span class="line">      LARGE_INTEGER ByteOffset;<span class="comment">//读请求的文件偏移位置 </span></span><br><span class="line">    &#125; Read; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">      ULONG Length; <span class="comment">//写请求的长度 </span></span><br><span class="line">      ULONG POINTER_ALIGNMENT Key; </span><br><span class="line">      LARGE_INTEGER ByteOffset; <span class="comment">//写请求的文件偏移位置 </span></span><br><span class="line">    &#125; Write; </span><br><span class="line"> </span><br><span class="line">    … </span><br><span class="line">  &#125; Parameters;<span class="comment">//一个复杂的联合体,对应各种irp的参数 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  PDEVICE_OBJECT DeviceObject;<span class="comment">//本栈层的设备对象 </span></span><br><span class="line">  PFILE_OBJECT FileObject;<span class="comment">//关联的文件对象 </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//当本栈层完成该层的irp后,会回到上层调用上层的完成例程。</span></span><br><span class="line">  <span class="comment">// 这就是为什么在irp尚未完成的情况下贸然卸载上层驱动,会导致下层驱动调用上层的完成例程时因为完成例程无效而蓝屏崩溃。 </span></span><br><span class="line"></span><br><span class="line">  PIO_COMPLETION_ROUTINE CompletionRoutine;<span class="comment">//记录着上层的完成例程 </span></span><br><span class="line">  PVOID Context;<span class="comment">//完成例程的参数 </span></span><br><span class="line">&#125; IO_STACK_LOCATION, *PIO_STACK_LOCATION;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><h3 id="IoCreateDevice"><a href="#IoCreateDevice" class="headerlink" title="IoCreateDevice"></a>IoCreateDevice</h3><p>下面的函数用于创建一个设备对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCreateDevice</span><span class="params">(IN PDRIVER_OBJECT DriverObject,<span class="comment">//指定驱动(可以是其它第三方驱动) </span></span></span></span><br><span class="line"><span class="function"><span class="params">               IN ULONG DeviceExtensionSize,<span class="comment">//自定义设备扩展的大小 </span></span></span></span><br><span class="line"><span class="function"><span class="params">               IN PUNICODE_STRING DeviceName,<span class="comment">//设备对象的名字 </span></span></span></span><br><span class="line"><span class="function"><span class="params">               IN DEVICE_TYPE DeviceType,<span class="comment">//设备类型 </span></span></span></span><br><span class="line"><span class="function"><span class="params">               IN ULONG DeviceCharacteristics,<span class="comment">//设备特征 </span></span></span></span><br><span class="line"><span class="function"><span class="params">               IN BOOLEAN Exclusive,<span class="comment">//同一时刻是否只能被一个进程独占打开 </span></span></span></span><br><span class="line"><span class="function"><span class="params">               OUT PDEVICE_OBJECT *DeviceObject)</span><span class="comment">//返回 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    WCHAR AutoNameBuffer[<span class="number">20</span>]; PAGED_CODE();<span class="comment">//确保当前irql&lt;=PASSIVE_LEVEL </span></span><br><span class="line">    <span class="comment">//根据设备数量自动生成的设备名称 </span></span><br><span class="line">    <span class="keyword">if</span> (DeviceCharacteristics &amp; FILE_AUTOGENERATED_DEVICE_NAME) </span><br><span class="line">    &#123; </span><br><span class="line">        swprintf(AutoNameBuffer,<span class="string">L"\\Device\\%08lx"</span>, </span><br><span class="line">                 InterlockedIncrementUL(&amp;IopDeviceObjectNumber)); </span><br><span class="line">        RtlInitUnicodeString(&amp;AutoName, AutoNameBuffer); </span><br><span class="line">        DeviceName = &amp;AutoName; </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">    InitializeObjectAttributes(&amp;ObjectAttributes,DeviceName,OBJ_KERNEL_HANDLE,<span class="literal">NULL</span>,<span class="literal">NULL</span>); </span><br><span class="line">    <span class="comment">//if 同一时刻只能被一个进程独占打开 </span></span><br><span class="line">    <span class="keyword">if</span> (Exclusive) ObjectAttributes.Attributes |= OBJ_EXCLUSIVE; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设备对象永久存于对象目录中,直至对象被完全销毁 </span></span><br><span class="line">    <span class="keyword">if</span> (DeviceName) ObjectAttributes.Attributes |= OBJ_PERMANENT; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//向上对齐8B后的自定义设备扩展大小 </span></span><br><span class="line">    AlignedDeviceExtensionSize = (DeviceExtensionSize + <span class="number">7</span>) &amp;~ <span class="number">7</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//设备对象体的总长 </span></span><br><span class="line">    TotalSize = <span class="keyword">sizeof</span>(DEVICE_OBJECT) +      <span class="comment">//设备对象本身 </span></span><br><span class="line">                AlignedDeviceExtensionSize + <span class="comment">//自定义设备扩展部分 </span></span><br><span class="line">                <span class="keyword">sizeof</span>(EXTENDED_DEVOBJ_EXTENSION); <span class="comment">//标准设备扩展部分 </span></span><br><span class="line"> </span><br><span class="line">    *DeviceObject = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">//创建分配设备对象(在非分页池中) </span></span><br><span class="line">    Status = ObCreateObject(KernelMode,IoDeviceObjectType,&amp;ObjectAttributes,KernelMode,<span class="literal">NULL</span>, </span><br><span class="line">                            TotalSize,<span class="number">0</span>,<span class="number">0</span>, (PVOID*)&amp;CreatedDeviceObject); </span><br><span class="line">    RtlZeroMemory(CreatedDeviceObject, TotalSize); CreatedDeviceObject-&gt;Type = IO_TYPE_DEVICE;<span class="comment">//固定 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个长度值是设备对象自身的长度加上自定义设备扩展的长度 </span></span><br><span class="line">    CreatedDeviceObject-&gt;Size = <span class="keyword">sizeof</span>(DEVICE_OBJECT) + (USHORT)DeviceExtensionSize; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取得标准设备扩展部分的位置 </span></span><br><span class="line">    DeviceObjectExtension = ((ULONG)(CreatedDeviceObject + <span class="number">1</span>) +AlignedDeviceExtensionSize); </span><br><span class="line">    CreatedDeviceObject-&gt;DeviceObjectExtension = DeviceObjectExtension;<span class="comment">//记录位置 </span></span><br><span class="line">    DeviceObjectExtension-&gt;Type = IO_TYPE_DEVICE_OBJECT_EXTENSION;<span class="comment">//固定 </span></span><br><span class="line">    DeviceObjectExtension-&gt;Size = <span class="number">0</span>; </span><br><span class="line">    PoInitializeDeviceObject(DeviceObjectExtension);<span class="comment">//初始化电源管理器 </span></span><br><span class="line">    DeviceObjectExtension-&gt;DeviceObject = CreatedDeviceObject; </span><br><span class="line">     </span><br><span class="line">    CreatedDeviceObject-&gt;DeviceType = DeviceType; CreatedDeviceObject-&gt;Characteristics = DeviceCharacteristics; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录自定义设备扩展部分的位置 </span></span><br><span class="line">    CreatedDeviceObject-&gt;DeviceExtension = DeviceExtensionSize ? CreatedDeviceObject + <span class="number">1</span> :NU LL; </span><br><span class="line">    CreatedDeviceObject-&gt;StackSize = <span class="number">1</span>;<span class="comment">//注意：设备对象初始的栈层数都为1 </span></span><br><span class="line">    CreatedDeviceObject-&gt;AlignmentRequirement = <span class="number">0</span>; </span><br><span class="line">    CreatedDeviceObject-&gt;Flags = DO_DEVICE_INITIALIZING;<span class="comment">//标记设备对象正在初始化过程中 </span></span><br><span class="line">    <span class="keyword">if</span> (Exclusive) CreatedDeviceObject-&gt;Flags |= DO_EXCLUSIVE; </span><br><span class="line">    <span class="keyword">if</span> (DeviceName) CreatedDeviceObject-&gt;Flags |= DO_DEVICE_HAS_NAME; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//物理卷设备在创建时都会自动分配一个vpb(后面我们会看到,文件卷设备在绑定物理卷设备后,也 会记录对应的vpb) </span></span><br><span class="line">    <span class="keyword">if</span> ((CreatedDeviceObject-&gt;DeviceType == FILE_DEVICE_DISK) || </span><br><span class="line">        (CreatedDeviceObject-&gt;DeviceType == FILE_DEVICE_VIRTUAL_DISK) || </span><br><span class="line">        (CreatedDeviceObject-&gt;DeviceType == FILE_DEVICE_CD_ROM) || </span><br><span class="line">        (CreatedDeviceObject-&gt;DeviceType == FILE_DEVICE_TAPE)) </span><br><span class="line">    &#123; </span><br><span class="line">        Status = IopCreateVpb(CreatedDeviceObject); </span><br><span class="line">        KeInitializeEvent(&amp;CreatedDeviceObject-&gt;DeviceLock,SynchronizationEvent,TRUE); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//磁盘卷设备的扇区大小默认512B,光盘为2048B </span></span><br><span class="line">    <span class="keyword">switch</span> (DeviceType) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">case</span> FILE_DEVICE_DISK_FILE_SYSTEM: </span><br><span class="line">        <span class="keyword">case</span> FILE_DEVICE_DISK: </span><br><span class="line">        <span class="keyword">case</span> FILE_DEVICE_VIRTUAL_DISK: </span><br><span class="line">            CreatedDeviceObject-&gt;SectorSize  = <span class="number">512</span>; </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> FILE_DEVICE_CD_ROM_FILE_SYSTEM: </span><br><span class="line">            CreatedDeviceObject-&gt;SectorSize = <span class="number">2048</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//文件系统中cdo和文件卷都需要挂入相应的全局的链表中 </span></span><br><span class="line">    <span class="keyword">if</span> ((CreatedDeviceObject-&gt;DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) || <span class="comment">//cdo </span></span><br><span class="line">        (CreatedDeviceObject-&gt;DeviceType == FILE_DEVICE_FILE_SYSTEM) || <span class="comment">//文件卷 </span></span><br><span class="line">        (CreatedDeviceObject-&gt;DeviceType == FILE_DEVICE_CD_ROM_FILE_SYSTEM) || <span class="comment">//cdo </span></span><br><span class="line">        (CreatedDeviceObject-&gt;DeviceType == FILE_DEVICE_NETWORK_FILE_SYSTEM) || <span class="comment">//cdo </span></span><br><span class="line">        (CreatedDeviceObject-&gt;DeviceType == FILE_DEVICE_TAPE_FILE_SYSTEM)) <span class="comment">//cdo </span></span><br><span class="line">    &#123; </span><br><span class="line">        InitializeListHead(&amp;CreatedDeviceObject-&gt;Queue.ListEntry); </span><br><span class="line">    &#125; </span><br><span class="line">    Else<span class="comment">//其他的一般设备都有一个DeviceQueue表示irp队列。 </span></span><br><span class="line">    &#123; </span><br><span class="line">        KeInitializeDeviceQueue(&amp;CreatedDeviceObject-&gt;DeviceQueue); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入对象目录 </span></span><br><span class="line">    Status = ObInsertObject(CreatedDeviceObject,<span class="literal">NULL</span>,FILE_READ_DATA | FILE_WRITE_DATA, </span><br><span class="line">                            <span class="number">1</span>, (PVOID*)&amp;CreatedDeviceObject,&amp;TempHandle); </span><br><span class="line">    ObReferenceObject(DriverObject); </span><br><span class="line">    ASSERT((DriverObject-&gt;Flags &amp; DRVO_UNLOAD_INVOKED) == <span class="number">0</span>);<span class="comment">//确保驱动没在卸载当中 </span></span><br><span class="line">    CreatedDeviceObject-&gt;DriverObject = DriverObject; </span><br><span class="line">    IopEditDeviceList(DriverObject, CreatedDeviceObject, IopAdd);<span class="comment">//挂入驱动对象的设备链表头 </span></span><br><span class="line">    <span class="keyword">if</span> (CreatedDeviceObject-&gt;Vpb) PoVolumeDevice(CreatedDeviceObject);<span class="comment">//电源管理相关 </span></span><br><span class="line">    ObCloseHandle(TempHandle, KernelMode);<span class="comment">//关闭临时的设备句柄(因为我们不需要这个句柄) </span></span><br><span class="line">    *DeviceObject = CreatedDeviceObject;<span class="comment">//返回 </span></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IofCallDriver"><a href="#IofCallDriver" class="headerlink" title="IofCallDriver"></a>IofCallDriver</h3><p>设备对象是用来接收处理 irp 的,可以把一个 irp 发给任意设备对象。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意这个函数,是在上层驱动的上下文中调用 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IoCallDriver IofCallDriver </span></span><br><span class="line"><span class="function">NTSTATUS FASTCALL <span class="title">IofCallDriver</span><span class="params">(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PDRIVER_OBJECT DriverObject; </span><br><span class="line">    PIO_STACK_LOCATION StackPtr; </span><br><span class="line">    DriverObject = DeviceObject-&gt;DriverObject; </span><br><span class="line">    Irp-&gt;CurrentLocation--;<span class="comment">//当前栈层位置向下滑动,指向下层栈空间 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Irp-&gt;CurrentLocation &lt;= <span class="number">0</span>)<span class="comment">//CurrentLocation是序号,不是索引 </span></span><br><span class="line">        KeBugCheckEx(NO_MORE_IRP_STACK_LOCATIONS, (ULONG_PTR)Irp, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//蓝屏 </span></span><br><span class="line"></span><br><span class="line">    StackPtr = IoGetNextIrpStackLocation(Irp); </span><br><span class="line">    Irp-&gt;Tail.Overlay.CurrentStackLocation = StackPtr;<span class="comment">//当前栈空间指向了下层 </span></span><br><span class="line">    StackPtr-&gt;DeviceObject = DeviceObject;<span class="comment">//记录好下层的设备 </span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//关键。调用下层驱动对应irp的派遣函数 </span></span><br><span class="line">    <span class="keyword">return</span> DriverObject-&gt;MajorFunction[StackPtr-&gt;MajorFunction](DeviceObject,Irp); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上可以看到,上层驱动在调用这个函数,将<code>irp</code>发到下层设备时,会自动在内部将当前栈空间位置向下滑动一个位置,指向下层的栈空间。<br><code>ddk</code>提供了一个宏,用来移动<code>irp</code>的栈空间位</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IoSetNextIrpStackLocation(Irp) \ </span></span><br><span class="line">&#123; \ </span><br><span class="line">   Irp-&gt;CurrentLocation--;\   <span class="comment">//序号向下滑动一项 </span></span><br><span class="line">   Irp-&gt;Tail.Overlay.CurrentStackLocation--;\    <span class="comment">//数组元素指针也向下滑动一项 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的宏实际上获取的就是当前栈空间的位置 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IoGetCurrentIrpStackLocation(irp) irp-&gt;Tail.Overlay.CurrentStackLocation </span></span><br><span class="line"><span class="comment">// 下面的宏实际上获取的就是下层栈空间的位置 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IoGetNextIrpStackLocation(irp)  irp-&gt;Tail.Overlay.CurrentStackLocation – 1</span></span><br></pre></td></tr></table></figure>
<h3 id="NtDeviceIoControlFile"><a href="#NtDeviceIoControlFile" class="headerlink" title="NtDeviceIoControlFile"></a>NtDeviceIoControlFile</h3><p>应用程序常常调用<code>DeviceIoControl</code>这个 API 与设备驱动通信,它实际上调用<code>NtDeviceIoControlFile</code>这个系统服务 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtDeviceIoControlFile</span><span class="params">(IN HANDLE DeviceHandle,<span class="comment">//实际上应该叫hFile </span></span></span></span><br><span class="line"><span class="function"><span class="params">                      IN HANDLE Event OPTIONAL,<span class="comment">//用户自己提供的irp完成事件 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                      IN PIO_APC_ROUTINE UserApcRoutine OPTIONAL,<span class="comment">//用户提供的APC例程 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                      IN PVOID UserApcContext OPTIONAL,<span class="comment">//APC参数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                      OUT PIO_STATUS_BLOCK IoStatusBlock,<span class="comment">//用户自己提供的Io状态块 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                      IN ULONG IoControlCode, </span></span></span><br><span class="line"><span class="function"><span class="params">                      IN PVOID InputBuffer, </span></span></span><br><span class="line"><span class="function"><span class="params">                      IN ULONG InputBufferLength OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">                      OUT PVOID OutputBuffer, </span></span></span><br><span class="line"><span class="function"><span class="params">                      IN ULONG OutputBufferLength OPTIONAL)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> IopDeviceFsIoControl(DeviceHandle,Event,UserApcRoutine,UserApcContext, </span><br><span class="line">                                IoStatusBlock,IoControlCode,InputBuffer,InputBufferLength, </span><br><span class="line">                                OutputBuffer,OutputBufferLength, </span><br><span class="line">                                TRUE);<span class="comment">//表示是普通的DeviceIoControl请求 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>必须注意<code>DeviceHandle</code>参数应该叫做文件句柄而不是设备句柄。<br>在 Windows 内核中,几乎从来没有<code>设备句柄</code>这种概念。<br>虽然可以为设备对象创建一个设备句柄,但很少这么做,因为设备句柄几乎没有什么作用。<br>相反应用程序一般都是调用<code>CreateFile</code>(它内部会打开设备对象,创建文件对象,返回文件对象 的句柄)<br>以后就可以用这个文件句柄,找到对应的文件对象及其设备对象去访问设备了。 </p>
<p>上面函数在调用时,用户可以提供一个<code>Event</code>和<code>IoStatusBlock</code><br>当 irp 完成时,就会触发用户提供的这个事件,然后返回完成结果到用户提供的<code>IoStatusBlock</code>中。<br>用户还可以提供 apc 例程,irp 在完成后会自动将这个 apc 插入到线程的用户 apc 队列中,然后返回用户空间时执行这个 apc。 </p>
<h4 id="IopDeviceFsIoControl"><a href="#IopDeviceFsIoControl" class="headerlink" title="IopDeviceFsIoControl"></a>IopDeviceFsIoControl</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IopDeviceFsIoControl</span><span class="params">(IN HANDLE DeviceHandle,IN HANDLE Event OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">                     IN PIO_APC_ROUTINE UserApcRoutine OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">                     IN PVOID UserApcContext OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">                     OUT PIO_STATUS_BLOCK IoStatusBlock,IN ULONG IoControlCode, </span></span></span><br><span class="line"><span class="function"><span class="params">                     IN PVOID InputBuffer,IN ULONG InputBufferLength OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">                     OUT PVOID OutputBuffer,IN ULONG OutputBufferLength OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">                     IN BOOLEAN IsDevIoCtl)</span><span class="comment">//表示是否是普通的DeviceIoControl </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PKEVENT EventObject = <span class="literal">NULL</span>; </span><br><span class="line">    BOOLEAN LockedForSynch = FALSE; </span><br><span class="line">    KPROCESSOR_MODE PreviousMode = ExGetPreviousMode(); </span><br><span class="line">    AccessType = IO_METHOD_FROM_CTL_CODE(IoControlCode);<span class="comment">//提取io控制码里面的io方式 </span></span><br><span class="line">    <span class="keyword">if</span> (PreviousMode != KernelMode) 检查用户空间地址是否可读可写,略 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得文件句柄对应的文件对象 </span></span><br><span class="line">    Status = ObReferenceObjectByHandle(DeviceHandle,<span class="number">0</span>,IoFileObjectType,PreviousMode, </span><br><span class="line">                                       (PVOID*)&amp;FileObject,&amp;HandleInformation); </span><br><span class="line">    <span class="comment">//Io完成端口不支持APC </span></span><br><span class="line">    <span class="keyword">if</span> ((FileObject-&gt;CompletionContext) &amp;&amp; (UserApcRoutine)) </span><br><span class="line">    &#123; </span><br><span class="line">        ObDereferenceObject(FileObject); </span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (PreviousMode != KernelMode) </span><br><span class="line">    &#123; </span><br><span class="line">        DesiredAccess = (ACCESS_MASK)((IoControlCode &gt;&gt; <span class="number">14</span>) &amp; <span class="number">3</span>);<span class="comment">//提取io控制码中的访问权限 </span></span><br><span class="line">        <span class="comment">//检查访问权限 </span></span><br><span class="line">        <span class="keyword">if</span> ((DesiredAccess != FILE_ANY_ACCESS) &amp;&amp; </span><br><span class="line">            (HandleInformation.GrantedAccess &amp; DesiredAccess) != DesiredAccess) </span><br><span class="line">        &#123; </span><br><span class="line">            ObDereferenceObject(FileObject); </span><br><span class="line">            <span class="keyword">return</span> STATUS_ACCESS_DENIED; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (Event)<span class="comment">//将用户提供的irp完成事件初始化为无信号状态 </span></span><br><span class="line">    &#123; </span><br><span class="line">        Status = ObReferenceObjectByHandle(Event,EVENT_MODIFY_STATE,ExEventObjectType, </span><br><span class="line">                                           PreviousMode, (PVOID*)&amp;EventObject,<span class="literal">NULL</span>); </span><br><span class="line">        KeClearEvent(EventObject); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (FileObject-&gt;Flags &amp; FO_SYNCHRONOUS_IO) </span><br><span class="line">    &#123; </span><br><span class="line"> </span><br><span class="line">        IopLockFileObject(FileObject); </span><br><span class="line">        LockedForSynch = TRUE;<span class="comment">//标记当初打开设备时,是同步方式 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//一般的设备都是直接打开的,上面没有绑定文件卷设备,若是这样,获取栈顶的设备 </span></span><br><span class="line">    <span class="keyword">if</span> (FileObject-&gt;Flags &amp; FO_DIRECT_DEVICE_OPEN) </span><br><span class="line">        DeviceObject = IoGetAttachedDevice(FileObject-&gt;DeviceObject); </span><br><span class="line">    Else <span class="comment">//物理卷设备可能不是直接打开的,上面绑定有文件卷设备,若是这样,就获取栈顶的文件卷 </span></span><br><span class="line">        DeviceObject = IoGetRelatedDeviceObject(FileObject); </span><br><span class="line"></span><br><span class="line">    KeClearEvent(&amp;FileObject-&gt;Event);<span class="comment">//文件对象内部的那个内置事件也初始化为无信号状态 </span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//关键。由IO管理器分配、生成一个irp(注意初始时,该irp的当前栈空间位置在栈顶的上面) </span></span><br><span class="line">    <span class="comment">//注意irp的StackSize就是栈顶设备的StackSize </span></span><br><span class="line">    Irp = IoAllocateIrp(DeviceObject-&gt;StackSize, FALSE); </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是irp的初始化,这部分可由我们自行完成(前提是必须熟悉irp中各个字段的含义) </span></span><br><span class="line">    Irp-&gt;UserIosb = IoStatusBlock;<span class="comment">//记录用户自提供的io状态块 </span></span><br><span class="line">    Irp-&gt;UserEvent = EventObject;<span class="comment">//记录用户自提供的的irp完成事件 </span></span><br><span class="line">    Irp-&gt;Overlay.AsynchronousParameters.UserApcRoutine = UserApcRoutine;<span class="comment">//记录用户提供的APC </span></span><br><span class="line">    Irp-&gt;Overlay.AsynchronousParameters.UserApcContext = UserApcContext; </span><br><span class="line">    Irp-&gt;Cancel = FALSE;<span class="comment">//初始时尚未被用户取消 </span></span><br><span class="line">    Irp-&gt;CancelRoutine = <span class="literal">NULL</span>;<span class="comment">//初始时无取消例程 </span></span><br><span class="line">    Irp-&gt;PendingReturned = FALSE;<span class="comment">//下层尚未Pending返回 </span></span><br><span class="line">    Irp-&gt;RequestorMode = PreviousMode;<span class="comment">//来自指定模式的irp请求 </span></span><br><span class="line">    Irp-&gt;MdlAddress = <span class="literal">NULL</span>;<span class="comment">//由具体的io方式决定 </span></span><br><span class="line">    Irp-&gt;AssociatedIrp.SystemBuffer = <span class="literal">NULL</span>; <span class="comment">//由具体的io方式决定 </span></span><br><span class="line">    Irp-&gt;Flags = <span class="number">0</span>; </span><br><span class="line">    Irp-&gt;Tail.Overlay.AuxiliaryBuffer = <span class="literal">NULL</span>; </span><br><span class="line">    Irp-&gt;Tail.Overlay.OriginalFileObject = FileObject;<span class="comment">//最初发往的文件对象 </span></span><br><span class="line">    Irp-&gt;Tail.Overlay.Thread = PsGetCurrentThread();<span class="comment">//该irp的发起者线程 </span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//此时的下层栈空间位置也即栈顶位置(指第一个栈空间) </span></span><br><span class="line">    <span class="comment">//在下发irp前,先构造好下层栈空间中的功能码和参数 </span></span><br><span class="line">    StackPtr = IoGetNextIrpStackLocation(Irp); </span><br><span class="line">    StackPtr-&gt;FileObject = FileObject; </span><br><span class="line">    StackPtr-&gt;MajorFunction = IsDevIoCtl ? </span><br><span class="line">                              IRP_MJ_DEVICE_CONTROL :<span class="comment">//普通的控制请求irp </span></span><br><span class="line">                              IRP_MJ_FILE_SYSTEM_CONTROL;<span class="comment">//专用于文件系统cdo的控制请求irp </span></span><br><span class="line">    StackPtr-&gt;MinorFunction = <span class="number">0</span>; </span><br><span class="line">    StackPtr-&gt;Control = <span class="number">0</span>; </span><br><span class="line">    StackPtr-&gt;Flags = <span class="number">0</span>; </span><br><span class="line">    StackPtr-&gt;Parameters.DeviceIoControl.Type3InputBuffer = <span class="literal">NULL</span>; </span><br><span class="line"> </span><br><span class="line">    StackPtr-&gt;Parameters.DeviceIoControl.IoControlCode = IoControlCode; </span><br><span class="line">    StackPtr-&gt;Parameters.DeviceIoControl.InputBufferLength = InputBufferLength; </span><br><span class="line">    StackPtr-&gt;Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength; </span><br><span class="line">    <span class="keyword">switch</span> (AccessType)<span class="comment">//检查该控制请求irp的io方式 </span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">case</span> METHOD_BUFFERED:<span class="comment">//若是缓冲方式,就由系统分配一个内核缓冲 </span></span><br><span class="line">            _SEH2_TRY </span><br><span class="line">            &#123; </span><br><span class="line">                BufferLength = max(InputBufferLength , OutputBufferLength); </span><br><span class="line">                <span class="keyword">if</span> (BufferLength) </span><br><span class="line">                &#123; </span><br><span class="line">                    Irp-&gt;AssociatedIrp.SystemBuffer = ExAllocatePoolWithTag(NonPagedPool,BufferLength,TAG_SYS_BUF); </span><br><span class="line">                    <span class="keyword">if</span> (InputBuffer) </span><br><span class="line">                    &#123; </span><br><span class="line">                        RtlCopyMemory(Irp-&gt;AssociatedIrp.SystemBuffer,InputBuffer, </span><br><span class="line">                                      InputBufferLength); </span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//标记该irp是缓冲io方式,并且完成时需要释放内核缓冲 </span></span><br><span class="line">                    Irp-&gt;Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER; </span><br><span class="line">                    <span class="keyword">if</span> (OutputBuffer) Irp-&gt;Flags |= IRP_INPUT_OPERATION; </span><br><span class="line">                    Irp-&gt;UserBuffer = OutputBuffer; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">            _SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">            &#123; </span><br><span class="line">                IopCleanupAfterException(FileObject, Irp, EventObject, <span class="literal">NULL</span>); </span><br><span class="line">                _SEH2_YIELD(<span class="keyword">return</span> _SEH2_GetExceptionCode()); </span><br><span class="line">            &#125; </span><br><span class="line">            _SEH2_END; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> METHOD_IN_DIRECT: </span><br><span class="line">        <span class="keyword">case</span> METHOD_OUT_DIRECT: </span><br><span class="line">            _SEH2_TRY </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> ((InputBufferLength) &amp;&amp; (InputBuffer))<span class="comment">//输入缓冲固定不能使用直接io方式 </span></span><br><span class="line">                &#123; </span><br><span class="line">                    Irp-&gt;AssociatedIrp.SystemBuffer = ExAllocatePoolWithTag(NonPagedPool,InputBufferLength,TAG_SYS_BUF); </span><br><span class="line">                    RtlCopyMemory(Irp-&gt;AssociatedIrp.SystemBuffer,InputBuffer, </span><br><span class="line">                                  InputBufferLength); </span><br><span class="line">                    Irp-&gt;Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER; </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span> (OutputBuffer)<span class="comment">//输出缓冲可使用直接io方式(mdl方式) </span></span><br><span class="line"> </span><br><span class="line">                &#123; </span><br><span class="line">                    Irp-&gt;MdlAddress = IoAllocateMdl(OutputBuffer,OutputBufferLength, </span><br><span class="line">                                                    FALSE,FALSE,Irp); </span><br><span class="line">                    MmProbeAndLockPages(Irp-&gt;MdlAddress,PreviousMode, </span><br><span class="line">                            (AccessType == METHOD_IN_DIRECT) ?IoReadAccess : IoWriteAccess); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">            _SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">            &#123; </span><br><span class="line">                IopCleanupAfterException(FileObject, Irp, EventObject, <span class="literal">NULL</span>); </span><br><span class="line">                _SEH2_YIELD(<span class="keyword">return</span> _SEH2_GetExceptionCode()); </span><br><span class="line">            &#125; </span><br><span class="line">            _SEH2_END; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">case</span> METHOD_NEITHER: </span><br><span class="line">            Irp-&gt;UserBuffer = OutputBuffer; </span><br><span class="line">            StackPtr-&gt;Parameters.DeviceIoControl.Type3InputBuffer = InputBuffer;<span class="comment">//第三类方式 </span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//发给文件系统cdo设备的控制请求都会延迟完成 </span></span><br><span class="line">    Irp-&gt;Flags |= (!IsDevIoCtl) ? IRP_DEFER_IO_COMPLETION : <span class="number">0</span>; </span><br><span class="line">    <span class="comment">//发送该irp,异步返回或同步等待完成 </span></span><br><span class="line">    <span class="keyword">return</span> IopPerformSynchronousRequest(DeviceObject,Irp,FileObject,!IsDevIoCtl, </span><br><span class="line">                                        PreviousMode,LockedForSynch,IopOtherTransfer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这儿要强调下,为什么设备栈栈顶的过滤设备能最先得到irp？</p>
<p>根本原因就是io管理器在将irp发给设备时,并不是直接发给当初<code>CreateFile</code>打开的额那个设备,而是要先调用<code>IoGetAttachedDevice</code>/<code>I oGetRelatedDeviceObject</code>这两个关键函数获得栈顶的设备,然后将irp发给它。 </p>
<h4 id="IoGetAttachedDevice"><a href="#IoGetAttachedDevice" class="headerlink" title="IoGetAttachedDevice"></a>IoGetAttachedDevice</h4><p>下面的函数用来获取设备栈栈顶的设备<code>PDEVICE_OBJECT</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PDEVICE_OBJECT <span class="title">IoGetAttachedDevice</span><span class="params">(PDEVICE_OBJECT DeviceObject)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (DeviceObject-&gt;AttachedDevice) </span><br><span class="line">        DeviceObject = DeviceObject-&gt;AttachedDevice; </span><br><span class="line">    <span class="keyword">return</span> DeviceObject; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的函数用来获取文件对象关联设备的设备栈栈顶的设备(用于文件系统)                                         </span></span><br><span class="line"><span class="function">PDEVICE_OBJECT <span class="title">IoGetRelatedDeviceObject</span><span class="params">(IN PFILE_OBJECT FileObject)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PDEVICE_OBJECT DeviceObject = FileObject-&gt;DeviceObject;<span class="comment">//先获得当初打开的设备 </span></span><br><span class="line">    <span class="keyword">if</span> ((FileObject-&gt;Vpb) &amp;&amp; (FileObject-&gt;Vpb-&gt;DeviceObject))<span class="comment">//if打开卷设备产生的文件对象 </span></span><br><span class="line">    &#123; </span><br><span class="line">        ASSERT(!(FileObject-&gt;Flags &amp; FO_DIRECT_DEVICE_OPEN)); </span><br><span class="line"> </span><br><span class="line">        DeviceObject = FileObject-&gt;Vpb-&gt;DeviceObject;<span class="comment">//文件卷设备 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//最典型,若是打开物理卷设备产生的文件对象,并且上面绑定有文件卷设备 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!(FileObject-&gt;Flags &amp; FO_DIRECT_DEVICE_OPEN) &amp;&amp; </span><br><span class="line">              (FileObject-&gt;DeviceObject-&gt;Vpb) &amp;&amp; </span><br><span class="line">              (FileObject-&gt;DeviceObject-&gt;Vpb-&gt;DeviceObject)) </span><br><span class="line">    &#123; </span><br><span class="line">        DeviceObject = FileObject-&gt;DeviceObject-&gt;Vpb-&gt;DeviceObject;<span class="comment">//文件卷设备 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        DeviceObject = FileObject-&gt;DeviceObject;<span class="comment">//当初直接打开的物理卷设备或其他普通设备 </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (DeviceObject-&gt;AttachedDevice) </span><br><span class="line">    &#123; </span><br><span class="line">        DeviceObject = IoGetAttachedDevice(DeviceObject);<span class="comment">//目标设备栈的栈顶设备 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> DeviceObject; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数一般用于文件系统。<br>物理卷设备往往不是直接打开的,它上面一般都会绑定着一个文件卷设备。<br>但是文件卷与物理卷之间的绑定关系没有形式上绑定(也即不是通过设备对象的<code>AttachedDevice</code>字段来维护绑定关系),而是通过一个<code>vpb</code> 来记录他们之间的绑定关系。<br>物理卷设备所在的设备栈与文件卷设备所在的设备栈是两个不同的设备栈。<br>这样<code>IoGetAttachedDevice</code>就没法获得文件卷设备栈的栈顶对象,需要通过<code>IoGetRelatedDeviceObject</code>这个专用的函数来获得绑定了物理卷设备的最上面的文件卷设备。 </p>
<p><br></p>
<h3 id="IoAllocateIrp"><a href="#IoAllocateIrp" class="headerlink" title="IoAllocateIrp"></a>IoAllocateIrp</h3><p>所有 irp 都是由 io 管理器分配生成的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">PIRP </span><br><span class="line">IoAllocateIrp(IN CCHAR StackSize,<span class="comment">//指该irp包含的栈层数 </span></span><br><span class="line">              IN BOOLEAN ChargeQuota)<span class="comment">//指是否计较内存配额浪费,一般传FALSE </span></span><br><span class="line">&#123; </span><br><span class="line">    PIRP Irp = <span class="literal">NULL</span>; </span><br><span class="line">    USHORT Size;<span class="comment">//该irp的实际需要分配的长度 </span></span><br><span class="line">    PKPRCB Prcb; </span><br><span class="line">    UCHAR Flags = <span class="number">0</span>; </span><br><span class="line">    PNPAGED_LOOKASIDE_LIST List = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line">    PP_NPAGED_LOOKASIDE_NUMBER ListType = LookasideSmallIrpList;<span class="comment">//irp容器类型 </span></span><br><span class="line">    Size = IoSizeOfIrp(StackSize);<span class="comment">//获得irp的有效长度 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ChargeQuota) </span><br><span class="line">        Flags |= IRP_QUOTA_CHARGED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果栈层数小于等于8又不计较配额浪费,那么就从预置的irp容器分配 </span></span><br><span class="line">    <span class="keyword">if</span> ((StackSize &lt;= <span class="number">8</span>) &amp;&amp; (ChargeQuota == FALSE))  </span><br><span class="line">    &#123; </span><br><span class="line">        Flags = IRP_ALLOCATED_FIXED_SIZE;<span class="comment">//标记为分配的是固定长度 </span></span><br><span class="line">        <span class="keyword">if</span> (StackSize != <span class="number">1</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            Size = IoSizeOfIrp(<span class="number">8</span>);<span class="comment">//对齐8个栈层大小 </span></span><br><span class="line"> </span><br><span class="line">            ListType = LookasideLargeIrpList;<span class="comment">//改用8号irp容器 </span></span><br><span class="line">        &#125; </span><br><span class="line">        Prcb = KeGetCurrentPrcb(); </span><br><span class="line">        <span class="comment">//先尝试从该容器的P链表中分配出一个irp </span></span><br><span class="line">        List = (PNPAGED_LOOKASIDE_LIST)Prcb-&gt;PPLookasideList[ListType].P; </span><br><span class="line">        List-&gt;L.TotalAllocates++;<span class="comment">//递增该链表总的分配请求计数 </span></span><br><span class="line">        Irp = (PIRP)InterlockedPopEntrySList(&amp;List-&gt;L.ListHead);<span class="comment">//分配 </span></span><br><span class="line">        <span class="keyword">if</span> (!Irp)<span class="comment">//if 分配失败 </span></span><br><span class="line">        &#123; </span><br><span class="line">            List-&gt;L.AllocateMisses++;<span class="comment">//递增该链表的分配失败计数 </span></span><br><span class="line">            <span class="comment">//再尝试从该容器的L链表中分配出一个irp </span></span><br><span class="line">            List = (PNPAGED_LOOKASIDE_LIST)Prcb-&gt;PPLookasideList[ListType].L; </span><br><span class="line">            List-&gt;L.TotalAllocates++;<span class="comment">//递增该链表总的分配请求计数 </span></span><br><span class="line">            Irp = (PIRP)InterlockedPopEntrySList(&amp;List-&gt;L.ListHead); <span class="comment">//分配 </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!Irp)<span class="comment">//如果仍然分配失败或者尚未分配 </span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//if 从L链表中分配失败 </span></span><br><span class="line">        <span class="keyword">if</span> (Flags &amp; IRP_ALLOCATED_FIXED_SIZE) List-&gt;L.AllocateMisses++;<span class="comment">//递增分配失败计数 </span></span><br><span class="line">        Irp = ExAllocatePoolWithTag(NonPagedPool, Size, TAG_IRP);<span class="comment">//直接从非分页池中分配 </span></span><br><span class="line">    &#125; </span><br><span class="line">    Else     </span><br><span class="line">        Flags &amp;= ~IRP_QUOTA_CHARGED; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分配完irp后,做一些基本的初始化 </span></span><br><span class="line">    IoInitializeIrp(Irp, Size, StackSize);  </span><br><span class="line">    Irp-&gt;AllocationFlags = Flags;<span class="comment">//记录分配标志 </span></span><br><span class="line">    <span class="keyword">return</span> Irp; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IoSizeOfIrp(_StackSize) sizeof(IRP) + _StackSize * sizeof(IO_STACK_LOCATION)</span></span><br></pre></td></tr></table></figure>
<p>如上由于 irp 频繁分配,所以内核中准备了两个 irp 容器。<br>一个单层的 irp 容器、一个 8 层的 irp 容器。<br>当 irp 栈层数小于等于 8 时,并且不计较配额浪费时,就从容器中分配 irp 结构,这样能加快分配速度。<br>Irp 分配后,系统内部会做一些基本的初始化</p>
<h4 id="IoInitializeIrp"><a href="#IoInitializeIrp" class="headerlink" title="IoInitializeIrp"></a>IoInitializeIrp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">IoInitializeIrp</span><span class="params">(IN PIRP Irp, </span></span></span><br><span class="line"><span class="function"><span class="params">                IN USHORT PacketSize,<span class="comment">//实际分配的长度 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN CCHAR StackSize)</span><span class="comment">//栈层数 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    RtlZeroMemory(Irp, PacketSize);<span class="comment">//整个结构全部清0 </span></span><br><span class="line">    Irp-&gt;Type = IO_TYPE_IRP; </span><br><span class="line">    Irp-&gt;Size = PacketSize; </span><br><span class="line">    Irp-&gt;StackCount = StackSize; </span><br><span class="line">    Irp-&gt;CurrentLocation = StackSize + <span class="number">1</span>;<span class="comment">//初始栈空间位置在栈顶的上面 </span></span><br><span class="line">    Irp-&gt;Tail.Overlay.CurrentStackLocation = (PIO_STACK_LOCATION)(Irp + <span class="number">1</span>) + StackSize; </span><br><span class="line">    Irp-&gt;ApcEnvironment = KeGetCurrentThread()-&gt;ApcStateIndex; </span><br><span class="line"> </span><br><span class="line">    InitializeListHead(&amp;Irp-&gt;ThreadListEntry);<span class="comment">//用来挂入线程的irp链表 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IopDeviceFsIoControl</code>函数内部会调用下面的函数来将构造好的 irp 发到目标设备,并且异步返回或者同步等待处理完毕后再返回。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IopPerformSynchronousRequest</span><span class="params">(IN PDEVICE_OBJECT DeviceObject, </span></span></span><br><span class="line"><span class="function"><span class="params">                             IN PIRP Irp, </span></span></span><br><span class="line"><span class="function"><span class="params">                             IN PFILE_OBJECT FileObject, </span></span></span><br><span class="line"><span class="function"><span class="params">                             IN BOOLEAN Deferred, </span></span></span><br><span class="line"><span class="function"><span class="params">                             IN KPROCESSOR_MODE PreviousMode, </span></span></span><br><span class="line"><span class="function"><span class="params">                             IN BOOLEAN SynchIo,<span class="comment">//关键参数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                             IN IOP_TRANSFER_TYPE TransferType)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    NTSTATUS Status; </span><br><span class="line">    PKNORMAL_ROUTINE NormalRoutine; </span><br><span class="line">    PVOID NormalContext; </span><br><span class="line">    KIRQL OldIrql; </span><br><span class="line">    PAGED_CODE(); </span><br><span class="line">    IopQueueIrpToThread(Irp);<span class="comment">//将irp挂入线程的pending irp链表中 </span></span><br><span class="line">    IopUpdateOperationCount(TransferType); </span><br><span class="line">    Status = IoCallDriver(DeviceObject, Irp);<span class="comment">//将irp发给指定的设备 </span></span><br><span class="line">    <span class="keyword">if</span> (Deferred)<span class="comment">//很多irp请求都需要延迟完成 </span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (Status != STATUS_PENDING) </span><br><span class="line">        &#123; </span><br><span class="line">            ASSERT(!Irp-&gt;PendingReturned); </span><br><span class="line">            KeRaiseIrql(APC_LEVEL, &amp;OldIrql); </span><br><span class="line">            <span class="comment">//IoCompleteRequest的后半工作 </span></span><br><span class="line">            IopCompleteRequest(&amp;Irp-&gt;Tail.Apc,&amp;NormalRoutine,&amp;NormalContext, </span><br><span class="line">                               (PVOID*)&amp;FileObject,&amp;NormalContext); </span><br><span class="line">            KeLowerIrql(OldIrql); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//if文件对象当初在CreateFile打开设备时,声明的是同步IO方式,以后的每次irp就一直等待完成后 才返回退出函数 </span></span><br><span class="line">    <span class="keyword">if</span> (SynchIo) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (Status == STATUS_PENDING)<span class="comment">//即使下层驱动是异步完成的,也要一直等到其完成后再返回 </span></span><br><span class="line">        &#123; </span><br><span class="line">            Status = KeWaitForSingleObject(&amp;FileObject-&gt;Event,<span class="comment">//等待文件对象的内置完成事件 </span></span><br><span class="line">                                           Executive,PreviousMode, </span><br><span class="line">                                           (FileObject-&gt;Flags &amp; FO_ALERTABLE_IO),<span class="comment">//Alertable </span></span><br><span class="line">                                           <span class="literal">NULL</span>); </span><br><span class="line"> </span><br><span class="line">            <span class="comment">//如果是被用户apc或者强制唤醒要求给强制唤醒的,就夭折该次irp </span></span><br><span class="line">            <span class="keyword">if</span> ((Status == STATUS_ALERTED) || (Status == STATUS_USER_APC)) </span><br><span class="line">                IopAbortInterruptedIrp(&amp;FileObject-&gt;Event, Irp); </span><br><span class="line">            Status = FileObject-&gt;FinalStatus; </span><br><span class="line">        &#125; </span><br><span class="line">        IopUnlockFileObject(FileObject); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上,这个函数将 irp 发给指定设备,然后立即返回或者等到其完成后再返回<br>下面这个函数用来将 irp 挂入线程的<code>pending irp</code>链表(当线程终止时,会自动扫描它的<code>pending irp</code>链表,调用<code>IoCancelIrp</code>一一给予取消) </p>
<h4 id="IopQueueIrpToThread"><a href="#IopQueueIrpToThread" class="headerlink" title="IopQueueIrpToThread"></a>IopQueueIrpToThread</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID  <span class="title">IopQueueIrpToThread</span><span class="params">(IN PIRP Irp)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    KIRQL OldIrql; </span><br><span class="line">    KeRaiseIrql(APC_LEVEL, &amp;OldIrql); </span><br><span class="line">    InsertHeadList(&amp;Irp-&gt;Tail.Overlay.Thread-&gt;IrpList, &amp;Irp-&gt;ThreadListEntry); </span><br><span class="line">    KeLowerIrql(OldIrql); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IoCancelIrp"><a href="#IoCancelIrp" class="headerlink" title="IoCancelIrp"></a>IoCancelIrp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN  <span class="title">IoCancelIrp</span><span class="params">(IN PIRP Irp)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    KIRQL OldIrql; </span><br><span class="line">    PDRIVER_CANCEL CancelRoutine; </span><br><span class="line">    IoAcquireCancelSpinLock(&amp;OldIrql);<span class="comment">//锁定 </span></span><br><span class="line">    Irp-&gt;Cancel = TRUE;<span class="comment">//标记该irp已被用户发起了取消请求 </span></span><br><span class="line">    CancelRoutine = (PVOID)IoSetCancelRoutine(Irp, <span class="literal">NULL</span>);<span class="comment">//获得该irp的取消例程 </span></span><br><span class="line">    <span class="keyword">if</span> (CancelRoutine)<span class="comment">//if 那个irp设有取消例程,就调用 </span></span><br><span class="line">    &#123; </span><br><span class="line">        Irp-&gt;CancelIrql = OldIrql; </span><br><span class="line">        CancelRoutine(IoGetCurrentIrpStackLocation(Irp)-&gt;DeviceObject, Irp);<span class="comment">//调用取消例程 </span></span><br><span class="line">        <span class="keyword">return</span> TRUE; </span><br><span class="line">    &#125; </span><br><span class="line">    IoReleaseCancelSpinLock(OldIrql); </span><br><span class="line">    <span class="keyword">return</span> FALSE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="IoAttachDevice-设备的绑定"><a href="#IoAttachDevice-设备的绑定" class="headerlink" title="IoAttachDevice(设备的绑定)"></a>IoAttachDevice(设备的绑定)</h3><p>设备的绑定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoAttachDevice</span><span class="params">(PDEVICE_OBJECT SourceDevice,<span class="comment">//我们的设备 </span></span></span></span><br><span class="line"><span class="function"><span class="params">               PUNICODE_STRING TargetDeviceName,<span class="comment">//要绑定的目标设备的名字 </span></span></span></span><br><span class="line"><span class="function"><span class="params">               PDEVICE_OBJECT *AttachedDevice)</span><span class="comment">//返回实际绑定的原栈顶设备 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   NTSTATUS Status; </span><br><span class="line"> </span><br><span class="line">   PFILE_OBJECT FileObject = <span class="literal">NULL</span>; </span><br><span class="line">   PDEVICE_OBJECT TargetDevice = <span class="literal">NULL</span>; </span><br><span class="line">   <span class="comment">//先根据名称获得目标设备对象 </span></span><br><span class="line">    Status = IopGetDeviceObjectPointer(TargetDeviceName,FILE_READ_ATTRIBUTES, </span><br><span class="line">                                       &amp;FileObject,&amp;TargetDevice,IO_ATTACH_DEVICE_API); </span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">return</span> Status; </span><br><span class="line"></span><br><span class="line">    Status = IoAttachDeviceToDeviceStackSafe(SourceDevice,TargetDevice,AttachedDevice); </span><br><span class="line">    ObDereferenceObject(FileObject); </span><br><span class="line">    <span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于设备对象,除了可以使用<code>ObReferenceObjectByName</code>根据名称得到对象指针外,也可使用下面的函数来获得设备对象的指针 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IopGetDeviceObjectPointer</span><span class="params">(IN PUNICODE_STRING ObjectName,IN ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="function"><span class="params">                          OUT PFILE_OBJECT *FileObject,OUT PDEVICE_OBJECT *DeviceObject, </span></span></span><br><span class="line"><span class="function"><span class="params">                          IN ULONG AttachFlag)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    OBJECT_ATTRIBUTES ObjectAttributes; </span><br><span class="line">    IO_STATUS_BLOCK StatusBlock; </span><br><span class="line">    PFILE_OBJECT LocalFileObject; </span><br><span class="line">    HANDLE FileHandle; </span><br><span class="line">    NTSTATUS Status; InitializeObjectAttributes(&amp;ObjectAttributes,ObjectName,OBJ_KERNEL_HANDLE,<span class="literal">NULL</span>,<span class="literal">NULL</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先打开设备,给那个设备发送一个IRP_MJ_CREATE </span></span><br><span class="line">    Status = ZwOpenFile(&amp;FileHandle,DesiredAccess,&amp;ObjectAttributes,&amp;StatusBlock, </span><br><span class="line">                        <span class="number">0</span>,FILE_NON_DIRECTORY_FILE | AttachFlag); </span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">return</span> Status; </span><br><span class="line">    Status = ObReferenceObjectByHandle(FileHandle,<span class="number">0</span>,IoFileObjectType,KernelMode, </span><br><span class="line">                                       (PVOID*)&amp;LocalFileObject,<span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">    &#123; </span><br><span class="line">        *DeviceObject = IoGetRelatedDeviceObject(LocalFileObject);<span class="comment">//这个函数已看过 </span></span><br><span class="line">        *FileObject = LocalFileObject; </span><br><span class="line">    &#125; </span><br><span class="line">    ZwClose(FileHandle);<span class="comment">//关闭文件句柄,内部会发送IRP_MJ_CLEANUP </span></span><br><span class="line">    <span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IoAttachDevice</code>实质上调用的是<code>IoAttachDeviceToDeviceStackSafe</code>我们看</p>
<h4 id="IoAttachDeviceToDeviceStackSafe"><a href="#IoAttachDeviceToDeviceStackSafe" class="headerlink" title="IoAttachDeviceToDeviceStackSafe"></a>IoAttachDeviceToDeviceStackSafe</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoAttachDeviceToDeviceStackSafe</span><span class="params">(IN PDEVICE_OBJECT SourceDevice, </span></span></span><br><span class="line"><span class="function"><span class="params">                                IN PDEVICE_OBJECT TargetDevice, </span></span></span><br><span class="line"><span class="function"><span class="params">                                IN OUT PDEVICE_OBJECT *AttachedToDeviceObject)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!IopAttachDeviceToDeviceStackSafe(SourceDevice,TargetDevice,AttachedToDeviceObject)) </span><br><span class="line">        <span class="keyword">return</span> STATUS_NO_SUCH_DEVICE; </span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PDEVICE_OBJECT <span class="title">IopAttachDeviceToDeviceStackSafe</span><span class="params">(IN PDEVICE_OBJECT SourceDevice,<span class="comment">//我们的设备 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                                 IN PDEVICE_OBJECT TargetDevice,<span class="comment">//要绑定到的目标设备 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                                 OUT PDEVICE_OBJECT *AttachedToDeviceObject OPTIONAL)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//获得我们设备的标准设备扩展 </span></span><br><span class="line">    PEXTENDED_DEVOBJ_EXTENSION SourceDeviceExtension = IoGetDevObjExtension(SourceDevice); </span><br><span class="line">    PDEVICE_OBJECT AttachedDevice = IoGetAttachedDevice(TargetDevice);<span class="comment">//获取栈顶的设备 </span></span><br><span class="line">    <span class="comment">//检查栈顶设备的当前状态是否可以被绑定 </span></span><br><span class="line">    <span class="keyword">if</span> ((AttachedDevice-&gt;Flags &amp; DO_DEVICE_INITIALIZING) || </span><br><span class="line">        (IoGetDevObjExtension(AttachedDevice)-&gt;ExtensionFlags &amp; </span><br><span class="line">        (DOE_UNLOAD_PENDING | DOE_DELETE_PENDING | DOE_REMOVE_PENDING | DOE_REMOVE_PROCESSED))) </span><br><span class="line">    &#123; </span><br><span class="line">        AttachedDevice = <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    Else <span class="comment">//绑定到目标设备所在设备栈的栈顶设备 </span></span><br><span class="line">    &#123; </span><br><span class="line">        AttachedDevice-&gt;AttachedDevice = SourceDevice;<span class="comment">//关键。原栈顶设备记录绑定到它的设备 </span></span><br><span class="line">        SourceDevice-&gt;StackSize = AttachedDevice-&gt;StackSize + <span class="number">1</span>;<span class="comment">//绑定后自动确定StackSize </span></span><br><span class="line">        SourceDevice-&gt;AlignmentRequirement = AttachedDevice-&gt;AlignmentRequirement; </span><br><span class="line">        SourceDevice-&gt;SectorSize = AttachedDevice-&gt;SectorSize;<span class="comment">//绑定后自动确定扇区大小 </span></span><br><span class="line">        <span class="keyword">if</span> (IoGetDevObjExtension(AttachedDevice)-&gt;ExtensionFlags &amp; DOE_START_PENDING) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//传播标志 </span></span><br><span class="line">            IoGetDevObjExtension(SourceDevice)-&gt;ExtensionFlags |= DOE_START_PENDING; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键。在标准设备扩展中也会记录实际绑定到的下层设备(不过我们一般是在自定义设备扩展 中记录实际绑到的下层设备)。</span></span><br><span class="line">        <span class="comment">// 不过由于一个设备可以同时绑定到N个下层设备,所以这个隐藏的 AttachedTo字段记录的是最近一次绑到的下层设备 </span></span><br><span class="line">        SourceDeviceExtension-&gt;AttachedTo = AttachedDevice; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (AttachedToDeviceObject) *AttachedToDeviceObject = AttachedDevice;<span class="comment">//返回 </span></span><br><span class="line">    <span class="keyword">return</span> AttachedDevice; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上这个函数将我们的设备绑定到目标设备(其实是绑定到目标设备所在设备栈的栈顶设备),绑定过程中,系统会自动确定我们设备的<code>StackSize</code>,并将实际绑到的设备记录在隐藏字段<code>AttachedTo</code>中。 </p>
<h4 id="IoAttachDeviceByPointer"><a href="#IoAttachDeviceByPointer" class="headerlink" title="IoAttachDeviceByPointer"></a>IoAttachDeviceByPointer</h4><p>如果知道了两个设备的指针,可以直接使用下面的函数进行绑定,不过这个函数有一个缺点,他不会返回实际绑到的下层设备。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoAttachDeviceByPointer</span><span class="params">(IN PDEVICE_OBJECT SourceDevice,IN PDEVICE_OBJECT TargetDevice)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PDEVICE_OBJECT AttachedDevice; </span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS; </span><br><span class="line">    AttachedDevice = IoAttachDeviceToDeviceStack(SourceDevice, TargetDevice); </span><br><span class="line">    <span class="keyword">if</span> (!AttachedDevice) Status = STATUS_NO_SUCH_DEVICE; </span><br><span class="line">    <span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IoAttachDeviceToDeviceStack"><a href="#IoAttachDeviceToDeviceStack" class="headerlink" title="IoAttachDeviceToDeviceStack"></a>IoAttachDeviceToDeviceStack</h4><p>下面的函数可以解决这个缺点,返回实际绑到的设备,若返回 NULL,则表示绑定失败 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PDEVICE_OBJECT <span class="title">IoAttachDeviceToDeviceStack</span><span class="params">(IN PDEVICE_OBJECT SourceDevice,IN PDEVICE_OBJECT TargetDevice)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> IopAttachDeviceToDeviceStackSafe(SourceDevice,TargetDevice,<span class="literal">NULL</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="IoCompleteRequest"><a href="#IoCompleteRequest" class="headerlink" title="IoCompleteRequest"></a>IoCompleteRequest</h3><p>Irp 请求的完成处理:当一个 irp 完成时,用户会调用完成这个<code>IoCompleteRequest</code>irp<br>我们看看到底一个 irp 是如何完成的,完成时做了哪些工作呢？ </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IoCompleteRequest IofCompleteRequest </span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID FASTCALL <span class="title">IofCompleteRequest</span><span class="params">(IN PIRP Irp,IN CCHAR PriorityBoost)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    NTSTATUS ErrorCode = STATUS_SUCCESS; </span><br><span class="line">    <span class="keyword">if</span> (Irp-&gt;CurrentLocation &gt; Irp-&gt;StackCount + <span class="number">1</span>) </span><br><span class="line">        KeBugCheckEx(MULTIPLE_IRP_COMPLETE_REQUESTS, (ULONG_PTR)Irp, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">    ASSERT(!Irp-&gt;CancelRoutine);<span class="comment">//必须取消了取消例程,否则蓝屏 </span></span><br><span class="line">    ASSERT(Irp-&gt;IoStatus.Status != STATUS_PENDING);<span class="comment">//不能在阻塞态调用本函数完成irp </span></span><br><span class="line">    ASSERT(Irp-&gt;IoStatus.Status != <span class="number">-1</span>); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Get the last stack */</span> </span><br><span class="line">    LastStackPtr = (PIO_STACK_LOCATION)(Irp + <span class="number">1</span>);<span class="comment">//最底层的栈空间 </span></span><br><span class="line">    <span class="keyword">if</span> (LastStackPtr-&gt;Control &amp; SL_ERROR_RETURNED) </span><br><span class="line">        ErrorCode = PtrToUlong(LastStackPtr-&gt;Parameters.Others.Argument4); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * Start the loop with the current stack and point the IRP to the next stack </span></span><br><span class="line"><span class="comment">     * and then keep incrementing the stack as we loop through. The IRP should </span></span><br><span class="line"><span class="comment">     * always point to the next stack location w.r.t the one currently being </span></span><br><span class="line"><span class="comment">     * analyzed, so completion routine code will see the appropriate value. </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">     * Because of this, we must loop until the current stack location is +1 of </span></span><br><span class="line"><span class="comment">     * the stack count, because when StackPtr is at the end, CurrentLocation is +1. </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="comment">//StackPtr从最底层到最顶层 </span></span><br><span class="line">    <span class="keyword">for</span> (StackPtr = IoGetCurrentIrpStackLocation(Irp), </span><br><span class="line">         Irp-&gt;CurrentLocation++, </span><br><span class="line">         Irp-&gt;Tail.Overlay.CurrentStackLocation++; </span><br><span class="line">              Irp-&gt;CurrentLocation &lt;= (Irp-&gt;StackCount + <span class="number">1</span>); </span><br><span class="line">         StackPtr++, </span><br><span class="line">         Irp-&gt;CurrentLocation++, </span><br><span class="line">         Irp-&gt;Tail.Overlay.CurrentStackLocation++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//记录下层当初处理该irp时是否是异步返回的 </span></span><br><span class="line">        Irp-&gt;PendingReturned = StackPtr-&gt;Control &amp; SL_PENDING_RETURNED; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Check if we failed */</span> </span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Irp-&gt;IoStatus.Status)) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">/* Check if it was changed by a completion routine */</span> </span><br><span class="line">            <span class="keyword">if</span> (Irp-&gt;IoStatus.Status != ErrorCode) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">/* Update the error for the current stack */</span> </span><br><span class="line">                ErrorCode = Irp-&gt;IoStatus.Status; </span><br><span class="line">                StackPtr-&gt;Control |= SL_ERROR_RETURNED; </span><br><span class="line">                LastStackPtr-&gt;Parameters.Others.Argument4 = UlongToPtr(ErrorCode); </span><br><span class="line">                LastStackPtr-&gt;Control |= SL_ERROR_RETURNED; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        IopClearStackLocation(StackPtr);<span class="comment">//清理掉该层栈空间 </span></span><br><span class="line">        <span class="comment">//检查是否满足可以调用完成例程的条件 </span></span><br><span class="line">        <span class="keyword">if</span> ((NT_SUCCESS(Irp-&gt;IoStatus.Status) &amp;&amp; </span><br><span class="line">             (StackPtr-&gt;Control &amp; SL_INVOKE_ON_SUCCESS)) || </span><br><span class="line">            (!NT_SUCCESS(Irp-&gt;IoStatus.Status) &amp;&amp; </span><br><span class="line">             (StackPtr-&gt;Control &amp; SL_INVOKE_ON_ERROR)) || </span><br><span class="line">            (Irp-&gt;Cancel &amp;&amp; </span><br><span class="line">             (StackPtr-&gt;Control &amp; SL_INVOKE_ON_CANCEL))) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (Irp-&gt;CurrentLocation == (Irp-&gt;StackCount + <span class="number">1</span>)) </span><br><span class="line">                DeviceObject = <span class="literal">NULL</span>;<span class="comment">//回溯到最高层时DeviceObject = NULL </span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                DeviceObject = IoGetCurrentIrpStackLocation(Irp)-&gt;DeviceObject; </span><br><span class="line">            <span class="comment">//关键。调用上层的完成例程(注意此时的栈层位于上层栈空间) </span></span><br><span class="line">            Status = StackPtr-&gt;CompletionRoutine(DeviceObject,Irp,StackPtr-&gt;Context); </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment">//如果该层的完成例程返回结果指示需要进一步完成的话,就中止,不再向上回溯 </span></span><br><span class="line">            <span class="keyword">if</span> (Status == STATUS_MORE_PROCESSING_REQUIRED) <span class="keyword">return</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        Else <span class="comment">//如果不满足调用完成例程的条件 </span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> ((Irp-&gt;CurrentLocation &lt;= Irp-&gt;StackCount) &amp;&amp; (Irp-&gt;PendingReturned)) </span><br><span class="line">                IoMarkIrpPending(Irp); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (Irp-&gt;Flags &amp; IRP_ASSOCIATED_IRP)<span class="comment">//if 这是某个主irp关联的N个副irp之一 </span></span><br><span class="line">    &#123; </span><br><span class="line">        MasterIrp = Irp-&gt;AssociatedIrp.MasterIrp; </span><br><span class="line">        MasterCount = InterlockedDecrement(&amp;MasterIrp-&gt;AssociatedIrp.IrpCount); </span><br><span class="line">        <span class="comment">//释放该irp关联的所有MDL </span></span><br><span class="line">        <span class="keyword">for</span> (Mdl = Irp-&gt;MdlAddress; Mdl; Mdl = NextMdl) </span><br><span class="line">        &#123; </span><br><span class="line">            NextMdl = Mdl-&gt;Next; </span><br><span class="line">            IoFreeMdl(Mdl); </span><br><span class="line">        &#125; </span><br><span class="line">        IoFreeIrp(Irp);<span class="comment">//释放irp结构体本身 </span></span><br><span class="line">        <span class="comment">//若这是最后一个副irp,就完成掉它的主irp </span></span><br><span class="line">        <span class="keyword">if</span> (MasterCount==<span class="number">0</span>) IofCompleteRequest(MasterIrp, PriorityBoost); </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放该irp关联的其他辅助缓冲 </span></span><br><span class="line">    <span class="keyword">if</span> (Irp-&gt;Tail.Overlay.AuxiliaryBuffer) </span><br><span class="line">    &#123; </span><br><span class="line">        ExFreePool(Irp-&gt;Tail.Overlay.AuxiliaryBuffer); </span><br><span class="line">        Irp-&gt;Tail.Overlay.AuxiliaryBuffer = <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (Irp-&gt;Flags &amp; (IRP_PAGING_IO | IRP_CLOSE_OPERATION)) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (Irp-&gt;Flags &amp; (IRP_SYNCHRONOUS_PAGING_IO | IRP_CLOSE_OPERATION)) </span><br><span class="line">        &#123; </span><br><span class="line">            *Irp-&gt;UserIosb = Irp-&gt;IoStatus; </span><br><span class="line">            KeSetEvent(Irp-&gt;UserEvent, PriorityBoost, FALSE); </span><br><span class="line">            Flags = Irp-&gt;Flags &amp; (IRP_SYNCHRONOUS_PAGING_IO | IRP_PAGING_IO); </span><br><span class="line">            <span class="keyword">if</span> (Flags) IoFreeIrp(Irp);<span class="comment">//释放分页IO irp </span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    Mdl = Irp-&gt;MdlAddress;<span class="comment">//解锁该irp关联的所有MDL页面,允许换出到外存 </span></span><br><span class="line">    <span class="keyword">while</span> (Mdl) </span><br><span class="line">    &#123; </span><br><span class="line"> </span><br><span class="line"> 	 	MmUnlockPages(Mdl); </span><br><span class="line">        Mdl = Mdl-&gt;Next; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> ((Irp-&gt;Flags &amp; IRP_DEFER_IO_COMPLETION) &amp;&amp; !(Irp-&gt;PendingReturned)) </span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//直接返回,不再调用IopCompleteRequest了,由用户自己调用,去完成后半部分的工作 </span></span><br><span class="line">    Thread = Irp-&gt;Tail.Overlay.Thread; </span><br><span class="line">    FileObject = Irp-&gt;Tail.Overlay.OriginalFileObject; </span><br><span class="line">    <span class="keyword">if</span> (!Irp-&gt;Cancel) <span class="comment">//最常见 </span></span><br><span class="line">    &#123; </span><br><span class="line">        KeInitializeApc(&amp;Irp-&gt;Tail.Apc,&amp;Thread-&gt;Tcb,Irp-&gt;ApcEnvironment, </span><br><span class="line">                        IopCompleteRequest,<span class="comment">//进一步的完成工作以apc的方式执行 </span></span><br><span class="line">                        <span class="literal">NULL</span>,<span class="literal">NULL</span>,KernelMode,<span class="literal">NULL</span>); </span><br><span class="line">        KeInsertQueueApc(&amp;Irp-&gt;Tail.Apc,FileObject,<span class="literal">NULL</span>,PriorityBoost); </span><br><span class="line">    &#125; </span><br><span class="line">    Else <span class="comment">//该irp是被取消的(也即用户要求以取消方式完成掉这个irp) </span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (Thread) </span><br><span class="line">        &#123; </span><br><span class="line">            KeInitializeApc(&amp;Irp-&gt;Tail.Apc,&amp;Thread-&gt;Tcb,Irp-&gt;ApcEnvironment, </span><br><span class="line">                            IopCompleteRequest, </span><br><span class="line">                            <span class="literal">NULL</span>,<span class="literal">NULL</span>,KernelMode,<span class="literal">NULL</span>); </span><br><span class="line">            KeInsertQueueApc(&amp;Irp-&gt;Tail.Apc,FileObject,<span class="literal">NULL</span>,PriorityBoost); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            IopCleanupIrp(Irp, FileObject); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IopCompleteRequest"><a href="#IopCompleteRequest" class="headerlink" title="IopCompleteRequest"></a>IopCompleteRequest</h3><p><code>IopCompleteRequest</code>是后半部分的完成工作,我们看</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">IopCompleteRequest</span><span class="params">(IN PKAPC Apc, </span></span></span><br><span class="line"><span class="function"><span class="params">                   IN PKNORMAL_ROUTINE* NormalRoutine, </span></span></span><br><span class="line"><span class="function"><span class="params">                   IN PVOID* NormalContext, </span></span></span><br><span class="line"><span class="function"><span class="params">                   IN PVOID* SystemArgument1, </span></span></span><br><span class="line"><span class="function"><span class="params">                   IN PVOID* SystemArgument2)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PFILE_OBJECT FileObject; </span><br><span class="line">    PIRP Irp; </span><br><span class="line">    PMDL Mdl, NextMdl; </span><br><span class="line">    PVOID Port = <span class="literal">NULL</span>, Key = <span class="literal">NULL</span>; </span><br><span class="line">    BOOLEAN SignaledCreateRequest = FALSE; </span><br><span class="line">    FileObject = (PFILE_OBJECT)*SystemArgument1; </span><br><span class="line">    Irp = CONTAINING_RECORD(Apc, IRP, Tail.Apc); </span><br><span class="line">    <span class="comment">//拷贝给用户空间,释放该irp关联的系统缓冲 </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (Irp-&gt;Flags &amp; IRP_BUFFERED_IO) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> ((Irp-&gt;Flags &amp; IRP_INPUT_OPERATION) &amp;&amp; </span><br><span class="line">            (Irp-&gt;IoStatus.Status != STATUS_VERIFY_REQUIRED) &amp;&amp; </span><br><span class="line">            !(NT_ERROR(Irp-&gt;IoStatus.Status))) </span><br><span class="line">        &#123; </span><br><span class="line">            RtlCopyMemory(Irp-&gt;UserBuffer,Irp-&gt;AssociatedIrp.SystemBuffer, </span><br><span class="line">                          Irp-&gt;IoStatus.Information); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (Irp-&gt;Flags &amp; IRP_DEALLOCATE_BUFFER) </span><br><span class="line">            ExFreePool(Irp-&gt;AssociatedIrp.SystemBuffer); </span><br><span class="line">    &#125; </span><br><span class="line">    Irp-&gt;Flags &amp;= ~(IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//释放该irp关联的所有mdl </span></span><br><span class="line">    <span class="keyword">for</span> (Mdl = Irp-&gt;MdlAddress; Mdl; Mdl = NextMdl) </span><br><span class="line">    &#123; </span><br><span class="line">        NextMdl = Mdl-&gt;Next; </span><br><span class="line">        IoFreeMdl(Mdl); </span><br><span class="line">    &#125; </span><br><span class="line">    Irp-&gt;MdlAddress = <span class="literal">NULL</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!(NT_ERROR(Irp-&gt;IoStatus.Status)) || </span><br><span class="line">         (NT_ERROR(Irp-&gt;IoStatus.Status) &amp;&amp; (Irp-&gt;PendingReturned) &amp;&amp; </span><br><span class="line">          !(IsIrpSynchronous(Irp, FileObject)))) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> ((FileObject) &amp;&amp; (FileObject-&gt;CompletionContext)) </span><br><span class="line">        &#123; </span><br><span class="line">            Port = FileObject-&gt;CompletionContext-&gt;Port; </span><br><span class="line">            Key = FileObject-&gt;CompletionContext-&gt;Key; </span><br><span class="line">        &#125; </span><br><span class="line">        *Irp-&gt;UserIosb = Irp-&gt;IoStatus; </span><br><span class="line">        <span class="keyword">if</span> (Irp-&gt;UserEvent) </span><br><span class="line">        &#123; </span><br><span class="line">            KeSetEvent(Irp-&gt;UserEvent, <span class="number">0</span>, FALSE); </span><br><span class="line">            <span class="keyword">if</span> (FileObject) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> ((FileObject-&gt;Flags &amp; FO_SYNCHRONOUS_IO) &amp;&amp; </span><br><span class="line">                    !(Irp-&gt;Flags &amp; IRP_OB_QUERY_NAME)) </span><br><span class="line">                &#123; </span><br><span class="line">                    KeSetEvent(&amp;FileObject-&gt;Event, <span class="number">0</span>, FALSE); </span><br><span class="line">                    FileObject-&gt;FinalStatus = Irp-&gt;IoStatus.Status; </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span> (Irp-&gt;Flags &amp; IRP_CREATE_OPERATION) </span><br><span class="line"> </span><br><span class="line">                &#123; </span><br><span class="line">                    Irp-&gt;Overlay.AsynchronousParameters.UserApcRoutine = <span class="literal">NULL</span>; </span><br><span class="line">                    SignaledCreateRequest = TRUE; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (FileObject) </span><br><span class="line">        &#123; </span><br><span class="line">            KeSetEvent(&amp;FileObject-&gt;Event, <span class="number">0</span>, FALSE); </span><br><span class="line">            FileObject-&gt;FinalStatus = Irp-&gt;IoStatus.Status; </span><br><span class="line">            <span class="keyword">if</span> (Irp-&gt;Flags &amp; IRP_CREATE_OPERATION) </span><br><span class="line">            &#123; </span><br><span class="line">                Irp-&gt;Overlay.AsynchronousParameters.UserApcRoutine = <span class="literal">NULL</span>; </span><br><span class="line">                SignaledCreateRequest = TRUE; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//更新各自类型的历史总计转交字节数 </span></span><br><span class="line">        <span class="keyword">if</span> (!(Irp-&gt;Flags &amp; IRP_CREATE_OPERATION)) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (Irp-&gt;Flags &amp; IRP_WRITE_OPERATION) </span><br><span class="line">                IopUpdateTransferCount(IopWriteTransfer,Irp-&gt;IoStatus.Information); </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Irp-&gt;Flags &amp; IRP_READ_OPERATION) </span><br><span class="line">                IopUpdateTransferCount(IopReadTransfer,Irp-&gt;IoStatus.Information); </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                IopUpdateTransferCount(IopOtherTransfer,Irp-&gt;IoStatus.Information); </span><br><span class="line">        &#125; </span><br><span class="line">        IopUnQueueIrpFromThread(Irp);<span class="comment">//脱出线程的阻塞irp链表 </span></span><br><span class="line">        <span class="comment">//用于用户空间的apc方式IO </span></span><br><span class="line">        <span class="keyword">if</span> (Irp-&gt;Overlay.AsynchronousParameters.UserApcRoutine) </span><br><span class="line">        &#123; </span><br><span class="line">            KeInitializeApc(&amp;Irp-&gt;Tail.Apc, </span><br><span class="line">                            KeGetCurrentThread(), </span><br><span class="line">                            CurrentApcEnvironment, </span><br><span class="line">                            IopFreeIrpKernelApc, </span><br><span class="line">                            IopAbortIrpKernelApc, </span><br><span class="line">                            (PKNORMAL_ROUTINE)Irp-&gt; </span><br><span class="line">                            Overlay.AsynchronousParameters.UserApcRoutine, </span><br><span class="line">                            Irp-&gt;RequestorMode, </span><br><span class="line">                            Irp-&gt; </span><br><span class="line">                            Overlay.AsynchronousParameters.UserApcContext); </span><br><span class="line"> </span><br><span class="line">            KeInsertQueueApc(&amp;Irp-&gt;Tail.Apc, Irp-&gt;UserIosb, <span class="literal">NULL</span>, <span class="number">2</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//将一个irp完成事件插入指定完成端口的消息队列中 </span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((Port) &amp;&amp; </span><br><span class="line">                 (Irp-&gt;Overlay.AsynchronousParameters.UserApcContext)) </span><br><span class="line">        &#123; </span><br><span class="line">            Irp-&gt;Tail.CompletionKey = Key; </span><br><span class="line">            Irp-&gt;Tail.Overlay.PacketType = IopCompletionPacketIrp; </span><br><span class="line">            KeInsertQueue(Port, &amp;Irp-&gt;Tail.Overlay.ListEntry); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            IoFreeIrp(Irp);<span class="comment">//释放irp结构体本身 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> ((Irp-&gt;PendingReturned) &amp;&amp; (FileObject)) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (Irp-&gt;Flags &amp; IRP_SYNCHRONOUS_API) </span><br><span class="line">            &#123; </span><br><span class="line">                *Irp-&gt;UserIosb = Irp-&gt;IoStatus; </span><br><span class="line">                <span class="keyword">if</span> (Irp-&gt;UserEvent) </span><br><span class="line">                    KeSetEvent(Irp-&gt;UserEvent, <span class="number">0</span>, FALSE); </span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    KeSetEvent(&amp;FileObject-&gt;Event, <span class="number">0</span>, FALSE); </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123; </span><br><span class="line">                FileObject-&gt;FinalStatus = Irp-&gt;IoStatus.Status; </span><br><span class="line">                KeSetEvent(&amp;FileObject-&gt;Event, <span class="number">0</span>, FALSE); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        IopUnQueueIrpFromThread(Irp); </span><br><span class="line">        IoFreeIrp(Irp); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 最后是释放 irp 结构体本身 </span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">IoFreeIrp</span><span class="params">(IN PIRP Irp)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PNPAGED_LOOKASIDE_LIST List; </span><br><span class="line">    PP_NPAGED_LOOKASIDE_NUMBER ListType = LookasideSmallIrpList; </span><br><span class="line">    PKPRCB Prcb; </span><br><span class="line">    ASSERT(IsListEmpty(&amp;Irp-&gt;ThreadListEntry)); </span><br><span class="line">    ASSERT(Irp-&gt;CurrentLocation &gt;= Irp-&gt;StackCount); </span><br><span class="line">    <span class="keyword">if</span> (!(Irp-&gt;AllocationFlags &amp; IRP_ALLOCATED_FIXED_SIZE)) </span><br><span class="line">        ExFreePoolWithTag(Irp, TAG_IRP); </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line"> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (Irp-&gt;StackCount != <span class="number">1</span>) ListType = LookasideLargeIrpList; </span><br><span class="line">        Prcb = KeGetCurrentPrcb(); </span><br><span class="line">        List = (PNPAGED_LOOKASIDE_LIST)Prcb-&gt;PPLookasideList[ListType].P; </span><br><span class="line">        List-&gt;L.TotalFrees++; </span><br><span class="line">        <span class="keyword">if</span> (ExQueryDepthSList(&amp;List-&gt;L.ListHead) &gt;= List-&gt;L.Depth) </span><br><span class="line">        &#123; </span><br><span class="line">            List-&gt;L.FreeMisses++; </span><br><span class="line">            List = (PNPAGED_LOOKASIDE_LIST)Prcb-&gt;PPLookasideList[ListType].L; </span><br><span class="line">            List-&gt;L.TotalFrees++; </span><br><span class="line">            <span class="keyword">if</span> (ExQueryDepthSList(&amp;List-&gt;L.ListHead) &gt;= List-&gt;L.Depth) </span><br><span class="line">            &#123; </span><br><span class="line">                List-&gt;L.FreeMisses++; </span><br><span class="line">                ExFreePoolWithTag(Irp, TAG_IRP); </span><br><span class="line">                Irp = <span class="literal">NULL</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (Irp) </span><br><span class="line">        &#123; </span><br><span class="line">           InterlockedPushEntrySList(&amp;List-&gt;L.ListHead,Irp); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Irp 完成工作可以看出主要是:向上回溯调用各层的完成例程,资源的释放,系统缓冲释放,MDL 释放,irp 结构体本身的释放,触发完成事件信号等操作。 </p>
<p><br><br><br></p>
<h2 id="驱动的加载过程"><a href="#驱动的加载过程" class="headerlink" title="驱动的加载过程"></a>驱动的加载过程</h2><p>Windows 系统中共分 4 种类型的驱动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define SERVICE_KERNEL_DRIVER          0x00000001 //普通内核驱动 </span><br><span class="line">#define SERVICE_FILE_SYSTEM_DRIVER     0x00000002 //文件系统驱动 </span><br><span class="line">#define SERVICE_ADAPTER                0x00000004 //适配器驱动 </span><br><span class="line">#define SERVICE_RECOGNIZER_DRIVER 0x00000008 //文件系统识别器驱动每个驱动的类型记录在注册表中对应服务键下的 type 值中。</span><br></pre></td></tr></table></figure></p>
<p>非文件系统驱动的驱动对象名都是<code>Driver\服务名</code>形式,文件系统驱动的驱动对象名则是<code>FileSystem\服务名</code>形式。这点小差别要注意。 </p>
<p>驱动有四种加载时机: </p>
<ul>
<li>1、 系统引导时加载 </li>
<li>2、 系统初始化时加载 </li>
<li>3、 SCM 服务管理器在系统启动后的自动加载 </li>
<li>4、 运行时动态加载 </li>
</ul>
<h3 id="NtLoadDriver"><a href="#NtLoadDriver" class="headerlink" title="NtLoadDriver"></a>NtLoadDriver</h3><p>老式驱动和 WDM 驱动都支持动态加载。<br>老式驱动可以使用<code>NtLoadDriver</code>这个系统服务进行动态加载(实际上 SCM 服务管理器最终就是通过这个函数加载驱动的)<br>WDM 驱动则在设备热插拔时由 Pnp 管理器调用<code>IopLoadServiceModule</code>动态加载。 </p>
<blockquote>
<p>注意：凡是由<code>NtLoadDriver</code>加载的驱动都强制变成老式驱动,即使它提供了<code>AddDevice</code> </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS  <span class="title">NtLoadDriver</span><span class="params">(IN PUNICODE_STRING DriverServiceName)</span> <span class="comment">//参数表示服务键的全路径 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    UNICODE_STRING CapturedDriverServiceName = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span> &#125;; </span><br><span class="line">    KPROCESSOR_MODE PreviousMode; </span><br><span class="line">    LOAD_UNLOAD_PARAMS LoadParams; </span><br><span class="line">    NTSTATUS Status; </span><br><span class="line"> </span><br><span class="line">    PAGED_CODE(); </span><br><span class="line">    PreviousMode = KeGetPreviousMode();<span class="comment">//一般都是用户空间的SCM在调用本函数 </span></span><br><span class="line">    <span class="comment">//检查当前令牌是否具有加载驱动的特权(加载驱动很危险,必须把好这个关口,做足权限检查) </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!SeSinglePrivilegeCheck(SeLoadDriverPrivilege, PreviousMode)) </span><br><span class="line">        <span class="keyword">return</span> STATUS_PRIVILEGE_NOT_HELD; </span><br><span class="line">    <span class="comment">//将DriverServiceName参数从用户空间拷贝到内核空间的CapturedDriverServiceName </span></span><br><span class="line">    </span><br><span class="line">    Status = ProbeAndCaptureUnicodeString(&amp;CapturedDriverServiceName,PreviousMode, </span><br><span class="line">                                          DriverServiceName); </span><br><span class="line">    LoadParams.ServiceName = &amp;CapturedDriverServiceName;<span class="comment">//服务名 </span></span><br><span class="line">    LoadParams.DriverObject = <span class="literal">NULL</span>;<span class="comment">//NULL表示加载,否则表示卸载 </span></span><br><span class="line">    KeInitializeEvent(&amp;LoadParams.Event, NotificationEvent, FALSE); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PsGetCurrentProcess() == PsInitialSystemProcess) </span><br><span class="line">        IopLoadUnloadDriver(&amp;LoadParams);</span><br><span class="line">        <span class="comment">//if当前进程是`system`,立即就地调用 </span></span><br><span class="line">        <span class="comment">//将这个加载任务打包成一个工作项,交由系统工作者线程去完成。</span></span><br><span class="line">        <span class="comment">//由于系统工作者线程本身就 是`system`进程中的线程,因此,这就是为什么每个驱动的DriverEntry总是运行在`system`进程中 </span></span><br><span class="line">    Else <span class="comment">//最典型 </span></span><br><span class="line">    &#123; </span><br><span class="line">        ExInitializeWorkItem(&amp;LoadParams.WorkItem,IopLoadUnloadDriver, (PVOID)&amp;LoadParams); </span><br><span class="line">        ExQueueWorkItem(&amp;LoadParams.WorkItem, DelayedWorkQueue); </span><br><span class="line">        KeWaitForSingleObject(&amp;LoadParams.Event, UserRequest, KernelMode,FALSE, <span class="literal">NULL</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    ReleaseCapturedUnicodeString(&amp;CapturedDriverServiceName,PreviousMode); </span><br><span class="line">    <span class="keyword">return</span> LoadParams.Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上上面的函数检查权限通过后,就打包成工作项,转入<code>system</code>进程中去加载驱动。</p>
<h4 id="IopLoadUnloadDriver"><a href="#IopLoadUnloadDriver" class="headerlink" title="IopLoadUnloadDriver"></a>IopLoadUnloadDriver</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">IopLoadUnloadDriver</span><span class="params">(PLOAD_UNLOAD_PARAMS LoadParams)</span><span class="comment">//既用来加载,也可用来卸载 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">if</span> (LoadParams-&gt;DriverObject) </span><br><span class="line">   &#123; </span><br><span class="line">       (*LoadParams-&gt;DriverObject-&gt;DriverUnload)(LoadParams-&gt;DriverObject);<span class="comment">//调用卸载例程 </span></span><br><span class="line">       LoadParams-&gt;Status = STATUS_SUCCESS; </span><br><span class="line">       KeSetEvent(&amp;LoadParams-&gt;Event, <span class="number">0</span>, FALSE); </span><br><span class="line">       <span class="keyword">return</span>; </span><br><span class="line">   &#125;    </span><br><span class="line">   RtlInitUnicodeString(&amp;ImagePath, <span class="literal">NULL</span>); </span><br><span class="line">   ServiceName = *LoadParams-&gt;ServiceName;<span class="comment">//要加载的目标驱动的服务名 </span></span><br><span class="line">   cur = LoadParams-&gt;ServiceName-&gt;Buffer + (LoadParams-&gt;ServiceName-&gt;Length / <span class="number">2</span>) - <span class="number">1</span>; </span><br><span class="line">   <span class="keyword">while</span> (LoadParams-&gt;ServiceName-&gt;Buffer != cur) </span><br><span class="line">   &#123; </span><br><span class="line">      if(*cur == L'\\') </span><br><span class="line">      &#123; </span><br><span class="line">         ServiceName.Buffer = cur + <span class="number">1</span>; </span><br><span class="line">         ServiceName.Length = LoadParams-&gt;ServiceName-&gt;Length - </span><br><span class="line"> </span><br><span class="line">            (USHORT)((ULONG_PTR)ServiceName.Buffer - (ULONG)LoadParams-&gt;ServiceName-&gt;Buffer); </span><br><span class="line">         <span class="keyword">break</span>; </span><br><span class="line">      &#125; </span><br><span class="line">      cur--; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">//上面的循环提取服务键全路径末尾的服务名 </span></span><br><span class="line">   IopDisplayLoadingMessage(&amp;ServiceName); </span><br><span class="line">   RtlZeroMemory(&amp;QueryTable, <span class="keyword">sizeof</span>(QueryTable)); </span><br><span class="line"> </span><br><span class="line">   RtlInitUnicodeString(&amp;ImagePath, <span class="literal">NULL</span>); </span><br><span class="line">   QueryTable[<span class="number">0</span>].Name = <span class="string">L"Type"</span>; </span><br><span class="line">   QueryTable[<span class="number">0</span>].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED; </span><br><span class="line">   QueryTable[<span class="number">0</span>].EntryContext = &amp;Type;<span class="comment">//从注册表的服务键查询服务的类型,查询结果放在这个字段 </span></span><br><span class="line">   QueryTable[<span class="number">1</span>].Name = <span class="string">L"ImagePath"</span>; </span><br><span class="line">   QueryTable[<span class="number">1</span>].Flags = RTL_QUERY_REGISTRY_DIRECT; </span><br><span class="line">   QueryTable[<span class="number">1</span>].EntryContext = &amp;ImagePath;<span class="comment">//查询sys文件的路径 </span></span><br><span class="line">   Status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, </span><br><span class="line">                                   LoadParams-&gt;ServiceName-&gt;Buffer, QueryTable, <span class="literal">NULL</span>, <span class="literal">NULL</span>); </span><br><span class="line">   <span class="comment">//创建设备节点,注意第二个参数为NULL,因为这个函数加载的驱动都是老式驱动,老式驱动是没有硬 件pdo,但是为了统一,系统会在内部为其创建一个模拟的‘硬件pdo’。 </span></span><br><span class="line">   Status = IopCreateDeviceNode(IopRootDeviceNode, <span class="literal">NULL</span>, &amp;ServiceName, &amp;DeviceNode); </span><br><span class="line">   <span class="keyword">if</span> (!NT_SUCCESS(Status)) … </span><br><span class="line">   <span class="comment">//检查对象目录中这个驱动是否已经加载过了,因为若已经加载了,驱动对象会进入对象目录中。 </span></span><br><span class="line">   Status = IopGetDriverObject(&amp;DriverObject,&amp;ServiceName, </span><br><span class="line">               (Type == SERVICE_FILE_SYSTEM_DRIVER || Type == SERVICE_RECOGNIZER_DRIVER )); </span><br><span class="line">   <span class="keyword">if</span> (!NT_SUCCESS(Status))<span class="comment">//if 这个驱动以前没加载过(防止重复加载) </span></span><br><span class="line">   &#123; </span><br><span class="line">       <span class="comment">//关键。加载驱动的sys文件到内存,跟加载exe、dll文件相似。 </span></span><br><span class="line">       Status = MmLoadSystemImage(&amp;ImagePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;ModuleObject, &amp;BaseAddress); </span><br><span class="line">       <span class="keyword">if</span> (!NT_SUCCESS(Status) &amp;&amp; Status != STATUS_IMAGE_ALREADY_LOADED) … </span><br><span class="line">       RtlCreateUnicodeString(&amp;DeviceNode-&gt;ServiceName, ServiceName.Buffer); </span><br><span class="line">       <span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">       &#123; </span><br><span class="line">           <span class="comment">//关键。为其创建一个DriverObject,并调用驱动的DriverEntry函数进行初始化 </span></span><br><span class="line">           Status = IopInitializeDriverModule(DeviceNode,ModuleObject, </span><br><span class="line">               &amp;DeviceNode-&gt;ServiceName, </span><br><span class="line">               (Type == SERVICE_FILE_SYSTEM_DRIVER || Type == <span class="number">8</span> SERVICE_RECOGNIZER_DRIVER), </span><br><span class="line">               &amp;DriverObject); </span><br><span class="line">           <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="comment">//if DriverEntry返回失败 </span></span><br><span class="line">           &#123; </span><br><span class="line">               MmUnloadSystemImage(ModuleObject); </span><br><span class="line">               IopFreeDeviceNode(DeviceNode); </span><br><span class="line">               LoadParams-&gt;Status = Status; </span><br><span class="line">               KeSetEvent(&amp;LoadParams-&gt;Event, <span class="number">0</span>, FALSE); </span><br><span class="line"> </span><br><span class="line">               <span class="keyword">return</span>; </span><br><span class="line">           &#125; </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="comment">//下面的两行实际上一点不起作用,纯属多余,因此,完全可以删去不看。 </span></span><br><span class="line">       IopInitializeDevice(DeviceNode, DriverObject);<span class="comment">//尝试调用其AddDevice函数 </span></span><br><span class="line">       Status = IopStartDevice(DeviceNode);<span class="comment">//尝试启动设备 </span></span><br><span class="line">   &#125; </span><br><span class="line">   Else <span class="comment">//若驱动先前已经加载了,就失败返回。 </span></span><br><span class="line">   &#123; </span><br><span class="line">      ObDereferenceObject(DriverObject); </span><br><span class="line">      IopFreeDeviceNode(DeviceNode); </span><br><span class="line">   &#125; </span><br><span class="line">   LoadParams-&gt;Status = Status; </span><br><span class="line">   KeSetEvent(&amp;LoadParams-&gt;Event, <span class="number">0</span>, FALSE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面函数关键的工作,就是将驱动文件加载到内存,然后为为驱动创建一个对象,再调用驱动的<code>DriverEntry</code>函数。<br>不过这儿有一个小问题要注意：就是需要为老式驱动创建一个用作栈底基石的<code>pdo</code>,其实老式设备根本没有硬件 pdo,只不过是系统为了方便统一管理,为老式驱动也模拟创建一个硬件 pdo,然后纳入 PNP 框架统一管理。</p>
<p>创建设备节点的函数<code>IopCreateDeviceNode</code>我们后面会看。 </p>
<h5 id="IopGetDriverObject"><a href="#IopGetDriverObject" class="headerlink" title="IopGetDriverObject"></a>IopGetDriverObject</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS FASTCALL <span class="title">IopGetDriverObject</span><span class="params">(PDRIVER_OBJECT *DriverObject,PUNICODE_STRING ServiceName, </span></span></span><br><span class="line"><span class="function"><span class="params">                   BOOLEAN FileSystem)</span><span class="comment">//表示该驱动的类型是否是文件系统 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   PDRIVER_OBJECT Object; </span><br><span class="line">   WCHAR NameBuffer[MAX_PATH]; </span><br><span class="line">   UNICODE_STRING DriverName; </span><br><span class="line">   NTSTATUS Status; </span><br><span class="line">   *DriverObject = <span class="literal">NULL</span>; </span><br><span class="line">   DriverName.Buffer = NameBuffer; </span><br><span class="line">   DriverName.Length = <span class="number">0</span>; </span><br><span class="line">   DriverName.MaximumLength = <span class="keyword">sizeof</span>(NameBuffer); </span><br><span class="line">   <span class="keyword">if</span> (FileSystem) </span><br><span class="line">      RtlAppendUnicodeToString(&amp;DriverName,”L\\FileSystem\\”); </span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      RtlAppendUnicodeToString(&amp;DriverName,L”\\Driver\\”); </span><br><span class="line">   RtlAppendUnicodeStringToString(&amp;DriverName, ServiceName); </span><br><span class="line">   Status = ObReferenceObjectByName(&amp;DriverName, </span><br><span class="line">                                OBJ_OPENIF | OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, </span><br><span class="line">                                <span class="literal">NULL</span>,<span class="number">0</span>,IoDriverObjectType,KernelMode,<span class="literal">NULL</span>, (PVOID*)&amp;Object); </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (!NT_SUCCESS(Status))<span class="comment">//检查是否有这个驱动对象 </span></span><br><span class="line">      <span class="keyword">return</span> Status; </span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">   *DriverObject = Object;<span class="comment">//返回找到的驱动对象 </span></span><br><span class="line">   <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上驱动对象本身也是一种内核对象,他也是有名称的。<br>这个函数检查对象目录中是否有指定的驱动对象,若有,就说明,这个驱动已被加载了,否则,就还未加载。 </p>
<h4 id="IopInitializeDriverModule"><a href="#IopInitializeDriverModule" class="headerlink" title="IopInitializeDriverModule"></a>IopInitializeDriverModule</h4><p>当加载完驱动文件后,就会调用下面的函数为其创建一个驱动对象,调用<code>DriverEntry</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS FASTCALL <span class="title">IopInitializeDriverModule</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">   IN PDEVICE_NODE DeviceNode,<span class="comment">//没使用 </span></span></span></span><br><span class="line"><span class="function"><span class="params">   IN PLDR_DATA_TABLE_ENTRY ModuleObject,<span class="comment">//该驱动模块的描述信息 </span></span></span></span><br><span class="line"><span class="function"><span class="params">   IN PUNICODE_STRING ServiceName,<span class="comment">//服务名 </span></span></span></span><br><span class="line"><span class="function"><span class="params">   IN BOOLEAN FileSystemDriver,<span class="comment">//是否为文件系统驱动 </span></span></span></span><br><span class="line"><span class="function"><span class="params">   OUT PDRIVER_OBJECT *DriverObject)</span><span class="comment">//返回创建的驱动对象 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">const</span> WCHAR ServicesKeyName[] = <span class="string">L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"</span>; </span><br><span class="line">   WCHAR NameBuffer[MAX_PATH]; </span><br><span class="line">   UNICODE_STRING DriverName; </span><br><span class="line">   UNICODE_STRING RegistryKey; </span><br><span class="line">   PDRIVER_INITIALIZE DriverEntry; </span><br><span class="line">   PDRIVER_OBJECT Driver; </span><br><span class="line">   NTSTATUS Status; </span><br><span class="line">   DriverEntry = ModuleObject-&gt;EntryPoint;<span class="comment">//关键。得到该驱动的oep,即DriverEntry </span></span><br><span class="line">   <span class="keyword">if</span> (ServiceName != <span class="literal">NULL</span> &amp;&amp; ServiceName-&gt;Length != <span class="number">0</span>) </span><br><span class="line">   &#123; </span><br><span class="line">      RegistryKey.Length = <span class="number">0</span>; </span><br><span class="line">      RegistryKey.MaximumLength = <span class="keyword">sizeof</span>(ServicesKeyName) + ServiceName-&gt;Length; </span><br><span class="line">      RegistryKey.Buffer = ExAllocatePool(PagedPool, RegistryKey.MaximumLength); </span><br><span class="line">      RtlAppendUnicodeToString(&amp;RegistryKey, ServicesKeyName); </span><br><span class="line">      RtlAppendUnicodeStringToString(&amp;RegistryKey, ServiceName);<span class="comment">//构造好服务键全路径 </span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      RtlInitUnicodeString(&amp;RegistryKey, <span class="literal">NULL</span>); </span><br><span class="line">   <span class="keyword">if</span> (ServiceName &amp;&amp; ServiceName-&gt;Length &gt; <span class="number">0</span>) </span><br><span class="line">   &#123; </span><br><span class="line">      <span class="keyword">if</span> (FileSystemDriver == TRUE) </span><br><span class="line">         wcscpy(NameBuffer, ”L\\FileSystem\\”); </span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">         wcscpy(NameBuffer, ”L\\Driver\\”); </span><br><span class="line">      RtlInitUnicodeString(&amp;DriverName, NameBuffer); </span><br><span class="line">      DriverName.MaximumLength = <span class="keyword">sizeof</span>(NameBuffer); </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">      RtlAppendUnicodeStringToString(&amp;DriverName, ServiceName);<span class="comment">//构造好这个驱动的驱动对象名 </span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      DriverName.Length = <span class="number">0</span>; </span><br><span class="line">   <span class="comment">//上面构造好这个驱动的驱动对象名后,下面就开始创建驱动对象了 </span></span><br><span class="line">   Status = IopCreateDriver(DriverName.Length &gt; <span class="number">0</span> ? &amp;DriverName : <span class="literal">NULL</span>, </span><br><span class="line">                            DriverEntry,&amp;RegistryKey,ModuleObject,&amp;Driver); </span><br><span class="line">   RtlFreeUnicodeString(&amp;RegistryKey); </span><br><span class="line">   *DriverObject = Driver;<span class="comment">//返回创建的驱动对象 </span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (!NT_SUCCESS(Status))    </span><br><span class="line">      <span class="keyword">return</span> Status; <span class="comment">//DriverEntry可能返回失败到这里来 </span></span><br><span class="line">  </span><br><span class="line">   IopReadyDeviceObjects(Driver); </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (PnpSystemInit) </span><br><span class="line">      IopReinitializeDrivers();<span class="comment">//调用所有注册了重初始化例程的驱动他们的重初始化例程 </span></span><br><span class="line">   <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IopCreateDriver"><a href="#IopCreateDriver" class="headerlink" title="IopCreateDriver"></a>IopCreateDriver</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IopCreateDriver</span><span class="params">(IN PUNICODE_STRING DriverName OPTIONAL,<span class="comment">//驱动对象的名称,一般都会提供 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN PDRIVER_INITIALIZE InitializationFunction,<span class="comment">//DriverEntry </span></span></span></span><br><span class="line"><span class="function"><span class="params">                IN PUNICODE_STRING RegistryPath,<span class="comment">//服务键的全路径 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                PLDR_DATA_TABLE_ENTRY ModuleObject,<span class="comment">//驱动模块信息 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                OUT PDRIVER_OBJECT *pDriverObject)</span><span class="comment">//返回创建的驱动对象 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ULONG RetryCount = <span class="number">0</span>; try_again: </span><br><span class="line">    <span class="keyword">if</span> (!DriverName)<span class="comment">//如果没提供名称,根据当前TickCount随机生成一个驱动对象名称(少见) </span></span><br><span class="line">    &#123; </span><br><span class="line">        NameLength = (USHORT)swprintf(NameBuffer,<span class="string">L"\\Driver\\%08u"</span>,KeTickCount); </span><br><span class="line">        LocalDriverName.Length = NameLength * <span class="keyword">sizeof</span>(WCHAR); </span><br><span class="line">        LocalDriverName.MaximumLength = LocalDriverName.Length + <span class="keyword">sizeof</span>(UNICODE_NULL); </span><br><span class="line">        LocalDriverName.Buffer = NameBuffer; </span><br><span class="line">    &#125; </span><br><span class="line">    Else <span class="comment">//最典型 </span></span><br><span class="line">        LocalDriverName = *DriverName; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//LocalDriverName就表示最后的驱动对象名称 </span></span><br><span class="line">    ObjectSize = <span class="keyword">sizeof</span>(DRIVER_OBJECT) + <span class="keyword">sizeof</span>(EXTENDED_DRIVER_EXTENSION); </span><br><span class="line">    InitializeObjectAttributes(&amp;ObjectAttributes,&amp;LocalDriverName, </span><br><span class="line">                               OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,<span class="literal">NULL</span>,<span class="literal">NULL</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//驱动对象体的大小为驱动对象结构本身的大小 + 后面紧跟的标准驱动扩展结构的大小 </span></span><br><span class="line">    Status = ObCreateObject(KernelMode,IoDriverObjectType,&amp;ObjectAttributes,KernelMode, </span><br><span class="line">                            <span class="literal">NULL</span>,ObjectSize,<span class="number">0</span>,<span class="number">0</span>, (PVOID*)&amp;DriverObject); </span><br><span class="line">    RtlZeroMemory(DriverObject, ObjectSize); </span><br><span class="line">    DriverObject-&gt;Type = IO_TYPE_DRIVER; </span><br><span class="line"> </span><br><span class="line">    DriverObject-&gt;Size = <span class="keyword">sizeof</span>(DRIVER_OBJECT); </span><br><span class="line">    DriverObject-&gt;Flags = DRVO_LEGACY_DRIVER; </span><br><span class="line">    DriverObject-&gt;DriverExtension = (PDRIVER_EXTENSION)(DriverObject + <span class="number">1</span>);<span class="comment">//指向尾部的扩展 </span></span><br><span class="line">    DriverObject-&gt;DriverExtension-&gt;DriverObject = DriverObject; </span><br><span class="line">    DriverObject-&gt;DriverInit = InitializationFunction;<span class="comment">//DriverEntry </span></span><br><span class="line">    DriverObject-&gt;DriverSection = ModuleObject;<span class="comment">//指向驱动的模块信息 </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= IRP_MJ_MAXIMUM_FUNCTION; i++) </span><br><span class="line">        DriverObject-&gt;MajorFunction[i] = IopInvalidDeviceRequest;<span class="comment">//默认的irp派遣函数是这个 </span></span><br><span class="line">    ServiceKeyName.Buffer = ExAllocatePoolWithTag(PagedPool,LocalDriverName.Length + </span><br><span class="line">                                                  <span class="keyword">sizeof</span>(WCHAR),TAG_IO); </span><br><span class="line">    ServiceKeyName.Length = LocalDriverName.Length; </span><br><span class="line">    ServiceKeyName.MaximumLength = LocalDriverName.MaximumLength; </span><br><span class="line">    RtlCopyMemory(ServiceKeyName.Buffer,LocalDriverName.Buffer,LocalDriverName.Length); </span><br><span class="line">    ServiceKeyName.Buffer[ServiceKeyName.Length / <span class="keyword">sizeof</span>(WCHAR)] = UNICODE_NULL; </span><br><span class="line">    DriverObject-&gt;DriverExtension-&gt;ServiceKeyName = ServiceKeyName;<span class="comment">//驱动对象的名称,\0终止 </span></span><br><span class="line"></span><br><span class="line">    RtlCopyMemory(&amp;DriverObject-&gt;DriverName,&amp;ServiceKeyName,<span class="keyword">sizeof</span>(UNICODE_STRING)); </span><br><span class="line">    <span class="comment">//看到没,会把驱动对象挂入对象目录中,从而可防止重复加载 </span></span><br><span class="line">    Status = ObInsertObject(DriverObject,<span class="literal">NULL</span>,FILE_READ_DATA,<span class="number">0</span>,<span class="literal">NULL</span>,&amp;hDriver); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//由TickCount生成的随机驱动对象名称可能会产生冲突,因此重试。 </span></span><br><span class="line">    <span class="keyword">if</span> (!DriverName &amp;&amp; (Status == STATUS_OBJECT_NAME_COLLISION) &amp;&amp; (RetryCount &lt; <span class="number">100</span>)) </span><br><span class="line">    &#123; </span><br><span class="line">        RetryCount++; </span><br><span class="line">        <span class="keyword">goto</span> try_again; </span><br><span class="line">    &#125; </span><br><span class="line">    Status = ObReferenceObjectByHandle(hDriver,<span class="number">0</span>,IoDriverObjectType,KernelMode, </span><br><span class="line">                                       (PVOID*)&amp;DriverObject,<span class="literal">NULL</span>); </span><br><span class="line">    ZwClose(hDriver); </span><br><span class="line">    DriverObject-&gt;HardwareDatabase = &amp;IopHardwareDatabaseKey;<span class="comment">//固定 </span></span><br><span class="line">    DriverObject-&gt;DriverStart = ModuleObject ? ModuleObject-&gt;DllBase : <span class="number">0</span>; DriverObject-&gt;DriverSize = ModuleObject ? ModuleObject-&gt;SizeOfImage : <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关键。调用我们的DriverEntry </span></span><br><span class="line">    Status = (*InitializationFunction)(DriverObject, RegistryPath); </span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="comment">//我们的DriverEntry可能返回失败 </span></span><br><span class="line">    &#123; </span><br><span class="line">        DriverObject-&gt;DriverSection = <span class="literal">NULL</span>; </span><br><span class="line">        ObMakeTemporaryObject(DriverObject); </span><br><span class="line">        ObDereferenceObject(DriverObject); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        *pDriverObject = DriverObject;<span class="comment">//返回 </span></span><br><span class="line">    <span class="comment">//即使我们误将派遣函数填为NULL,也会被系统后台自动更为IopInvalidDeviceRequest </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= IRP_MJ_MAXIMUM_FUNCTION; i++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (DriverObject-&gt;MajorFunction[i] == <span class="literal">NULL</span>) </span><br><span class="line"> </span><br><span class="line">            DriverObject-&gt;MajorFunction[i] = IopInvalidDeviceRequest; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> Status; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//下面是默认的 irp 派遣函数,它仅仅简单以失败方式完成这个 irp </span></span><br><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">IopInvalidDeviceRequest</span><span class="params">(PDEVICE_OBJECT DeviceObject,PIRP Irp)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   Irp-&gt;IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST; </span><br><span class="line">   Irp-&gt;IoStatus.Information = <span class="number">0</span>; </span><br><span class="line">   IoCompleteRequest(Irp, IO_NO_INCREMENT); </span><br><span class="line">   <span class="keyword">return</span> STATUS_INVALID_DEVICE_REQUEST; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当加载了一个驱动,调用了<code>DriverEntry</code>函数后,就会接着调用<code>IopReinitializeDrivers</code>这个函数<br>检测系统中是否有驱动注册了<code>重初始化例程</code>,若有就调用之。 </p>
<h5 id="IopReinitializeDrivers"><a href="#IopReinitializeDrivers" class="headerlink" title="IopReinitializeDrivers"></a>IopReinitializeDrivers</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">IopReinitializeDrivers</span><span class="params">(VOID)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PDRIVER_REINIT_ITEM ReinitItem; </span><br><span class="line">    PLIST_ENTRY Entry; </span><br><span class="line">    Entry = ExInterlockedRemoveHeadList(&amp;DriverReinitListHead,&amp;DriverReinitListLock);<span class="comment">//取下来 </span></span><br><span class="line">    <span class="keyword">while</span> (Entry)<span class="comment">//遍历所有注册了`重初始化例程`的驱动 </span></span><br><span class="line">    &#123; </span><br><span class="line">        ReinitItem = CONTAINING_RECORD(Entry, DRIVER_REINIT_ITEM, ItemEntry); </span><br><span class="line">        <span class="comment">//递增那个驱动的`重初始化例程`历史被调用次数 </span></span><br><span class="line">        ReinitItem-&gt;DriverObject-&gt;DriverExtension-&gt;Count++;  </span><br><span class="line">        ReinitItem-&gt;DriverObject-&gt;Flags &amp;= ~DRVO_REINIT_REGISTERED; </span><br><span class="line">        <span class="comment">//调用那个驱动注册的`重初始化例程` </span></span><br><span class="line">        ReinitItem-&gt;ReinitRoutine(ReinitItem-&gt;DriverObject,ReinitItem-&gt;Context, </span><br><span class="line">                                  ReinitItem-&gt;DriverObject-&gt;DriverExtension-&gt;Count); </span><br><span class="line">        ExFreePool(Entry);<span class="comment">//执行后,就删除掉 </span></span><br><span class="line">        Entry = ExInterlockedRemoveHeadList(&amp;DriverReinitListHead,&amp;DriverReinitListLock); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="IoRegisterDriverReinitialization"><a href="#IoRegisterDriverReinitialization" class="headerlink" title="IoRegisterDriverReinitialization"></a>IoRegisterDriverReinitialization</h5><p>驱动可以调用下面的函数这册一个<code>重初始化例程</code>,以在其<code>DriverEntry</code>被调用后,可以重新得到初始化。<br>注意<code>重初始化例程</code>一得到调用就立马删除。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">IoRegisterDriverReinitialization</span><span class="params">(IN PDRIVER_OBJECT DriverObject, </span></span></span><br><span class="line"><span class="function"><span class="params">                                 IN PDRIVER_REINITIALIZE ReinitRoutine,IN PVOID Context)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PDRIVER_REINIT_ITEM ReinitItem; </span><br><span class="line">    ReinitItem = ExAllocatePoolWithTag(NonPagedPool,<span class="keyword">sizeof</span>(DRIVER_REINIT_ITEM),TAG_REINIT); </span><br><span class="line"> </span><br><span class="line">    ReinitItem-&gt;DriverObject = DriverObject; </span><br><span class="line">    ReinitItem-&gt;ReinitRoutine = ReinitRoutine; </span><br><span class="line">    ReinitItem-&gt;Context = Context; </span><br><span class="line">    DriverObject-&gt;Flags |= DRVO_REINIT_REGISTERED; </span><br><span class="line">    <span class="comment">//挂入全局队列 ExInterlockedInsertTailList(&amp;DriverReinitListHead,&amp;ReinitItem-&gt;ItemEntry, &amp;DriverReinitListLock); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们看完了老式驱动通过 SCM 服务管理器加载的过程。 </p>
<p>实际上SCM 在加载自启型(<code>AUTO_START</code>型)的驱动时,也是最终调用的<code>NtLoadDriver</code>加载的。</p>
<p>因此我们可以说,凡是通过 SCM 加载的驱动,都是老式驱动。<br>SCM 只能加载老式驱动。<br>下面我们看系统初始化(不是指引导)时,是如何加载各个硬件设备的驱动的。 </p>
<h3 id="驱动加载过程-非NtLoadDriver"><a href="#驱动加载过程-非NtLoadDriver" class="headerlink" title="驱动加载过程(非NtLoadDriver)"></a>驱动加载过程(非NtLoadDriver)</h3><p>在此先介绍下背景知识:<br>系统在启动后,会根据总线布局层次枚举系统中所有的硬件设备,为它们创建设备节点,<br>加入到设备节点树中,同时加载它们的端口驱动。<br>内核中有一个设备节点树,树中的每个节点叫<code>设备节点</code>,每个设备节点就表示一个硬件设备。<br>系统在初始化时,<code>PNP</code>管理器会从根总线逐级向下枚举出系统中的所有硬件设备,为各个硬件创建一个设备节点,然后为其创建用作栈底基石的 pdo,记录在各个硬件的设备节点中,然后将设备节点按照总线位置关系挂 入节点树中。</p>
<p>因此可以说,节点树就是用来系统中的物理硬件排放顺序的一个缩影,通过遍历这个节点 树,我们不仅可以找出系统中的所有硬件设备,还可以得出他们之间的物理位置关系。 </p>
<p>节点树中的每个节点表示一条总线或一个设备,总线也是一种特殊的设备,它也有自己的驱动。<br>比如<code>pci.sys</code>就是用来驱动总线本身的一个驱动。<br>节点树的根是一条总线,但是它实际上不存在,看不见摸不着,它是虚拟的,我们叫它<code>根总线</code>,也可叫它<code>虚拟根总线</code>。</p>
<p>在根总线下面也即节点树的第一层,一般都是一条条具体的总线。如<code>PCI</code>总线、<code>PCICMA</code>总线等,就好像<code>PCI</code>总线、<code>PCICMA</code>总线挂在根总线的下面, <code>PCI</code>总线本身也是一个设备,它是根总线下面的一个设备节点。<br><code>PCI</code>总线的下面,则可以挂接其他的总线如 ISA 总线、ATA 总线、USB 总线,PCI 总线下面也可以直接挂接真正的设备,如网卡、声卡等。</p>
<p>如果节点树中的某个设备节点是一个总线,那么他下面往往还可以挂接其他设备,就像文件夹一样。<br>如果设备节点是个真正的设备,那么它下面一般不能在挂接其他设备,这种设备节点我们可以叫他<code>叶设备</code>。</p>
<p>一般来说,非总线设备都是叶设备,不能再挂接其他设备,但是也有例外的时候,比如 USB 根 HUB,它本身是挂在 USB 总线上的,但是一个 HUB 可以提供很多插口,外接其他 USB 设备或其他 HUB。 </p>
<p>我们可以说：设备节点即是硬件,硬件即是设备节点。 根总线是虚拟的,系统在初始化时,会创建一个全局的虚拟设备对象,来表示那条根总线,这个全局变量是<code>PnpRootDeviceObject</code>,然后会创建一个全局的根设备节点来表示那条总线,这个全局变量名是<code>IopRootDeviceNode</code>,同时还会创建一个根驱动对象<code>IopRootDriverObject</code>。</p>
<p>这三者都是系统初始化时创建的,他们之间的关系是：<code>PnpRootDeviceObject</code>-&gt;<code>DriverObject</code>等于<code>IopRootDriverObject</code>,<code>IopRootDeviceNode</code>-&gt;<code>PhysicalDeviceObject</code>等于<code>PnpRootDeviceObject</code>。 </p>
<p>简而言之：在根总线驱动中创建的根总线设备对象,根设备节点则代表根总线。 另外节点树中的每个节点都表示真实的硬件设备对象,因此设备节点中的<code>PhysicalDeviceObject</code>总是指那个用作堆栈基石的栈底 pdo,也即<code>硬件 pdo</code>。<br>各个硬件设备的栈底 pdo 都是由其所在的总线驱动为其创建的。</p>
<p>比如显卡是挂在 pci 总线上的,因此显卡的硬件 pdo 就是由 PCI 总线驱动(pci.sys)在内部 创建的。<br>因此我们可以说某个设备,你挂在哪条总线旗下,你的硬件 pdo 就是由那条总线的驱动自动为你创建的。 </p>
<p>设备节点树反映的是物理位置布局层次关系,而设备栈反映的则是逻辑堆栈层次关系(设计设备栈的目的 就是用来使驱动开发变得模块化以减轻驱动开发工作,仅此而已),<br>设备树与设备栈之间没有必然的关系。<br>如果说设备树是立体的(最上面的根,最下面的是叶),那么设备栈就是水平的(离我们最近的是栈顶,最远的是栈底)。 </p>
<p>换言之,有下面的说法</p>
<ul>
<li><ol>
<li>每个设备节点都有自己的设备堆栈,并且位于设备栈底。 </li>
</ol>
</li>
<li><ol start="2">
<li>设备树中有多少个设备节点,系统中就有多少个设备栈。(各个设备栈之间是独立的,互不关联) </li>
</ol>
</li>
</ul>
<p>关于设备节点的图形展示,推荐阅读：<a href="http://technet.microsoft.com/zh-cn/library/ff554721" target="_blank" rel="noopener">http://technet.microsoft.com/zh-cn/library/ff554721</a><br>(注：由于本人对硬件也不是太了解,上面的大段话可能有误,望各位同行纠正) </p>
<h4 id="基本结构-1"><a href="#基本结构-1" class="headerlink" title="基本结构"></a>基本结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_NODE</span> //设备节点 </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_NODE</span> *<span class="title">Sibling</span>;</span><span class="comment">//下一个兄弟节点 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_NODE</span> *<span class="title">Child</span>;</span><span class="comment">//第一个子节点 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_NODE</span> *<span class="title">Parent</span>;</span><span class="comment">//父节点 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_NODE</span> *<span class="title">LastChild</span>;</span><span class="comment">//最后一个子节点 </span></span><br><span class="line">    </span><br><span class="line">    ULONG Level;<span class="comment">//在节点数的层号(从上往下数,基于0的索引) </span></span><br><span class="line">    PDEVICE_OBJECT PhysicalDeviceObject;<span class="comment">//关键字段。所属的硬件pdo(指栈底的基石pdo) </span></span><br><span class="line">    PCM_RESOURCE_LIST ResourceList;<span class="comment">//分配到的资源列表 </span></span><br><span class="line">    PCM_RESOURCE_LIST ResourceListTranslated;<span class="comment">//转换资源列表 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每个硬件设备(包括总线)都记录在注册表中,对应这册表中的某个键。每个设备由设备ID与实例 ID的组合唯一标识。(设备ID其实是设备类ID),</span></span><br><span class="line">    <span class="comment">//常见的InstancePath如:Root\Legacy_设备类名\0000, Root\Legacy_设备类名\0001,  Root\Legacy_设备类名\0003 </span></span><br><span class="line">    UNICODE_STRING InstancePath;<span class="comment">//本硬件设备在注册表中的的实例键路径 </span></span><br><span class="line">    UNICODE_STRING ServiceName;<span class="comment">//本硬件匹配的端口驱动 </span></span><br><span class="line">    PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements;<span class="comment">//资源需求 </span></span><br><span class="line">    ULONG BusNumber;<span class="comment">//挂在总线位置 LIST_ENTRY DeviceTranslatorList; </span></span><br><span class="line">…… </span><br><span class="line">&#125; DEVICE_NODE, *PDEVICE_NODE;</span><br></pre></td></tr></table></figure>
<h4 id="IopCreateDeviceNode"><a href="#IopCreateDeviceNode" class="headerlink" title="IopCreateDeviceNode"></a>IopCreateDeviceNode</h4><p>下面的函数用来为指定的硬件设备创建一个硬件设备节点,加入到设备树,同时记录到注册表中。    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IopCreateDeviceNode</span><span class="params">(PDEVICE_NODE ParentNode,<span class="comment">//父节点 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    PDEVICE_OBJECT PhysicalDeviceObject,<span class="comment">//硬件设备(老式驱动为NULL) </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    PUNICODE_STRING ServiceName,<span class="comment">//匹配的驱动 </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    PDEVICE_NODE *DeviceNode)</span><span class="comment">//返回 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   UNICODE_STRING LegacyPrefix = RTL_CONSTANT_STRING(<span class="string">L"LEGACY_"</span>); </span><br><span class="line">   UNICODE_STRING UnknownDeviceName = RTL_CONSTANT_STRING(<span class="string">L"UNKNOWN"</span>); </span><br><span class="line"> </span><br><span class="line">   Node = (PDEVICE_NODE)ExAllocatePool(NonPagedPool, <span class="keyword">sizeof</span>(DEVICE_NODE));<span class="comment">//分配一个节点 </span></span><br><span class="line"> </span><br><span class="line">   RtlZeroMemory(Node, <span class="keyword">sizeof</span>(DEVICE_NODE)); </span><br><span class="line">   <span class="keyword">if</span> (!ServiceName) </span><br><span class="line">       ServiceName1 = &amp;UnknownDeviceName; </span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">       ServiceName1 = ServiceName; </span><br><span class="line">   <span class="keyword">if</span> (!PhysicalDeviceObject)<span class="comment">//老式驱动是没有硬件pdo支撑的,模拟为其创建一个 </span></span><br><span class="line">   &#123; </span><br><span class="line">      FullServiceName.MaximumLength = LegacyPrefix.Length + ServiceName1-&gt;Length; </span><br><span class="line">      FullServiceName.Length = <span class="number">0</span>; </span><br><span class="line">      FullServiceName.Buffer = ExAllocatePool(PagedPool, FullServiceName.MaximumLength); </span><br><span class="line">      RtlAppendUnicodeStringToString(&amp;FullServiceName, &amp;LegacyPrefix); </span><br><span class="line">      RtlAppendUnicodeStringToString(&amp;FullServiceName, ServiceName1); </span><br><span class="line">      <span class="comment">//FullServiceName此时等于“LEGACY_服务名” </span></span><br><span class="line">      <span class="comment">//在根总线驱动中为其创建一个模拟的硬件pdo(用作栈底基石) </span></span><br><span class="line">      Status = PnpRootCreateDevice(&amp;FullServiceName, &amp;PhysicalDeviceObject, &amp;Node-&gt;InstancePath);<span class="comment">//返回生成的实例键路径 </span></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      <span class="comment">//将该硬件设备记录到注册表中(即创建它的实例键),这就是为什么这次表的ROOT键下面有一大 </span></span><br><span class="line">      <span class="comment">//堆‘Legacy_设备类名’和‘Legacy_设备类名\XXXX’的原因,就是这个函数创建写入注册表的。 </span></span><br><span class="line">      <span class="comment">//注意是REG_OPTION_VOLATILE类型,即不会保存到注册表磁盘中,机器一重启就会丢失。 </span></span><br><span class="line">      Status = IopCreateDeviceKeyPath(&amp;Node-&gt;InstancePath, REG_OPTION_VOLATILE, &amp;InstanceHandle);<span class="comment">//返回实例键的hKey </span></span><br><span class="line">      Node-&gt;ServiceName.Buffer = ExAllocatePool(PagedPool, ServiceName1-&gt;Length); </span><br><span class="line">      Node-&gt;ServiceName.MaximumLength = ServiceName1-&gt;Length; </span><br><span class="line">      Node-&gt;ServiceName.Length = <span class="number">0</span>; </span><br><span class="line">      RtlAppendUnicodeStringToString(&amp;Node-&gt;ServiceName, ServiceName1);<span class="comment">//匹配的端口驱动 </span></span><br><span class="line">      <span class="keyword">if</span> (ServiceName) </span><br><span class="line">      &#123;    </span><br><span class="line">          RtlInitUnicodeString(&amp;KeyName, <span class="string">L"Service"</span>); </span><br><span class="line">          <span class="comment">//在注册表登记这个硬件设备的匹配端口驱动 </span></span><br><span class="line">          Status = ZwSetValueKey(InstanceHandle, &amp;KeyName, <span class="number">0</span>, REG_SZ, ServiceName-&gt;Buffer, ServiceName-&gt;Length); </span><br><span class="line">      &#125; </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">      &#123; </span><br><span class="line">          <span class="comment">//在注册表中登记这个设备是一个老式设备 </span></span><br><span class="line">          RtlInitUnicodeString(&amp;KeyName, <span class="string">L"Legacy"</span>); </span><br><span class="line">          LegacyValue = <span class="number">1</span>; </span><br><span class="line">          Status = ZwSetValueKey(InstanceHandle, &amp;KeyName, <span class="number">0</span>, REG_DWORD, &amp;LegacyValue, <span class="keyword">sizeof</span>(LegacyValue)); </span><br><span class="line">          <span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">          &#123; </span><br><span class="line">              RtlInitUnicodeString(&amp;KeyName, <span class="string">L"Class"</span>); </span><br><span class="line">              RtlInitUnicodeString(&amp;ClassName, <span class="string">L"LegacyDriver"</span>); </span><br><span class="line">              Status = ZwSetValueKey(InstanceHandle, &amp;KeyName, <span class="number">0</span>, REG_SZ, ClassName.Buffer, ClassName.Length); </span><br><span class="line">          &#125; </span><br><span class="line">      &#125; </span><br><span class="line">      ZwClose(InstanceHandle); </span><br><span class="line"> </span><br><span class="line">      ExFreePool(FullServiceName.Buffer); </span><br><span class="line">      IopDeviceNodeSetFlag(Node, DNF_LEGACY_DRIVER);<span class="comment">//标记这个硬件是一个老式的设备 </span></span><br><span class="line">      IopDeviceNodeSetFlag(Node, DNF_ADDED);<span class="comment">//标记已经被绑定(用来模拟pnp设备) </span></span><br><span class="line">      IopDeviceNodeSetFlag(Node, DNF_STARTED);<span class="comment">//标记已启动(用来模拟pnp设备) </span></span><br><span class="line">   &#125; </span><br><span class="line">    </span><br><span class="line">    Node-&gt;PhysicalDeviceObject = PhysicalDeviceObject;<span class="comment">//关键。记录指定的硬件pdo </span></span><br><span class="line">    (PhysicalDeviceObject-&gt;DeviceObjectExtension)-&gt;DeviceNode = Node;<span class="comment">//互相维护 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ParentNode) </span><br><span class="line">    &#123; </span><br><span class="line">        KeAcquireSpinLock(&amp;IopDeviceTreeLock, &amp;OldIrql); </span><br><span class="line">        Node-&gt;Parent = ParentNode; </span><br><span class="line">        Node-&gt;Sibling = ParentNode-&gt;Child; </span><br><span class="line">        ParentNode-&gt;Child = Node;<span class="comment">//挂在父节点的子节点列表开头 </span></span><br><span class="line">        <span class="keyword">if</span> (ParentNode-&gt;LastChild == <span class="literal">NULL</span>) </span><br><span class="line">            ParentNode-&gt;LastChild = Node; </span><br><span class="line">        KeReleaseSpinLock(&amp;IopDeviceTreeLock, OldIrql); </span><br><span class="line">        Node-&gt;Level = ParentNode-&gt;Level + <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    PhysicalDeviceObject-&gt;Flags &amp;= ~DO_DEVICE_INITIALIZING; </span><br><span class="line">    *DeviceNode = Node;<span class="comment">//返回创建的设备节点 </span></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个函数专用于在根总线驱动中创建一个硬件 pdo</p>
<blockquote>
<p>所有老式设备,以及最上层的总线,都挂在根总线下面因此他们的硬件 pdo 都是靠这个函数创建的</p>
</blockquote>
<h4 id="PnpRootCreateDevice"><a href="#PnpRootCreateDevice" class="headerlink" title="PnpRootCreateDevice"></a>PnpRootCreateDevice</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">PnpRootCreateDevice</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    IN PUNICODE_STRING ServiceName,<span class="comment">//服务名 </span></span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PDEVICE_OBJECT *PhysicalDeviceObject,<span class="comment">//返回创建的设备对象 </span></span></span></span><br><span class="line"><span class="function"><span class="params">    OUT OPTIONAL PUNICODE_STRING FullInstancePath)</span><span class="comment">//返回实例键路径(‘Root\类型\实例ID’形式) </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    UNICODE_STRING PathSep = RTL_CONSTANT_STRING(<span class="string">L"\\"</span>); </span><br><span class="line">    <span class="comment">//#define REGSTR_PATH_SYSTEMENUM  TEXT("System\\CurrentControlSet\\Enum") </span></span><br><span class="line">    </span><br><span class="line">    UNICODE_STRING EnumKeyName = RTL_CONSTANT_STRING(<span class="string">L"\\Registry\\Machine\\"</span>REGSTR_PATH_SYSTEMENUM); </span><br><span class="line">    HANDLE EnumHandle, DeviceKeyHandle = INVALID_HANDLE_VALUE; </span><br><span class="line">    DeviceExtension = PnpRootDeviceObject-&gt;DeviceExtension;<span class="comment">//根总线设备的扩展 KeAcquireGuardedMutex(&amp;DeviceExtension-&gt;DeviceListLock); </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//#define REGSTR_KEY_ROOTENUM  TEXT("Root") </span></span><br><span class="line">    _snwprintf(DevicePath, <span class="keyword">sizeof</span>(DevicePath) / <span class="keyword">sizeof</span>(WCHAR), <span class="string">L"%s\\%wZ"</span>, REGSTR_KEY_ROOTENUM, ServiceName); </span><br><span class="line">    <span class="comment">//最终DevicePath等于‘Root\服务名’形式 </span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//PNPROOT_DEVICE为根总线驱动中定义的‘扩展中的扩展’结构 </span></span><br><span class="line">    Device = ExAllocatePoolWithTag(PagedPool, <span class="keyword">sizeof</span>(PNPROOT_DEVICE), TAG_PNP_ROOT); </span><br><span class="line">    RtlZeroMemory(Device, <span class="keyword">sizeof</span>(PNPROOT_DEVICE)); </span><br><span class="line">    RtlCreateUnicodeString(&amp;Device-&gt;DeviceID, DevicePath);<span class="comment">//记录该硬件设备的DeviceID </span></span><br><span class="line">    <span class="comment">//打开Enum键 </span></span><br><span class="line">    Status = IopOpenRegistryKeyEx(&amp;EnumHandle, <span class="literal">NULL</span>, &amp;EnumKeyName, KEY_READ); </span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">    &#123; </span><br><span class="line">        InitializeObjectAttributes(&amp;ObjectAttributes, &amp;Device-&gt;DeviceID, OBJ_CASE_INSENSITIVE, EnumHandle, <span class="literal">NULL</span>); </span><br><span class="line">        <span class="comment">//创建‘Root\服务名’键,注意是REG_OPTION_VOLATILE类型,即不会保存到注册表磁盘中 </span></span><br><span class="line">        <span class="comment">//机器一重启就会丢失。 </span></span><br><span class="line">        Status = ZwCreateKey(&amp;DeviceKeyHandle, KEY_SET_VALUE, &amp;ObjectAttributes, <span class="number">0</span>, <span class="literal">NULL</span>, REG_OPTION_VOLATILE, <span class="literal">NULL</span>); </span><br><span class="line">        ZwClose(EnumHandle); </span><br><span class="line">    &#125; </span><br><span class="line">    RtlZeroMemory(QueryTable, <span class="keyword">sizeof</span>(QueryTable)); </span><br><span class="line">    QueryTable[<span class="number">0</span>].Name = <span class="string">L"NextInstance"</span>; </span><br><span class="line">    QueryTable[<span class="number">0</span>].EntryContext = &amp;NextInstance; </span><br><span class="line">    QueryTable[<span class="number">0</span>].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在注册表中查询该类设备的下一个可分配的空闲实例ID号 </span></span><br><span class="line">    Status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE, (PWSTR)DeviceKeyHandle, </span><br><span class="line">                                    QueryTable,<span class="literal">NULL</span>,<span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))<span class="comment">//若没有NextInstance值(这种情况少见) </span></span><br><span class="line">    &#123;   </span><br><span class="line">    <span class="comment">//搜索一个空闲的尚未分配出去的实例ID号 </span></span><br><span class="line">        <span class="keyword">for</span> (NextInstance = <span class="number">0</span>; NextInstance &lt;= <span class="number">9999</span>; NextInstance++) </span><br><span class="line">        &#123; </span><br><span class="line">             _snwprintf(InstancePath, <span class="keyword">sizeof</span>(InstancePath) / <span class="keyword">sizeof</span>(WCHAR), <span class="string">L"%04lu"</span>, NextInstance); </span><br><span class="line">             Status = LocateChildDevice(DeviceExtension, DevicePath, InstancePath, &amp;Device); </span><br><span class="line">             <span class="keyword">if</span> (Status == STATUS_NO_SUCH_DEVICE) <span class="comment">//if 找到了 </span></span><br><span class="line">                 <span class="keyword">break</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//经过上面的折腾后,NextInstance就是本次可用分配到的实例ID号 </span></span><br><span class="line">    _snwprintf(InstancePath, <span class="keyword">sizeof</span>(InstancePath) / <span class="keyword">sizeof</span>(WCHAR), <span class="string">L"%04lu"</span>, NextInstance); </span><br><span class="line">    Status = LocateChildDevice(DeviceExtension, DevicePath, InstancePath, &amp;Device); </span><br><span class="line">    NextInstance++; </span><br><span class="line"></span><br><span class="line">    Status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,DeviceKeyHandle,<span class="string">L"NextInstance"</span>, REG_DWORD,&amp;NextInstance,<span class="keyword">sizeof</span>(NextInstance)); </span><br><span class="line"> </span><br><span class="line">    RtlCreateUnicodeString(&amp;Device-&gt;InstanceID, InstancePath);<span class="comment">//‘XXXX’形式 </span></span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (FullInstancePath) </span><br><span class="line">    &#123; </span><br><span class="line">        FullInstancePath-&gt;MaximumLength = Device-&gt;DeviceID.Length + PathSep.Length + Device-&gt;InstanceID.Length; </span><br><span class="line">        FullInstancePath-&gt;Length = <span class="number">0</span>; </span><br><span class="line">        FullInstancePath-&gt;Buffer = ExAllocatePool(PagedPool,FullInstancePath-&gt;MaximumLength); </span><br><span class="line">        RtlAppendUnicodeStringToString(FullInstancePath, &amp;Device-&gt;DeviceID); </span><br><span class="line">        RtlAppendUnicodeStringToString(FullInstancePath, &amp;PathSep); </span><br><span class="line">        RtlAppendUnicodeStringToString(FullInstancePath, &amp;Device-&gt;InstanceID); </span><br><span class="line">        <span class="comment">//最终为FullInstancePath等于‘Root\服务名\XXXX’形式 </span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关键,创建硬件pdo。(注意：除了wdm驱动,系统也会为老式驱动模拟创建一个硬件pdo) </span></span><br><span class="line">    Status = IoCreateDevice( </span><br><span class="line">        PnpRootDeviceObject-&gt;DriverObject,<span class="comment">//关键。根总线驱动 </span></span><br><span class="line">        <span class="keyword">sizeof</span>(PNPROOT_PDO_DEVICE_EXTENSION),<span class="comment">//根总线驱动中定义的设备扩展 </span></span><br><span class="line">        <span class="literal">NULL</span>,FILE_DEVICE_CONTROLLER, </span><br><span class="line">        FILE_AUTOGENERATED_DEVICE_NAME,<span class="comment">//硬件pdo的对象名都是自动生成的,\Device\XXXXXXXX形式 </span></span><br><span class="line">        FALSE,&amp;Device-&gt;Pdo); </span><br><span class="line">    PdoDeviceExtension = (PPNPROOT_PDO_DEVICE_EXTENSION)Device-&gt;Pdo-&gt;DeviceExtension; </span><br><span class="line">    RtlZeroMemory(PdoDeviceExtension, <span class="keyword">sizeof</span>(PNPROOT_PDO_DEVICE_EXTENSION)); </span><br><span class="line">    PdoDeviceExtension-&gt;Common.IsFDO = FALSE;<span class="comment">//硬件pdo当然不是fdo了 PdoDeviceExtension-&gt;DeviceInfo = Device;//扩展中的扩展 </span></span><br><span class="line">    <span class="comment">//标记这个设备对象是在其所属的总线驱动枚举到后,自动在内部给创建的 </span></span><br><span class="line">    Device-&gt;Pdo-&gt;Flags |= DO_BUS_ENUMERATED_DEVICE;  </span><br><span class="line">    Device-&gt;Pdo-&gt;Flags &amp;= ~DO_DEVICE_INITIALIZING; </span><br><span class="line">    <span class="comment">//关键。根总线下面挂接的所有老式设备、其它总线,都记录在根总线设备扩展的链表中。 </span></span><br><span class="line">    InsertTailList(&amp;DeviceExtension-&gt;DeviceListHead, &amp;Device-&gt;ListEntry); </span><br><span class="line">    DeviceExtension-&gt;DeviceListCount++; </span><br><span class="line">    *PhysicalDeviceObject = Device-&gt;Pdo;<span class="comment">//返回创建的硬件pdo </span></span><br><span class="line">    Status = STATUS_SUCCESS; cleanup: <span class="comment">//清理工作,略 </span></span><br><span class="line">    <span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上上面这个函数的主要用途就是为指定服务类型的设备分配一个实例 ID,在根总线驱动中创建一个硬件 pdo。 </p>
<p>下面的函数用来将硬件设备记录到注册表中(即创建一个对应它的实例键) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IopCreateDeviceKeyPath</span><span class="params">(IN PCUNICODE_STRING RegistryPath,<span class="comment">//`Root\服务名\XXXX`形式 </span></span></span></span><br><span class="line"><span class="function"><span class="params">	IN ULONG CreateOptions,OUT PHANDLE Handle)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// #define ENUM_ROOT L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum" </span></span><br><span class="line">    UNICODE_STRING EnumU = RTL_CONSTANT_STRING(ENUM_ROOT); </span><br><span class="line">    HANDLE hParent = <span class="literal">NULL</span>, hKey; </span><br><span class="line">    *Handle = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">//打开Enum键 </span></span><br><span class="line">    Status = IopOpenRegistryKeyEx(&amp;hParent, <span class="literal">NULL</span>, &amp;EnumU, KEY_CREATE_SUB_KEY); </span><br><span class="line">    Current = KeyName.Buffer = RegistryPath-&gt;Buffer; </span><br><span class="line">    Last = &amp;RegistryPath-&gt;Buffer[RegistryPath-&gt;Length / <span class="keyword">sizeof</span>(WCHAR)]; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面的循环为RegistryPath路径参数中的各节创建一个键 </span></span><br><span class="line">    <span class="keyword">while</span> (Current &lt;= Last) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (Current != Last &amp;&amp; *Current != <span class="string">'\\'</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            Current++; </span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        dwLength = (ULONG_PTR)Current - (ULONG_PTR)KeyName.Buffer; </span><br><span class="line">        KeyName.MaximumLength = KeyName.Length = dwLength; </span><br><span class="line">        InitializeObjectAttributes(&amp;ObjectAttributes,&amp;KeyName,OBJ_CASE_INSENSITIVE, </span><br><span class="line">                                   hParent,<span class="literal">NULL</span>); </span><br><span class="line">        Status = ZwCreateKey(&amp;hKey,Current == Last ? KEY_ALL_ACCESS : KEY_CREATE_SUB_KEY, </span><br><span class="line">                             &amp;ObjectAttributes,<span class="number">0</span>,<span class="literal">NULL</span>,CreateOptions,<span class="literal">NULL</span>); </span><br><span class="line">        <span class="keyword">if</span> (hParent)  ZwClose(hParent); </span><br><span class="line">        <span class="keyword">if</span> (Current == Last) </span><br><span class="line">        &#123; </span><br><span class="line">            *Handle = hKey; </span><br><span class="line">            <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">        &#125; </span><br><span class="line">        hParent = hKey; </span><br><span class="line">        Current++; </span><br><span class="line">        KeyName.Buffer = (LPWSTR)Current; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> STATUS_UNSUCCESSFUL; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="Pnp-驱动的加载过程"><a href="#Pnp-驱动的加载过程" class="headerlink" title="Pnp 驱动的加载过程"></a>Pnp 驱动的加载过程</h4><p>看完了老式驱动通过 NtLoadDriver 的加载过程,下面看 Pnp 驱动的加载过程<br>Pnp 驱动最初是在启动机器,上电自检后进行加载的,这是系统初始化时的静态加载。Pnp 驱动本意为即插 即用,所以 pnp 驱动最重要的特征便是还可以在设备插入电脑时动态加载设备驱动。下面先看一下系统初 始化时静态加载 Pnp 驱动的过程 </p>
<h5 id="IoInitSystem"><a href="#IoInitSystem" class="headerlink" title="IoInitSystem"></a>IoInitSystem</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN  <span class="title">IoInitSystem</span><span class="params">(IN PLOADER_PARAMETER_BLOCK LoaderBlock)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   … </span><br><span class="line">   IopEnumerateDevice(IopRootDeviceNode-&gt;PhysicalDeviceObject);<span class="comment">//枚举出根总线下面的所有设备 </span></span><br><span class="line">   … </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这个函数枚举出指定总线下面挂接的所有子设备,加载它们的驱动 </span></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">IopEnumerateDevice</span><span class="params">(IN PDEVICE_OBJECT DeviceObject)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PDEVICE_NODE DeviceNode = IopGetDeviceNode(DeviceObject);<span class="comment">//对应的设备节点 </span></span><br><span class="line">    <span class="comment">//先将根设备报告给pnp管理器的用户模式部分 </span></span><br><span class="line">    IopQueueTargetDeviceEvent(&amp;GUID_DEVICE_ARRIVAL,&amp;DeviceNode-&gt;InstancePath); </span><br><span class="line">    Stack.Parameters.QueryDeviceRelations.Type = BusRelations;<span class="comment">//查询总线关系 </span></span><br><span class="line">    <span class="comment">//向指定的总线发出一个查询子设备请求 </span></span><br><span class="line">    Status = IopInitiatePnpIrp(DeviceObject,&amp;IoStatusBlock, </span><br><span class="line">        IRP_MN_QUERY_DEVICE_RELATIONS,&amp;Stack); </span><br><span class="line">    <span class="comment">//一般总线驱动会处理这种irp,返回枚举出的所有子设备 </span></span><br><span class="line">    DeviceRelations = (PDEVICE_RELATIONS)IoStatusBlock.Information; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DeviceRelations-&gt;Count; i++) </span><br><span class="line">    &#123; </span><br><span class="line">        ChildDeviceObject = DeviceRelations-&gt;Objects[i]; </span><br><span class="line">        ChildDeviceNode = IopGetDeviceNode(ChildDeviceObject); </span><br><span class="line">        <span class="keyword">if</span> (!ChildDeviceNode)<span class="comment">//if尚未为其创建设备节点 </span></span><br><span class="line">        &#123; </span><br><span class="line">            Status = IopCreateDeviceNode(DeviceNode,ChildDeviceObject,<span class="literal">NULL</span>,&amp;ChildDeviceNode); </span><br><span class="line">            <span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">            &#123; </span><br><span class="line">                ChildDeviceNode-&gt;Flags |= DNF_ENUMERATED; </span><br><span class="line">                ChildDeviceObject-&gt;Flags |= DO_BUS_ENUMERATED_DEVICE; </span><br><span class="line">            &#125; </span><br><span class="line">            Else 。。。 </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123; </span><br><span class="line">            ChildDeviceNode-&gt;Flags |= DNF_ENUMERATED; </span><br><span class="line">            ObDereferenceObject(ChildDeviceObject); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    ExFreePool(DeviceRelations); </span><br><span class="line">    <span class="comment">//通过上面,指定总线中的所有子设备都登记到设备节点树中去了,下面开始处理每个子设备 </span></span><br><span class="line">    IopInitDeviceTreeTraverseContext(&amp;Context,DeviceNode, IopActionInterrogateDeviceStack, DeviceNode); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对指定总线下面的每个子设备执行IopActionInterrogateDeviceStack函数 </span></span><br><span class="line">    Status = IopTraverseDeviceTree(&amp;Context);  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    IopInitDeviceTreeTraverseContext(&amp;Context,DeviceNode,IopActionConfigureChildServices,DeviceNode); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对指定总线下面的每个子设备执行IopActionConfigureChildServices函数 </span></span><br><span class="line">    Status = IopTraverseDeviceTree(&amp;Context); </span><br><span class="line">    Status = IopInitializePnpServices(DeviceNode);<span class="comment">//加载该设备的驱动程序 </span></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//下面这个函数用来为指定总线下面的每个子设备执行指定的函数 </span></span><br><span class="line"><span class="function">NTSTATUS  <span class="title">IopTraverseDeviceTree</span><span class="params">(PDEVICETREE_TRAVERSE_CONTEXT Context)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   NTSTATUS Status; </span><br><span class="line">   Context-&gt;DeviceNode = Context-&gt;FirstDeviceNode; </span><br><span class="line">   Status = IopTraverseDeviceTreeNode(Context);<span class="comment">//实质函数 </span></span><br><span class="line">   <span class="keyword">if</span> (Status == STATUS_UNSUCCESSFUL) </span><br><span class="line">      Status = STATUS_SUCCESS; </span><br><span class="line">   <span class="keyword">return</span> Status; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//下面这个函数对指定总线及其下面的所有子孙设备调用指定函数,递归 </span></span><br><span class="line"><span class="function">NTSTATUS  <span class="title">IopTraverseDeviceTreeNode</span><span class="params">(PDEVICETREE_TRAVERSE_CONTEXT Context)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   PDEVICE_NODE ParentDeviceNode; </span><br><span class="line">   PDEVICE_NODE ChildDeviceNode; </span><br><span class="line">   NTSTATUS Status; </span><br><span class="line">   ParentDeviceNode = Context-&gt;DeviceNode; </span><br><span class="line">   Status = (Context-&gt;Action)(ParentDeviceNode, Context-&gt;Context); </span><br><span class="line">   <span class="keyword">if</span> (!NT_SUCCESS(Status)) </span><br><span class="line">      <span class="keyword">return</span> Status; </span><br><span class="line">   <span class="keyword">for</span> (ChildDeviceNode = ParentDeviceNode-&gt;Child; </span><br><span class="line">        ChildDeviceNode != <span class="literal">NULL</span>; </span><br><span class="line">        ChildDeviceNode = ChildDeviceNode-&gt;Sibling) </span><br><span class="line">   &#123; </span><br><span class="line">      Context-&gt;DeviceNode = ChildDeviceNode; </span><br><span class="line">      Status = IopTraverseDeviceTreeNode(Context); </span><br><span class="line">      <span class="keyword">if</span> (!NT_SUCCESS(Status)) </span><br><span class="line">         <span class="keyword">return</span> Status; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对每个子设备都会先后执行<code>IopActionInterrogateDeviceStack</code>、<code>IopActionConfigureChildServices</code><br>这两个函数所做的工作如下:<code>IopActionInterrogateDeviceStack</code>函数会查询指定总线下面挂接的所有直接子设备的设备 ID、实例 ID,</p>
<p>记录到注册表中,然后查询每个直接子设备的所有硬件ID、所有兼容ID、设备描述、设备能力、总线信息。<br>然后记录到注册表中,并查询它们的资源需求。<br>然后将每个直接子设备报告给 PNP 管理器的用户模式部分。 </p>
<p>至于<code>IopActionConfigureChildServices</code>函数的工作不多,作用不大忽略 </p>
<h5 id="IopInitializePnpServices"><a href="#IopInitializePnpServices" class="headerlink" title="IopInitializePnpServices"></a>IopInitializePnpServices</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IopInitializePnpServices</span><span class="params">(IN PDEVICE_NODE DeviceNode)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   DEVICETREE_TRAVERSE_CONTEXT Context; </span><br><span class="line">   IopInitDeviceTreeTraverseContext(&amp;Context,DeviceNode, </span><br><span class="line">      IopActionInitChildServices,DeviceNode); </span><br><span class="line">   <span class="keyword">return</span> IopTraverseDeviceTree(&amp;Context);<span class="comment">//加载指定总线下面每个子设备的驱动程序 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//下面的函数加载对应的驱动 </span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">IopActionInitChildServices</span><span class="params">(PDEVICE_NODE DeviceNode, </span></span></span><br><span class="line"><span class="function"><span class="params">                           PVOID Context)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   PDEVICE_NODE ParentDeviceNode; </span><br><span class="line">   NTSTATUS Status; </span><br><span class="line">   BOOLEAN BootDrivers = !PnpSystemInit; </span><br><span class="line">   ParentDeviceNode = (PDEVICE_NODE)Context; </span><br><span class="line">   <span class="keyword">if</span> (DeviceNode == ParentDeviceNode) </span><br><span class="line">      <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">   <span class="keyword">if</span> (IopDeviceNodeHasFlag(DeviceNode, DNF_STARTED) || </span><br><span class="line">       IopDeviceNodeHasFlag(DeviceNode, DNF_ADDED) || </span><br><span class="line">       IopDeviceNodeHasFlag(DeviceNode, DNF_DISABLED)) </span><br><span class="line">       <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">   <span class="keyword">if</span> (DeviceNode-&gt;ServiceName.Buffer == <span class="literal">NULL</span>) … </span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">   &#123; </span><br><span class="line">      PLDR_DATA_TABLE_ENTRY ModuleObject; </span><br><span class="line">      PDRIVER_OBJECT DriverObject; </span><br><span class="line">      Status = IopGetDriverObject(&amp;DriverObject,&amp;DeviceNode-&gt;ServiceName,FALSE); </span><br><span class="line">      <span class="keyword">if</span> (!NT_SUCCESS(Status)) </span><br><span class="line">      &#123; </span><br><span class="line">         <span class="comment">//加载相应的驱动 </span></span><br><span class="line">         Status = IopLoadServiceModule(&amp;DeviceNode-&gt;ServiceName, &amp;ModuleObject); </span><br><span class="line">         <span class="keyword">if</span> (NT_SUCCESS(Status) || Status == STATUS_IMAGE_ALREADY_LOADED) </span><br><span class="line">         &#123; </span><br><span class="line">            <span class="keyword">if</span> ((Status != STATUS_IMAGE_ALREADY_LOADED) || </span><br><span class="line">                (Status == STATUS_IMAGE_ALREADY_LOADED &amp;&amp; !DriverObject)) </span><br><span class="line"> </span><br><span class="line">            &#123; </span><br><span class="line">               Status = IopInitializeDriverModule(DeviceNode, ModuleObject, </span><br><span class="line">                  &amp;DeviceNode-&gt;ServiceName, FALSE, &amp;DriverObject); </span><br><span class="line">            &#125; </span><br><span class="line">            Else  Status = STATUS_SUCCESS; </span><br><span class="line">         &#125; </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">          Status = PipCallDriverAddDevice(DeviceNode, FALSE, DriverObject); </span><br><span class="line">      Else … </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的函数在加载完驱动后进行调用,加载注册的所有上下层过滤驱动,然后调用 AddDevice 函数 </span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">PipCallDriverAddDevice</span><span class="params">(IN PDEVICE_NODE DeviceNode,IN BOOLEAN LoadDriver,IN PDRIVER_OBJECT DriverObject)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    UNICODE_STRING EnumRoot = RTL_CONSTANT_STRING(ENUM_ROOT); </span><br><span class="line">    UNICODE_STRING ControlClass = </span><br><span class="line">    RTL_CONSTANT_STRING(<span class="string">L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Class"</span>); </span><br><span class="line">    PKEY_VALUE_FULL_INFORMATION KeyValueInformation = <span class="literal">NULL</span>; </span><br><span class="line">    Status = IopOpenRegistryKeyEx(&amp;EnumRootKey,<span class="literal">NULL</span>,&amp;EnumRoot,KEY_READ); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开对应的实例键 </span></span><br><span class="line">    Status = IopOpenRegistryKeyEx(&amp;SubKey,EnumRootKey,&amp;DeviceNode-&gt;InstancePath,KEY_READ); </span><br><span class="line">    Status = IopGetRegistryValue(SubKey,REGSTR_VAL_CLASSGUID,&amp;KeyValueInformation); </span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">    &#123; </span><br><span class="line">        Buffer = (PVOID)((ULONG_PTR)KeyValueInformation + KeyValueInformation-&gt;DataOffset); </span><br><span class="line">        PnpRegSzToString(Buffer, KeyValueInformation-&gt;DataLength, &amp;ClassGuid.Length); </span><br><span class="line">        ClassGuid.MaximumLength = KeyValueInformation-&gt;DataLength; </span><br><span class="line">        ClassGuid.Buffer = Buffer; </span><br><span class="line">        Status = IopOpenRegistryKeyEx(&amp;ControlKey,<span class="literal">NULL</span>,&amp;ControlClass,KEY_READ); </span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status))  ClassKey = <span class="literal">NULL</span>; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//打开对应的设备类键 </span></span><br><span class="line">            Status = IopOpenRegistryKeyEx(&amp;ClassKey,ControlKey,&amp;ClassGuid,KEY_READ); </span><br><span class="line">            <span class="keyword">if</span> (!NT_SUCCESS(Status))   ClassKey = <span class="literal">NULL</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (ClassKey) </span><br><span class="line">        &#123; </span><br><span class="line">            RtlInitUnicodeString(&amp;Properties, REGSTR_KEY_DEVICE_PROPERTIES); </span><br><span class="line"> </span><br><span class="line">             </span><br><span class="line">            Status = IopOpenRegistryKeyEx(&amp;PropertiesKey,ClassKey,&amp;Properties,KEY_READ); </span><br><span class="line">            <span class="keyword">if</span> (!NT_SUCCESS(Status))    PropertiesKey = <span class="literal">NULL</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先加载该设备实例注册的所有下层过滤驱动以及所属设备类注册的所有下层过滤驱动 </span></span><br><span class="line">    IopAttachFilterDrivers(DeviceNode, TRUE);  </span><br><span class="line">    Status = IopInitializeDevice(DeviceNode, DriverObject);<span class="comment">//调用AddDevice </span></span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS(Status)) </span><br><span class="line">    &#123; </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//再加载该设备实例注册的所有上层过滤驱动以及所属设备类注册的所有上层过滤驱动 </span></span><br><span class="line">        IopAttachFilterDrivers(DeviceNode, FALSE); </span><br><span class="line">        Status = IopStartDevice(DeviceNode); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> Status; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">IopInitializeDevice</span><span class="params">(PDEVICE_NODE DeviceNode,PDRIVER_OBJECT DriverObject)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   PDEVICE_OBJECT Fdo; </span><br><span class="line">   NTSTATUS Status; </span><br><span class="line">   <span class="keyword">if</span> (!DriverObject) </span><br><span class="line">   &#123; </span><br><span class="line">      DeviceNode-&gt;Flags |= DNF_ADDED; </span><br><span class="line">      <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">if</span> (!DriverObject-&gt;DriverExtension-&gt;AddDevice) </span><br><span class="line">      DeviceNode-&gt;Flags |= DNF_LEGACY_DRIVER; </span><br><span class="line">   <span class="keyword">if</span> (DeviceNode-&gt;Flags &amp; DNF_LEGACY_DRIVER) </span><br><span class="line">   &#123; </span><br><span class="line">      DeviceNode-&gt;Flags |= DNF_ADDED + DNF_STARTED; </span><br><span class="line">      <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">   &#125; </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="comment">//关键。调用AddDevice函数 </span></span><br><span class="line">   Status = DriverObject-&gt;DriverExtension-&gt;AddDevice(DriverObject, DeviceNode-&gt;PhysicalDeviceObject); </span><br><span class="line">   <span class="keyword">if</span> (!NT_SUCCESS(Status)) </span><br><span class="line">   &#123; </span><br><span class="line">      IopDeviceNodeSetFlag(DeviceNode, DNF_DISABLED); </span><br><span class="line">      <span class="keyword">return</span> Status; </span><br><span class="line">   &#125; </span><br><span class="line">   Fdo = IoGetAttachedDeviceReference(DeviceNode-&gt;PhysicalDeviceObject); </span><br><span class="line">   <span class="comment">//少见,因为一般AddDevice函数中,用户都会创建一个fdo绑定在pdo上 </span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (Fdo == DeviceNode-&gt;PhysicalDeviceObject) … </span><br><span class="line">   <span class="keyword">if</span> (Fdo-&gt;DeviceType == FILE_DEVICE_ACPI) … </span><br><span class="line">   IopDeviceNodeSetFlag(DeviceNode, DNF_ADDED);<span class="comment">//标志已调用了AddDevice函数 </span></span><br><span class="line">   <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="IopStartDevice"><a href="#IopStartDevice" class="headerlink" title="IopStartDevice"></a>IopStartDevice</h5><p>下面的函数过滤、分配、转换资源,最后启动设备</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS  <span class="title">IopStartDevice</span><span class="params">(PDEVICE_NODE DeviceNode)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   NTSTATUS Status; </span><br><span class="line">   HANDLE InstanceHandle = INVALID_HANDLE_VALUE, ControlHandle = INVALID_HANDLE_VALUE; </span><br><span class="line">   UNICODE_STRING KeyName; </span><br><span class="line">   OBJECT_ATTRIBUTES ObjectAttributes; </span><br><span class="line">   <span class="keyword">if</span> (DeviceNode-&gt;Flags &amp; (DNF_STARTED | DNF_START_REQUEST_PENDING)) </span><br><span class="line">       <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">   Status = IopAssignDeviceResources(DeviceNode);<span class="comment">//IO管理器自动为其分配需要的资源 </span></span><br><span class="line">   <span class="keyword">if</span> (!NT_SUCCESS(Status)) </span><br><span class="line">       <span class="keyword">goto</span> ByeBye; </span><br><span class="line">   IopStartAndEnumerateDevice(DeviceNode);<span class="comment">//分配资源后启动设备 </span></span><br><span class="line">   Status = IopCreateDeviceKeyPath(&amp;DeviceNode-&gt;InstancePath, <span class="number">0</span>, &amp;InstanceHandle); </span><br><span class="line">   <span class="keyword">if</span> (!NT_SUCCESS(Status)) </span><br><span class="line">       <span class="keyword">goto</span> ByeBye; </span><br><span class="line">   </span><br><span class="line">   RtlInitUnicodeString(&amp;KeyName, <span class="string">L"Control"</span>); </span><br><span class="line">   InitializeObjectAttributes(&amp;ObjectAttributes,&amp;KeyName,OBJ_CASE_INSENSITIVE, </span><br><span class="line">                              InstanceHandle,<span class="literal">NULL</span>); </span><br><span class="line">   </span><br><span class="line">   Status = ZwCreateKey(&amp;ControlHandle, KEY_SET_VALUE, &amp;ObjectAttributes, <span class="number">0</span>, <span class="literal">NULL</span>, REG_OPTION_VOLATILE, <span class="literal">NULL</span>); </span><br><span class="line">   <span class="keyword">if</span> (!NT_SUCCESS(Status)) </span><br><span class="line">       <span class="keyword">goto</span> ByeBye; </span><br><span class="line">   RtlInitUnicodeString(&amp;KeyName, <span class="string">L"ActiveService"</span>); </span><br><span class="line">   Status = ZwSetValueKey(ControlHandle, &amp;KeyName, <span class="number">0</span>, REG_SZ, DeviceNode-&gt;ServiceName.Buffer, DeviceNode-&gt;ServiceName.Length); </span><br><span class="line"></span><br><span class="line">ByeBye: </span><br><span class="line">   <span class="keyword">if</span> (ControlHandle != INVALID_HANDLE_VALUE) </span><br><span class="line">       ZwClose(ControlHandle); </span><br><span class="line">   <span class="keyword">if</span> (InstanceHandle != INVALID_HANDLE_VALUE) </span><br><span class="line">       ZwClose(InstanceHandle); </span><br><span class="line">   <span class="keyword">return</span> Status; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">NTSTATUS  <span class="title">IopStartAndEnumerateDevice</span><span class="params">(IN PDEVICE_NODE DeviceNode)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PDEVICE_OBJECT DeviceObject; </span><br><span class="line"> </span><br><span class="line">    NTSTATUS Status; </span><br><span class="line">    DeviceObject = DeviceNode-&gt;PhysicalDeviceObject; </span><br><span class="line">    <span class="keyword">if</span> (!(DeviceNode-&gt;Flags &amp; DNF_STARTED))<span class="comment">//if 尚未启动 </span></span><br><span class="line">        IopStartDevice2(DeviceObject);<span class="comment">//启动设备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当一个pnp设备启动后,需要继续往下枚举出它下面的各个设备,加入设备节点树,记录到注册表中, 加载各自的驱动。</span></span><br><span class="line">    <span class="comment">// 由此而形成递归关系,使系统在初始化时沿着各条总线的物理布局层次,周而复始逐级 向下枚举出所有设备。</span></span><br><span class="line">    <span class="comment">// 这样最终枚举出所有pnp设备,建立好整个设备节点树,完成初始化。    </span></span><br><span class="line">    <span class="keyword">if</span> ((DeviceNode-&gt;Flags &amp; DNF_STARTED) &amp;&amp; (DeviceNode-&gt;Flags &amp; DNF_NEED_ENUMERATION_ONLY)) </span><br><span class="line">    &#123; </span><br><span class="line">        IoSynchronousInvalidateDeviceRelations(DeviceObject, BusRelations); </span><br><span class="line">        IopDeviceNodeClearFlag(DeviceNode, DNF_NEED_ENUMERATION_ONLY); </span><br><span class="line">        Status = STATUS_SUCCESS; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        Status = STATUS_SUCCESS; </span><br><span class="line">    <span class="keyword">return</span> Status; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function">VOID  <span class="title">IopStartDevice2</span><span class="params">(IN PDEVICE_OBJECT DeviceObject)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    IO_STACK_LOCATION Stack; </span><br><span class="line">    PDEVICE_NODE DeviceNode; </span><br><span class="line">    NTSTATUS Status; </span><br><span class="line">    PVOID Dummy; </span><br><span class="line">    DeviceNode = IopGetDeviceNode(DeviceObject); </span><br><span class="line">    RtlZeroMemory(&amp;Stack, <span class="keyword">sizeof</span>(IO_STACK_LOCATION)); </span><br><span class="line">    Stack.MajorFunction = IRP_MJ_PNP; </span><br><span class="line">    Stack.MinorFunction = IRP_MN_START_DEVICE;<span class="comment">//这种irp </span></span><br><span class="line">    <span class="keyword">if</span> (!(DeviceNode-&gt;Flags &amp; DNF_RESOURCE_REPORTED)) </span><br><span class="line">    &#123; </span><br><span class="line">        Stack.Parameters.StartDevice.AllocatedResources = </span><br><span class="line">            DeviceNode-&gt;ResourceList; </span><br><span class="line">        Stack.Parameters.StartDevice.AllocatedResourcesTranslated = </span><br><span class="line">            DeviceNode-&gt;ResourceListTranslated; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向栈顶设备发送这种irp,请求启动设备。 </span></span><br><span class="line">    Status = IopSynchronousCall(DeviceObject, &amp;Stack, &amp;Dummy); </span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) </span><br><span class="line">    &#123; </span><br><span class="line">        IopSendRemoveDevice(DeviceObject); </span><br><span class="line">        DeviceNode-&gt;Flags |= DNF_START_FAILED; </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    DeviceNode-&gt;Flags |= DNF_STARTED; </span><br><span class="line"> </span><br><span class="line">    DeviceNode-&gt;Flags |= DNF_NEED_ENUMERATION_ONLY;<span class="comment">//标志需要继续枚举下面设备 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">IoSynchronousInvalidateDeviceRelations</span><span class="params">(IN PDEVICE_OBJECT DeviceObject, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                IN DEVICE_RELATION_TYPE Type)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">switch</span> (Type) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">case</span> BusRelations: </span><br><span class="line">            <span class="keyword">return</span> IopEnumerateDevice(DeviceObject);<span class="comment">//枚举下面设备 </span></span><br><span class="line">        <span class="keyword">case</span> PowerRelations: </span><br><span class="line">             <span class="keyword">return</span> STATUS_NOT_IMPLEMENTED; </span><br><span class="line">        <span class="keyword">case</span> TargetDeviceRelation: </span><br><span class="line">            <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="keyword">return</span> STATUS_NOT_SUPPORTED; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此pnp 驱动的静态加载过程讲解完毕,pnp 设备可以在动态插入时动态加载。</p>
<h5 id="IoInvalidateDeviceRelations"><a href="#IoInvalidateDeviceRelations" class="headerlink" title="IoInvalidateDeviceRelations"></a>IoInvalidateDeviceRelations</h5><p>当系统发现一个新的 pnp 设备插入机器时,会调用下面的函数完成驱动加载 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">IoInvalidateDeviceRelations</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    IN PDEVICE_OBJECT DeviceObject, </span></span></span><br><span class="line"><span class="function"><span class="params">    IN DEVICE_RELATION_TYPE Type)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PIO_WORKITEM WorkItem; </span><br><span class="line">    PINVALIDATE_DEVICE_RELATION_DATA Data; </span><br><span class="line">    Data = ExAllocatePool(NonPagedPool, <span class="keyword">sizeof</span>(INVALIDATE_DEVICE_RELATION_DATA)); </span><br><span class="line">    WorkItem = IoAllocateWorkItem(DeviceObject); </span><br><span class="line">    ObReferenceObject(DeviceObject); </span><br><span class="line">    Data-&gt;DeviceObject = DeviceObject; </span><br><span class="line">    Data-&gt;Type = Type; </span><br><span class="line">    Data-&gt;WorkItem = WorkItem; </span><br><span class="line">    IoQueueWorkItem( </span><br><span class="line">        WorkItem, </span><br><span class="line">        IopAsynchronousInvalidateDeviceRelations, <span class="comment">//关键函数 </span></span><br><span class="line">        DelayedWorkQueue, </span><br><span class="line">        Data); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function">VOID <span class="title">IopAsynchronousInvalidateDeviceRelations</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">     IN PDEVICE_OBJECT DeviceObject, </span></span></span><br><span class="line"><span class="function"><span class="params">     IN PVOID InvalidateContext)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	PINVALIDATE_DEVICE_RELATION_DATA Data = InvalidateContext; </span><br><span class="line">	<span class="comment">//重新枚举,建立设备节点树,加载驱动 </span></span><br><span class="line">    IoSynchronousInvalidateDeviceRelations(Data-&gt;DeviceObject,Data-&gt;Type); </span><br><span class="line">    ObDereferenceObject(Data-&gt;DeviceObject); </span><br><span class="line">    IoFreeWorkItem(Data-&gt;WorkItem); </span><br><span class="line">    ExFreePool(Data); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们说总线本身也是一种设备。我们可以向一条总线发出一个请求,查询它下面挂接的所有设备。<br>根总线驱动就会处理这种 irp,返回查询结果给客户。</p>
<h5 id="PnpRootQueryDeviceRelations"><a href="#PnpRootQueryDeviceRelations" class="headerlink" title="PnpRootQueryDeviceRelations"></a>PnpRootQueryDeviceRelations</h5><p>具体的处理这种 irp 的派遣函数如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">PnpRootQueryDeviceRelations</span><span class="params">(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PDEVICE_RELATIONS Relations = <span class="literal">NULL</span>, OtherRelations = Irp-&gt;IoStatus.Information; </span><br><span class="line">    PPNPROOT_DEVICE Device = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">//从这册表中枚举出根总线下面的所有设备(因为根总线是虚拟的,所以借助注册表) </span></span><br><span class="line">    Status = EnumerateDevices(DeviceObject); </span><br><span class="line">    DeviceExtension = (PPNPROOT_FDO_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension; </span><br><span class="line">    Size = FIELD_OFFSET(DEVICE_RELATIONS, Objects) + <span class="keyword">sizeof</span>(PDEVICE_OBJECT) * DeviceExtension-&gt;DeviceListCount; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OtherRelations) </span><br><span class="line">        Size += <span class="keyword">sizeof</span>(PDEVICE_OBJECT) * OtherRelations-&gt;Count; </span><br><span class="line">    Relations = (PDEVICE_RELATIONS)ExAllocatePool(PagedPool, Size); </span><br><span class="line">    RtlZeroMemory(Relations, Size); </span><br><span class="line">    <span class="keyword">if</span> (OtherRelations) </span><br><span class="line">    &#123; </span><br><span class="line">        Relations-&gt;Count = OtherRelations-&gt;Count; </span><br><span class="line">        RtlCopyMemory(Relations-&gt;Objects, OtherRelations-&gt;Objects, <span class="keyword">sizeof</span>(PDEVICE_OBJECT) * OtherRelations-&gt;Count); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (NextEntry = DeviceExtension-&gt;DeviceListHead.Flink; </span><br><span class="line">         NextEntry != &amp;DeviceExtension-&gt;DeviceListHead; </span><br><span class="line">         NextEntry = NextEntry-&gt;Flink) </span><br><span class="line">    &#123; </span><br><span class="line">        Device = CONTAINING_RECORD(NextEntry, PNPROOT_DEVICE, ListEntry); </span><br><span class="line">        <span class="keyword">if</span> (!Device-&gt;Pdo) </span><br><span class="line">        &#123; </span><br><span class="line">            Status = IoCreateDevice( </span><br><span class="line">                DeviceObject-&gt;DriverObject, </span><br><span class="line">                <span class="keyword">sizeof</span>(PNPROOT_PDO_DEVICE_EXTENSION), </span><br><span class="line"> </span><br><span class="line">                <span class="literal">NULL</span>, </span><br><span class="line">                FILE_DEVICE_CONTROLLER, </span><br><span class="line">                FILE_AUTOGENERATED_DEVICE_NAME,<span class="comment">//硬件pdo的对象名称都是自动生成的 </span></span><br><span class="line">                FALSE, </span><br><span class="line">                &amp;Device-&gt;Pdo); </span><br><span class="line">            PdoDeviceExtension = (PPNPROOT_PDO_DEVICE_EXTENSION)Device-&gt;Pdo-&gt;DeviceExtension; </span><br><span class="line">            RtlZeroMemory(PdoDeviceExtension, <span class="keyword">sizeof</span>(PNPROOT_PDO_DEVICE_EXTENSION)); </span><br><span class="line">            PdoDeviceExtension-&gt;Common.IsFDO = FALSE; </span><br><span class="line">            PdoDeviceExtension-&gt;DeviceInfo = Device; </span><br><span class="line">            Device-&gt;Pdo-&gt;Flags |= DO_BUS_ENUMERATED_DEVICE; </span><br><span class="line">            Device-&gt;Pdo-&gt;Flags &amp;= ~DO_DEVICE_INITIALIZING; </span><br><span class="line">        &#125; </span><br><span class="line">        Relations-&gt;Objects[Relations-&gt;Count++] = Device-&gt;Pdo; </span><br><span class="line">    &#125; </span><br><span class="line">    Irp-&gt;IoStatus.Information = (ULONG_PTR)Relations;<span class="comment">//将枚举结果返回给客户 cleanup:… </span></span><br><span class="line">    <span class="keyword">return</span> Status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="Mdl"><a href="#Mdl" class="headerlink" title="Mdl"></a>Mdl</h1><p>Mdl 意为<code>内存映射描述符</code>、<code>缓冲描述符</code>，一个 mdl 就代表一个缓冲。<br>（任意一块物理内存，可以同时 映射到用户地址空间和系统地址空间的）<br>设备 IO 方式分为三种:缓冲方式、直接 IO 方式、直接方式 </p>
<p>缓冲方式：将用户空间中的数据拷贝到内核缓冲，将内核缓冲中的数据拷贝到用户空间，效率低，适合少量数据交换构体本身的释放,触发完成事件信号等操作。<br>直接 IO 方式：将用户空间中的内存通过 MDL 机制映射到系统地址空间，效率高，适合大数据交换<br>直接方式：直接使用用户空间地址，效率最高，但不安全。 </p>
<h2 id="核心Api"><a href="#核心Api" class="headerlink" title="核心Api"></a>核心Api</h2><p>向设备写数据的操作通过下面的内核 API 执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtWriteFile</span><span class="params">(IN HANDLE FileHandle, </span></span></span><br><span class="line"><span class="function"><span class="params">            IN HANDLE Event OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">            IN PIO_APC_ROUTINE ApcRoutine OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">            IN PVOID ApcContext OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">            OUT PIO_STATUS_BLOCK IoStatusBlock, </span></span></span><br><span class="line"><span class="function"><span class="params">            IN PVOID Buffer, </span></span></span><br><span class="line"><span class="function"><span class="params">            IN ULONG Length, </span></span></span><br><span class="line"><span class="function"><span class="params">            IN PLARGE_INTEGER ByteOffset OPTIONAL, </span></span></span><br><span class="line"><span class="function"><span class="params">            IN PULONG Key OPTIONAL)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (DeviceObject-&gt;Flags &amp; DO_BUFFERED_IO) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (Length) </span><br><span class="line">        &#123; </span><br><span class="line">            _SEH2_TRY </span><br><span class="line">            &#123; </span><br><span class="line">                Irp-&gt;AssociatedIrp.SystemBuffer = ExAllocatePoolWithTag(NonPagedPool,Length,TAG_SYSB); </span><br><span class="line">                <span class="comment">//看到没，系统内部自动分配一个内核缓冲，再将用户空间数据拷贝到内核缓冲 </span></span><br><span class="line">                RtlCopyMemory(Irp-&gt;AssociatedIrp.SystemBuffer, Buffer, Length); </span><br><span class="line">            &#125; </span><br><span class="line">            _SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">            &#123; </span><br><span class="line">                IopCleanupAfterException(FileObject, Irp, EventObject, <span class="literal">NULL</span>); </span><br><span class="line">                _SEH2_YIELD(<span class="keyword">return</span> _SEH2_GetExceptionCode()); </span><br><span class="line">            &#125; </span><br><span class="line">            _SEH2_END; </span><br><span class="line">            Irp-&gt;Flags = (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DeviceObject-&gt;Flags &amp; DO_DIRECT_IO) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (Length) </span><br><span class="line"> </span><br><span class="line">        &#123; </span><br><span class="line">            _SEH2_TRY </span><br><span class="line">            &#123;    </span><br><span class="line">                <span class="comment">//看到没，分配一个MDL </span></span><br><span class="line">                Mdl = IoAllocateMdl(Buffer, Length, FALSE, TRUE, Irp); </span><br><span class="line">                MmProbeAndLockPages(Mdl, PreviousMode, IoReadAccess); </span><br><span class="line">            &#125; </span><br><span class="line">            _SEH2_EXCEPT(EXCEPTION_EXECUTE_HANDLER) </span><br><span class="line">            &#123; </span><br><span class="line">                IopCleanupAfterException(FileObject, Irp, EventObject, <span class="literal">NULL</span>); </span><br><span class="line">                _SEH2_YIELD(<span class="keyword">return</span> _SEH2_GetExceptionCode()); </span><br><span class="line">            &#125; </span><br><span class="line">            _SEH2_END; </span><br><span class="line">        &#125; </span><br><span class="line">        Irp-&gt;Flags = <span class="number">0</span>; </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MDL</span> &#123;</span> <span class="comment">//缓冲描述符 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">MDL</span> *<span class="title">Next</span>;</span><span class="comment">//下一个MDL，用来构成mdl链表 </span></span><br><span class="line">  CSHORT Size;<span class="comment">//整个mdl结构体的长度（包含后面的数组） </span></span><br><span class="line">  CSHORT MdlFlags; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS</span> *<span class="title">Process</span>;</span><span class="comment">//所属进程 </span></span><br><span class="line">  PVOID MappedSystemVa;<span class="comment">//该段缓冲在映射在系统空间中的地址 </span></span><br><span class="line">  PVOID StartVa;<span class="comment">//虚拟地址（对齐4kb） </span></span><br><span class="line">  ULONG ByteCount;<span class="comment">//该段缓冲的长度 </span></span><br><span class="line">  ULONG ByteOffset;<span class="comment">// StartVa+ByteOffset就是该段缓冲在Process进程地址空间中的虚拟地址 </span></span><br><span class="line">&#125; MDL, *PMDL;</span><br></pre></td></tr></table></figure>
<p>MDL结构体后面紧跟一个物理页号数组。用来记录这段缓冲的物理页面。（物理页面不一定连续）<br>注意：MDL结构体本身必须位于非分页内存中 </p>
<h3 id="IoAllocateMdl"><a href="#IoAllocateMdl" class="headerlink" title="IoAllocateMdl"></a>IoAllocateMdl</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PMDL <span class="title">IoAllocateMdl</span><span class="params">(IN PVOID VirtualAddress,<span class="comment">// 目标虚拟内存的其实地址 </span></span></span></span><br><span class="line"><span class="function"><span class="params">              IN ULONG Length,<span class="comment">//目标虚拟内存的长度 </span></span></span></span><br><span class="line"><span class="function"><span class="params">              IN BOOLEAN SecondaryBuffer,<span class="comment">//指新的mdl是插入到指定irp的关联mdl链表后面还是替换 </span></span></span></span><br><span class="line"><span class="function"><span class="params">              IN BOOLEAN ChargeQuota, </span></span></span><br><span class="line"><span class="function"><span class="params">              IN PIRP Irp)</span><span class="comment">//将新建的mdl插入或替换到这个irp的mdl链表中 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> </span><br><span class="line">    PMDL Mdl = <span class="literal">NULL</span>, p; </span><br><span class="line">    ULONG Flags = <span class="number">0</span>; </span><br><span class="line">    ULONG Size; </span><br><span class="line">    <span class="keyword">if</span> (Length &gt;= <span class="number">2</span>GB) <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">//计算这段虚拟内存跨越了多少个虚拟页面（包括左右两端两个部分占据的页面） </span></span><br><span class="line">    Size = ADDRESS_AND_SIZE_TO_SPAN_PAGES(VirtualAddress, Length); </span><br><span class="line">    <span class="keyword">if</span> (Size &gt; <span class="number">23</span>)<span class="comment">//若超过了23个虚拟页面，就采用实际占用的虚拟页面数 </span></span><br><span class="line">    &#123; </span><br><span class="line">        Size *= <span class="keyword">sizeof</span>(PFN_NUMBER); </span><br><span class="line">        Size += <span class="keyword">sizeof</span>(MDL); </span><br><span class="line">        <span class="keyword">if</span> (Size &gt; MAXUSHORT) <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    Else <span class="comment">//否则，使用固定大小的23个虚拟页面，这样分配内存比较快。 </span></span><br><span class="line">    &#123; </span><br><span class="line">        Size = (<span class="number">23</span> * <span class="keyword">sizeof</span>(PFN_NUMBER)) + <span class="keyword">sizeof</span>(MDL); </span><br><span class="line">        Flags |= MDL_ALLOCATED_FIXED_SIZE; </span><br><span class="line">        Mdl = IopAllocateMdlFromLookaside(LookasideMdlList); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!Mdl) </span><br><span class="line">    &#123; </span><br><span class="line">    <span class="comment">//分配一个mdl结构体（包含后面的物理页号数组） </span></span><br><span class="line">        Mdl = ExAllocatePoolWithTag(NonPagedPool, Size, TAG_MDL); </span><br><span class="line">        <span class="keyword">if</span> (!Mdl) <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    MmInitializeMdl(Mdl, VirtualAddress, Length); </span><br><span class="line">    Mdl-&gt;MdlFlags |= Flags; </span><br><span class="line">    <span class="keyword">if</span> (Irp) </span><br><span class="line">    &#123; </span><br><span class="line">      <span class="keyword">if</span> (SecondaryBuffer) <span class="comment">//插在原mdl链表末尾 </span></span><br><span class="line">      &#123; </span><br><span class="line">            p = Irp-&gt;MdlAddress; </span><br><span class="line">            <span class="keyword">while</span> (p-&gt;Next) p = p-&gt;Next; </span><br><span class="line">            p-&gt;Next = Mdl; </span><br><span class="line">      &#125; </span><br><span class="line">      Else <span class="comment">//替换原mdl为新的mdl </span></span><br><span class="line">      &#123; </span><br><span class="line">            Irp-&gt;MdlAddress = Mdl; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">    <span class="keyword">return</span> Mdl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MmInitializeMdl(_MemoryDescriptorList, \ </span></span><br><span class="line"> </span><br><span class="line">                        _BaseVa, \ </span><br><span class="line">                        _Length) \ </span><br><span class="line">&#123; \ </span><br><span class="line">  (_MemoryDescriptorList)-&gt;Next = (PMDL) <span class="literal">NULL</span>; \   <span class="comment">//单个mdl </span></span><br><span class="line">  (_MemoryDescriptorList)-&gt;Size = (CSHORT) (<span class="keyword">sizeof</span>(MDL) + \ </span><br><span class="line">    (<span class="keyword">sizeof</span>(PFN_NUMBER) * ADDRESS_AND_SIZE_TO_SPAN_PAGES(_BaseVa, _Length))); \ </span><br><span class="line">  (_MemoryDescriptorList)-&gt;MdlFlags = <span class="number">0</span>; \ </span><br><span class="line">  (_MemoryDescriptorList)-&gt;StartVa = (PVOID) PAGE_ALIGN(_BaseVa); \ </span><br><span class="line">  (_MemoryDescriptorList)-&gt;ByteOffset = BYTE_OFFSET(_BaseVa); \ </span><br><span class="line">  (_MemoryDescriptorList)-&gt;ByteCount = (ULONG) _Length; \ </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上文在<code>NtWriteFile</code>函数体内中，分配一个对应大小的mdl内存映射描述符后，又马上调用了<code>MmProbeAndLockPages</code>函数，这是为什么呢？</p>
<p>这个函数会获取这段虚拟内存映射着的物理页面，记录到mdl 结构体后面紧跟的数组中 ，并将这些物理页面锁定在内存，防止被置换出去（注意：如果当时那些虚拟页 面尚未映射到物理内存，这个函数内部还会自动将那些虚拟页面换入物理内存的）</p>
<p>通过<code>IoAllocateMdl</code>、<code>MmProbeAndLockPages</code>这两步操作后，指定虚拟内存就被锁定在物理内存了，就完成 了映射的准备工作。接下来用户想要在什么时候把这段虚拟内存对应的那些物理内存映射到系统地址空 间时，就可以使用<code>MmGetSystemAddressForMdl</code>宏达到目的。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define  MmGetSystemAddressForMdl(Mdl) \ </span><br><span class="line">   Mdl-&gt;MdlFlags &amp; (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL) ? \ </span><br><span class="line">   Mdl-&gt;MappedSystemVa : MmMapLockedPages (Mdl,KernelMode) </span><br><span class="line"></span><br><span class="line">// 这个宏的意思是如果该段虚拟内存尚未映射到系统空间，就映射MmMapLockedPages</span><br></pre></td></tr></table></figure>
<p>这个函数用于映射用户空间中锁定的页面到内核地址空间中（实际上内核地址空间中有 一块专用区段叫mdl区段，专用于mdl映射，这个函数就是将用户空间内存映射到内核中的那个区段中的） </p>
<p><br></p>
<h3 id="IoFreeMdl"><a href="#IoFreeMdl" class="headerlink" title="IoFreeMdl"></a>IoFreeMdl</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">IoFreeMdl</span><span class="params">(PMDL Mdl)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    MmPrepareMdlForReuse(Mdl); </span><br><span class="line">    <span class="keyword">if</span> (!(Mdl-&gt;MdlFlags &amp; MDL_ALLOCATED_FIXED_SIZE)) </span><br><span class="line">        ExFreePoolWithTag(Mdl, TAG_MDL); </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        IopFreeMdlFromLookaside(Mdl, LookasideMdlList); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外:系统空间的非分页内存本身就是锁定在内存的,也可以使用mdl </span></span><br><span class="line"><span class="function">VOID  <span class="title">MmBuildMdlForNonPagedPool</span><span class="params">(IN PMDL Mdl)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    PPFN_NUMBER MdlPages, EndPage; </span><br><span class="line">    PFN_NUMBER Pfn, PageCount; </span><br><span class="line">    PVOID Base; </span><br><span class="line">    PMMPTE PointerPte; </span><br><span class="line"> </span><br><span class="line">    Mdl-&gt;Process = <span class="literal">NULL</span>; </span><br><span class="line">     </span><br><span class="line">    MdlPages = (PPFN_NUMBER)(Mdl + <span class="number">1</span>); Base = Mdl-&gt;StartVa; </span><br><span class="line">    <span class="comment">//非分页内存本身就位于系统空间，不用重新映射，直接使用 </span></span><br><span class="line">    Mdl-&gt;MappedSystemVa = (PVOID)((ULONG_PTR)Base + Mdl-&gt;ByteOffset); </span><br><span class="line">    PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(Mdl-&gt;MappedSystemVa,Mdl-&gt;ByteCount); </span><br><span class="line">    EndPage = MdlPages + PageCount; </span><br><span class="line">    PointerPte = MiAddressToPte(Base); </span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123; </span><br><span class="line">        Pfn = PFN_FROM_PTE(PointerPte++); </span><br><span class="line">        *MdlPages++ = Pfn;<span class="comment">//关键。填充mdl结构体后面的物理页号数组 </span></span><br><span class="line">    &#125; <span class="keyword">while</span> (MdlPages &lt; EndPage); </span><br><span class="line">    Mdl-&gt;MdlFlags |= MDL_SOURCE_IS_NONPAGED_POOL;<span class="comment">//标记来源本身就是非分页内存。 </span></span><br><span class="line">    <span class="keyword">if</span> (!MiGetPfnEntry(Pfn)) Mdl-&gt;MdlFlags |= MDL_IO_SPACE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>MmBuildMdlForNonPagedPool</code>后，也可以使用<code>MmGetSystemAddressForMdl</code>宏获得系统空间地址。 </p>
<p><br><br><br></p>
<h1 id="网络通信篇"><a href="#网络通信篇" class="headerlink" title="网络通信篇"></a>网络通信篇</h1><p>典型的基于 tcpip 协议套接字方式的网络通信模块层次</p>
<p><img src="/2020/11/03/windows-kernel-summary/image-03.png" width="200px"></p>
<p>应用程序调用<code>WS2_32.dll</code>中的<code>socket api</code>，<code>socket api</code>在内部生成<code>socket irp</code>发给 afd.sys 这个中间辅助驱动层，<br>afd.sys 将<code>socket irp</code>转换成<code>tdi irp</code>发给<code>tcpip</code>协议驱动，协议驱动通过注册的回调函数与小端口驱动（中间可能穿插 N 个中间层过滤驱动），小端口驱动最终通过中断与网卡交互，操作硬件。 </p>
<p>其中，协议驱动、中间层驱动、小端口驱动三者之间的交互是通过 ndis.sys 这个库函数模块实现的，或者说 ndis.sys 提供了 ndis 框架，协议驱动、中间层驱动、小端口驱动三者都得遵循这个框架。 </p>
<blockquote>
<p>为什么网络通信需要这么复杂的分层？</p>
</blockquote>
<p>答案是为了减轻开发维护管理工作的需要，分层能够提供最大的灵 活性。<br>各层的设计人员只需专注自身模块的设计工作，无需担心其他模块是怎么实现的，只需保持接口一致即可。</p>
<p>如应用程序可以调用<code>socket api</code>就可以实现网络通信，而不管底层是如何实现的。使用<code>socket api</code>还可以使得 windows 上能兼容运行 Unix 系统上的网络通信程序，ws2_32.dll 这个模块中实现了<code>socket</code>接口。<br>Afd.sys 实际上是一个适配层，他可以适配 N 种协议驱动。<br>Tcpip.sys 是一种协议驱动（其实是一个协议栈驱动），它内部实现了一套协议栈，决定了如何解析从网卡 接收到的包，以及以什么格式将应用程序数据发到网卡。<br>只不过 tcpip.sys 将收到的包按链路层、网络层、 传输层分层三层逐层解析。<br>事实上我们可以完全可以自定义、自编写一个协议驱动，按照我们自己的协议来发包、收包（我们的这个自定义协议驱动可以采用分层机制，也可以采用简单的单层机制），这样在发送方电脑和接收方电脑都安装我们的自定义协议驱动后，发送方就可以按照自定义协议发包，接收方就按照约定的格式解包。 </p>
<p>如果不考虑中间驱动，协议驱动是直接与小端口驱动交互的。<br>协议驱动从小端口驱动收包，协议驱动发包给小端口驱动，这就是二者之间的交互。他们之间的交互通过 ndis 框架预约的一套回调函数接口来实现。 </p>
<p>下面我们看各层驱动的实现：<br>一个协议驱动需要在<code>DriverEntry</code>中将自己注册为一个协议驱动，向 ndis 框架登记、声明自己的协议特征。<br>一个协议特征记录了协议的名称以及它提供的各个回调函数 </p>
<p><hr></p>
<p><hr></p>
<hr>

<p>后面的还是看书为准吧……不想写了… 记在脑子里才是真的记住了, 写这么多到时候也不想看了<br>后面的还是看书为准吧……不想写了… 记在脑子里才是真的记住了, 写这么多到时候也不想看了<br>后面的还是看书为准吧……不想写了… 记在脑子里才是真的记住了, 写这么多到时候也不想看了</p>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2020/11/03/windows-kernel-summary/';
        this.page.title = 'Windows&amp;WRK&amp;ReactOS 源码一览';
        this.page.identifier = '2020/11/03/windows-kernel-summary/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
