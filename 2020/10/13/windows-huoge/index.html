<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Windows-x86 内核相关 - 海哥 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="Windows 内核技术详解笔记
保护模式x86 CPU的三个模式: 实模式、保护模式和虚拟8086模式 

一开机大多数都是实模式, 后期才进入保护模式, 后期如何写代码从实模式进入保护模式

保护模式有什么特点?保护模式保护以下两种机制:段机制、页机制, 进入段进行权限检查,页的读写检查读写保护等保护模式保护的是寄存器, CR0~CR4等控制寄存器, 

段寄存器1、什么是段寄存器?有哪些?
当我们用汇编读写某一个地址时:mov dword ptr ds:[0x123456],eax

我们">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Go/Rust</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">系统内核</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">逆向知识</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">数据库</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#保护模式"><span class="toc-number">1.</span> <span class="toc-text">保护模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#段寄存器"><span class="toc-number">1.1.</span> <span class="toc-text">段寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段寄存器结构"><span class="toc-number">1.2.</span> <span class="toc-text">段寄存器结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段寄存器属性"><span class="toc-number">1.3.</span> <span class="toc-text">段寄存器属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段描述符与段选择子"><span class="toc-number">1.4.</span> <span class="toc-text">段描述符与段选择子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段描述符属性P位与G位"><span class="toc-number">1.5.</span> <span class="toc-text">段描述符属性P位与G位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段描述符属性S位与Type域"><span class="toc-number">1.6.</span> <span class="toc-text">段描述符属性S位与Type域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#系统段描述符"><span class="toc-number">1.6.1.</span> <span class="toc-text">系统段描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据段、代码段描述符"><span class="toc-number">1.6.2.</span> <span class="toc-text">数据段、代码段描述符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段描述符DB位"><span class="toc-number">1.7.</span> <span class="toc-text">段描述符DB位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段权限检查"><span class="toc-number">1.8.</span> <span class="toc-text">段权限检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码跨段流程"><span class="toc-number">1.9.</span> <span class="toc-text">代码跨段流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码间的跳转"><span class="toc-number">1.9.1.</span> <span class="toc-text">代码间的跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码间的跳转执行流程"><span class="toc-number">1.9.2.</span> <span class="toc-text">代码间的跳转执行流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#长调用与短调用"><span class="toc-number">1.10.</span> <span class="toc-text">长调用与短调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#短调用"><span class="toc-number">1.10.1.</span> <span class="toc-text">短调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#长调用-跨段不提权"><span class="toc-number">1.10.2.</span> <span class="toc-text">长调用(跨段不提权)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#长调用-跨段并提权"><span class="toc-number">1.10.3.</span> <span class="toc-text">长调用(跨段并提权)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用门"><span class="toc-number">1.11.</span> <span class="toc-text">调用门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无参"><span class="toc-number">1.11.1.</span> <span class="toc-text">无参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有参"><span class="toc-number">1.11.2.</span> <span class="toc-text">有参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断门"><span class="toc-number">1.12.</span> <span class="toc-text">中断门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IDT"><span class="toc-number">1.12.1.</span> <span class="toc-text">IDT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断返回"><span class="toc-number">1.12.2.</span> <span class="toc-text">中断返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用门与中断门的区别"><span class="toc-number">1.12.3.</span> <span class="toc-text">调用门与中断门的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#陷阱门"><span class="toc-number">1.13.</span> <span class="toc-text">陷阱门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造一个陷阱门"><span class="toc-number">1.13.1.</span> <span class="toc-text">构造一个陷阱门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#陷阱门与中断门的区别"><span class="toc-number">1.13.2.</span> <span class="toc-text">陷阱门与中断门的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EFLAG寄存器"><span class="toc-number">1.13.3.</span> <span class="toc-text">EFLAG寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#任务段"><span class="toc-number">1.14.</span> <span class="toc-text">任务段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU如何找到TSS"><span class="toc-number">1.14.1.</span> <span class="toc-text">CPU如何找到TSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TR寄存器读写"><span class="toc-number">1.14.2.</span> <span class="toc-text">TR寄存器读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#具体案例"><span class="toc-number">1.14.3.</span> <span class="toc-text">具体案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#任务门"><span class="toc-number">1.15.</span> <span class="toc-text">任务门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IDT中断描述符"><span class="toc-number">1.15.1.</span> <span class="toc-text">IDT中断描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#任务门指向流程"><span class="toc-number">1.15.2.</span> <span class="toc-text">任务门指向流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-10-12分页"><span class="toc-number">1.16.</span> <span class="toc-text">10-10-12分页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4GB内存空间"><span class="toc-number">1.16.1.</span> <span class="toc-text">4GB内存空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#物理地址"><span class="toc-number">1.16.2.</span> <span class="toc-text">物理地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#物理在哪里"><span class="toc-number">1.16.3.</span> <span class="toc-text">物理在哪里</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置分页的方式"><span class="toc-number">1.16.4.</span> <span class="toc-text">设置分页的方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#物理页"><span class="toc-number">1.17.</span> <span class="toc-text">物理页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PDE-PTE属性"><span class="toc-number">1.17.1.</span> <span class="toc-text">PDE,PTE属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P位"><span class="toc-number">1.17.2.</span> <span class="toc-text">P位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#R-W-位"><span class="toc-number">1.17.3.</span> <span class="toc-text">R/W 位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#U-S位"><span class="toc-number">1.17.4.</span> <span class="toc-text">U/S位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-位"><span class="toc-number">1.17.5.</span> <span class="toc-text">A 位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-位"><span class="toc-number">1.17.6.</span> <span class="toc-text">D 位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P-S位"><span class="toc-number">1.17.7.</span> <span class="toc-text">P/S位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G位-PWT位-PCD位"><span class="toc-number">1.17.8.</span> <span class="toc-text">G位  PWT位  PCD位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码挂物理页"><span class="toc-number">1.18.</span> <span class="toc-text">代码挂物理页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#页目录基址"><span class="toc-number">1.18.1.</span> <span class="toc-text">页目录基址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#拆分C0300000"><span class="toc-number">1.18.1.1.</span> <span class="toc-text">拆分C0300000</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#页目录表基址"><span class="toc-number">1.18.1.2.</span> <span class="toc-text">页目录表基址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页表基址"><span class="toc-number">1.18.2.</span> <span class="toc-text">页表基址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#拆分C0000000-C0001000"><span class="toc-number">1.18.2.1.</span> <span class="toc-text">拆分C0000000 / C0001000</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有了0xC0300000和0xC0000000能做什么"><span class="toc-number">1.18.2.2.</span> <span class="toc-text">有了0xC0300000和0xC0000000能做什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MnIsAddressValid"><span class="toc-number">1.18.2.3.</span> <span class="toc-text">MnIsAddressValid</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TLB"><span class="toc-number">1.19.</span> <span class="toc-text">TLB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#地址解析"><span class="toc-number">1.19.1.</span> <span class="toc-text">地址解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB结构"><span class="toc-number">1.19.2.</span> <span class="toc-text">TLB结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB种类"><span class="toc-number">1.19.3.</span> <span class="toc-text">TLB种类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#驱动"><span class="toc-number">2.</span> <span class="toc-text">驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一个驱动程序"><span class="toc-number">2.1.</span> <span class="toc-text">第一个驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#驱动的开发流程"><span class="toc-number">2.1.1.</span> <span class="toc-text">驱动的开发流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本代码"><span class="toc-number">2.1.2.</span> <span class="toc-text">基本代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译环境"><span class="toc-number">2.1.3.</span> <span class="toc-text">编译环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核编程基础"><span class="toc-number">2.2.</span> <span class="toc-text">内核编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内核API的使用"><span class="toc-number">2.2.1.</span> <span class="toc-text">内核API的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#未导出函数的使用"><span class="toc-number">2.2.2.</span> <span class="toc-text">未导出函数的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本数据类型"><span class="toc-number">2.2.3.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#返回值"><span class="toc-number">2.2.4.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核中的异常处理"><span class="toc-number">2.2.5.</span> <span class="toc-text">内核中的异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的内核内存函数"><span class="toc-number">2.2.6.</span> <span class="toc-text">常用的内核内存函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核字符串种类"><span class="toc-number">2.2.7.</span> <span class="toc-text">内核字符串种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核字符串常用函数"><span class="toc-number">2.2.8.</span> <span class="toc-text">内核字符串常用函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核空间与内核模块"><span class="toc-number">2.3.</span> <span class="toc-text">内核空间与内核模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内核空间"><span class="toc-number">2.3.1.</span> <span class="toc-text">内核空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核模块"><span class="toc-number">2.3.2.</span> <span class="toc-text">内核模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DRIVER-OBJECT"><span class="toc-number">2.3.3.</span> <span class="toc-text">DRIVER_OBJECT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打印DRIVER-OBJECT地址"><span class="toc-number">2.3.4.</span> <span class="toc-text">打印DRIVER_OBJECT地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历内核模块"><span class="toc-number">2.3.5.</span> <span class="toc-text">遍历内核模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0环与3环通信-常规方式"><span class="toc-number">2.4.</span> <span class="toc-text">0环与3环通信(常规方式)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#设备对象"><span class="toc-number">2.4.1.</span> <span class="toc-text">设备对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建设备对象"><span class="toc-number">2.4.2.</span> <span class="toc-text">创建设备对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置交互数据的方式"><span class="toc-number">2.4.3.</span> <span class="toc-text">设置交互数据的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建符号链接"><span class="toc-number">2.4.4.</span> <span class="toc-text">创建符号链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IRP与派遣函数"><span class="toc-number">2.4.5.</span> <span class="toc-text">IRP与派遣函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IRP的类型"><span class="toc-number">2.4.6.</span> <span class="toc-text">IRP的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#派遣函数在哪里注册呢？"><span class="toc-number">2.4.7.</span> <span class="toc-text">派遣函数在哪里注册呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册派遣函数"><span class="toc-number">2.4.8.</span> <span class="toc-text">注册派遣函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#派遣函数的格式"><span class="toc-number">2.4.9.</span> <span class="toc-text">派遣函数的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过IRP-MJ-DEVICE-CONTROL交互数据"><span class="toc-number">2.4.10.</span> <span class="toc-text">通过IRP_MJ_DEVICE_CONTROL交互数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#系统调用"><span class="toc-number">3.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3环进0环-上"><span class="toc-number">3.1.</span> <span class="toc-text">3环进0环 上</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KUSER-SHARED-DATA"><span class="toc-number">3.1.1.</span> <span class="toc-text">_KUSER_SHARED_DATA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x7FFE0300到底存储的是什么"><span class="toc-number">3.1.2.</span> <span class="toc-text">0x7FFE0300到底存储的是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进0环需要更改哪些寄存器？"><span class="toc-number">3.1.3.</span> <span class="toc-text">进0环需要更改哪些寄存器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断门进0环"><span class="toc-number">3.1.4.</span> <span class="toc-text">中断门进0环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速调用进0环"><span class="toc-number">3.1.5.</span> <span class="toc-text">快速调用进0环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3环进0环-下"><span class="toc-number">3.2.</span> <span class="toc-text">3环进0环 下</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#INT-0x2E进0环"><span class="toc-number">3.2.1.</span> <span class="toc-text">INT 0x2E进0环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sysenter进0环"><span class="toc-number">3.2.2.</span> <span class="toc-text">sysenter进0环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">3.2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#保存现场"><span class="toc-number">3.3.</span> <span class="toc-text">保存现场</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Trap-Frame结构"><span class="toc-number">3.3.1.</span> <span class="toc-text">_Trap_Frame结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KPCR"><span class="toc-number">3.3.2.</span> <span class="toc-text">KPCR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统服务表"><span class="toc-number">3.4.</span> <span class="toc-text">系统服务表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SystemServiceTable-系统服务表"><span class="toc-number">3.4.1.</span> <span class="toc-text">SystemServiceTable 系统服务表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SystemServiceTable-系统服务表在哪"><span class="toc-number">3.4.2.</span> <span class="toc-text">SystemServiceTable 系统服务表在哪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断要调用的函数在哪个表"><span class="toc-number">3.4.3.</span> <span class="toc-text">判断要调用的函数在哪个表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#找到要执行的函数与参数个数"><span class="toc-number">3.4.4.</span> <span class="toc-text">找到要执行的函数与参数个数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSDT-API函数的调用过程"><span class="toc-number">3.5.</span> <span class="toc-text">SSDT(API函数的调用过程)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SystemServiceTable-系统服务表-1"><span class="toc-number">3.5.1.</span> <span class="toc-text">SystemServiceTable 系统服务表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何访问系统服务表"><span class="toc-number">3.5.2.</span> <span class="toc-text">如何访问系统服务表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程线程"><span class="toc-number">4.</span> <span class="toc-text">进程线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程结构体EPROCESS"><span class="toc-number">4.1.</span> <span class="toc-text">进程结构体EPROCESS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程结构体EPROCESS-1"><span class="toc-number">4.1.1.</span> <span class="toc-text">进程结构体EPROCESS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KPROCESS主要成员介绍"><span class="toc-number">4.1.2.</span> <span class="toc-text">KPROCESS主要成员介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EPROCESS其他成员"><span class="toc-number">4.1.3.</span> <span class="toc-text">EPROCESS其他成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程结构体ETHREAD"><span class="toc-number">4.2.</span> <span class="toc-text">线程结构体ETHREAD</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程结构体ETHREAD-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">线程结构体ETHREAD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KTHREAD主要成员介绍"><span class="toc-number">4.2.2.</span> <span class="toc-text">KTHREAD主要成员介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ETHREAD其他成员介绍"><span class="toc-number">4.2.3.</span> <span class="toc-text">ETHREAD其他成员介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KPCR-CPU控制区-Processor-Control-Region"><span class="toc-number">4.3.</span> <span class="toc-text">KPCR(CPU控制区(Processor Control Region))</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KPCR介绍"><span class="toc-number">4.3.1.</span> <span class="toc-text">KPCR介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NT-TIB主要成员介绍"><span class="toc-number">4.3.2.</span> <span class="toc-text">_NT_TIB主要成员介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KPCR的其他成员介绍"><span class="toc-number">4.3.3.</span> <span class="toc-text">KPCR的其他成员介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PRCB成员介绍"><span class="toc-number">4.3.4.</span> <span class="toc-text">PRCB成员介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特别强调"><span class="toc-number">4.3.5.</span> <span class="toc-text">特别强调</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#等待链表-调度链表"><span class="toc-number">4.4.</span> <span class="toc-text">等待链表/调度链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#33个链表"><span class="toc-number">4.4.1.</span> <span class="toc-text">33个链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#等待链表"><span class="toc-number">4.4.2.</span> <span class="toc-text">等待链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调度链表"><span class="toc-number">4.4.3.</span> <span class="toc-text">调度链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看调度链表"><span class="toc-number">4.4.4.</span> <span class="toc-text">查看调度链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#版本差异"><span class="toc-number">4.4.5.</span> <span class="toc-text">版本差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-1"><span class="toc-number">4.4.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟线程切换"><span class="toc-number">4.5.</span> <span class="toc-text">模拟线程切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关键结构体"><span class="toc-number">4.5.1.</span> <span class="toc-text">关键结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调度链表-1"><span class="toc-number">4.5.2.</span> <span class="toc-text">调度链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化线程堆栈"><span class="toc-number">4.5.3.</span> <span class="toc-text">初始化线程堆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程切换"><span class="toc-number">4.5.4.</span> <span class="toc-text">线程切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模拟线程切换总结："><span class="toc-number">4.5.5.</span> <span class="toc-text">模拟线程切换总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows线程切换-主动切换"><span class="toc-number">4.6.</span> <span class="toc-text">Windows线程切换_主动切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KiSwapContext函数"><span class="toc-number">4.6.1.</span> <span class="toc-text">KiSwapContext函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SwapContext函数"><span class="toc-number">4.6.2.</span> <span class="toc-text">SwapContext函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-2"><span class="toc-number">4.6.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows线程切换-时钟中断切换"><span class="toc-number">4.7.</span> <span class="toc-text">Windows线程切换_时钟中断切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何中断一个正在执行的程序"><span class="toc-number">4.7.1.</span> <span class="toc-text">如何中断一个正在执行的程序?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统时钟"><span class="toc-number">4.7.2.</span> <span class="toc-text">系统时钟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时钟中断的执行流程"><span class="toc-number">4.7.3.</span> <span class="toc-text">时钟中断的执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-3"><span class="toc-number">4.7.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows线程切换-时间片"><span class="toc-number">4.8.</span> <span class="toc-text">Windows线程切换_时间片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关于时间片"><span class="toc-number">4.8.1.</span> <span class="toc-text">关于时间片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存在备用线程-NextThread"><span class="toc-number">4.8.2.</span> <span class="toc-text">存在备用线程(NextThread)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程切换的三种情况"><span class="toc-number">4.8.3.</span> <span class="toc-text">线程切换的三种情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows线程切换-TSS"><span class="toc-number">4.9.</span> <span class="toc-text">Windows线程切换_TSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内核堆栈"><span class="toc-number">4.9.1.</span> <span class="toc-text">内核堆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核堆栈的结构"><span class="toc-number">4.9.2.</span> <span class="toc-text">内核堆栈的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用API进0环"><span class="toc-number">4.9.3.</span> <span class="toc-text">调用API进0环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TSS"><span class="toc-number">4.9.4.</span> <span class="toc-text">TSS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows线程切换-FS"><span class="toc-number">4.10.</span> <span class="toc-text">Windows线程切换_FS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SwapContext代码分析"><span class="toc-number">4.10.1.</span> <span class="toc-text">SwapContext代码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows线程切换-线程优先级"><span class="toc-number">4.11.</span> <span class="toc-text">Windows线程切换_线程优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调度链表-32个"><span class="toc-number">4.11.1.</span> <span class="toc-text">调度链表(32个)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何高效查找"><span class="toc-number">4.11.2.</span> <span class="toc-text">如何高效查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果没有就绪线程怎么办"><span class="toc-number">4.11.3.</span> <span class="toc-text">如果没有就绪线程怎么办</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程挂靠"><span class="toc-number">4.12.</span> <span class="toc-text">进程挂靠</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程与线程的关系"><span class="toc-number">4.12.1.</span> <span class="toc-text">进程与线程的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程与进程如何关联"><span class="toc-number">4.12.2.</span> <span class="toc-text">线程与进程如何关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#养父母负责提供Cr3"><span class="toc-number">4.12.3.</span> <span class="toc-text">养父母负责提供Cr3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cr3的值可以随便改吗"><span class="toc-number">4.12.4.</span> <span class="toc-text">Cr3的值可以随便改吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分析NtReadVirtualMemory函数"><span class="toc-number">4.12.5.</span> <span class="toc-text">分析NtReadVirtualMemory函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-4"><span class="toc-number">4.12.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跨进程读写内存"><span class="toc-number">4.13.</span> <span class="toc-text">跨进程读写内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#跨进程操作"><span class="toc-number">4.13.1.</span> <span class="toc-text">跨进程操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NtReadVirtualMemory流程解析"><span class="toc-number">4.13.2.</span> <span class="toc-text">NtReadVirtualMemory流程解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NtWriteVirtualMemory流程解析"><span class="toc-number">4.13.3.</span> <span class="toc-text">NtWriteVirtualMemory流程解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#句柄"><span class="toc-number">5.</span> <span class="toc-text">句柄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#句柄表"><span class="toc-number">5.1.</span> <span class="toc-text">句柄表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是句柄（内核对象）"><span class="toc-number">5.1.1.</span> <span class="toc-text">什么是句柄（内核对象）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要有句柄"><span class="toc-number">5.1.2.</span> <span class="toc-text">为什么要有句柄?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#句柄表在哪"><span class="toc-number">5.1.3.</span> <span class="toc-text">句柄表在哪?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#句柄表结构"><span class="toc-number">5.1.4.</span> <span class="toc-text">句柄表结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-5"><span class="toc-number">5.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全局句柄表"><span class="toc-number">5.2.</span> <span class="toc-text">全局句柄表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全局句柄表-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">全局句柄表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局句柄表结构"><span class="toc-number">5.2.2.</span> <span class="toc-text">全局句柄表结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#观察句柄表"><span class="toc-number">5.2.3.</span> <span class="toc-text">观察句柄表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多核同步"><span class="toc-number">6.</span> <span class="toc-text">多核同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#临界区"><span class="toc-number">6.1.</span> <span class="toc-text">临界区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#演示代码"><span class="toc-number">6.1.1.</span> <span class="toc-text">演示代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LOCK指令"><span class="toc-number">6.1.2.</span> <span class="toc-text">LOCK指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多行代码原子操作"><span class="toc-number">6.1.3.</span> <span class="toc-text">多行代码原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临界区-1"><span class="toc-number">6.1.4.</span> <span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自己实现临界区"><span class="toc-number">6.1.5.</span> <span class="toc-text">自己实现临界区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自旋锁"><span class="toc-number">6.2.</span> <span class="toc-text">自旋锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不同版本的内核文件"><span class="toc-number">6.2.1.</span> <span class="toc-text">不同版本的内核文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows自旋锁"><span class="toc-number">6.2.2.</span> <span class="toc-text">Windows自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-6"><span class="toc-number">6.2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程等待与唤醒"><span class="toc-number">6.3.</span> <span class="toc-text">线程等待与唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#等待与唤醒机制"><span class="toc-number">6.3.1.</span> <span class="toc-text">等待与唤醒机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可等待对象"><span class="toc-number">6.3.2.</span> <span class="toc-text">可等待对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可等待对象的差异"><span class="toc-number">6.3.3.</span> <span class="toc-text">可等待对象的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个线程等待一个对象"><span class="toc-number">6.3.4.</span> <span class="toc-text">一个线程等待一个对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个线程等待多个对象"><span class="toc-number">6.3.5.</span> <span class="toc-text">一个线程等待多个对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#等待网"><span class="toc-number">6.3.6.</span> <span class="toc-text">等待网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-7"><span class="toc-number">6.3.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WaitForSingleObject函数分析"><span class="toc-number">6.4.</span> <span class="toc-text">WaitForSingleObject函数分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WaitForSingleObject参数说明"><span class="toc-number">6.4.1.</span> <span class="toc-text">WaitForSingleObject参数说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WaitForSingleObject参数说明-1"><span class="toc-number">6.4.2.</span> <span class="toc-text">WaitForSingleObject参数说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NtWaitForSingleObject"><span class="toc-number">6.4.3.</span> <span class="toc-text">NtWaitForSingleObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KeWaitForSingleObject：上半部分"><span class="toc-number">6.4.4.</span> <span class="toc-text">KeWaitForSingleObject：上半部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-8"><span class="toc-number">6.4.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Event"><span class="toc-number">6.5.</span> <span class="toc-text">Event</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建事件对象-信号"><span class="toc-number">6.5.1.</span> <span class="toc-text">创建事件对象:信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建事件对象-类型"><span class="toc-number">6.5.2.</span> <span class="toc-text">创建事件对象:类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SetEvent函数分析"><span class="toc-number">6.5.3.</span> <span class="toc-text">SetEvent函数分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WaitForSingleObject"><span class="toc-number">6.5.4.</span> <span class="toc-text">WaitForSingleObject</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SEMAPHORE"><span class="toc-number">6.6.</span> <span class="toc-text">SEMAPHORE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事件-EVENT"><span class="toc-number">6.6.1.</span> <span class="toc-text">事件(EVENT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量-SEMAPHORE"><span class="toc-number">6.6.2.</span> <span class="toc-text">信号量(SEMAPHORE)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要使用信号量"><span class="toc-number">6.6.3.</span> <span class="toc-text">为什么要使用信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建信号量对象"><span class="toc-number">6.6.4.</span> <span class="toc-text">创建信号量对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReleaseSemaphore函数分析"><span class="toc-number">6.6.5.</span> <span class="toc-text">ReleaseSemaphore函数分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#互斥体"><span class="toc-number">6.7.</span> <span class="toc-text">互斥体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要有互斥体-等待对象被遗弃"><span class="toc-number">6.7.1.</span> <span class="toc-text">为什么要有互斥体:等待对象被遗弃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要有互斥体-重入"><span class="toc-number">6.7.2.</span> <span class="toc-text">为什么要有互斥体:重入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MUTANT结构体介绍"><span class="toc-number">6.7.3.</span> <span class="toc-text">MUTANT结构体介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CreateMutex函数"><span class="toc-number">6.7.4.</span> <span class="toc-text">CreateMutex函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReleaseMutex函数"><span class="toc-number">6.7.5.</span> <span class="toc-text">ReleaseMutex函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何解决重入问题"><span class="toc-number">6.7.6.</span> <span class="toc-text">如何解决重入问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何解决等待对象被遗弃问题"><span class="toc-number">6.7.7.</span> <span class="toc-text">如何解决等待对象被遗弃问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#禁用内核APC"><span class="toc-number">6.7.8.</span> <span class="toc-text">禁用内核APC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#异常"><span class="toc-number">7.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">7.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU异常的产生"><span class="toc-number">7.1.1.</span> <span class="toc-text">CPU异常的产生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#软件模拟异常的产生"><span class="toc-number">7.1.2.</span> <span class="toc-text">软件模拟异常的产生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常处理流程"><span class="toc-number">7.1.3.</span> <span class="toc-text">异常处理流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VEH"><span class="toc-number">7.2.</span> <span class="toc-text">VEH</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RtlAddVectoredExceptionHandler"><span class="toc-number">7.2.1.</span> <span class="toc-text">RtlAddVectoredExceptionHandler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SEH"><span class="toc-number">7.3.</span> <span class="toc-text">SEH</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#汇编塞入"><span class="toc-number">7.3.1.</span> <span class="toc-text">汇编塞入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-except-逆向"><span class="toc-number">7.3.2.</span> <span class="toc-text">try__except 逆向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scopetable"><span class="toc-number">7.3.3.</span> <span class="toc-text">scopetable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#except-handler"><span class="toc-number">7.3.4.</span> <span class="toc-text">except_handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-finally"><span class="toc-number">7.3.5.</span> <span class="toc-text">try__finally</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#局部展开"><span class="toc-number">7.3.5.1.</span> <span class="toc-text">局部展开</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全局展开"><span class="toc-number">7.3.5.2.</span> <span class="toc-text">全局展开</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#调试"><span class="toc-number">8.</span> <span class="toc-text">调试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#调试对象"><span class="toc-number">8.1.</span> <span class="toc-text">调试对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何在调试器与被调试程序之间建立联系"><span class="toc-number">8.1.1.</span> <span class="toc-text">如何在调试器与被调试程序之间建立联系?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DebugActiveProcess执行流程"><span class="toc-number">8.1.2.</span> <span class="toc-text">DebugActiveProcess执行流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调试事件的采集"><span class="toc-number">8.2.</span> <span class="toc-text">调试事件的采集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调试事件的种类"><span class="toc-number">8.2.1.</span> <span class="toc-text">调试事件的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试事件采集函数"><span class="toc-number">8.2.2.</span> <span class="toc-text">调试事件采集函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建进程、线程必经之路"><span class="toc-number">8.2.2.1.</span> <span class="toc-text">创建进程、线程必经之路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#退出线程、进程必经之路"><span class="toc-number">8.2.2.2.</span> <span class="toc-text">退出线程、进程必经之路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加载模块的必经之路"><span class="toc-number">8.2.2.3.</span> <span class="toc-text">加载模块的必经之路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#卸载模块的必经之路"><span class="toc-number">8.2.2.4.</span> <span class="toc-text">卸载模块的必经之路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异常的必经之路"><span class="toc-number">8.2.2.5.</span> <span class="toc-text">异常的必经之路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试事件写入函数"><span class="toc-number">8.2.3.</span> <span class="toc-text">调试事件写入函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调试事件的处理"><span class="toc-number">8.3.</span> <span class="toc-text">调试事件的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建进程的方式"><span class="toc-number">8.3.1.</span> <span class="toc-text">创建进程的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#附加进程的方式"><span class="toc-number">8.3.2.</span> <span class="toc-text">附加进程的方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常的处理流程"><span class="toc-number">8.4.</span> <span class="toc-text">异常的处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异常处理的大概"><span class="toc-number">8.4.1.</span> <span class="toc-text">异常处理的大概</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#软件断点"><span class="toc-number">8.5.</span> <span class="toc-text">软件断点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存断点"><span class="toc-number">8.6.</span> <span class="toc-text">内存断点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#触发异常-调试器接管异常的过程"><span class="toc-number">8.6.1.</span> <span class="toc-text">触发异常-调试器接管异常的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存断点-1"><span class="toc-number">8.6.2.</span> <span class="toc-text">内存断点</span></a></li></ol></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            Windows-x86 内核相关 - 海哥
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2020/10/13/windows-huoge/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2020-10-13T04:44:30.000Z" itemprop="datePublished">2020-10-13</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Windows驱动/">Windows驱动</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>Windows 内核技术详解笔记<br><a id="more"></a></p>
<h1 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h1><p>x86 CPU的三个模式: 实模式、保护模式和虚拟8086模式 </p>
<blockquote>
<p>一开机大多数都是实模式, 后期才进入保护模式, 后期如何写代码从实模式进入保护模式</p>
</blockquote>
<p>保护模式有什么特点?<br>保护模式保护以下两种机制:<code>段机制</code>、<code>页机制</code>, 进入段进行权限检查,页的读写检查读写保护等<br>保护模式保护的是寄存器, CR0~CR4等控制寄存器, </p>
<p><br></p>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>1、什么是段寄存器?有哪些?</p>
<p>当我们用汇编读写某一个地址时:<br><code>mov dword ptr ds:[0x123456],eax</code></p>
<blockquote>
<p>我们真正读写的地址是:<code>ds.base + Ox123456</code></p>
</blockquote>
<p><code>ES CS SS DS FS GS LDTR TR</code>共8个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EDI写ES</span><br><span class="line">EBP,ESP写SS</span><br><span class="line">立即数写DS</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="段寄存器结构"><a href="#段寄存器结构" class="headerlink" title="段寄存器结构"></a>段寄存器结构</h2><p><img src="/2020/10/13/windows-huoge/image-01.png" width="500px"></p>
<p>段寄存器的读写</p>
<p>读段寄存器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如：MOV AX,ES    只能读16位的可见部分</span><br><span class="line"></span><br><span class="line">读写LDTR的指令为：SLDT/LLDT</span><br><span class="line"></span><br><span class="line">读写TR的指令为：STR/LTR</span><br></pre></td></tr></table></figure>
<p>写段寄存器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如：MOV DS,AX   写时是写96位</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="段寄存器属性"><a href="#段寄存器属性" class="headerlink" title="段寄存器属性"></a>段寄存器属性</h2><p>段寄存器有96位：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Selector  //16位</span><br><span class="line">Atrribute  //16位</span><br><span class="line">Base	 //32位</span><br><span class="line">Limit	 //32位</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/13/windows-huoge/image-02.png" width="500px"></p>
<p>但我们只能看见16位，那如果证明Attribute、Base、Limit的存在呢？</p>
<blockquote>
<p>探测Attribute</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int var = 0;					</span><br><span class="line">__asm					</span><br><span class="line">&#123;					</span><br><span class="line">	mov ax,ss	//cs不行 cs是可读 可执行 但不可写	</span><br><span class="line">	mov ds,ax				</span><br><span class="line">	mov dword ptr ds:[var],eax				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>探测Base</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int var = 1;					</span><br><span class="line">__asm					</span><br><span class="line">&#123;					</span><br><span class="line">	mov ax,fs				</span><br><span class="line">	mov gs,ax				</span><br><span class="line">	mov eax,gs:[0]	//不要用DS 否则编译不过去		</span><br><span class="line">	mov dword ptr ds:[var],eax	</span><br><span class="line">	</span><br><span class="line">	//mov edx,dword ptr ds:[0x7FFDF000]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>探测Limit</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int var = 1;					</span><br><span class="line">__asm					</span><br><span class="line">&#123;					</span><br><span class="line">	mov ax,fs				</span><br><span class="line">	mov gs,ax				</span><br><span class="line">	mov eax,gs:[0]	//不要用DS 否则编译不过去		</span><br><span class="line">	mov dword ptr ds:[var],eax	</span><br><span class="line">	</span><br><span class="line">	//mov edx,dword ptr ds:[0x7FFDF000]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="段描述符与段选择子"><a href="#段描述符与段选择子" class="headerlink" title="段描述符与段选择子"></a>段描述符与段选择子</h2><p>1、GDT(全局描述符表)  LDT(局部描述符表)</p>
<p><code>当我们执行类似MOV DS,AX指令时，CPU会查表，根据AX的值来决定查找GDT还是LDT,查找表的什么位置，查出多少数据.</code></p>
<p><img src="/2020/10/13/windows-huoge/image-03.png" width="500px"></p>
<p>段选择子是一个16位的段描述符，该描述符指向了定义该段的段描述符.                </p>
<p><img src="/2020/10/13/windows-huoge/image-04.png" width="500px"></p>
<blockquote>
<p>RPL：请求特权级别</p>
</blockquote>
<blockquote>
<p>TI：</p>
<ul>
<li>TI=0  查GDT表</li>
<li>TI=1  查LDT表</li>
</ul>
</blockquote>
<blockquote>
<p>Index：</p>
</blockquote>
<p>处理器将索引值乘以8在加上GDT或者LDT的基地址，就是要加载的段描述符</p>
<p>加载段描述符至段寄存器</p>
<p>除了MOV指令，我们还可以使用LES、LSS、LDS、LFS、LGS指令修改寄存器.</p>
<p>CS不能通过上述的指令进行修改，CS为代码段，CS的改变会导致EIP的改变，要改CS，必须要保证CS与EIP一起改，后面会讲.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char buffer[6];					</span><br><span class="line">__asm							</span><br><span class="line">&#123;			</span><br><span class="line">	les ecx,fword ptr ds:[buffer] //高2个字节给es，低四个字节给ecx	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：RPL&lt;=DPL(在数值上)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="段描述符属性P位与G位"><a href="#段描述符属性P位与G位" class="headerlink" title="段描述符属性P位与G位"></a>段描述符属性P位与G位</h2><p><img src="/2020/10/13/windows-huoge/image-05.png" width="500px"></p>
<p>P = 1 段描述符有效</p>
<p>P = 0 段描述符无效</p>
<h2 id="段描述符属性S位与Type域"><a href="#段描述符属性S位与Type域" class="headerlink" title="段描述符属性S位与Type域"></a>段描述符属性S位与Type域</h2><p><img src="/2020/10/13/windows-huoge/image-05.png" width="500px"></p>
<p>S = 1 代码段或者数据段描述符</p>
<p>S = 0 系统段描述符    </p>
<h3 id="系统段描述符"><a href="#系统段描述符" class="headerlink" title="系统段描述符"></a>系统段描述符</h3><p>当S=0时，该段描述符为系统描述符</p>
<p><img src="/2020/10/13/windows-huoge/image-06.png" width="500px"></p>
<h3 id="数据段、代码段描述符"><a href="#数据段、代码段描述符" class="headerlink" title="数据段、代码段描述符"></a>数据段、代码段描述符</h3><p><img src="/2020/10/13/windows-huoge/image-07.png" width="500px"></p>
<ul>
<li>A 访问位，表示该位最后一次被操作系统清零后，该段是否被访问过.每当处理器将该段选择符置入某个段寄存器时，就将该位置1.</li>
<li>W 是否可写</li>
<li>E 扩展方向</li>
</ul>
<p><img src="/2020/10/13/windows-huoge/image-08.png" width="500px"></p>
<p><br></p>
<h2 id="段描述符DB位"><a href="#段描述符DB位" class="headerlink" title="段描述符DB位"></a>段描述符DB位</h2><p><img src="/2020/10/13/windows-huoge/image-05.png" width="500px"></p>
<blockquote>
<p>情况一：对CS段的影响        </p>
</blockquote>
<ul>
<li>D = 1 采用32位寻址方式                </li>
<li>D = 0 采用16位寻址方式                </li>
<li>前缀67 改变寻址方式    </li>
</ul>
<blockquote>
<p>情况二：对SS段的影响        </p>
</blockquote>
<ul>
<li>D = 1 隐式堆栈访问指令（如：PUSH POP CALL） 使用32位堆栈指针寄存器ESP                </li>
<li>D = 0 隐式堆栈访问指令（如：PUSH POP CALL） 使用16位堆栈指针寄存器SP    </li>
</ul>
<blockquote>
<p>情况三：向下拓展的数据段        </p>
</blockquote>
<ul>
<li>D = 1 段上线为4GB                </li>
<li>D = 0 段上线为64KB    </li>
</ul>
<p><br></p>
<h2 id="段权限检查"><a href="#段权限检查" class="headerlink" title="段权限检查"></a>段权限检查</h2><p>段权限检查<br><code>MOV DS,AX</code></p>
<blockquote>
<p>CPL(Current Privilege Level) ：当前特权级</p>
</blockquote>
<p>如何查看程序处于几环?<br>CS和SS中存储的段选择子后2位.        </p>
<p>DPL(Descriptor Privilege Level)  描述符特权级别<br><img src="/2020/10/13/windows-huoge/image-05.png" width="500px"></p>
<p>DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么.</p>
<p>通俗的理解：<br>如果你想访问我，那么你应该具备什么特权.     </p>
<p>举例说明：<br><code>mov DS,AX</code><br>如果AX指向的段DPL = 0  但当前程序的CPL = 3 这行指令是不会成功的！</p>
<blockquote>
<p>RPL(Request Privilege Level)  请求特权级别</p>
</blockquote>
<p>举例说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mov ax,0008	与	Mov ax,000B 		//段选择子  		</span><br><span class="line">Mov ds,ax		Mov ds,ax		//将段描述</span><br></pre></td></tr></table></figure></p>
<p>指向的是同一个段描述符,但RPL是不一样的.</p>
<p>数据段的权限检查<br>参考如下代码：<br>比如当前程序处于0环，也就是说CPL=0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mov ax,000B	//1011   RPL = 3</span><br><span class="line"></span><br><span class="line">Mov ds,ax	//ax指向的段描述符的DPL = 0</span><br></pre></td></tr></table></figure></p>
<p>数据段的权限检查：<br><code>CPL &lt;= DPL  并且 RPL &lt;= DPL (数值上的比较)</code><br>注意：<br>代码段和系统段描述符中的检查方式并不一样,具体参加后面课程.</p>
<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li>CPL  CPU当前的权限级别</li>
<li>DPL  如果你想访问我，你应该具备什么样的权限</li>
<li>RPL  用什么权限去访问一个段</li>
</ul>
<p>为啥要有RPL?</p>
<p>我们本可以用“读 写”的权限去打开一个文件，但为了避免出错，有些时候我们使用“只读”的权限去打开。</p>
<p><br></p>
<h2 id="代码跨段流程"><a href="#代码跨段流程" class="headerlink" title="代码跨段流程"></a>代码跨段流程</h2><p>段寄存器:<br>ES,CS,SS,DS,FS,GS,LDTR,TR</p>
<p>段寄存器读写：<br>除CS外，其他的段寄存器都可以通过MOV,LES,LSS,LDS,LFS,LGS指令进行修改    </p>
<p>CS为什么不可以直接修改呢？<br>CS的改变意味着EIP的改变，改变CS的同时必须修改EIP,所以我们无法使用上面的指令来进行修改.        </p>
<h3 id="代码间的跳转"><a href="#代码间的跳转" class="headerlink" title="代码间的跳转"></a>代码间的跳转</h3><p>(段间跳转  非调用门之类的)<br>段间跳转，有2种情况，即要跳转的段是一致代码段还是非一致代码段(如何区分参见之前视频)</p>
<blockquote>
<p>同时修改CS与EIP的指令<br>JMP FAR / CALL FAR / RETF / INT /IRETED    </p>
</blockquote>
<blockquote>
<p>只改变EIP的指令<br>JMP / CALL / JCC / RET    </p>
</blockquote>
<h3 id="代码间的跳转执行流程"><a href="#代码间的跳转执行流程" class="headerlink" title="代码间的跳转执行流程"></a>代码间的跳转执行流程</h3><p><code>JMP 0x20:0x004183D7</code>CPU如何执行这行代码?</p>
<ul>
<li><p>(1) 段选择子拆分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x20 对应二进制形式 0000 0000 0010 0000	</span><br><span class="line">RPL = 00   </span><br><span class="line">TI = 0</span><br><span class="line">Index = 4</span><br></pre></td></tr></table></figure>
</li>
<li><p>(2) 查表得到段描述符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TI = 0 所以查GDT表	</span><br><span class="line">Index = 4 找到对应的段描述符</span><br><span class="line">四种情况可以跳转：代码段、调用门、TSS任务段、任务门</span><br></pre></td></tr></table></figure>
</li>
<li><p>(3) 权限检查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果是非一致代码段，要求:CPL == DPL 并且 RPL &lt;= DPL		</span><br><span class="line">如果是一致代码段，要求:CPL &gt;= DPL</span><br></pre></td></tr></table></figure>
</li>
<li><p>(4) 加载段描述符<br>通过上面的权限检查后，CPU会将段描述符加载到CS段寄存器中.</p>
</li>
<li>(5) 代码执行<br>CPU将 CS.Base + Offset 的值写入EIP 然后执行CS:EIP处的代码，段间跳转结束.</li>
</ul>
<p>直接对代码段进行JMP 或者 CALL的操作<br>无论目标是一致代码段还是非一致代码段，CPL都不会发生改变.如果要提升CPL的权限，只能通过调用门.</p>
<p><br></p>
<h2 id="长调用与短调用"><a href="#长调用与短调用" class="headerlink" title="长调用与短调用"></a>长调用与短调用</h2><p>我们通过JMP FAR可以实现段间的跳转，如果要实现跨段的调用就必须要<br>学习CALL FAR，也就是长调用.</p>
<p>CALL FAR 比JMP FAR要复杂，JMP并不影响堆栈,但CALL指令会影响.</p>
<h3 id="短调用"><a href="#短调用" class="headerlink" title="短调用"></a>短调用</h3><p>指令格式：CALL  立即数/寄存器/内存</p>
<p><img src="/2020/10/13/windows-huoge/image-09.png" width="500px"><br>发生改变的寄存器：ESP EIP</p>
<h3 id="长调用-跨段不提权"><a href="#长调用-跨段不提权" class="headerlink" title="长调用(跨段不提权)"></a>长调用(跨段不提权)</h3><p>指令格式：CALL  CS:EIP(EIP是废弃的)</p>
<blockquote>
<p>与JMP跨段不一样, JMP FAR CS:EIP中的EIP会跳到指定地址, 但是CALL的EIP是废弃的<br>修改CS就为跨段, 根据段选择子拿到的段描述符DPL是3,如果CSCPL一直是3环, 则是不提权跨段<br>不提权用的堆栈还是原来的堆栈SS<br>如果用普通的RET只是将EIP指向返回地址, 但是CS不会回到原址,而RETF则会刷入原来的CS寄存器</p>
</blockquote>
<p><img src="/2020/10/13/windows-huoge/image-10.png" width="500px"><br>发生改变的寄存器：ESP EIP  CS</p>
<h3 id="长调用-跨段并提权"><a href="#长调用-跨段并提权" class="headerlink" title="长调用(跨段并提权)"></a>长调用(跨段并提权)</h3><p>指令格式：CALL  CS:EIP(EIP是废弃的)</p>
<blockquote>
<p>这次段选择子找到的DPL是0,那就是提权跨段调用<br>CS一旦提权了, SS也得提权, CS和SS是一对的<br>ESP栈顶指针寄存器也得提权, 从3环换成0环<br>SS和ESP从哪里来, 一旦看到CS提权之后, 就会去TSS那边要这两个</p>
</blockquote>
<p><img src="/2020/10/13/windows-huoge/image-11.png" width="500px"><br><img src="/2020/10/13/windows-huoge/image-12.png" width="500px"></p>
<p>发生改变的寄存器：ESP EIP  CS SS</p>
<ul>
<li>1) 跨段调用时，一旦有权限切换，就会切换堆栈.</li>
<li>2) CS的权限一旦改变，SS的权限也要随着改变，CS与SS的等级必须一样.</li>
<li>3) JMP FAR 只能跳转到同级非一致代码段，但CALL FAR可以通过调用门<br>提权，提升CPL的权限.</li>
</ul>
<p><br></p>
<h2 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h2><blockquote>
<p>调用门描述符</p>
</blockquote>
<p><img src="/2020/10/13/windows-huoge/image-13.png" width="600px"></p>
<p>TYPE: 1100代表的是TSS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">真正存入CS寄存器的是门里面的段选择子指向的段描述符决定</span><br></pre></td></tr></table></figure></p>
<p>1、调用门执行流程</p>
<p>指令格式：<code>CALL  CS:EIP(EIP是废弃的)</code></p>
<p>执行步骤：</p>
<ul>
<li>1) 根据CS的值 查GDT表，找到对应的段描述符  这个描述符是一个调用门.(注意当前CS的CPL一定要和调用门的DPL一致,否则敲门的权力都没有)</li>
<li>2) 在调用门描述符中存储另一个代码段段的选择子.(在代码段上就可以指定是0环的RPL还是3环的RPL)</li>
<li>3) 选择子指向的段  段.Base + 偏移地址 就是真正要执行的地址.</li>
</ul>
<h3 id="无参"><a href="#无参" class="headerlink" title="无参"></a>无参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __declspec(naked) NoArgs()&#123;</span><br><span class="line">	__asm&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	SegVal segVal = &#123;<span class="number">0</span>, <span class="number">0x4b</span>&#125;;</span><br><span class="line">	__asm&#123;</span><br><span class="line">		call fword ptr[segVal]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印一下函数地址<code>NoArg:0x00401030</code>,<code>HasArg:0x00401040</code></p>
<p>根据<code>ox4b</code>可以找到第<code>0100 1011</code><br>RPL:3环<br>TI:0<br>Index:9</p>
<p>从而修改GDT第十项:<code>0040ec00, 00081030</code>, 跳到index2的段描述符提权</p>
<h3 id="有参"><a href="#有参" class="headerlink" title="有参"></a>有参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegVal</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> val;</span><br><span class="line">	<span class="keyword">short</span> seg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) HasArgs()&#123;</span><br><span class="line">	__asm&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">		pushad</span><br><span class="line">		pushfd</span><br><span class="line">		mov eax, dword ptr[esp+<span class="number">0x24</span>+<span class="number">0x8</span>+<span class="number">0x8</span>]</span><br><span class="line">		mov esi, dword ptr[esp+<span class="number">0x24</span>+<span class="number">0x8</span>+<span class="number">0x4</span>]</span><br><span class="line">		mov edi, dword ptr[esp+<span class="number">0x24</span>+<span class="number">0x8</span>] <span class="comment">// 取三个参数</span></span><br><span class="line">		popfd</span><br><span class="line">		popad</span><br><span class="line">		retf <span class="number">0xc</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	SegVal segVal = &#123;<span class="number">0</span>, <span class="number">0x4b</span>&#125;;</span><br><span class="line">	__asm&#123;</span><br><span class="line">		push <span class="number">1</span></span><br><span class="line">		push <span class="number">2</span></span><br><span class="line">		push <span class="number">3</span></span><br><span class="line">		call fword ptr [segVal]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印一下函数地址<code>NoArg:0x00401030</code>,<code>HasArg:0x00401040</code></p>
<p>根据<code>ox4b</code>可以找到第<code>0100 1011</code><br>RPL:3环<br>TI:0<br>Index:9</p>
<p>从而修改GDT第十项:<code>0040ec03, 00081030</code>, 跳到index2的段描述符提权,并且参数为3个</p>
<p>根据esp查内存地址, 分以下结构</p>
<ul>
<li>第三个参数</li>
<li>第二个参数</li>
<li>第一个参数</li>
<li>ESP</li>
<li>SS</li>
</ul>
<p><br><br><br></p>
<h2 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h2><p>Windows没有使用调用门，但是使用了中断门：</p>
<ul>
<li><1> 系统调用</1></li>
<li><2> 调试</2></li>
</ul>
<h3 id="IDT"><a href="#IDT" class="headerlink" title="IDT"></a>IDT</h3><p>IDT即中断描述符表,同GDT一样，IDT也是由一系列描述符组成的，每个<br>描述符占8个字节。但要注意的是，IDT表中的第一个元素不是NULL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU遇到INT指令会查IDT表</span><br><span class="line">INT指令后面跟的就是索引</span><br><span class="line">中断门没有RPL了,所以中断门只查CPL</span><br></pre></td></tr></table></figure>
<p>GDT表大约有两大类, 系统段、代码&amp;数据段<br>IDT表是任务门, 中断门, 陷阱门 </p>
<p><img src="/2020/10/13/windows-huoge/image-15.png" width="500px"></p>
<blockquote>
<p>中断门:  P为1, S为0, TYPE=1110<br>任务门:  P为1, S为0, TYPE=0101<br>陷阱门:  P为1, S为0, TYPE=1111</p>
</blockquote>
<p><img src="/2020/10/13/windows-huoge/image-14.png" width="600px"></p>
<p>这个中断描述符跟调用门结构很像, 只是无参</p>
<p>注意,这结构里面的段选择子查的还是会走GDT, 虽然是从IDT拿到的中断描述符<br>但是中断描述符的段选择子还是会走GDT的数据</p>
<blockquote>
<p>INT X<br>X是索引, <code>X*8+IDT</code>的基址</p>
</blockquote>
<h3 id="中断返回"><a href="#中断返回" class="headerlink" title="中断返回"></a>中断返回</h3><p>INT N指令</p>
<p>1:在没有权限切换时, 会向堆栈push 3个值, 分别是:</p>
<p><code>CS EFLAG EIP</code>(返回地址)</p>
<p>2:在有权限切换时, 会向堆栈push5个值, 分别是:</p>
<p><code>SS ESP EFLAG CS EIP</code></p>
<p>在中断门中, 不能用RETF返回, 而是应该通过IRET/IRETD指令返回 </p>
<h3 id="调用门与中断门的区别"><a href="#调用门与中断门的区别" class="headerlink" title="调用门与中断门的区别"></a>调用门与中断门的区别</h3><ul>
<li>1)调用门通过CALL FAR指令执行但中断门通过INT指令</li>
<li>2)调用门查询GDT表，中断门查询IDT表(根据段选择子还查GDT)</li>
<li>3)CALL CS:EIP中的CS是段选择子,由3部分组成但INTN指令中的N只是索引，中断门不检查RPL,只检查CPL</li>
<li>4)调用门可以有参数，但中断门没有参数</li>
</ul>
<p><br></p>
<h2 id="陷阱门"><a href="#陷阱门" class="headerlink" title="陷阱门"></a>陷阱门</h2><p><img src="/2020/10/13/windows-huoge/image-16.png" width="500px"></p>
<h3 id="构造一个陷阱门"><a href="#构造一个陷阱门" class="headerlink" title="构造一个陷阱门"></a>构造一个陷阱门</h3><ul>
<li>1）构造一个陷阱门(<code>0040EFO0 00081030</code>)</li>
<li>2）写入到IDT表中<blockquote>
<p>eq 8003f500 0040EFO0 00081030</p>
</blockquote>
</li>
<li>3）执行陷阱门</li>
</ul>
<h3 id="陷阱门与中断门的区别"><a href="#陷阱门与中断门的区别" class="headerlink" title="陷阱门与中断门的区别"></a>陷阱门与中断门的区别</h3><blockquote>
<p>通过中断门与陷阱门打印EFLAG寄存器的值</p>
</blockquote>
<ul>
<li>执行前:216</li>
<li>执行中:<ul>
<li>陷阱门:216</li>
<li>中断门:16</li>
</ul>
</li>
</ul>
<p>中断门会清除掉EFL寄存器的IF位,而陷阱门不会</p>
<h3 id="EFLAG寄存器"><a href="#EFLAG寄存器" class="headerlink" title="EFLAG寄存器"></a>EFLAG寄存器</h3><p><img src="/2020/10/13/windows-huoge/image-17.png" width="700px"></p>
<p>IF标志用于控制处理器对可屏蔽中断请求的响应。<br>置1以响应可屏蔽中断,反之则禁止可屏蔽中断。<br>IF标志只对不可屏蔽中断没有影响。</p>
<blockquote>
<p>不可屏蔽中断? </p>
</blockquote>
<p><code>int 3 == 0xcc</code></p>
<p><br></p>
<h2 id="任务段"><a href="#任务段" class="headerlink" title="任务段"></a>任务段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在调用门、中断门与陷阱门中，一旦出现权限切换，那么就会有堆栈的切换。</span><br><span class="line">而且由于CS的CPL发生改变，也导致了SS也必须要切换。</span><br><span class="line"></span><br><span class="line">切换时，会有新的ESP和SS(CS是由中断门或者调用门指定)这2个值从哪里来的呢？</span><br><span class="line"></span><br><span class="line">答案：TSS (Task-state segment )，任务状态段.</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/13/windows-huoge/image-18.png" width="500px"></p>
<p>这张表里很重要的一点就是LDT的段选择子, 这也说明了一个任务会带一个LDT, 而GDT只会有一个</p>
<p>LDT的段选择子, 衍生出了LDTR寄存器, 那么GDT知道去哪里找, LDT也就知道了从LDTR寄存器里面找</p>
<h3 id="CPU如何找到TSS"><a href="#CPU如何找到TSS" class="headerlink" title="CPU如何找到TSS"></a>CPU如何找到TSS</h3><blockquote>
<p>TR段寄存器</p>
</blockquote>
<p><img src="/2020/10/13/windows-huoge/image-20.png" width="500px"></p>
<p>由GDT表中的TSS段描述符加载到TR段寄存器, TR段寄存器里面指向了TSS内存内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Windows只有了ESP0,SS0, 其他都没有用到</span><br><span class="line">所以EAX,EBX.....很多进行TSS任务切换, 如线程切换的时候, 不会替换其他寄存器里面的内容</span><br></pre></td></tr></table></figure>
<h3 id="TR寄存器读写"><a href="#TR寄存器读写" class="headerlink" title="TR寄存器读写"></a>TR寄存器读写</h3><ul>
<li>1) 将TSS段描述符加载到TR寄存器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指令：LTR</span><br><span class="line">说明：</span><br><span class="line">用LTR指令去装载的话 仅仅是改变TR寄存器的值(96位) </span><br><span class="line">并没有真正改变TSS  </span><br><span class="line">LTR指令只能在系统层使用</span><br><span class="line">加载后TSS段描述符会状态位会发生改变</span><br></pre></td></tr></table></figure>
<ul>
<li>2) 读TR寄存器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指令：STR</span><br><span class="line">说明：如果用STR去读的话，只读了TR的16位 也就是选择子</span><br></pre></td></tr></table></figure>
<h3 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h3><p><img src="/2020/10/13/windows-huoge/image-21.png" width="500px"></p>
<p>构造TSS段描述符公式:XX00e9XX XXXX0068 </p>
<blockquote>
<p>eq 8003f0c0 0000e912 fDCCo068</p>
</blockquote>
<p>这些xxx就是base地址,即TSS的内存base</p>
<p>怎么替换呢? </p>
<ul>
<li>修改TR寄存器<ul>
<li>1)在Ring0我们可以通过LTR指令去修改TR寄存器</li>
<li>2)在Ring3我们可以通过CALL FAR或者JMP FAR指令来修改</li>
</ul>
</li>
<li>用JMP去访问一个代码段的时候,改变的是CS和EIP:<ul>
<li>JMP 0x48:0x123456如果Ox48是代码段</li>
<li>执行后:CS–&gt;0x48 EIP–&gt;0x123456</li>
</ul>
</li>
<li>用JMP去访问一个任务段的时候:<ul>
<li>如果Ox48是TSS段描述符，先修改TR寄存器，在用TR.Base指向的TSs中的值修改当前的寄存器</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这里jmp和call是有区别的, Previous Task Link用call会填上原来的TSS, JMP则为0</span><br><span class="line">并且call使用的时候NT为变1, JMP则不会变</span><br><span class="line">NT位如果为0, IRET的返回值从堆栈取</span><br><span class="line">NT位如果为1, IRET的返回值会从TSS的Previous Task LinK找</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="任务门"><a href="#任务门" class="headerlink" title="任务门"></a>任务门</h2><p>虽然windows没有用到TSS大量的知识,好像不需要任务门<br>但是IDT表里面有任务门,INT 8, 双重错误(比如进行一个任务出错则进入0号中断, 0号中断的处理又出错就进入8号中断)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在上一节中讲解了如何通过CALL、JMP指令访问任务段</span><br><span class="line">这一节主要介绍如何通过任务门去访问任务段</span><br><span class="line">既然已经可以访问任务段了，那为什么还要有任务门呢？</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/13/windows-huoge/image-22.png" width="500px"></p>
<h3 id="IDT中断描述符"><a href="#IDT中断描述符" class="headerlink" title="IDT中断描述符"></a>IDT中断描述符</h3><p>IDT表可以包含3种门描述符：</p>
<ul>
<li>任务门描述符</li>
<li>中断门描述符</li>
<li>陷阱门描述符    </li>
</ul>
<h3 id="任务门指向流程"><a href="#任务门指向流程" class="headerlink" title="任务门指向流程"></a>任务门指向流程</h3><p>任务门执行过程：</p>
<ul>
<li>INT N</li>
<li>查IDT表，找到任务门描述符</li>
<li>通过任务门描述符，查GDT表，找到TSS段描述符</li>
<li>使用TSS段中的值修改TR寄存器</li>
<li>IRETD返回</li>
</ul>
<p><br><br><br></p>
<h2 id="10-10-12分页"><a href="#10-10-12分页" class="headerlink" title="10-10-12分页"></a>10-10-12分页</h2><h3 id="4GB内存空间"><a href="#4GB内存空间" class="headerlink" title="4GB内存空间"></a>4GB内存空间</h3><p><img src="/2020/10/13/windows-huoge/image-24.png" width="500px"></p>
<h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><p>线性地址、有效地址、物理地址</p>
<p>如下指令：</p>
<p><code>MOV eax,dword ptr ds:[0x12345678]</code></p>
<p>其中0x12345678 是有效地址</p>
<p><code>ds.Base + 0x12345678</code> 是线性地址</p>
<p>所有在汇编里面的地址都是假的线性地址, 还有一个地址叫”物理地址”</p>
<p><img src="/2020/10/13/windows-huoge/image-25.png" width="500px"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面MOV eax,dword ptr ds:[0x12345678]想要执行成功, 首先过段的机制,再过页的机制</span><br></pre></td></tr></table></figure>
<h3 id="物理在哪里"><a href="#物理在哪里" class="headerlink" title="物理在哪里"></a>物理在哪里</h3><p>每个进程都有一个CR3,(准确的说是都一个CR3的值，CR3本身是<br>个寄存器，一个核，只有一套寄存器)</p>
<p>CR3指向一个物理页，一共4096字节,如图：</p>
<p><img src="/2020/10/13/windows-huoge/image-26.png" width="500px"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPU保护模式下只有CR3存的base是物理地址,其他都是线性地址</span><br><span class="line">不过提一嘴, 汇编代码只能使用线性地址, 所以操作系统怎么挂物理页后面会讲</span><br></pre></td></tr></table></figure>
<h3 id="设置分页的方式"><a href="#设置分页的方式" class="headerlink" title="设置分页的方式"></a>设置分页的方式</h3><p><img src="/2020/10/13/windows-huoge/image-27.png" width="800px"></p>
<p>将noexecute 改成 execute</p>
<p><img src="/2020/10/13/windows-huoge/image-28.png" width="500px"></p>
<p><br><br><br></p>
<h2 id="物理页"><a href="#物理页" class="headerlink" title="物理页"></a>物理页</h2><p>PDE_PTE<br><img src="/2020/10/13/windows-huoge/image-23.png" width="500px"></p>
<p>从这开始学习页的机制.</p>
<p>CR3首地址<br>PDT 页目录表(4096个字节 4kb大小) </p>
<pre><code>- PDE 页目录项(4字节, 4字节32位,高20位是物理地址低12位是属性)
    - PTT(页表)
        - PTE(页表项: 4字节, 32位, 高20位是物理地址[这里指向具体4kb大小的物理页], 低12位是属性)
- .... 1024个PDE
</code></pre><p>既然有1024项, 则是2的10次方分布<br>10-10-12</p>
<p>1024个PDE, 1024个PTE 4k物理页</p>
<p><code>1024*1024*4KB = 4G</code></p>
<p><br><br><br></p>
<h3 id="PDE-PTE属性"><a href="#PDE-PTE属性" class="headerlink" title="PDE,PTE属性"></a>PDE,PTE属性</h3><p>物理页的属性 = PDE属性 &amp; PTE属性</p>
<p><img src="/2020/10/13/windows-huoge/image-29.png" width="700px"><br><img src="/2020/10/13/windows-huoge/image-30.png" width="700px"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这里提一嘴, 当内存不够的时候会有页换出</span><br><span class="line">线性地址原先的物理内存被放到磁盘, 这里的物理内存就会被其他进程的线性地址占用</span><br><span class="line">那么原先的线性地址就把P位置为0不可用</span><br><span class="line">如果下次当前进程在读到这个线性地址的时候会进入异常</span><br><span class="line">这个时候CPU会走IDT的E号中断</span><br><span class="line"></span><br><span class="line">那CPU如何判断E号中断, 是因为页换出, 还是真的不可用</span><br><span class="line">00401234(PTE p=0) -&gt; 10, 000-&gt;PTE(p=0)</span><br><span class="line">这个时候9~11位的数据就有辨别作用了,具体操作空间给操作系统</span><br></pre></td></tr></table></figure>
<h3 id="P位"><a href="#P位" class="headerlink" title="P位"></a>P位</h3><p>线性地址0 为什么不能访问呢？</p>
<p>没有指定物理页，指定物理页就一定能访问吗？</p>
<p>先看PDE与PTE的P位  P=1 才是有效的物理页</p>
<h3 id="R-W-位"><a href="#R-W-位" class="headerlink" title="R/W 位"></a>R/W 位</h3><p>R/W = 0 只读<br>R/W = 1 可读可写</p>
<blockquote>
<p>实验<br>定义一个只读类型的变量，再另一个线性地址指向相同的物理页，通过修改PDE/PTE属性，实现可写。</p>
</blockquote>
<h3 id="U-S位"><a href="#U-S位" class="headerlink" title="U/S位"></a>U/S位</h3><p>U是用户 1<br>S是系统 0</p>
<p>0-7FFFFFFF: U/S = 1<br>80000000 - FFFFFFFF: U/S = 0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ds:[12345678],0</span><br><span class="line">// 低2g U/S=1, CPL=3, CPL=0都是可以访问的, PDE&amp;PTE的RW位也要有写权限</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov dword ptr ds:[81234567],0</span><br><span class="line">// 高2g 系统位内存段 U/S=0, 要想保证访问成功, DS段要权限, PDE&amp;PTE的RW位也要有写权限</span><br><span class="line">// 如果当前的CPL为3的话, 写不了, 需要提权</span><br></pre></td></tr></table></figure>
<p>如果当前在应用层写代码访问高2g的内存地址</p>
<ul>
<li>提权,突破PDE、PTE的U/S位限制</li>
<li>改PDE、PTE的U/S位限制(也得提权)</li>
</ul>
<h3 id="A-位"><a href="#A-位" class="headerlink" title="A 位"></a>A 位</h3><p>是否被访问(读或者写)过,访问过置1<br>即使只访问一个字节也会导致PDE PTE置1</p>
<h3 id="D-位"><a href="#D-位" class="headerlink" title="D 位"></a>D 位</h3><p>脏位:是否被写过,0没有被写过,1被写过</p>
<h3 id="P-S位"><a href="#P-S位" class="headerlink" title="P/S位"></a>P/S位</h3><p>只对PDE有意义，PS == PageSize的意思  </p>
<p>当PS==1的时候 PDE直接指向物理页,无PTE,低22位是页内偏移。</p>
<p>线性地址只能拆成2段：大小为4MB,俗称“大页”</p>
<h3 id="G位-PWT位-PCD位"><a href="#G位-PWT位-PCD位" class="headerlink" title="G位  PWT位  PCD位"></a>G位  PWT位  PCD位</h3><p>学完控制寄存器与TLB才能讲 此处略过。。。</p>
<p><br><br><br></p>
<h2 id="代码挂物理页"><a href="#代码挂物理页" class="headerlink" title="代码挂物理页"></a>代码挂物理页</h2><ul>
<li>低2G(0-7FFFFFFF) 几乎不同</li>
<li>高2G(80000000-FFFFFFFF) 几乎相同</li>
<li>0-7FFFFFFF的前后64k都是没有映射</li>
</ul>
<p>让其0线性地址可用挂上物理页(类似VirtualAlloc分配内存), 准确来讲挂PDE/PTE, 访问PDE/PTE,就得能拿到PDT/PTT</p>
<hr>

<h3 id="页目录基址"><a href="#页目录基址" class="headerlink" title="页目录基址"></a>页目录基址</h3><p>如果系统要保证某个线性地址是有效的，<br>那么必须为其填充正确的PDE与PTE，如果我们想填充PDE与PTE那么必须能够访问<br>PDT与PTT，那么存在2个问题：</p>
<ul>
<li>1、一定已经有“人”为我们访问PDT与PTT挂好了PDE与PTE,我们只有找到这个线性地址就可以了。</li>
<li>2、这个为我们挂好PDE与PTE的“人”是谁？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：CR3中存储的是物理地址，不能在程序中直接读取的。</span><br><span class="line">如果想读取，也要把CR3的值挂到PDT和PTT中才能访问</span><br><span class="line">那么怎么通过线性地址访问PDT和PTT呢？</span><br></pre></td></tr></table></figure>
<h4 id="拆分C0300000"><a href="#拆分C0300000" class="headerlink" title="拆分C0300000"></a>拆分C0300000</h4><p>(参加实验)</p>
<p>结论：C0300000存储的值就是PDT</p>
<p>如果我们要访问第N个PDE，那么有如下公式：</p>
<p><code>0xC0300000 + N*4</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// mov dword ptr ds:[0x123], 1 // CPU会拿(123-&gt;CR3),所以CR3是物理地址,不能在汇编里面用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 0xc0300000 </span><br><span class="line">mov dword ptr ds:[PDT], 0x0000167</span><br></pre></td></tr></table></figure>
<p>通过<code>0xc0300000</code>地址找到PDT</p>
<p>1100 0000 0011 00000 0000 00000 0000 0000 </p>
<p>10-10-24拆</p>
<p>1100 0000 00   = 300 <em> 4 = c00<br>1100 0000 00   = 300 </em> 4 = c00<br>00000 0000 0000 = 0 = 0</p>
<p><img src="/2020/10/13/windows-huoge/image-31.png" width="1100px"></p>
<p>可以看到拆<code>0xc0300000</code>就会有如上的输出 </p>
<p>但是如果直接看CR3的物理地址: <code>!dd 0x10df8000</code></p>
<p><img src="/2020/10/13/windows-huoge/image-33.png" width="800px"><br><img src="/2020/10/13/windows-huoge/image-32.png" width="600px"></p>
<p>那么直接查CR3的物理地址和查<code>0xC0300000</code>是一个PDT<br>那<code>0xC030000</code>是可以在汇编上动手脚找到PDT</p>
<p>那么接下来的语句即可执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 0xc0300000 </span><br><span class="line">mov dword ptr ds:[0xc0300000], 0x0000167</span><br></pre></td></tr></table></figure>
<hr>

<h4 id="页目录表基址"><a href="#页目录表基址" class="headerlink" title="页目录表基址"></a>页目录表基址</h4><blockquote>
<p>Xp系统 10-10-12分页模式</p>
</blockquote>
<p><img src="/2020/10/13/windows-huoge/image-34.png" width="400px"></p>
<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li>1、通过0xC0300000找到的物理页就是页目录表</li>
<li>2、这个物理页即是页目录表本身也是页表</li>
<li>3、0xC030页目录表是一张特殊的页表，每一项PTE指向的不是普通的物理页，而是指向其他的页表.</li>
<li>4、如果我们要访问第N个PDE，那么有如下公式：<code>0xC0300000 + N*4</code> </li>
</ul>
<hr>

<h3 id="页表基址"><a href="#页表基址" class="headerlink" title="页表基址"></a>页表基址</h3><p>上一节我们讲解了页目录表基址,也就是说通过0xC0300000这个线性地址<br>可以访问一张表，这张表就是页目录表，有了这个地址，我们可以任意修改页目录表。</p>
<p>但如果我们要设置某个线性地址PDE和PTE那么还要能够访问PTT，如何访问呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0xc0300000得到一个物理页</span><br><span class="line">这个物理页跟CR3得到的PDT是一样的</span><br><span class="line"></span><br><span class="line">0xc0000000的PTE = c03的PTE</span><br><span class="line">PDT: 0xC00</span><br><span class="line">PTT: 0x00</span><br><span class="line"></span><br><span class="line">mov dword ptr ds:[0xc0300000], 0x12345678 // 改了0地址的PDE</span><br></pre></td></tr></table></figure>
<h4 id="拆分C0000000-C0001000"><a href="#拆分C0000000-C0001000" class="headerlink" title="拆分C0000000 / C0001000"></a>拆分C0000000 / C0001000</h4><p><img src="/2020/10/13/windows-huoge/image-35.png" width="400px"></p>
<p>总结：</p>
<ul>
<li>1、页表被映射到了从0xC0000000到0xC03FFFFF的4M地址空间</li>
<li>2、在这1024个表中有一张特殊的表：页目录表</li>
<li>3、页目录被映射到了0xC0300000开始处的4K地址空间</li>
</ul>
<h4 id="有了0xC0300000和0xC0000000能做什么"><a href="#有了0xC0300000和0xC0000000能做什么" class="headerlink" title="有了0xC0300000和0xC0000000能做什么"></a>有了0xC0300000和0xC0000000能做什么</h4><p>掌握了这两个地址，就掌握了一个进程所有的物理内存读写权限。</p>
<ul>
<li><p>1、什么是PDI与PTI<br>10-10-12<br>第一个10为PDI<br>第二个10为PTI</p>
</li>
<li><p>2、访问页目录表的公式：<br><code>0xC0300000 + PDI*4</code></p>
</li>
<li><p>3、访问页表的公式：<br><code>0xC0000000 + PDI*4096 + PTI*4</code></p>
</li>
</ul>
<h4 id="MnIsAddressValid"><a href="#MnIsAddressValid" class="headerlink" title="MnIsAddressValid"></a>MnIsAddressValid</h4><p>逆向分析该函数是否有效(10-10-12)</p>
<p><br><br><br></p>
<h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2><h3 id="地址解析"><a href="#地址解析" class="headerlink" title="地址解析"></a>地址解析</h3><ul>
<li>1）通过一个线性地址访问一个物理页。比如：一个DWORD，其实未必真正读的是4个字节，我们先读的PDE再读PTE 最后才读的4个字节的页。</li>
<li>2）在2-9-9-12会读24个字节 如果跨页可能更多。</li>
</ul>
<p>为了提高效率，只能做记录。</p>
<p>CPU内部做了一个表，来记录这些东西，这个表格是CPU内部的，和寄存器一样快，这个表格：TLB（Translation Lookaside Buffer）。</p>
<h3 id="TLB结构"><a href="#TLB结构" class="headerlink" title="TLB结构"></a>TLB结构</h3><p><img src="/2020/10/13/windows-huoge/image-36.png" width="500px"></p>
<p>说明：</p>
<ul>
<li>1) ATTR（属性）：属性是PDPE PDE PTE三个属性AND起来的. 如果是10-10-12 就是PDE and PTE</li>
<li>2) 不同的CPU 这个表的大小不一样.</li>
<li>3) 只要Cr3变了，TLB立马刷新，一核一套TLB.</li>
</ul>
<p>操作系统的高2G映射基本不变，如果Cr3改了，TLB刷新 重建高2G以上很浪费。<br>所以PDE和PTE中有个G标志位，如果G位为1刷新TLB时将不会刷新 PDE/PTE的<br>G位为1的页，当TLB满了，根据统计信息将不常用的地址废弃，最近最常用的保留.</p>
<h3 id="TLB种类"><a href="#TLB种类" class="headerlink" title="TLB种类"></a>TLB种类</h3><p>TLB在X86体系的CPU里的实际应用最早是从Intel的486CPU开始的，在X86体系<br>的CPU里边，一般都设有如下4组TLB:</p>
<ul>
<li>第一组：缓存一般页表（4K字节页面）的指令页表缓存（Instruction-TLB）；</li>
<li>第二组：缓存一般页表（4K字节页面）的数据页表缓存（Data-TLB）；</li>
<li>第三组：缓存大尺寸页表（2M/4M字节页面）的指令页表缓存（Instruction-TLB）；</li>
<li>第四组：缓存大尺寸页表（2M/4M字节页面）的数据页表缓存（Data-TLB）</li>
</ul>
<p><br></p>
<h1 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h1><h2 id="第一个驱动程序"><a href="#第一个驱动程序" class="headerlink" title="第一个驱动程序"></a>第一个驱动程序</h2><h3 id="驱动的开发流程"><a href="#驱动的开发流程" class="headerlink" title="驱动的开发流程"></a>驱动的开发流程</h3><ul>
<li>编写代码        </li>
<li>生成.sys文件        </li>
<li>部署        </li>
<li>启动        </li>
<li>停止        </li>
<li>卸载</li>
</ul>
<h3 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(pDriver);</span><br><span class="line">	KdPrint((<span class="string">"Goodbye~\n"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriver, PUNICODE_STRING pRegPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(pRegPath);</span><br><span class="line"></span><br><span class="line">	pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">	KdPrint((<span class="string">"Hello Driver!\n"</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><ul>
<li>Drvier Settings: TargetOsVersion Windows7  TargetPlatform Desktop</li>
<li>Inf2Cat: Windows Version List 10_${DDKPlatForm}, </li>
<li>C/C++-常规:警告等级 等级3, 将警告视为错误 否</li>
</ul>
<p><br></p>
<h2 id="内核编程基础"><a href="#内核编程基础" class="headerlink" title="内核编程基础"></a>内核编程基础</h2><h3 id="内核API的使用"><a href="#内核API的使用" class="headerlink" title="内核API的使用"></a>内核API的使用</h3><ul>
<li><1> 在应用层编程我们可以使用WINDOWS提供的各种API函数，只要导入头文件<br>&lt;windows.h&gt;就可以了，但是在内核编程的时候，我们不能像在Ring3那样直接使用。微软为内核程序提供了专用的API，只要在程序中包含相应的头文件就可以使用了，如：#include &lt;ntddk.h&gt; (假设你已经正确安装了WDK)</1></li>
<li><2> 在应用层编程的时候，我们通过MSDN来了解函数的详细信息，在内核编程的时候，要使用WDK自己的帮助文档。</2></li>
</ul>
<h3 id="未导出函数的使用"><a href="#未导出函数的使用" class="headerlink" title="未导出函数的使用"></a>未导出函数的使用</h3><p>WDK说明文档中只包含了内核模块导出的函数，对于未导出的函数，则不能直接使用。</p>
<p>如果要使用未导出的函数，只要自己定义一个函数指针，并且为函数指针提供正确的函数地址就可以使用了。有两种办法都可以获取为导出的函数地址：</p>
<ul>
<li><1> 特征码搜索</1></li>
<li><2> 解析内核PDB文件</2></li>
</ul>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><1> 在内核编程的时候，强烈建议大家遵守WDK的编码习惯,不要这样写：</1></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned long length;</span><br></pre></td></tr></table></figure>
<p><2> 习惯使用WDK自己的类型：</2></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ULONG(unsigned long)		PULONG(unsigned long *)</span><br><span class="line"></span><br><span class="line">UCHAR(unsigned char)		PUCHAR(unsigned char *)</span><br><span class="line"></span><br><span class="line">UINT(unsigned int)		PUNIT(unsigned int *)	</span><br><span class="line"></span><br><span class="line">VOID(void)			PVOID(void *)</span><br></pre></td></tr></table></figure>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>大部分内核函数的返回值都是NTSTATUS类型，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS PsCreateSystemThread();    </span><br><span class="line">NTSTATUS ZwOpenProcess();</span><br><span class="line">NTSTATUS ZwOpenEvent();</span><br></pre></td></tr></table></figure>
<p>这个值能说明函数执行的结果，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STATUS_SUCCESS		0x00000000	成功		</span><br><span class="line">STATUS_INVALID_PARAMETER	0xC000000D	参数无效	</span><br><span class="line">STATUS_BUFFER_OVERFLOW	0x80000005	缓冲区长度不够</span><br></pre></td></tr></table></figure>
<p>当你调用的内核函数，如果返回的结果不是STATUS_SUCCESS，就说明函数执行中遇到了问题，具体是什么问题，可以在ntstatus.h文件中查看。</p>
<h3 id="内核中的异常处理"><a href="#内核中的异常处理" class="headerlink" title="内核中的异常处理"></a>内核中的异常处理</h3><p>在内核中，一个小小的错误就可能导致蓝屏，比如：读写一个无效的内存地址。为了让自己的内核程序更加健壮，强烈建议大家在编写内核程序时，使用异常处。<br>Windows提供了结构化异常处理机制，一般的编译器都是支持的，如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__try&#123;</span><br><span class="line">	<span class="comment">//可能出错的代码</span></span><br><span class="line">&#125;</span><br><span class="line">__except(filter_value) &#123;</span><br><span class="line">	<span class="comment">//出错时要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>出现异常时，可根据filter_value的值来决定程序该如果执行，当filter_value的值为：</p>
<ul>
<li>EXCEPTION_EXECUTE_HANDLER(1)，代码进入except块</li>
<li>EXCEPTION_CONTINUE_SEARCH(0)，不处理异常，由上一层调用函数处理</li>
<li>EXCEPTION_CONTINUE_EXECUTION(-1)，回去继续执行错误处的代码</li>
</ul>
<h3 id="常用的内核内存函数"><a href="#常用的内核内存函数" class="headerlink" title="常用的内核内存函数"></a>常用的内核内存函数</h3><p>对内存的使用，主要就是：申请、设置、拷贝以及释放。</p>
<p><img src="/2020/10/13/windows-huoge/image-37.png" width="500px"></p>
<h3 id="内核字符串种类"><a href="#内核字符串种类" class="headerlink" title="内核字符串种类"></a>内核字符串种类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CHAR(<span class="keyword">char</span>)/WCHAR(<span class="keyword">wchar_t</span>)/ANSI_STRING/UNICODE_STRING</span><br><span class="line"></span><br><span class="line">ANSI_STRING字符串：</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PCHAR Buffer;</span><br><span class="line">&#125;STRING;</span><br><span class="line"></span><br><span class="line">UNICODE_STRING字符串：</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaxmumLength;</span><br><span class="line">    PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING</span><br></pre></td></tr></table></figure>
<h3 id="内核字符串常用函数"><a href="#内核字符串常用函数" class="headerlink" title="内核字符串常用函数"></a>内核字符串常用函数</h3><p>字符串常用的功能无非就是：</p>
<p>创建、复制、比较以及转换等等</p>
<p><img src="/2020/10/13/windows-huoge/image-38.png" width="500px"></p>
<p><br></p>
<h2 id="内核空间与内核模块"><a href="#内核空间与内核模块" class="headerlink" title="内核空间与内核模块"></a>内核空间与内核模块</h2><h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><p>内核模块定义全局变量：在不同进程中查看</p>
<p><img src="/2020/10/13/windows-huoge/image-39.png" width="500px"></p>
<h3 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h3><p><img src="/2020/10/13/windows-huoge/image-40.png" width="500px"></p>
<ul>
<li><p><1> 硬件种类繁多，不可能做一个兼容所有硬件的内核，所以，微软提供规定的接口格式，让硬件驱动人员安装规定的格式编写“驱动程序” 。</1></p>
</li>
<li><p><2> 这些驱动程序每一个都是一个模块，称为“内核模块”，都可以加载到内核中，都遵守PE结构。但本质上讲，任意一个.sys文件与内核文件没有区别。</2></p>
</li>
</ul>
<h3 id="DRIVER-OBJECT"><a href="#DRIVER-OBJECT" class="headerlink" title="DRIVER_OBJECT"></a>DRIVER_OBJECT</h3><p>每个内核模块都有一个对应的结构体，来描述这个模块在内核中的：<br>位置、大小、名称等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _DRIVER_OBJECT</span><br><span class="line">nt!_DRIVER_OBJECT</span><br><span class="line">   +0x000 Type             : Int2B</span><br><span class="line">   +0x002 Size             : Int2B</span><br><span class="line">   +0x004 DeviceObject     : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +0x008 Flags            : Uint4B</span><br><span class="line">   +0x00c DriverStart      : Ptr32 Void</span><br><span class="line">   +0x010 DriverSize       : Uint4B</span><br><span class="line">   +0x014 DriverSection    : Ptr32 Void</span><br><span class="line">   +0x018 DriverExtension  : Ptr32 _DRIVER_EXTENSION</span><br><span class="line">   +0x01c DriverName       : _UNICODE_STRING</span><br><span class="line">   .....</span><br></pre></td></tr></table></figure>
<h3 id="打印DRIVER-OBJECT地址"><a href="#打印DRIVER-OBJECT地址" class="headerlink" title="打印DRIVER_OBJECT地址"></a>打印DRIVER_OBJECT地址</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DbgPrint(<span class="string">"DRIVER_OBJECT对象地址：%x \r\n"</span>,driver);</span><br></pre></td></tr></table></figure>
<p>通过DRIVER_OBJECT找到当前模块信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DbgPrint(<span class="string">"驱动名称：%ws \r\n"</span>,driver-&gt;DriverName.Buffer);</span><br><span class="line">DbgPrint(<span class="string">"模块基址：%x \r\n"</span>,driver-&gt;DriverStart	);</span><br><span class="line">DbgPrint(<span class="string">"模块大小：%x \r\n"</span>,driver-&gt;DriverSize	);</span><br></pre></td></tr></table></figure>
<h3 id="遍历内核模块"><a href="#遍历内核模块" class="headerlink" title="遍历内核模块"></a>遍历内核模块</h3><ul>
<li><1> dt _DRIVER_OBJECT  (地址)</1></li>
<li><2> dt _LDR_DATA_TABLE_ENTRY  (DriverSection)</2></li>
<li><3> <code>dt _LDR_DATA_TABLE_ENTRY  (InLoadOrderLinks.Flink)</code></3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _LDR_DATA_TABLE_ENTRY</span><br><span class="line">nt!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +0x000 InLoadOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x008 InMemoryOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x010 InInitializationOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x018 DllBase          : Ptr32 Void</span><br><span class="line">   +0x01c EntryPoint       : Ptr32 Void</span><br><span class="line">   +0x020 SizeOfImage      : Uint4B</span><br><span class="line">   +0x024 FullDllName      : _UNICODE_STRING</span><br><span class="line">   +0x02c BaseDllName      : _UNICODE_STRING</span><br><span class="line">   +0x034 Flags            : Uint4B</span><br><span class="line">   +0x038 LoadCount        : Uint2B</span><br><span class="line">   ....</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="0环与3环通信-常规方式"><a href="#0环与3环通信-常规方式" class="headerlink" title="0环与3环通信(常规方式)"></a>0环与3环通信(常规方式)</h2><h3 id="设备对象"><a href="#设备对象" class="headerlink" title="设备对象"></a>设备对象</h3><p>我们在开发窗口程序的时候，消息被封装成一个结构体：MSG，在内核开发时，消息被封装成另外一个结构体：IRP(I/O Request Package)。</p>
<p>在窗口程序中，能够接收消息的只能是窗口对象。在内核中，能够接收IRP消息的只能是设备对象。</p>
<p><img src="/2020/10/13/windows-huoge/image-41.png" width="500px"></p>
<h3 id="创建设备对象"><a href="#创建设备对象" class="headerlink" title="创建设备对象"></a>创建设备对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建设备名称</span></span><br><span class="line">UNICODE_STRING Devicename;</span><br><span class="line">RtlInitUnicodeString(&amp;Devicename,<span class="string">L"\\Device\\MyDevice"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建设备</span></span><br><span class="line">IoCreateDevice(</span><br><span class="line">	pDriver,				<span class="comment">//当前设备所属的驱动对象</span></span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	&amp;Devicename,			<span class="comment">//设备对象的名称</span></span><br><span class="line">	FILE_DEVICE_UNKNOWN,</span><br><span class="line">	FILE_DEVICE_SECURE_OPEN,</span><br><span class="line">	FALSE,</span><br><span class="line">	&amp;pDeviceObj			<span class="comment">//设备对象指针</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="设置交互数据的方式"><a href="#设置交互数据的方式" class="headerlink" title="设置交互数据的方式"></a>设置交互数据的方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;</span><br></pre></td></tr></table></figure>
<ul>
<li>缓冲区方式读写(DO_BUFFERED_IO) ：操作系统将应用程序提供缓冲区的数据复制到内核模式下的地址中。</li>
<li>直接方式读写(DO_DIRECT_IO)  ：操作系统会将用户模式下的缓冲区锁住。然后操作系统将这段缓冲区在内核模式地址再次映射一遍。这样，用户模式的缓冲区和内核模式的缓冲区指向的是同一区域的物理内存。缺点就是要单独占用物理页面。</li>
<li>其他方式读写(在调用IoCreateDevice创建设备后对pDevObj-&gt;Flags即不设置DO_BUFFERED_IO也不设置DO_DIRECT_IO此时就是其他方式)  ：</li>
</ul>
<p>在使用其他方式读写设备时，派遣函数直接读写应用程序提供的缓冲区地址。在驱动程序中，直接操作应用程序的缓冲区地址是很危险的。只有驱动程序与应用程序运行在相同线程上下文的情况下，才能使用这种方式。  </p>
<h3 id="创建符号链接"><a href="#创建符号链接" class="headerlink" title="创建符号链接"></a>创建符号链接</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建符号链接名称</span></span><br><span class="line">RtlInitUnicodeString(&amp;SymbolicLinkName,<span class="string">L"\\??\\MyTestDriver"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建符号链接</span></span><br><span class="line">IoCreateSymbolicLink(&amp;SymbolicLinkName,&amp;Devicename);</span><br></pre></td></tr></table></figure>
<p>特别说明：</p>
<ul>
<li><p>1、设备名称的作用是给内核对象用的，如果要在Ring3访问，必须要有符号链接<br>其实就是一个别名，没有这个别名，在Ring3不可见。</p>
</li>
<li><p>2、内核模式下，符号链接是以“\??\”开头的，如C 盘就是“\??\C:”</p>
</li>
<li><p>3、而在用户模式下，则是以“\.\”开头的，如C 盘就是“\.\C:</p>
</li>
</ul>
<h3 id="IRP与派遣函数"><a href="#IRP与派遣函数" class="headerlink" title="IRP与派遣函数"></a>IRP与派遣函数</h3><p><img src="/2020/10/13/windows-huoge/image-42.png" width="500px"></p>
<h3 id="IRP的类型"><a href="#IRP的类型" class="headerlink" title="IRP的类型"></a>IRP的类型</h3><ul>
<li><p><1> 当应用层通过CreateFile，ReadFile，WriteFile，CloseHandle等函数打开、从设备读取数据、向设备写入数据、关闭设备的时候，会使操作系统产生出IRP_MJ_CREATE，IRP_MJ_READ，IRP_MJ_WRITE，IRP_MJ_CLOSE等不同的IRP。</1></p>
</li>
<li><p><2> 其他类型的IRP</2></p>
</li>
</ul>
<p><img src="/2020/10/13/windows-huoge/image-43.png" width="500px"></p>
<h3 id="派遣函数在哪里注册呢？"><a href="#派遣函数在哪里注册呢？" class="headerlink" title="派遣函数在哪里注册呢？"></a>派遣函数在哪里注册呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _DRIVER_OBJECT</span><br><span class="line">nt!_DRIVER_OBJECT</span><br><span class="line">   +0x000 Type             : Int2B</span><br><span class="line">   +0x002 Size             : Int2B</span><br><span class="line">   +0x004 DeviceObject     : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +0x008 Flags            : Uint4B</span><br><span class="line">   +0x00c DriverStart      : Ptr32 Void</span><br><span class="line">   +0x010 DriverSize       : Uint4B</span><br><span class="line">....</span><br><span class="line">   +0x030 DriverStartIo    : Ptr32     void </span><br><span class="line">   +0x034 DriverUnload     : Ptr32     void 		//卸载函数</span><br><span class="line">   +0x038 MajorFunction    : [28] Ptr32     long 	//派遣函数</span><br></pre></td></tr></table></figure>
<h3 id="注册派遣函数"><a href="#注册派遣函数" class="headerlink" title="注册派遣函数"></a>注册派遣函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS DriverEntry( 。。。。)  </span><br><span class="line">&#123;  </span><br><span class="line">    //设置卸载函数   </span><br><span class="line">    pDriverObject-&gt;DriverUnload = 卸载函数;  </span><br><span class="line">  </span><br><span class="line">    //设置派遣函数   </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CREATE] 	= 派遣函数1;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] 	= 派遣函数2;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_WRITE] 	= 派遣函数3;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_READ] 	= 派遣函数4;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] 	= 派遣函数5;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SET_INFORMATION] 	= 派遣函数6;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] 	= 派遣函数7;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SHUTDOWN] 		= 派遣函数8;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SYSTEM_CONTROL] 	= 派遣函数9;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">IRP_MJ_MAXIMUM_FUNCTION   派遣函数的最大值</span><br></pre></td></tr></table></figure>
<h3 id="派遣函数的格式"><a href="#派遣函数的格式" class="headerlink" title="派遣函数的格式"></a>派遣函数的格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//派遣函数的格式：</span><br><span class="line"></span><br><span class="line">NTSTATUS MyDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><br><span class="line">&#123;</span><br><span class="line">	//处理自己的业务...</span><br><span class="line"></span><br><span class="line">	//设置返回状态</span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	//  getlasterror()得到的就是这个值</span><br><span class="line">	pIrp-&gt;IoStatus.Information = 0;		//  返回给3环多少数据 没有填0</span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);</span><br><span class="line">	return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过IRP-MJ-DEVICE-CONTROL交互数据"><a href="#通过IRP-MJ-DEVICE-CONTROL交互数据" class="headerlink" title="通过IRP_MJ_DEVICE_CONTROL交互数据"></a>通过IRP_MJ_DEVICE_CONTROL交互数据</h3><p>应用层调用DeviceControl函数会产生此IRP.</p>
<p><br><br><br></p>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>kernal32!ReadProcessMemory -&gt; ntddl!NtReadVirtualMemory -&gt; </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax,0BA</span><br><span class="line">mov edx, 7FFE0300</span><br><span class="line">call dword ptr [edx]</span><br><span class="line">retn 14h</span><br></pre></td></tr></table></figure>
<p><code>7FFE0300</code>地址下的函数位ntddl!KiIntSystemCall函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea edx [esp + arg_4]</span><br><span class="line">int 2e</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>
<p>至此进入idt的中断表, 寻找2e位置的函数偏移地址, 以及刷新<code>cs,ss,eip,esp</code>等信息在Tss存取</p>
<h2 id="3环进0环-上"><a href="#3环进0环-上" class="headerlink" title="3环进0环 上"></a>3环进0环 上</h2><h3 id="KUSER-SHARED-DATA"><a href="#KUSER-SHARED-DATA" class="headerlink" title="_KUSER_SHARED_DATA"></a><code>_KUSER_SHARED_DATA</code></h3><p>1) 在 User 层和 Kernel 层分别定义了一个<code>_KUSER_SHARED_DATA</code>结构区域，用于 User 层和 Kernel 层共享某些数据</p>
<p>2) 它们使用固定的地址值映射，<code>_KUSER_SHARED_DATA</code>结构区域在 User 和 Kernel 层地址分别为：</p>
<p>User 层地址为：0x7ffe0000<br>Kernnel 层地址为：0xffdf0000</p>
<p>特别说明：</p>
<p>虽然指向的是同一个物理页，但在User 层是只读的，在Kernnel层是可写的.</p>
<h3 id="0x7FFE0300到底存储的是什么"><a href="#0x7FFE0300到底存储的是什么" class="headerlink" title="0x7FFE0300到底存储的是什么"></a>0x7FFE0300到底存储的是什么</h3><p>实验：是否支持快速调用</p>
<p>当通过eax=1来执行cpuid指令时，处理器的特征信息被放在ecx和edx寄存器中，其中edx包含了一个SEP位（11位），该位指明了当前处理器知否支持sysenter/sysexit指令</p>
<p>支持：<br>ntdll.dll!KiFastSystemCall()</p>
<p>不支持：<br>ntdll.dll!KiIntSystemCall()</p>
<h3 id="进0环需要更改哪些寄存器？"><a href="#进0环需要更改哪些寄存器？" class="headerlink" title="进0环需要更改哪些寄存器？"></a>进0环需要更改哪些寄存器？</h3><ul>
<li><p>1) CS的权限由3变为0  意味着需要新的CS</p>
</li>
<li><p>2) SS与CS的权限永远一致 需要新的SS</p>
</li>
<li><p>3) 权限发生切换的时候，堆栈也一定会切换，需要新的ESP</p>
</li>
<li><p>4) 进0环后代码的位置，需要EIP</p>
</li>
</ul>
<h3 id="中断门进0环"><a href="#中断门进0环" class="headerlink" title="中断门进0环"></a>中断门进0环</h3><p><img src="/2020/10/13/windows-huoge/image-45.png" width="500px"></p>
<h3 id="快速调用进0环"><a href="#快速调用进0环" class="headerlink" title="快速调用进0环"></a>快速调用进0环</h3><p><img src="/2020/10/13/windows-huoge/image-46.png" width="500px"></p>
<p>为什么叫快速调用？</p>
<p>中断门进0环，需要的CS、EIP在IDT表中，需要查内存(SS与ESP由TSS提供)<br>而CPU如果支持sysenter指令时，操作系统会提前将CS/SS/ESP/EIP的值存储在MSR寄存器中，sysenter指令执行时，CPU会将MSR寄存器中的值直接写入相关<br>寄存器，没有读内存的过程，所以叫快速调用，本质是一样的！</p>
<p><br><br><br></p>
<h2 id="3环进0环-下"><a href="#3环进0环-下" class="headerlink" title="3环进0环 下"></a>3环进0环 下</h2><p>在上一节中讲到了，如果CPU支持sysenter指令，那么API调用时<br>会通过sysenter指令进入0环，如果不支持sysenter指令，通过中断门进0环，默认<br>的中断号：0x2E(IDT表)</p>
<h3 id="INT-0x2E进0环"><a href="#INT-0x2E进0环" class="headerlink" title="INT 0x2E进0环"></a>INT 0x2E进0环</h3><ul>
<li>步骤一：在IDT表中找到0x2E号门描述符</li>
<li>步骤二：分析CS/SS/ESP/EIP的来源</li>
<li>步骤三：分析EIP是什么</li>
</ul>
<h3 id="sysenter进0环"><a href="#sysenter进0环" class="headerlink" title="sysenter进0环"></a>sysenter进0环</h3><p>在执行sysenter指令之前，操作系统必须指定0环的CS段、SS段、EIP以及ESP.</p>
<p><img src="/2020/10/13/windows-huoge/image-47.png" width="500px"></p>
<p>可以通过RDMSR/WRMST来进行读写（操作系统使用WRMST写该寄存器）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; rdmsr 174   //查看CS</span><br><span class="line">kd&gt; rdmsr 175   //查看ESP</span><br><span class="line">kd&gt; rdmsr 176   //查看EIP</span><br></pre></td></tr></table></figure>
<p>参考：Intel白皮书第二卷(搜索sysenter)</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>API通过中断门进0环：</p>
<ul>
<li>1)  固定中断号为0x2E</li>
<li>2)  CS/EIP由门描述符提供   ESP/SS由TSS提供</li>
<li>3)  进入0环后执行的内核函数：NT!KiSystemService</li>
</ul>
<p>API通过sysenter指令进0环：</p>
<ul>
<li>1)  CS/ESP/EIP由MSR寄存器提供(SS是算出来的)</li>
<li>2)  进入0环后执行的内核函数：NT!KiFastCallEntry</li>
</ul>
<p>内核模块：ntoskrnl.exe/ntkrnlpa.exe</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDA pro直接找_IDT, 然后找_IDT的具体偏移位置的函数</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/13/windows-huoge/image-48.png" width="500px"></p>
<p>3环进0环从Tss那边拿了esp0, ss, esp</p>
<p>只要我们3环进0环, 就要把我们的寄存器保存下来, 保存的结构体就是<code>_KTRAP_FRAME</code></p>
<p><br></p>
<h2 id="保存现场"><a href="#保存现场" class="headerlink" title="保存现场"></a>保存现场</h2><p>在上一节中，我们讲到了API进入0环后会调用的函数：                        </p>
<p>KiSystemService 或者 KiFastCallEntry                        </p>
<p>上一节课给大家留的课后作业：                        </p>
<ul>
<li>1) 进0环后，原来的寄存器存在哪里？</li>
<li>2) 如何根据系统服务号(eax中存储)找到要执行的内核函数？                        </li>
<li>3) 调用时参数是存储到3环的堆栈，如何传递给内核函数？                        </li>
<li>4) 2种调用方式是如何返回到3环的？                        </li>
</ul>
<h3 id="Trap-Frame结构"><a href="#Trap-Frame结构" class="headerlink" title="_Trap_Frame结构"></a><code>_Trap_Frame</code>结构</h3><p><img src="/2020/10/13/windows-huoge/image-49.png" width="500px"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTrap_Frame</span><br><span class="line">nt!_KTRAP_FRAME</span><br><span class="line">   +0x000 DbgEbp           : Uint4B</span><br><span class="line">   +0x004 DbgEip           : Uint4B</span><br><span class="line">   +0x008 DbgArgMark       : Uint4B</span><br><span class="line">   +0x00c DbgArgPointer    : Uint4B</span><br><span class="line">   +0x010 TempSegCs        : Uint4B</span><br><span class="line">   +0x014 TempEsp          : Uint4B</span><br><span class="line">   +0x018 Dr0              : Uint4B</span><br><span class="line">   +0x01c Dr1              : Uint4B</span><br><span class="line">   +0x020 Dr2              : Uint4B</span><br><span class="line">   +0x024 Dr3              : Uint4B</span><br><span class="line">   +0x028 Dr6              : Uint4B</span><br><span class="line">   +0x02c Dr7              : Uint4B</span><br><span class="line">   +0x030 SegGs            : Uint4B</span><br><span class="line">   +0x034 SegEs            : Uint4B</span><br><span class="line">   +0x038 SegDs            : Uint4B</span><br><span class="line">   +0x03c Edx              : Uint4B</span><br><span class="line">   +0x040 Ecx              : Uint4B</span><br><span class="line">   +0x044 Eax              : Uint4B</span><br><span class="line">   +0x048 PreviousPreviousMode : Uint4B</span><br><span class="line">   +0x04c ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x050 SegFs            : Uint4B</span><br><span class="line">   +0x054 Edi              : Uint4B</span><br><span class="line">   +0x058 Esi              : Uint4B</span><br><span class="line">   +0x05c Ebx              : Uint4B</span><br><span class="line">   +0x060 Ebp              : Uint4B</span><br><span class="line">   +0x064 ErrCode          : Uint4B</span><br><span class="line">   +0x068 Eip              : Uint4B</span><br><span class="line">   +0x06c SegCs            : Uint4B</span><br><span class="line">   +0x070 EFlags           : Uint4B</span><br><span class="line">   +0x074 HardwareEsp      : Uint4B</span><br><span class="line">   +0x078 HardwareSegSs    : Uint4B</span><br><span class="line">   +0x07c V86Es            : Uint4B</span><br><span class="line">   +0x080 V86Ds            : Uint4B</span><br><span class="line">   +0x084 V86Fs            : Uint4B</span><br><span class="line">   +0x088 V86Gs            : Uint4B</span><br></pre></td></tr></table></figure>
<p>esp0指向了kTrapFrame结构体的<code>+0x078 HardwareSegSs    : Uint4B</code></p>
<p>所以操作系统在3环进0环的时候往这个结构体放入四个值就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+0x068 Eip              : Uint4B</span><br><span class="line">+0x06c SegCs            : Uint4B</span><br><span class="line">+0x070 EFlags           : Uint4B</span><br><span class="line">+0x074 HardwareEsp      : Uint4B</span><br></pre></td></tr></table></figure>
<p>每个线程都有自己的一个TrapFrame, esp0是当前线程0环堆栈的起始位置</p>
<h3 id="KPCR"><a href="#KPCR" class="headerlink" title="KPCR"></a>KPCR</h3><p>每个线程FS段寄存器上3环存储的是TEB, 进入0环就会变成KPCR</p>
<p>KPCR  叫CPU控制区（Processor Control Region）                </p>
<p>CPU也有自己的控制块，每一个CPU有一个，叫KPCR                </p>
<blockquote>
<p>查看当前有几个核 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeNumberProcessors</span><br><span class="line">805548e0  00000001 00000006 00009e0a a0013fff</span><br><span class="line">805548f0  806db4c0 00000000 00000000 0000005d</span><br><span class="line">80554900  8003f118 00000000 00000000 00000000</span><br><span class="line">80554910  00000001 00000000 00000001 00000000</span><br><span class="line">80554920  00000000 00000000 00000000 00000000</span><br><span class="line">80554930  00000000 00000000 00000000 00000000</span><br><span class="line">80554940  00000000 00000000 00000000 00000000</span><br><span class="line">80554950  00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看每个核对应的KPCR是什么</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KiProcessorBlock  L2			</span><br><span class="line">8055b240  ffdff120 00000000</span><br></pre></td></tr></table></figure>
<p>ffdff120 - 120就是KPCR的地址</p>
<blockquote>
<p>查看KPCR是什么</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KPCR</span><br><span class="line">nt!_KPCR</span><br><span class="line">   +0x000 NtTib            : _NT_TIB</span><br><span class="line">   +0x01c SelfPcr          : Ptr32 _KPCR</span><br><span class="line">   +0x020 Prcb             : Ptr32 _KPRCB</span><br><span class="line">   +0x024 Irql             : UChar</span><br><span class="line">   +0x028 IRR              : Uint4B</span><br><span class="line">   +0x02c IrrActive        : Uint4B</span><br><span class="line">   +0x030 IDR              : Uint4B</span><br><span class="line">   +0x034 KdVersionBlock   : Ptr32 Void</span><br><span class="line">   +0x038 IDT              : Ptr32 _KIDTENTRY</span><br><span class="line">   +0x03c GDT              : Ptr32 _KGDTENTRY</span><br><span class="line">   +0x040 TSS              : Ptr32 _KTSS</span><br><span class="line">   +0x044 MajorVersion     : Uint2B</span><br><span class="line">   +0x046 MinorVersion     : Uint2B</span><br><span class="line">   +0x048 SetMember        : Uint4B</span><br><span class="line">   +0x04c StallScaleFactor : Uint4B</span><br><span class="line">   +0x050 DebugActive      : UChar</span><br><span class="line">   +0x051 Number           : UChar</span><br><span class="line">   +0x052 Spare0           : UChar</span><br><span class="line">   +0x053 SecondLevelCacheAssociativity : UChar</span><br><span class="line">   +0x054 VdmAlert         : Uint4B</span><br><span class="line">   +0x058 KernelReserved   : [14] Uint4B</span><br><span class="line">   +0x090 SecondLevelCacheSize : Uint4B</span><br><span class="line">   +0x094 HalReserved      : [16] Uint4B</span><br><span class="line">   +0x0d4 InterruptMode    : Uint4B</span><br><span class="line">   +0x0d8 Spare1           : UChar</span><br><span class="line">   +0x0dc KernelReserved2  : [17] Uint4B</span><br><span class="line">   +0x120 PrcbData         : _KPRCB</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对应的地址KPCR是什么?</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KPCR ffdff000</span><br><span class="line">nt!_KPCR</span><br><span class="line">   +0x000 NtTib            : _NT_TIB</span><br><span class="line">   +0x01c SelfPcr          : 0xffdff000 _KPCR</span><br><span class="line">   +0x020 Prcb             : 0xffdff120 _KPRCB</span><br><span class="line">   +0x024 Irql             : 0 &apos;&apos;</span><br><span class="line">   +0x028 IRR              : 0</span><br><span class="line">   +0x02c IrrActive        : 0</span><br><span class="line">   +0x030 IDR              : 0xffffffff</span><br><span class="line">   +0x034 KdVersionBlock   : 0x8054df38 Void</span><br><span class="line">   +0x038 IDT              : 0x8003f400 _KIDTENTRY</span><br><span class="line">   +0x03c GDT              : 0x8003f000 _KGDTENTRY</span><br><span class="line">   +0x040 TSS              : 0x80042000 _KTSS</span><br><span class="line">   +0x044 MajorVersion     : 1</span><br><span class="line">   +0x046 MinorVersion     : 1</span><br><span class="line">   +0x048 SetMember        : 1</span><br><span class="line">   +0x04c StallScaleFactor : 0x8a0</span><br><span class="line">   +0x050 DebugActive      : 0 &apos;&apos;</span><br><span class="line">   +0x051 Number           : 0 &apos;&apos;</span><br><span class="line">   +0x052 Spare0           : 0 &apos;&apos;</span><br><span class="line">   +0x053 SecondLevelCacheAssociativity : 0 &apos;&apos;</span><br><span class="line">   +0x054 VdmAlert         : 0</span><br><span class="line">   +0x058 KernelReserved   : [14] 0</span><br><span class="line">   +0x090 SecondLevelCacheSize : 0</span><br><span class="line">   +0x094 HalReserved      : [16] 0</span><br><span class="line">   +0x0d4 InterruptMode    : 0</span><br><span class="line">   +0x0d8 Spare1           : 0 &apos;&apos;</span><br><span class="line">   +0x0dc KernelReserved2  : [17] 0</span><br><span class="line">   +0x120 PrcbData         : _KPRCB</span><br></pre></td></tr></table></figure>
<p>ffdff000 其实这个地址想拿到, 更容易的方式就是<br>当进入0环之后, 有<code>mov fx,bx</code>这样的段选择子, 解析出来最后的地址就是<code>0xffdff000</code></p>
<p><img src="/2020/10/13/windows-huoge/image-50.png" width="800px"></p>
<p>接下来的汇编代码, 是保存老的KPCR里面的ExceptionList</p>
<p><img src="/2020/10/13/windows-huoge/image-51.png" width="800px"></p>
<p>KPCR的第一个成员NT_TIB</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _NT_TIB					</span><br><span class="line">ntdll!_NT_TIB					</span><br><span class="line">   +0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD					</span><br><span class="line">   +0x004 StackBase        : Ptr32 Void					</span><br><span class="line">   +0x008 StackLimit       : Ptr32 Void					</span><br><span class="line">   +0x00c SubSystemTib     : Ptr32 Void					</span><br><span class="line">   +0x010 FiberData        : Ptr32 Void					</span><br><span class="line">   +0x010 Version          : Uint4B					</span><br><span class="line">   +0x014 ArbitraryUserPointer : Ptr32 Void					</span><br><span class="line">   +0x018 Self             : Ptr32 _NT_TIB					//结构体指针 指向自己</span><br></pre></td></tr></table></figure>
<p>这个链表是异常处理函数<code>+0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD</code><br>会去遍历这个异常链表, 选出来进行处理</p>
<p>接下来又给esi, 放置了KPCR+124的偏移, 这个为<code>_KTHREAD</code>, 其实这个就是<code>_ETHREAD的结构体</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KPRCB					</span><br><span class="line">ntdll!_KPRCB					</span><br><span class="line">   +0x000 MinorVersion     : Uint2B					</span><br><span class="line">   +0x002 MajorVersion     : Uint2B					</span><br><span class="line">   +0x004 CurrentThread    : Ptr32 _KTHREAD					//当前CPU所执行线程的_ETHREAD</span><br><span class="line">   +0x008 NextThread       : Ptr32 _KTHREAD					//下一个_ETHREAD</span><br><span class="line">   +0x00c IdleThread       : Ptr32 _KTHREAD					//当所以线程都执行完了CPU就可以执行这个</span><br><span class="line">   +0x010 Number           : Char					//CPU编号</span><br><span class="line">   +0x011 Reserved         : Char					</span><br><span class="line">   +0x012 BuildType        : Uint2B					</span><br><span class="line">   +0x014 SetMember        : Uint4B					</span><br><span class="line">   +0x018 CpuType          : Char					</span><br><span class="line">   +0x019 CpuID            : Char					</span><br><span class="line">   +0x01a CpuStep          : Uint2B					//CPU子版本号</span><br><span class="line">   +0x01c ProcessorState   : _KPROCESSOR_STATE					//CPU状态</span><br><span class="line">   +0x33c KernelReserved   : [16] Uint4B					</span><br><span class="line">   +0x37c HalReserved      : [16] Uint4B					</span><br><span class="line">   +0x3bc PrcbPad0         : [92] UChar					</span><br><span class="line">   +0x418 LockQueue        : [16] _KSPIN_LOCK_QUEUE					</span><br><span class="line">   +0x498 PrcbPad1         : [8] UChar					</span><br><span class="line">   +0x4a0 NpxThread        : Ptr32 _KTHREAD					//Npx浮点处理器  最后一次用过浮点的线程</span><br><span class="line">   +0x4a4 InterruptCount   : Uint4B					//中断计数 统计信息 没什么实际意义 自己调试用的</span><br><span class="line">   +0x4a8 KernelTime       : Uint4B					//统计信息</span><br><span class="line">   +0x4ac UserTime         : Uint4B					//统计信息</span><br><span class="line">   +0x4b0 DpcTime          : Uint4B					//统计信息</span><br><span class="line">   +0x4b4 DebugDpcTime     : Uint4B					//统计信息</span><br><span class="line">   +0x4b8 InterruptTime    : Uint4B					//统计信息</span><br><span class="line">   +0x4bc AdjustDpcThreshold : Uint4B					</span><br><span class="line">   +0x4c0 PageColor        : Uint4B					</span><br><span class="line">   +0x4c4 SkipTick         : Uint4B					</span><br><span class="line">   +0x4c8 MultiThreadSetBusy : UChar					</span><br><span class="line">   +0x4c9 Spare2           : [3] UChar					</span><br><span class="line">   +0x4cc ParentNode       : Ptr32 _KNODE					</span><br><span class="line">   +0x4d0 MultiThreadProcessorSet : Uint4B					</span><br><span class="line">   +0x4d4 MultiThreadSetMaster : Ptr32 _KPRCB					</span><br><span class="line">   +0x4d8 ThreadStartCount : [2] Uint4B					</span><br><span class="line">   +0x4e0 CcFastReadNoWait : Uint4B					</span><br><span class="line">   +0x4e4 CcFastReadWait   : Uint4B					</span><br><span class="line">   +0x4e8 CcFastReadNotPossible : Uint4B					</span><br><span class="line">   +0x4ec CcCopyReadNoWait : Uint4B					</span><br><span class="line">   +0x4f0 CcCopyReadWait   : Uint4B					</span><br><span class="line">   +0x4f4 CcCopyReadNoWaitMiss : Uint4B					</span><br><span class="line">   +0x4f8 KeAlignmentFixupCount : Uint4B					</span><br><span class="line">   +0x4fc KeContextSwitches : Uint4B					</span><br><span class="line">   +0x500 KeDcacheFlushCount : Uint4B					</span><br><span class="line">   +0x504 KeExceptionDispatchCount : Uint4B					</span><br><span class="line">   +0x508 KeFirstLevelTbFills : Uint4B					</span><br><span class="line">   +0x50c KeFloatingEmulationCount : Uint4B					</span><br><span class="line">   +0x510 KeIcacheFlushCount : Uint4B					</span><br><span class="line">   +0x514 KeSecondLevelTbFills : Uint4B					</span><br><span class="line">   +0x518 KeSystemCalls    : Uint4B					</span><br><span class="line">   +0x51c SpareCounter0    : [1] Uint4B					</span><br><span class="line">   +0x520 PPLookasideList  : [16] _PP_LOOKASIDE_LIST					</span><br><span class="line">   +0x5a0 PPNPagedLookasideList : [32] _PP_LOOKASIDE_LIST					</span><br><span class="line">   +0x6a0 PPPagedLookasideList : [32] _PP_LOOKASIDE_LIST					</span><br><span class="line">   +0x7a0 PacketBarrier    : Uint4B					</span><br><span class="line">   +0x7a4 ReverseStall     : Uint4B					</span><br><span class="line">   +0x7a8 IpiFrame         : Ptr32 Void					</span><br><span class="line">   +0x7ac PrcbPad2         : [52] UChar					</span><br><span class="line">   +0x7e0 CurrentPacket    : [3] Ptr32 Void					</span><br><span class="line">   +0x7ec TargetSet        : Uint4B					</span><br><span class="line">   +0x7f0 WorkerRoutine    : Ptr32     void 					</span><br><span class="line">   +0x7f4 IpiFrozen        : Uint4B					</span><br><span class="line">   +0x7f8 PrcbPad3         : [40] UChar					</span><br><span class="line">   +0x820 RequestSummary   : Uint4B					</span><br><span class="line">   +0x824 SignalDone       : Ptr32 _KPRCB					</span><br><span class="line">   +0x828 PrcbPad4         : [56] UChar					</span><br><span class="line">   +0x860 DpcListHead      : _LIST_ENTRY					</span><br><span class="line">   +0x868 DpcStack         : Ptr32 Void					</span><br><span class="line">   +0x86c DpcCount         : Uint4B					</span><br><span class="line">   +0x870 DpcQueueDepth    : Uint4B					</span><br><span class="line">   +0x874 DpcRoutineActive : Uint4B					</span><br><span class="line">   +0x878 DpcInterruptRequested : Uint4B					</span><br><span class="line">   +0x87c DpcLastCount     : Uint4B					</span><br><span class="line">   +0x880 DpcRequestRate   : Uint4B					</span><br><span class="line">   +0x884 MaximumDpcQueueDepth : Uint4B					</span><br><span class="line">   +0x888 MinimumDpcRate   : Uint4B					</span><br><span class="line">   +0x88c QuantumEnd       : Uint4B					</span><br><span class="line">   +0x890 PrcbPad5         : [16] UChar					</span><br><span class="line">   +0x8a0 DpcLock          : Uint4B					</span><br><span class="line">   +0x8a4 PrcbPad6         : [28] UChar					</span><br><span class="line">   +0x8c0 CallDpc          : _KDPC					</span><br><span class="line">   +0x8e0 ChainedInterruptList : Ptr32 Void					</span><br><span class="line">   +0x8e4 LookasideIrpFloat : Int4B					</span><br><span class="line">   +0x8e8 SpareFields0     : [6] Uint4B					</span><br><span class="line">   +0x900 VendorString     : [13] UChar					</span><br><span class="line">   +0x90d InitialApicId    : UChar					</span><br><span class="line">   +0x90e LogicalProcessorsPerPhysicalProcessor : UChar//每个物理处理器有几个逻辑处理器					</span><br><span class="line">   +0x910 MHz              : Uint4B//频率 					</span><br><span class="line">   +0x914 FeatureBits      : Uint4B					</span><br><span class="line">   +0x918 UpdateSignature  : _LARGE_INTEGER					</span><br><span class="line">   +0x920 NpxSaveArea      : _FX_SAVE_AREA					</span><br><span class="line">   +0xb30 PowerState       : _PROCESSOR_POWER_STATE</span><br></pre></td></tr></table></figure></p>
<p>接下来又将<code>_ETHREAD</code>的结构体里面偏移<code>push dword ptr [esi+140]</code>保存老的先前模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _EThread</span><br><span class="line">nt!_ETHREAD</span><br><span class="line">   +0x000 Tcb              : _KTHREAD</span><br><span class="line">   +0x1c0 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x1c0 NestedFaultCount : Pos 0, 2 Bits</span><br><span class="line">   +0x1c0 ApcNeeded        : Pos 2, 1 Bit</span><br><span class="line">   +0x1c8 ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +0x1c8 LpcReplyChain    : _LIST_ENTRY</span><br><span class="line">   +0x1c8 KeyedWaitChain   : _LIST_ENTRY</span><br><span class="line">   +0x1d0 ExitStatus       : Int4B</span><br><span class="line">   +0x1d0 OfsChain         : Ptr32 Void</span><br><span class="line">   +0x1d4 PostBlockList    : _LIST_ENTRY</span><br><span class="line">   +0x1dc TerminationPort  : Ptr32 _TERMINATION_PORT</span><br><span class="line">   +0x1dc ReaperLink       : Ptr32 _ETHREAD</span><br><span class="line">   +0x1dc KeyedWaitValue   : Ptr32 Void</span><br><span class="line">   +0x1e0 ActiveTimerListLock : Uint4B</span><br><span class="line">   +0x1e4 ActiveTimerListHead : _LIST_ENTRY</span><br><span class="line">   +0x1ec Cid              : _CLIENT_ID</span><br><span class="line">   +0x1f4 LpcReplySemaphore : _KSEMAPHORE</span><br><span class="line">   +0x1f4 KeyedWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x208 LpcReplyMessage  : Ptr32 Void</span><br><span class="line">   +0x208 LpcWaitingOnPort : Ptr32 Void</span><br><span class="line">   +0x20c ImpersonationInfo : Ptr32 _PS_IMPERSONATION_INFORMATION</span><br><span class="line">   +0x210 IrpList          : _LIST_ENTRY</span><br><span class="line">   +0x218 TopLevelIrp      : Uint4B</span><br><span class="line">   +0x21c DeviceToVerify   : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +0x220 ThreadsProcess   : Ptr32 _EPROCESS</span><br><span class="line">   +0x224 StartAddress     : Ptr32 Void</span><br><span class="line">   +0x228 Win32StartAddress : Ptr32 Void</span><br><span class="line">   +0x228 LpcReceivedMessageId : Uint4B</span><br><span class="line">   +0x22c ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x234 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x238 ThreadLock       : _EX_PUSH_LOCK</span><br><span class="line">   +0x23c LpcReplyMessageId : Uint4B</span><br><span class="line">   +0x240 ReadClusterSize  : Uint4B</span><br><span class="line">   +0x244 GrantedAccess    : Uint4B</span><br><span class="line">   +0x248 CrossThreadFlags : Uint4B</span><br><span class="line">   +0x248 Terminated       : Pos 0, 1 Bit</span><br><span class="line">   +0x248 DeadThread       : Pos 1, 1 Bit</span><br><span class="line">   +0x248 HideFromDebugger : Pos 2, 1 Bit</span><br><span class="line">   +0x248 ActiveImpersonationInfo : Pos 3, 1 Bit</span><br><span class="line">   +0x248 SystemThread     : Pos 4, 1 Bit</span><br><span class="line">   +0x248 HardErrorsAreDisabled : Pos 5, 1 Bit</span><br><span class="line">   +0x248 BreakOnTermination : Pos 6, 1 Bit</span><br><span class="line">   +0x248 SkipCreationMsg  : Pos 7, 1 Bit</span><br><span class="line">   +0x248 SkipTerminationMsg : Pos 8, 1 Bit</span><br><span class="line">   +0x24c SameThreadPassiveFlags : Uint4B</span><br><span class="line">   +0x24c ActiveExWorker   : Pos 0, 1 Bit</span><br><span class="line">   +0x24c ExWorkerCanWaitUser : Pos 1, 1 Bit</span><br><span class="line">   +0x24c MemoryMaker      : Pos 2, 1 Bit</span><br><span class="line">   +0x250 SameThreadApcFlags : Uint4B</span><br><span class="line">   +0x250 LpcReceivedMsgIdValid : Pos 0, 1 Bit</span><br><span class="line">   +0x250 LpcExitThreadCalled : Pos 1, 1 Bit</span><br><span class="line">   +0x250 AddressSpaceOwner : Pos 2, 1 Bit</span><br><span class="line">   +0x254 ForwardClusterOnly : UChar</span><br><span class="line">   +0x255 DisablePageFaultClustering : UChar</span><br><span class="line">   +0x258 KernelStackReference : Uint4B</span><br></pre></td></tr></table></figure>
<p>从第一个结构溯源到<code>_KTHREAD</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">nt!_KTHREAD</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER</span><br><span class="line">   +0x010 MutantListHead   : _LIST_ENTRY</span><br><span class="line">   +0x018 InitialStack     : Ptr32 Void</span><br><span class="line">   +0x01c StackLimit       : Ptr32 Void</span><br><span class="line">   +0x020 Teb              : Ptr32 Void</span><br><span class="line">   +0x024 TlsArray         : Ptr32 Void</span><br><span class="line">   +0x028 KernelStack      : Ptr32 Void</span><br><span class="line">   +0x02c DebugActive      : UChar</span><br><span class="line">   +0x02d State            : UChar</span><br><span class="line">   +0x02e Alerted          : [2] UChar</span><br><span class="line">   +0x030 Iopl             : UChar</span><br><span class="line">   +0x031 NpxState         : UChar</span><br><span class="line">   +0x032 Saturation       : Char</span><br><span class="line">   +0x033 Priority         : Char</span><br><span class="line">   +0x034 ApcState         : _KAPC_STATE</span><br><span class="line">   +0x04c ContextSwitches  : Uint4B</span><br><span class="line">   +0x050 IdleSwapBlock    : UChar</span><br><span class="line">   +0x051 VdmSafe          : UChar</span><br><span class="line">   +0x052 Spare0           : [2] UChar</span><br><span class="line">   +0x054 WaitStatus       : Int4B</span><br><span class="line">   +0x058 WaitIrql         : UChar</span><br><span class="line">   +0x059 WaitMode         : Char</span><br><span class="line">   +0x05a WaitNext         : UChar</span><br><span class="line">   +0x05b WaitReason       : UChar</span><br><span class="line">   +0x05c WaitBlockList    : Ptr32 _KWAIT_BLOCK</span><br><span class="line">   +0x060 WaitListEntry    : _LIST_ENTRY</span><br><span class="line">   +0x060 SwapListEntry    : _SINGLE_LIST_ENTRY</span><br><span class="line">   +0x068 WaitTime         : Uint4B</span><br><span class="line">   +0x06c BasePriority     : Char</span><br><span class="line">   +0x06d DecrementCount   : UChar</span><br><span class="line">   +0x06e PriorityDecrement : Char</span><br><span class="line">   +0x06f Quantum          : Char</span><br><span class="line">   +0x070 WaitBlock        : [4] _KWAIT_BLOCK</span><br><span class="line">   +0x0d0 LegoData         : Ptr32 Void</span><br><span class="line">   +0x0d4 KernelApcDisable : Uint4B</span><br><span class="line">   +0x0d8 UserAffinity     : Uint4B</span><br><span class="line">   +0x0dc SystemAffinityActive : UChar</span><br><span class="line">   +0x0dd PowerState       : UChar</span><br><span class="line">   +0x0de NpxIrql          : UChar</span><br><span class="line">   +0x0df InitialNode      : UChar</span><br><span class="line">   +0x0e0 ServiceTable     : Ptr32 Void</span><br><span class="line">   +0x0e4 Queue            : Ptr32 _KQUEUE</span><br><span class="line">   +0x0e8 ApcQueueLock     : Uint4B</span><br><span class="line">   +0x0f0 Timer            : _KTIMER</span><br><span class="line">   +0x118 QueueListEntry   : _LIST_ENTRY</span><br><span class="line">   +0x120 SoftAffinity     : Uint4B</span><br><span class="line">   +0x124 Affinity         : Uint4B</span><br><span class="line">   +0x128 Preempted        : UChar</span><br><span class="line">   +0x129 ProcessReadyQueue : UChar</span><br><span class="line">   +0x12a KernelStackResident : UChar</span><br><span class="line">   +0x12b NextProcessor    : UChar</span><br><span class="line">   +0x12c CallbackStack    : Ptr32 Void</span><br><span class="line">   +0x130 Win32Thread      : Ptr32 Void</span><br><span class="line">   +0x134 TrapFrame        : Ptr32 _KTRAP_FRAME</span><br><span class="line">   +0x138 ApcStatePointer  : [2] Ptr32 _KAPC_STATE</span><br><span class="line">   +0x140 PreviousMode     : Char</span><br><span class="line">   +0x141 EnableStackSwap  : UChar</span><br><span class="line">   +0x142 LargeStack       : UChar</span><br><span class="line">   +0x143 ResourceIndex    : UChar</span><br><span class="line">   +0x144 KernelTime       : Uint4B</span><br><span class="line">   +0x148 UserTime         : Uint4B</span><br><span class="line">   +0x14c SavedApcState    : _KAPC_STATE</span><br><span class="line">   +0x164 Alertable        : UChar</span><br><span class="line">   +0x165 ApcStateIndex    : UChar</span><br><span class="line">   +0x166 ApcQueueable     : UChar</span><br><span class="line">   +0x167 AutoAlignment    : UChar</span><br><span class="line">   +0x168 StackBase        : Ptr32 Void</span><br><span class="line">   +0x16c SuspendApc       : _KAPC</span><br><span class="line">   +0x19c SuspendSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x1b0 ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x1b8 FreezeCount      : Char</span><br><span class="line">   +0x1b9 SuspendCount     : Char</span><br><span class="line">   +0x1ba IdealProcessor   : UChar</span><br><span class="line">   +0x1bb DisableBoost     : UChar</span><br></pre></td></tr></table></figure>
<p>最后溯源到了PreviouseModel, 这个有什么功能和意义呢? </p>
<p>这个叫先前模式, 0环的程序可能是0环或者3环直接调用的, 但是0环和3环调用的实现功能是不一样的, 所以记录一下先前是什么模式的</p>
<p>接下来继续分析汇编代码, <code>sub esp, 48</code>, -48等于堆栈上清到<code>KTrap_Frame</code>最上面</p>
<p>继续回到<code>KTrap_Frame</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTrap_Frame</span><br><span class="line">nt!_KTRAP_FRAME</span><br><span class="line">   +0x000 DbgEbp           : Uint4B</span><br><span class="line">   +0x004 DbgEip           : Uint4B</span><br><span class="line">   +0x008 DbgArgMark       : Uint4B</span><br><span class="line">   +0x00c DbgArgPointer    : Uint4B</span><br><span class="line">   +0x010 TempSegCs        : Uint4B</span><br><span class="line">   +0x014 TempEsp          : Uint4B</span><br><span class="line">   +0x018 Dr0              : Uint4B</span><br><span class="line">   +0x01c Dr1              : Uint4B</span><br><span class="line">   +0x020 Dr2              : Uint4B</span><br><span class="line">   +0x024 Dr3              : Uint4B</span><br><span class="line">   +0x028 Dr6              : Uint4B</span><br><span class="line">   +0x02c Dr7              : Uint4B</span><br><span class="line">   +0x030 SegGs            : Uint4B</span><br><span class="line">   +0x034 SegEs            : Uint4B</span><br><span class="line">   +0x038 SegDs            : Uint4B</span><br><span class="line">   +0x03c Edx              : Uint4B</span><br><span class="line">   +0x040 Ecx              : Uint4B</span><br><span class="line">   +0x044 Eax              : Uint4B</span><br><span class="line">   +0x048 PreviousPreviousMode : Uint4B</span><br><span class="line">   +0x04c ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x050 SegFs            : Uint4B</span><br><span class="line">   +0x054 Edi              : Uint4B</span><br><span class="line">   +0x058 Esi              : Uint4B</span><br><span class="line">   +0x05c Ebx              : Uint4B</span><br><span class="line">   +0x060 Ebp              : Uint4B</span><br><span class="line">   +0x064 ErrCode          : Uint4B</span><br><span class="line">   +0x068 Eip              : Uint4B</span><br><span class="line">   +0x06c SegCs            : Uint4B</span><br><span class="line">   +0x070 EFlags           : Uint4B</span><br><span class="line">   +0x074 HardwareEsp      : Uint4B</span><br><span class="line">   +0x078 HardwareSegSs    : Uint4B</span><br><span class="line">   +0x07c V86Es            : Uint4B</span><br><span class="line">   +0x080 V86Ds            : Uint4B</span><br><span class="line">   +0x084 V86Fs            : Uint4B</span><br><span class="line">   +0x088 V86Gs            : Uint4B</span><br></pre></td></tr></table></figure>
<p>这样esp就指向了TrapFrame的头部了</p>
<p><img src="/2020/10/13/windows-huoge/image-52.png" width="800px"></p>
<p><br></p>
<h2 id="系统服务表"><a href="#系统服务表" class="headerlink" title="系统服务表"></a>系统服务表</h2><p>在上一节中，讲到进0环后，3环的各种寄存器都会保留到<br><code>_Trap_Frame</code>结构体中，这节我们来讲解：</p>
<p>如何根据系统服务号(eax中存储)找到要执行的内核函数？<br>调用时参数是存储到3环的堆栈，如何传递给内核函数？<br>eax, edx 这两个分别存储调用服务的编号, 以及调用的esp堆栈指针</p>
<h3 id="SystemServiceTable-系统服务表"><a href="#SystemServiceTable-系统服务表" class="headerlink" title="SystemServiceTable 系统服务表"></a>SystemServiceTable 系统服务表</h3><p><img src="/2020/10/13/windows-huoge/image-53.png" width="500px"></p>
<h3 id="SystemServiceTable-系统服务表在哪"><a href="#SystemServiceTable-系统服务表在哪" class="headerlink" title="SystemServiceTable 系统服务表在哪"></a>SystemServiceTable 系统服务表在哪</h3><p><img src="/2020/10/13/windows-huoge/image-54.png" width="500px"></p>
<h3 id="判断要调用的函数在哪个表"><a href="#判断要调用的函数在哪个表" class="headerlink" title="判断要调用的函数在哪个表"></a>判断要调用的函数在哪个表</h3><p><img src="/2020/10/13/windows-huoge/image-55.png" width="500px"></p>
<h3 id="找到要执行的函数与参数个数"><a href="#找到要执行的函数与参数个数" class="headerlink" title="找到要执行的函数与参数个数"></a>找到要执行的函数与参数个数</h3><p><img src="/2020/10/13/windows-huoge/image-56.png" width="500px"></p>
<p><br></p>
<h2 id="SSDT-API函数的调用过程"><a href="#SSDT-API函数的调用过程" class="headerlink" title="SSDT(API函数的调用过程)"></a>SSDT(API函数的调用过程)</h2><p>在上一节课中，我们讲到系统服务表的结构，以及如何找到系统服务<br>表(KTHREAD  0xE0偏移).<br>这一节课，我们通过其他方式来访问系统服务表.</p>
<h3 id="SystemServiceTable-系统服务表-1"><a href="#SystemServiceTable-系统服务表-1" class="headerlink" title="SystemServiceTable 系统服务表"></a>SystemServiceTable 系统服务表</h3><p><img src="/2020/10/13/windows-huoge/image-53.png" width="500px"></p>
<h3 id="如何访问系统服务表"><a href="#如何访问系统服务表" class="headerlink" title="如何访问系统服务表"></a>如何访问系统服务表</h3><p>SSDT  的全称是 System Services Descriptor Table，系统服务描述符表</p>
<p><code>kd&gt; dd  KeServiceDescriptorTable(SSDT)</code><br>导出的 声明一下就可以使用了</p>
<p><code>kd&gt; dd  KeServiceDescriptorTableShadow(SSDT Shadow)</code><br>未导出 需要用其他的方式来查找</p>
<p><br><br><br></p>
<h1 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h1><p><img src="/2020/10/13/windows-huoge/image-98.png" width="800px"></p>
<p>Ps开头的都是执行体函数<br>Ke(导出函数)、Ki(未导出函数)开头的都是内核函数 </p>
<p><img src=""></p>
<h2 id="进程结构体EPROCESS"><a href="#进程结构体EPROCESS" class="headerlink" title="进程结构体EPROCESS"></a>进程结构体EPROCESS</h2><p>从这一节开始学习进程、线程相关的知识。</p>
<p>进程线程的知识点很多，如果我们想了解问题的本质，就要从一些关键的结构体学起，这节课的内容是介绍一个与进程密切相关的结构体：</p>
<p><code>EPROCESS</code></p>
<h3 id="进程结构体EPROCESS-1"><a href="#进程结构体EPROCESS-1" class="headerlink" title="进程结构体EPROCESS"></a>进程结构体EPROCESS</h3><p>每个windows进程在0环都有一个对应的结构体：EPROCESS  这个结构体包含了进程所有重要的信息。<br>(在winbbg中查看EPROCESS结构体)</p>
<h3 id="KPROCESS主要成员介绍"><a href="#KPROCESS主要成员介绍" class="headerlink" title="KPROCESS主要成员介绍"></a>KPROCESS主要成员介绍</h3><ul>
<li><p>1)    +0x000 Header           : <code>_DISPATCHER_HEADER</code><br>“可等待”对象，比如Mutex互斥体、Event事件等（WaitForSingleObject）</p>
</li>
<li><p>2)    +0x018 DirectoryTableBase : [2] Uint4B<br>页目录表的基址</p>
</li>
<li><p>3)    +0x020 LdtDescriptor    : <code>_KGDTENTRY</code>    </p>
<pre><code>+0x028 Int21Descriptor  : `_KIDTENTRY`
</code></pre><p>历史遗留，16位Windows 段选择子不够 每个进程都有一个LDT表<br>Int21Descriptor  是 DOS下要用的</p>
</li>
<li><p>4)    +0x038 KernelTime       : Uint4B, +0x03c UserTime         : Uint4B<br>统计信息 记录了一个进程在内核模式/用户模式下所花的时间</p>
</li>
<li><p>5)       +0x05c Affinity         : Uint4B<br>规定进程里面的所有线程能在哪个CPU上跑,如果值为1，那这个进程的所以线程只能在0号CPU上跑(00000001)<br>如果值为3，那这个进程的所以线程能在0、1号CPU上跑(000000011)<br>如果值为4，那这个进程的所以线程能在2号CPU上跑(000000100)<br>如果值为5，那这个进程的所以线程能在0，2号CPU上跑(000000101)<br>4个字节共32位  所以最多32核 Windows64位 就64核<br>如果只有一个CPU 把这个设置为4 那么这个进程就死了</p>
</li>
<li><p>6)       +0x062 BasePriority     : Char<br>基础优先级或最低优先级 该进程中的所有线程最起码的优先级.    </p>
</li>
</ul>
<h3 id="EPROCESS其他成员"><a href="#EPROCESS其他成员" class="headerlink" title="EPROCESS其他成员"></a>EPROCESS其他成员</h3><ul>
<li>1)    +0x070 CreateTime       : <code>_LARGE_INTEGER</code>            +0x078 ExitTime         :<code>_LARGE_INTEGER</code><br>进程的创建/退出时间</li>
<li>2)    +0x084 UniqueProcessId  : Ptr32 Void<br>进程的编号 任务管理器中的PID</li>
<li>3)    +0x088 ActiveProcessLinks : <code>_LIST_ENTRY</code><br>双向链表 所有的活动进程都连接在一起，构成了一个链表<br>PsActiveProcessHead指向全局链表头</li>
</ul>
<p><img src="/2020/10/13/windows-huoge/image-57.png" width="700px"></p>
<ul>
<li><p>4)    +0x090 QuotaUsage       : [3] Uint4B                +0x09c QuotaPeak        : [3] Uint4B<br>物理页相关的统计信息</p>
</li>
<li><p>5)    +0x0a8 CommitCharge     : Uint4B                </p>
<pre><code>+0x0ac PeakVirtualSize  : Uint4B                
+0x0b0 VirtualSize      : Uint4B
</code></pre><p>虚拟内存相关的统计信息</p>
</li>
<li><p>6)    +0x11c VadRoot          : Ptr32 Void<br>标识0-2G哪些地址没占用了</p>
</li>
<li><p>7)    +0x0bc DebugPort        : Ptr32 Void<br>  +0x0c0 ExceptionPort    : Ptr32 Void<br>调试相关</p>
</li>
<li><p>8)    +0x0c4 ObjectTable      : Ptr32 <code>_HANDLE_TABLE</code><br>句柄表</p>
</li>
<li><p>9)    +0x174 ImageFileName    : [16] UChar<br>进程镜像文件名 最多16个字节</p>
</li>
<li><p>10)    +0x1a0 ActiveThreads    : Uint4B<br>活动线程的数量</p>
</li>
<li><p>11)    +0x1b0 Peb              : Ptr32 <code>_PEB</code><br>PEB((Process Environment Block 进程环境块)：进程在3环的一个结构体，里面包含了进程的模块列表、是否处于调试状态等信息。</p>
</li>
</ul>
<p>关于PEB或者其他成员更加详细的说明：<br>参考 潘爱民老师《Windows内核原理与实现》 中的第3章</p>
<p><br><br><br></p>
<h2 id="线程结构体ETHREAD"><a href="#线程结构体ETHREAD" class="headerlink" title="线程结构体ETHREAD"></a>线程结构体ETHREAD</h2><h3 id="线程结构体ETHREAD-1"><a href="#线程结构体ETHREAD-1" class="headerlink" title="线程结构体ETHREAD"></a>线程结构体ETHREAD</h3><p>每个windows线程在0环都有一个对应的结构体：ETHREAD  这个结构体包含了线程所有重要的信息。</p>
<p>(在winbbg中查看ETHREAD结构体)</p>
<h3 id="KTHREAD主要成员介绍"><a href="#KTHREAD主要成员介绍" class="headerlink" title="KTHREAD主要成员介绍"></a>KTHREAD主要成员介绍</h3><ul>
<li><p>1)    +0x000 Header           : <code>_DISPATCHER_HEADER</code><br>“可等待”对象，比如Mutex互斥体、Event事件等（WaitForSingleObject）</p>
</li>
<li><p>2)    +0x018 InitialStack     : Ptr32 Void</p>
<pre><code>   +0x01c StackLimit       : Ptr32 Void
+0x028 KernelStack      : Ptr32 Void
</code></pre><p>线程切换相关(其中KernelStack是操作系统用这个值, 填充到了Tss的esp0,这样的情况下CPU切换线程就能直接拿到这个ESP0)<br>当然线程切走的时候, 操作系统又会把esp0填充到kernelStack上去</p>
</li>
<li>3)    +0x020 Teb              : Ptr32 Void<br>TEB，Thread Environment Block，线程环境块。<br>大小4KB,位于用户地址空间。<br>FS:[0] -&gt; TEB(3环时  0环时FS执行KPCR)</li>
<li>4)    +0x02c DebugActive      : UChar<br>如果值为-1 不能使用调试寄存器：Dr0 - Dr7</li>
<li>5)    +0x034 ApcState         : <code>_KAPC_STATE</code><pre><code>   +0x0e8 ApcQueueLock     : Uint4B
+0x138 ApcStatePointer  : [2] Ptr32 `_KAPC_STATE`
+0x14c SavedApcState    : `_KAPC_STATE`
</code></pre>APC相关 </li>
<li>6)    +0x02d State            : UChar<br>线程状态：就绪、等待还是运行</li>
<li>7)    +0x06c BasePriority     : Char<br>其初始值是所属进程的BasePriority值(KPROCESS-&gt;BasePriority)，以后可以通过KeSetBasePriorityThread()函数重新设定</li>
<li>8)    +0x070 WaitBlock        : [4] <code>_KWAIT_BLOCK</code><br>等待哪个对象（WaitForSingleObject）</li>
<li>9)    +0x0e0 ServiceTable     : Ptr32 Void<br>指向系统服务表基址</li>
<li>10)    +0x134 TrapFrame<br>进0环时保存环境</li>
<li>11)    +0x140 PreviousMode     : Char<br>某些内核函数会判断程序是0环调用还是3环调用的</li>
<li>12)    +0x1b0 ThreadListEntry  : <code>_LIST_ENTRY</code><br>双向链表 一个进程所有的线程 都挂在一个链表中 挂的就是这个位置<br>一共有两个这样的链表</li>
</ul>
<h3 id="ETHREAD其他成员介绍"><a href="#ETHREAD其他成员介绍" class="headerlink" title="ETHREAD其他成员介绍"></a>ETHREAD其他成员介绍</h3><ul>
<li>1)    +0x1ec Cid              : <code>_CLIENT_ID</code><br>进程ID、线程ID</li>
<li>2)    +0x220 ThreadsProcess   : Ptr32 <code>_EPROCESS</code><br>指向自己所属进程</li>
<li>3)    +0x22c ThreadListEntry  : <code>_LIST_ENTRY</code><br>双向链表 一个进程所有的线程 都挂在一个链表中 挂的就是这个位置<br>一共有两个这样的链表</li>
</ul>
<p><img src="/2020/10/13/windows-huoge/image-58.png" width="700px"></p>
<p><br></p>
<h2 id="KPCR-CPU控制区-Processor-Control-Region"><a href="#KPCR-CPU控制区-Processor-Control-Region" class="headerlink" title="KPCR(CPU控制区(Processor Control Region))"></a>KPCR(CPU控制区(Processor Control Region))</h2><p>进程在内核中对应结构体：EPROCESS<br>线程在内核中对应结构体：ETHREAD<br>CPU在内核中也有一个对应的结构体：KPCR</p>
<h3 id="KPCR介绍"><a href="#KPCR介绍" class="headerlink" title="KPCR介绍"></a>KPCR介绍</h3><ul>
<li>1) 当线程进入0环时，FS:[0]指向KPCR(3环时FS:[0] -&gt; TEB)</li>
<li>2) 每个CPU都有一个KPCR结构体(一个核一个)</li>
<li>3) KPCR中存储了CPU本身要用的一些重要数据：GDT、IDT以及线程相关的一些信息。<br>(在winbbg中查看KPCR结构体)</li>
</ul>
<h3 id="NT-TIB主要成员介绍"><a href="#NT-TIB主要成员介绍" class="headerlink" title="_NT_TIB主要成员介绍"></a><code>_NT_TIB</code>主要成员介绍</h3><ul>
<li>1)    +0x000 ExceptionList    : Ptr32_EXCEPTION_REGISTRATION_RECORD<br>当前线程内核异常链表(SEH)</li>
<li>2)    +0x004 StackBase        : Ptr32 Void<pre><code>+0x008 StackLimit       : Ptr32 Void
</code></pre>当前线程内核栈的基址和大小</li>
<li>3)    +0x018 Self             : Ptr32 <code>_NT_TIB</code><br>指向自己(也就是指向KPCR结构) 这样设计的目的是为了查找方便.</li>
</ul>
<h3 id="KPCR的其他成员介绍"><a href="#KPCR的其他成员介绍" class="headerlink" title="KPCR的其他成员介绍"></a>KPCR的其他成员介绍</h3><ul>
<li>1)    +0x01c SelfPcr          : Ptr32 <code>_KPCR</code><br>指向自己，方便寻址         </li>
<li>2)    +0x020 Prcb             : Ptr32 <code>_KPRCB</code><br>指向拓展结构体PRCB  </li>
<li>3)    +0x038 IDT              : Ptr32 <code>_KIDTENTRY</code><br>IDT表基址</li>
<li>4)    +0x03c GDT              : Ptr32 <code>_KGDTENTRY</code><br>GDT表基址</li>
</ul>
<h3 id="PRCB成员介绍"><a href="#PRCB成员介绍" class="headerlink" title="PRCB成员介绍"></a>PRCB成员介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+0x004 CurrentThread    : Ptr32 _KTHREAD</span><br><span class="line">+0x008 NextThread       : Ptr32 _KTHREAD</span><br><span class="line">+0x00c IdleThread       : Ptr32 _KTHREAD</span><br></pre></td></tr></table></figure>
<p>当前线程<br>即将切换的下一个线程<br>空闲线程          </p>
<h3 id="特别强调"><a href="#特别强调" class="headerlink" title="特别强调"></a>特别强调</h3><p>我们课程里面讲解的内容，与《内核情景分析》《Windows内核原理与实现》均有不同。<br>ReactOS是开源免费的Windows NT系列(含NT4.0/2000/XP/2003)克隆操作系统<br>WRK 是微软针对教育和学术界开放的 Windows 内核的部分源码<br>而我们的课程是基于Windows XP SP2/SP3 二进制文件.<br>微软并不开源，很多内核成员的作用需要自己去分析.    </p>
<p><br></p>
<h2 id="等待链表-调度链表"><a href="#等待链表-调度链表" class="headerlink" title="等待链表/调度链表"></a>等待链表/调度链表</h2><p>内容回顾<br>进程结构体EPROCESS(0x50和0x190)是2个链表，里面圈着当前进程所有的线程。<br>对进程断链，程序可以正常运行，原因是CPU执行与调度是基于线程的，进程断链只是影响一些遍历系统进程的API，并不会影响程序执行。<br>对线程断链也是一样的，断链后在Windbg或者OD中无法看到被断掉的线程，但并不影响其执行(仍然再跑)。</p>
<p><img src="/2020/10/13/windows-huoge/image-59.png" width="700px"></p>
<h3 id="33个链表"><a href="#33个链表" class="headerlink" title="33个链表"></a>33个链表</h3><p>线程有3种状态：就绪、等待、运行</p>
<p>正在运行中的线程存储在KPCR中，就绪和等待的线程全在另外的33个链表中。<br>一个等待链表，32个就绪链表：<br>这些链表都使用了_KTHREAD(0x060)这个位置，也就是说，线程在某一时刻，只能属于其中一个圈。</p>
<h3 id="等待链表"><a href="#等待链表" class="headerlink" title="等待链表"></a>等待链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KiWaitListHead</span><br></pre></td></tr></table></figure>
<p>比如：线程调用了Sleep() 或者 WaitForSingleObject()或者SuspendThread()等函数时，就挂到这个链表(查看等待线程)</p>
<h3 id="调度链表"><a href="#调度链表" class="headerlink" title="调度链表"></a>调度链表</h3><p>调度链表有32个圈，就是优先级:0 - 31  0最低  31最高  默认优先级一般是8<br>改变优先级就是从一个圈里面卸下来挂到另外一个圈上<br>这32个圈是正在调度中的线程：包括正在运行的和准备运行的</p>
<p>比如：只有一个CPU但有10个线程在运行，那么某一时刻，正在运行的线程在KPCR中，其他9个在这32个圈中。</p>
<h3 id="查看调度链表"><a href="#查看调度链表" class="headerlink" title="查看调度链表"></a>查看调度链表</h3><p>既然有32个链表，就要有32个链表头。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KiDispatcherReadyListHead L70</span><br></pre></td></tr></table></figure></p>
<h3 id="版本差异"><a href="#版本差异" class="headerlink" title="版本差异"></a>版本差异</h3><p>XP只有一个33个圈，也就是说上面这个数组只有一个，多核也只有一个.<br>Win7也是一样的只有一个圈，如果是64位的，那就有64个圈.</p>
<p>服务器版本：<br><code>KiWaitListHead整个系统只有一个，但KiDispatcherReadyListHead这个数组有几个CPU就有几组</code></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>1、正在运行的线程在KPCR中</li>
<li>2、准备运行的线程在32个调度链表中(0 - 31级)，KiDispatcherReadyListHead 是个数组存储了这32个链表头.</li>
<li>3、等待状态的线程存储在等待链表中，KiWaitListHead存储链表头.</li>
<li>4、这些圈都挂一个相同的位置：<code>_KTHREAD(0x060)</code></li>
</ul>
<p><br></p>
<h2 id="模拟线程切换"><a href="#模拟线程切换" class="headerlink" title="模拟线程切换"></a>模拟线程切换</h2><p>内容回顾<br>在之前课程里面讲到了线程的等待链表和调度链表<br>这节课我们开始学习Windows的线程切换，线程切换比较复杂<br>为了更好的学习，我们要先读一份代码：<br>模拟Windows线程切换(ThreadSwitch)    </p>
<h3 id="关键结构体"><a href="#关键结构体" class="headerlink" title="关键结构体"></a>关键结构体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//线程结构体(仿EHREAD)</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	char *name;			//线程名 相当于线程TID</span><br><span class="line">	int Flags;			//线程状态</span><br><span class="line">	int SleepMillisecondDot;		//休眠时间</span><br><span class="line">	</span><br><span class="line">	void *InitialStack;			//线程堆栈起始位置</span><br><span class="line">	void *StackLimit;			//线程堆栈界限</span><br><span class="line">	void *KernelStack;		//线程堆栈当前位置,也就是ESP</span><br><span class="line">	</span><br><span class="line">	void *lpParameter;		//线程函数的参数</span><br><span class="line">	void (*func)(void *lpParameter);	//线程函数</span><br><span class="line">	</span><br><span class="line">&#125; GMThread_t;</span><br></pre></td></tr></table></figure>
<h3 id="调度链表-1"><a href="#调度链表-1" class="headerlink" title="调度链表"></a>调度链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//线程结构体数组</span><br><span class="line">extern GMThread_t GMThreadList[MAXGMTHREAD];</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/13/windows-huoge/image-61.png" width="700px"></p>
<h3 id="初始化线程堆栈"><a href="#初始化线程堆栈" class="headerlink" title="初始化线程堆栈"></a>初始化线程堆栈</h3><p><img src="/2020/10/13/windows-huoge/image-62.png" width="700px"></p>
<h3 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h3><p><img src="/2020/10/13/windows-huoge/image-63.png" width="700px"></p>
<h3 id="模拟线程切换总结："><a href="#模拟线程切换总结：" class="headerlink" title="模拟线程切换总结："></a>模拟线程切换总结：</h3><ul>
<li>1)  线程不是被动切换的，而是主动让出CPU.</li>
<li>2)  线程切换并没有使用TSS来保存寄存器，而是使用堆栈.</li>
<li>3)  线程切换的过程就是堆栈切换的过程.</li>
</ul>
<p><br></p>
<h2 id="Windows线程切换-主动切换"><a href="#Windows线程切换-主动切换" class="headerlink" title="Windows线程切换_主动切换"></a>Windows线程切换_主动切换</h2><p>在之前课程里面讲到了模拟Windows线程切换(ThreadSwitch)<br>在这个项目里面我们介绍了一个重要的函数：SwitchContext只有调用这个函数，就会导致线程切换<br>Windows也有类似的函数：KiSwapContext</p>
<h3 id="KiSwapContext函数"><a href="#KiSwapContext函数" class="headerlink" title="KiSwapContext函数"></a>KiSwapContext函数</h3><p><img src="/2020/10/13/windows-huoge/image-64.png" width="700px"></p>
<h3 id="SwapContext函数"><a href="#SwapContext函数" class="headerlink" title="SwapContext函数"></a>SwapContext函数</h3><p>关键函数</p>
<p><img src="/2020/10/13/windows-huoge/image-65.png" width="700px"></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>1) Windows中绝大部分API都调用了SwapContext函数, 也就是说，当线程只要调用了API，就是导致线程切换。</li>
<li>2) 线程切换时会比较是否属于同一个进程，如果不是，切换Cr3,Cr3换了，进程也就切换了。</li>
</ul>
<p>如果不调用API，就可以一直占用CPU吗？</p>
<p><br></p>
<h2 id="Windows线程切换-时钟中断切换"><a href="#Windows线程切换-时钟中断切换" class="headerlink" title="Windows线程切换_时钟中断切换"></a>Windows线程切换_时钟中断切换</h2><p>在上一节中我们讲过了，绝大部分系统内核函数都会调用SwapContext<br>函数，来实现线程的切换，那么这种切换是线程主动调用的。<br>那如果当前的线程不去调用系统API，操作系统如何实现线程切换呢?</p>
<h3 id="如何中断一个正在执行的程序"><a href="#如何中断一个正在执行的程序" class="headerlink" title="如何中断一个正在执行的程序?"></a>如何中断一个正在执行的程序?</h3><ul>
<li>1) 异常  比如缺页，或者INT N指令</li>
<li>2) 中断  比如时钟中断</li>
</ul>
<h3 id="系统时钟"><a href="#系统时钟" class="headerlink" title="系统时钟"></a>系统时钟</h3><p><img src="/2020/10/13/windows-huoge/image-66.png" width="600px"></p>
<p>Windows系列操作系统：10 - 20 毫秒<br>如要获取当前的时钟间隔值，可使用Win32 API：<br>GetSystemTimeAdjustment</p>
<h3 id="时钟中断的执行流程"><a href="#时钟中断的执行流程" class="headerlink" title="时钟中断的执行流程"></a>时钟中断的执行流程</h3><p><img src="/2020/10/13/windows-huoge/image-67.png" width="600px"></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>线程切换的几种情况：</p>
<ul>
<li>1)  主动调用API函数</li>
<li>2)  时钟中断</li>
<li>3)  异常处理</li>
</ul>
<p>如果一个线程不调用API，在代码中屏蔽中断(CLI指令),并且不会出现异常，那么当前线程将永久占有CPU,单核占有率100%  2核就是50%</p>
<p><br></p>
<h2 id="Windows线程切换-时间片"><a href="#Windows线程切换-时间片" class="headerlink" title="Windows线程切换_时间片"></a>Windows线程切换_时间片</h2><p>在上一节中我们讲过了，时钟中断会导致线程进行切换，但并不是说<br>只要有时钟中断就一定会切换线程，时钟中断时，两种情况会导致线程切换：</p>
<ul>
<li>1、当前的线程CPU时间片到期</li>
<li>2、有备用线程(KPCR.PrcbData.NextThread)</li>
</ul>
<h3 id="关于时间片"><a href="#关于时间片" class="headerlink" title="关于时间片"></a>关于时间片</h3><ul>
<li>1) 当一个新的线程开始执行时，初始化程序会在_KTHREAD.Quantum赋初始值，该值的大小由_KPROCESS.ThreadQuantum决定(观察ThreadQuantum大小)</li>
<li>2) 每次时钟中断会调用KeUpdateRunTime函数，该函数每次将当前线程Quantum减少3个单位，如果减到0，则将KPCR.PrcbData.QuantumEnd的值设置为非0。</li>
<li>3) KiDispatchInterrupt判断时间片到期：用KiQuantumEnd(重新设置时间片、找到要运行的线程) </li>
</ul>
<h3 id="存在备用线程-NextThread"><a href="#存在备用线程-NextThread" class="headerlink" title="存在备用线程(NextThread)"></a>存在备用线程(NextThread)</h3><p>这个值被设置时，即使当前线程的CPU时间片没有到期，仍然会被切换.<br>参见KiDispatchInterrupt代码</p>
<h3 id="线程切换的三种情况"><a href="#线程切换的三种情况" class="headerlink" title="线程切换的三种情况"></a>线程切换的三种情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(1)、当前线程主动调用API：</span><br><span class="line"></span><br><span class="line">API函数     KiSwapThread    KiSwapContext     SwapContext</span><br><span class="line"></span><br><span class="line">(2)、当前线程时间片到期：</span><br><span class="line"></span><br><span class="line">KiDispatchInterrupt     KiQuantumEnd     SwapContext</span><br><span class="line"></span><br><span class="line">(3)、有备用线程(KPCR.PrcbData.NextThread)</span><br><span class="line"></span><br><span class="line">KiDispatchInterrupt     SwapContext</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="Windows线程切换-TSS"><a href="#Windows线程切换-TSS" class="headerlink" title="Windows线程切换_TSS"></a>Windows线程切换_TSS</h2><p>SwapContext这个函数是Windows线程切换的核心，无论是主动切换还是系统时钟导致的线程切换，最终都会调用这个函数。<br>在这个函数中除了切换堆栈意外，还做了很多其他的事情，了解这些细节对我们学习操作系统至关重要。<br>这节课我们讲一下线程切换与TSS的关系。</p>
<h3 id="内核堆栈"><a href="#内核堆栈" class="headerlink" title="内核堆栈"></a>内核堆栈</h3><p><img src="/2020/10/13/windows-huoge/image-68.png" width="400px"></p>
<h3 id="内核堆栈的结构"><a href="#内核堆栈的结构" class="headerlink" title="内核堆栈的结构"></a>内核堆栈的结构</h3><p><img src="/2020/10/13/windows-huoge/image-69.png" width="400px"><img src="/2020/10/13/windows-huoge/image-70.png" width="400px"></p>
<h3 id="调用API进0环"><a href="#调用API进0环" class="headerlink" title="调用API进0环"></a>调用API进0环</h3><p>普通调用：通过TSS.ESP0得到0环堆栈<br>快速调用：从MSR得到一个临时0环栈，代码执行后仍然<br>通过TSS.ESP0得到当前线程0环堆栈。</p>
<h3 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h3><p>Intel设计TSS的目的是为了任务切换(线程切换),但Windows与Linux并没有使用。而是采用堆栈来保存线程的各种寄存器。<br>一个CPU只有一个TSS,但是线程很多，如何用一个TSS来保存所有线程的ESP0呢?</p>
<p>通过KPCR.TSS+4的位置ESPO0替换为ETHREAD.Tcb.InitialStack - 210, 就成功替换掉了目标线程的ESP值<br>并且这个ETHREAD.Tcb.InitialStack - 210就是TrapFrame的数据块了</p>
<p>TSS不仅存储了ESP0还存储了CR3</p>
<p><br></p>
<h2 id="Windows线程切换-FS"><a href="#Windows线程切换-FS" class="headerlink" title="Windows线程切换_FS"></a>Windows线程切换_FS</h2><p>FS:[0]寄存器在3环时指向TEB,进入0环后FS:[0]指向KPCR</p>
<p>系统中同时存在很多个线程，这就意味着FS:[0]在3环时指向的TEB要有多个(每个线程一份)。<br>但在实际的使用中我们发现，当我们在3环查看不同线程的FS寄存器时，FS的段选择子都是相同的,那是如何实现通过一个FS寄存器指向多个TEB呢?</p>
<h3 id="SwapContext代码分析"><a href="#SwapContext代码分析" class="headerlink" title="SwapContext代码分析"></a>SwapContext代码分析</h3><p><img src="/2020/10/13/windows-huoge/image-71.png" width="600px"></p>
<p><img src="/2020/10/13/windows-huoge/image-104.png" width="900px"></p>
<p>我们可以看到FS不用其他段选择子改掉KPCR和TEB的方式就是直接改段描述符的基址, 用原来的段选择子</p>
<p><br></p>
<h2 id="Windows线程切换-线程优先级"><a href="#Windows线程切换-线程优先级" class="headerlink" title="Windows线程切换_线程优先级"></a>Windows线程切换_线程优先级</h2><p>之前的课程讲过了，有三种情况会导致线程切换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(1)、当前线程主动调用API：</span><br><span class="line">API函数     KiSwapThread    KiSwapContext     SwapContext</span><br><span class="line"></span><br><span class="line">(2)、当前线程时间片到期：</span><br><span class="line">KiDispatchInterrupt     KiQuantumEnd     SwapContext</span><br><span class="line"></span><br><span class="line">(3)、有备用线程(KPCR.PrcbData.NextThread)</span><br><span class="line">KiDispatchInterrupt     SwapContext</span><br></pre></td></tr></table></figure>
<p>在KiSwapThread与KiQuantumEnd函数中都是通过KiFindReadyThread来找下一个要切换的线程，KiFindReadyThread是根据什么条件来选择下一个要执行的线程呢?</p>
<h3 id="调度链表-32个"><a href="#调度链表-32个" class="headerlink" title="调度链表(32个)"></a>调度链表(32个)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KiDispatcherReadyListHead</span><br><span class="line">8055bc20  8055bc20 8055bc20 8055bc28 8055bc28</span><br><span class="line">8055bc30  8055bc30 8055bc30 8055bc38 8055bc38</span><br><span class="line">8055bc40  8055bc40 8055bc40 8055bc48 8055bc48</span><br><span class="line">8055bc50  8055bc50 8055bc50 8055bc58 8055bc58</span><br><span class="line">8055bc60  8055bc60 8055bc60 8055bc68 8055bc68</span><br><span class="line">8055bc70  8055bc70 8055bc70 8055bc78 8055bc78</span><br><span class="line">8055bc80  8055bc80 8055bc80 8055bc88 8055bc88</span><br><span class="line">8055bc90  8055bc90 8055bc90 8055bc98 8055bc98</span><br></pre></td></tr></table></figure>
<p>KiFindReadyThread查找方式：<br>按照优先级别进行查找：<code>31..30..29..28.....</code></p>
<p>也就是说，在本次查找中，如果级别31的链表里面有线程，那么就不会查找级别为30的链表！</p>
<h3 id="如何高效查找"><a href="#如何高效查找" class="headerlink" title="如何高效查找"></a>如何高效查找</h3><p>调度链表有32个，每次都从头开始查找效率太低，所以Windows都过一个<br>DWORD类型变量的变量来记录：</p>
<p>当向调度链表(32个)中挂入或者摘除某个线程时，会判断当前级别的链表是否为空，为空将DWORD变量对应位置0，否则置1。</p>
<p>如下图：</p>
<p><img src="/2020/10/13/windows-huoge/image-72.png" width="500px"></p>
<p>这个变量：<code>_kiReadySummary</code></p>
<p>多cpu会随机寻找KiDispatcherReadyListHead指向的数组中的线程。线程可以绑定某个cpu（使用api：setThreadAffinityMask）</p>
<h3 id="如果没有就绪线程怎么办"><a href="#如果没有就绪线程怎么办" class="headerlink" title="如果没有就绪线程怎么办"></a>如果没有就绪线程怎么办</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PrcbData：</span><br><span class="line"></span><br><span class="line">+0x004 CurrentThread    : Ptr32 _KTHREAD</span><br><span class="line">+0x008 NextThread       : Ptr32 _KTHREAD</span><br><span class="line">+0x00c IdleThread       : Ptr32 _KTHREAD</span><br></pre></td></tr></table></figure>
<p>那么就会转向到IdleThread的线程上去</p>
<p><br></p>
<h2 id="进程挂靠"><a href="#进程挂靠" class="headerlink" title="进程挂靠"></a>进程挂靠</h2><p>进程与线程的关系：</p>
<ul>
<li>一个进程可以包含多个线程</li>
<li>一个进程至少要有一个线程</li>
</ul>
<p>进程为线程提供资源，也就是提供Cr3的值，Cr3中存储的是页目录表基址，Cr3确定了，线程能访问的内存也就确定了。</p>
<h3 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h3><p>线程代码：</p>
<p><code>mov eax,dword ptr ds:[0x12345678]</code></p>
<p>CPU如何解析0x12345678这个地址呢？</p>
<ul>
<li>1) CPU解析线性地址时要通过页目录表来找对应的物理页，页目录表基址存在Cr3寄存器中。</li>
<li>2) 当前的Cr3的值来源于当前的进程(<code>_KPROCESS.DirectoryTableBase(+0x018)</code>)。</li>
</ul>
<h3 id="线程与进程如何关联"><a href="#线程与进程如何关联" class="headerlink" title="线程与进程如何关联"></a>线程与进程如何关联</h3><p>ETHREAD结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+0x034 ApcState</span><br><span class="line">	+0x000 ApcListHead </span><br><span class="line">  		+0x010 Process </span><br><span class="line">  		+0x014 KernelApcInProgress</span><br><span class="line">  		+0x015 KernelApcPending</span><br><span class="line">  		+0x016 UserApcPending</span><br><span class="line"></span><br><span class="line">+0x220 ThreadsProcess</span><br></pre></td></tr></table></figure></p>
<p>+0x220 ThreadsProcess 线程所属的进程</p>
<p>Kthread里面还有一个KAPC_STATE#10位置就是一个Kprocess</p>
<p>同样的线程结构体两份进程指针</p>
<h3 id="养父母负责提供Cr3"><a href="#养父母负责提供Cr3" class="headerlink" title="养父母负责提供Cr3"></a>养父母负责提供Cr3</h3><p>线程切换的时候，会比较_KTHREAD结构体0x044处指定的EPROCESS是否为同一个,如果不是同一个，会将0x044处指定的EPROCESS的DirectoryTableBase的值取出，赋值给Cr3。<br>所以线程需要的Cr3的值来源于0x044处偏移指定的EPROCESS.</p>
<p>总结：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x220 亲生父母：这个线程谁创建的</span><br><span class="line">0x044 养父母：谁在为这个线程提供资源(也就是提供Cr3)</span><br><span class="line">一般情况下，0x220与0x44指向的是同一个进程</span><br></pre></td></tr></table></figure></p>
<h3 id="Cr3的值可以随便改吗"><a href="#Cr3的值可以随便改吗" class="headerlink" title="Cr3的值可以随便改吗?"></a>Cr3的值可以随便改吗?</h3><p>正常情况下，Cr3的值是由养父母提供的，但Cr3的值也可以改成和当前线程毫不相干的其他进程的DirectoryTableBase。</p>
<p>线程代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov cr3,A.DirectoryTableBase</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]		//A进程的0x12345678内存</span><br><span class="line">mov cr3,B.DirectoryTableBase</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]		//B进程的0x12345678内存</span><br><span class="line">mov cr3,C.DirectoryTableBase</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]		//C进程的0x12345678内存</span><br></pre></td></tr></table></figure>
<p>将当前Cr3的值改为其他进程，称为“进程挂靠”。</p>
<h3 id="分析NtReadVirtualMemory函数"><a href="#分析NtReadVirtualMemory函数" class="headerlink" title="分析NtReadVirtualMemory函数"></a>分析NtReadVirtualMemory函数</h3><p><img src="/2020/10/13/windows-huoge/image-73.png" width="300px"></p>
<p>可不可以只修改Cr3而不修改养父母？不可以，如果不修改养父母的值,一旦产生线程切换，就会变成自己读自己！</p>
<p>如果我们自己来写这个代码，在切换Cr3后关闭中断，并且不调用会导致线程切换的API,就可以不用修改养父母的值。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>正常情况下，当前线程使用的Cr3是由其所属进程提供的(ETHREAD 0x44偏移处指定的EPROCESS)，正是因为如此，A进程中的线程只能访问A的内存。<br>如果要让A进程中的线程能够访问B进程的内存，就必须要修改Cr3的值为B进程的页目录表基址(B.DirectoryTableBase),这就是所谓的“进程挂靠”。</p>
<p><br></p>
<h2 id="跨进程读写内存"><a href="#跨进程读写内存" class="headerlink" title="跨进程读写内存"></a>跨进程读写内存</h2><p>跨进程的本质是“进程挂靠”,正常情况下，A进程的线程只能访问A进程的地址空间，如果A进程的线程想访问B进程的地址空间，就要修改当前的Cr3的值为B进程的页目录表基值(KPROCESS.DirectoryTableBase)。</p>
<p>即：<code>mov cr3,B.DirectoryTableBase</code></p>
<h3 id="跨进程操作"><a href="#跨进程操作" class="headerlink" title="跨进程操作"></a>跨进程操作</h3><p>A进制中的线程代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cr3,B.DirectoryTableBase		//切换Cr3的值为B进程</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]		//将进程B 0x12345678的值存的eax中</span><br><span class="line">mov dword ptr ds:[0x00401234],eax		//将数据存储到0x00401234中</span><br><span class="line">mov cr3,A.DirectoryTableBase		//切换回Cr3的值</span><br></pre></td></tr></table></figure>
<ul>
<li>此时0x00401234中的数据还有吗?</li>
<li>如何将数据传递给A进程的变量呢?</li>
</ul>
<h3 id="NtReadVirtualMemory流程解析"><a href="#NtReadVirtualMemory流程解析" class="headerlink" title="NtReadVirtualMemory流程解析"></a>NtReadVirtualMemory流程解析</h3><p><img src="/2020/10/13/windows-huoge/image-74.png" width="500px"></p>
<ul>
<li>1、切换Cr3</li>
<li>2、将数据读复制到高2G</li>
<li>3、切换Cr3</li>
<li>4、从高2G复制到目标位置</li>
</ul>
<h3 id="NtWriteVirtualMemory流程解析"><a href="#NtWriteVirtualMemory流程解析" class="headerlink" title="NtWriteVirtualMemory流程解析"></a>NtWriteVirtualMemory流程解析</h3><p><img src="/2020/10/13/windows-huoge/image-75.png" width="500px"></p>
<ul>
<li>1、将数据从目标位置复制到高2G地址</li>
<li>2、切换Cr3</li>
<li>3、从高2G复制到目标位置</li>
<li>4、切换Cr3</li>
</ul>
<p><br><br><br></p>
<h1 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h1><h2 id="句柄表"><a href="#句柄表" class="headerlink" title="句柄表"></a>句柄表</h2><h3 id="什么是句柄（内核对象）"><a href="#什么是句柄（内核对象）" class="headerlink" title="什么是句柄（内核对象）"></a>什么是句柄（内核对象）</h3><p>当一个进程创建或者打开一个内核对象时，将获得一个句柄，通过这个句柄可以访问内核对象。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HANDLE g_hMutex = ::CreateMutex(NULL,FALSE, &quot;XYZ&quot;);</span><br><span class="line"></span><br><span class="line">HANDLE g_hMutex = ::OpenMutex(MUTEX_ALL_ACCESS,FALSE, &quot;XYZ&quot;);</span><br><span class="line"></span><br><span class="line">HANDLE g_hEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL);</span><br><span class="line"></span><br><span class="line">HANDLE g_hThread = ::CreateThread(NULL, 0, Proc, NULL, 0, NULL);</span><br></pre></td></tr></table></figure>
<h3 id="为什么要有句柄"><a href="#为什么要有句柄" class="headerlink" title="为什么要有句柄?"></a>为什么要有句柄?</h3><p>句柄存在的目的是为了避免在应用层直接修改内核对象。</p>
<p>HANDLE g_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);</p>
<p>如果g_hEvent存储的就是EVENT内核对象的地址,那么就意味着我们可以在应用层修改这个地址，一旦指向了无效的内核内存地址就会蓝屏。            </p>
<p><img src="/2020/10/13/windows-huoge/image-76.png" width="500px"></p>
<h3 id="句柄表在哪"><a href="#句柄表在哪" class="headerlink" title="句柄表在哪?"></a>句柄表在哪?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _EPROCESS							</span><br><span class="line">   +0x0c4 ObjectTable      : _HANDLE_TABLE			</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">kd&gt; dt _HANDLE_TABLE </span><br><span class="line">nt!_HANDLE_TABLE					</span><br><span class="line">   +0x000 TableCode</span><br><span class="line">   +0x004 QuotaProcess	</span><br><span class="line">   +0x008 UniqueProcessId</span><br><span class="line">   +0x00c HandleTableLock</span><br><span class="line">   +0x01c HandleTableList			</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>TableCode就是句柄表</p>
<p>涉及到句柄表的有以下这些概念：<br>HANDLE_TABLE<br>HANDLE_TABLE结构体中的TableCode变量<br>实际上啊，TableCode是指向句柄表项第一个句柄表项的指针（NULL句柄表项），TableCode就是HANDLE_TABLE_ENTRY的指针。<br>但是，当有两级以上表时，这个时候就不是了，先来搞定最简单的。<br>HANDLE_TABLE_ENTRY：句柄表项<br>对象头_OBJECT_HANDLE<br>EXHANDLE：这个就是提供给用户使用的句柄值</p>
<p>HANDLE_TABLE_ENTRY是一个8个字节的结构体。它包括：<br>指向对象头的指针<br>32位的访问掩码<br>因为对象头_OBJECT_HANDLE的大小是0x18h，是8的倍数，因为对象头总是按照8个字节对齐。<br>所以对象头的地址低3位肯定是0。所以HANDLE_TABLE_ENTRY的对象头的指针的低3位为0，低三位被用作一些访问标志。<br>句柄值：通过查看句柄值可以发现，句柄值总是4的倍数。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0004</span><br><span class="line">0x0008</span><br><span class="line">0x000C</span><br><span class="line">0x0010</span><br></pre></td></tr></table></figure>
<p>所以，句柄值低2位总是0，所以低2位可以被用作标志位。<br>句柄值的结构类型是EXHANDLE，在EXHANDLE中低2位为标志位。<br>0x0000这一个句柄值被用来做位NULL无效句柄。提供给用户使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">if(Handle == NULL/ *0x0000*/ )</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">typedef struct _EXHANDLE</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">// 注意啦，这里是个联合。</span><br><span class="line"></span><br><span class="line">// 实际上该结构体就占4个字节</span><br><span class="line"></span><br><span class="line">union</span><br><span class="line">&#123;</span><br><span class="line">	struct</span><br><span class="line">	&#123;</span><br><span class="line">		ULONG TagBits:2;</span><br><span class="line">		ULONG Index:30;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	HANDLE GenericHandleOverlay; //呵呵，这是用来提供给用户使用的句柄。</span><br><span class="line">	#define HANLE_VALUE_INC 4</span><br><span class="line">	ULONG_PTR Value; //这个表示什么意思呢？</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; EXHANDLE,*PEXHANDLE;</span><br></pre></td></tr></table></figure>
<hr>
<p>如何知道HANDLE_TABLE和HANDLE_TABLE_ENTRY的关系，可以参考ExpAllocateHandleTable。</p>
<p>ExpAllocateHandleTable用来为每个进程分配句柄表，并初始化句柄表。第一次只分配0级的句柄（保存真正句柄项）。</p>
<hr>
<p>我不知道该怎么写才顺，我就按照我的分析流程写吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">!Process 查看当前进程</span><br><span class="line"></span><br><span class="line">PROCESS 87ca7cf8   SessionId: 0   Cid: 0cb0     Peb: 7ffd8000   ParentCid: 03c4</span><br><span class="line"></span><br><span class="line">     DirBase: 3f13d000   ObjectTable: e2d11b78   HandleCount:   76.</span><br><span class="line"></span><br><span class="line">     Image: windbg.exe</span><br></pre></td></tr></table></figure>
<p>其中EPROCESS的地址在87ca7cf8，ObjectTable的地址在e2d11b78 。</p>
<p>ObjectTable是HANDLE_TABLE结构变量，它保存在EPROCESS中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dt _EPROCESS 87ca7cf8   来查看EPROCESS结构体的值。</span><br><span class="line">.....</span><br><span class="line">    +0x0c4 ObjectTable       : 0xe2d11b78_HANDLE_TABLE</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>ObjectTable在EPROCESS偏移0x0c4处。<br>ObjectTable保存着关于句柄表的信息。</p>
<p>我们使用下面的命令来查看HANDLE_TABLE内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dt _HANDLE_TABLE 0xe2d11b78     </span><br><span class="line"></span><br><span class="line">    +0x000 TableCode         : 0xe4702000</span><br><span class="line"></span><br><span class="line">   ......</span><br></pre></td></tr></table></figure></p>
<p>其中偏移0为TableCode，它实际上是句柄项(<code>_HANDLE_TABLE_ENTRY</code>)的指针。<br>句柄项(<code>_HANDLE_TABLE_ENTRY</code>)是用来保存真正的句柄信息的结构体。<br>(注意，当TableCode低2位为0时，TableCode才指向_HANDLE_TABLE_ENTRY，至于如何给TableCode分配值，还是需要分析一下源码。)</p>
<p><code>_HANDLE_TABLE_ENTRY</code>是两个32位的结构体：一个指向对象头的指针；一个是32位的标志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意，这个32位的对象头的指针并不是全部有效。因为对象头为0x18个字节，所以windows能保证对象头的分配地址总是8的倍数。</span><br><span class="line">所以这32位的对象头的指针低3位肯定都为0，windows将这低3位用作其他用途。</span><br><span class="line">因此当我们使用对象头指针时，一定要记得，低3位值不是我们需要的，应该置0 。即：value &amp; 0xFFFFFFF8。</span><br></pre></td></tr></table></figure>
<p>我们使用dt <code>_HANDLE_TABLE_ENTRY</code> 0xe4702000 来查看其值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lkd&gt; dt _HANDLE_TABLE_ENTRY 0xe4702000</span><br><span class="line"></span><br><span class="line">nt!_HANDLE_TABLE_ENTRY</span><br><span class="line"></span><br><span class="line">    +0x000 Object            : (null)</span><br><span class="line"></span><br><span class="line">    +0x000 ObAttributes      : 0</span><br><span class="line"></span><br><span class="line">    +0x000 InfoTable         : (null)</span><br><span class="line"></span><br><span class="line">    +0x000 Value             : 0</span><br><span class="line"></span><br><span class="line">    +0x004 GrantedAccess     : 0xfffffffe</span><br><span class="line"></span><br><span class="line">    +0x004 GrantedAccessIndex : 0xfffe</span><br><span class="line"></span><br><span class="line">    +0x006 CreatorBackTraceIndex : 0xffff</span><br><span class="line"></span><br><span class="line">    +0x004 NextFreeTableEntry : -2</span><br></pre></td></tr></table></figure></p>
<p>但是得到的值好像是无效的。<br>这就对了，因为句柄表的第一个值不被使用，做为一个无效值，用来提供给程序员做错误处理使用。<br>下面该怎么办呢？句柄表，句柄表肯定是一个连续的数组，连续的保存一些句柄表项。<br>我们使用dd 0x4702000来查看这块地址的一些值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lkd&gt; dd 0xe4702000</span><br><span class="line"></span><br><span class="line">e4702000   00000000 fffffffe e1008719 000f0003</span><br><span class="line"></span><br><span class="line">e4702010   e1858019 00000003 87d68f13 00100020</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>看值出来了，因为一个句柄表项<code>_HANDLE_TABLE_ENTRY</code>占8个字节。所以，前两个值看似一个无效的值。但是红色标示的却象个有用的句柄项。<br>注意了，<code>_HANDLE_TABLE_ENTRY</code>是2个32位组成的64位结构体。前面说过了，低32位是对象头的指针。但是要得到对象头的指针，我们必须将值&amp;0xFFFFFFF8，将低3位置0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e1008719 &amp; 0xFFFFFFF8 = e1008718</span><br></pre></td></tr></table></figure></p>
<p>我们还必须加上0x18才能得到真正的内核对象。因为内核对象在对象头的后面，对象头的大小是0x18。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dt _object_header</span><br><span class="line">lkd&gt; dt _object_header</span><br><span class="line">nt!_OBJECT_HEADER</span><br><span class="line">    +0x000 PointerCount      : Int4B</span><br><span class="line">...</span><br><span class="line">    +0x018 Body              : _QUAD</span><br></pre></td></tr></table></figure></p>
<p>用刚才的 e1008718 + 0x018 = e1008730 ，然后我们使用!Object e1008730查看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lkd&gt; !object e1008730</span><br><span class="line"></span><br><span class="line">Object: e1008730    Type: (89bddad0) KeyedEvent</span><br><span class="line"></span><br><span class="line">     ObjectHeader: e1008718 (old version)</span><br><span class="line"></span><br><span class="line">     HandleCount: 48   PointerCount: 49</span><br><span class="line"></span><br><span class="line">     Directory Object: e1000270   Name: CritSecOutOfMemoryEvent</span><br></pre></td></tr></table></figure></p>
<p>哈哈，挺像的 。使用!Handle列出当前句柄来测试一把。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">lkd&gt; !handle</span><br><span class="line"></span><br><span class="line">processor number 0, process 87ca7cf8</span><br><span class="line"></span><br><span class="line">PROCESS 87ca7cf8   SessionId: 0   Cid: 0cb0     Peb: 7ffd8000   ParentCid: 03c4</span><br><span class="line"></span><br><span class="line">     DirBase: 3f13d000   ObjectTable: e2d11b78   HandleCount:   99.</span><br><span class="line"></span><br><span class="line">     Image: windbg.exe</span><br><span class="line"></span><br><span class="line">Handle table at e4702000 with 99 Entries in use</span><br><span class="line"></span><br><span class="line">0004: Object: e1008730   GrantedAccess: 000f0003 Entry: e4702008</span><br><span class="line"></span><br><span class="line">Object: e1008730   Type: (89bddad0) KeyedEvent</span><br><span class="line"></span><br><span class="line">     ObjectHeader: e1008718 (old version)</span><br><span class="line"></span><br><span class="line">         HandleCount: 48   PointerCount: 49</span><br><span class="line"></span><br><span class="line">         Directory Object: e1000270   Name: CritSecOutOfMemoryEvent</span><br><span class="line"></span><br><span class="line">0008: Object: e1858030   GrantedAccess: 00000003 Entry: e4702010</span><br><span class="line"></span><br><span class="line">Object: e1858030   Type: (89c153b0) Directory</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>对比一下，成功，我们已经找到了句柄值为0004的内核对象。<br>OK，冒出了句柄值，那么句柄值是如何被关联起来呢？想下0004，它对应<code>_HANDLE_TABLE_ENTRY</code>表项的低几个啊？<br>句柄值为0x0000代表是NULL，刚好_HANDLE_TABLE_ENTRY的第0个表项为无效值<br>句柄值为0x0004有效，刚好指的是_HANDLE_TABLE_ENTRY的第1个表项。</p>
<p>那句柄值为0x0008了？<br>原来句柄值总是4的倍数。值/4就代表句柄表项数组_HANDLE_TABLE_ENTRY的索引啊。<br>这时，句柄值的低两位永远是0啦，为啥呢？是4的倍数，第2为不就为0？自己算算。<br>0x00,0x04,0x08,0x10,0x14等等的二进制<br>既然第2位永远为0，那么微软就利用了这两位做一个标志位，用来指示当前句柄值所代表的内核对象到那个表项数组中找到？</p>
<p>什么意思呢？<br>句柄表实际上是分级的，分3级，我们可以像理解分页一样。<br>分页分为：页目录、页表、物理页。<br>每个页目录保存1024个页表，每个页表保存着1024个物理页，每个页为4k。<br>句柄表可以这样分：</p>
<p>4K的目录，保存1K个表指针（指针为一项，占4个字节吗，总共是1024个项）。<br>每个4K的表，保存着1K个_HANDLE_TABLE_ENTRY数组指针。<br>每个4K的_HANDLE_TABLE_ENTRY数组保存着512个_HANDLE_TABLE_ENTRY，咋是512个？因为每一个_HANDLE_TABLE_ENTRY是8个字节。<br>每个_HANDLE_TABLE_ENTRY指向真正的内核对象前的对象头。（第1个表项除外，代表空。）</p>
<p>哈哈，句柄表就这么简单，就是太多繁琐的东西。记不住。<br>记下笔记备忘之。<br>这两天试着写写访问句柄表信息的小驱动。写完后配合代码和WRK再整理。</p>
<h3 id="句柄表结构"><a href="#句柄表结构" class="headerlink" title="句柄表结构"></a>句柄表结构</h3><p><img src="/2020/10/13/windows-huoge/image-77.png" width="700px"></p>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul>
<li>1、一个进程可以创建、打开很多内核对象，这些内核对象的地址存储在当前进程的句柄表中。我们在应用层得到的句柄值，实际上就是当前进程句柄表的索引。</li>
<li>2、同一个内核对象可以被不同的进程所引用，但句柄的值可能一样也可能不一样。</li>
</ul>
<p><br></p>
<h2 id="全局句柄表"><a href="#全局句柄表" class="headerlink" title="全局句柄表"></a>全局句柄表</h2><p>在进程中可以创建、打开很多内核对象，这些内核对象的地址都存储在当前进程的句柄表中。我们在应用层得到的句柄实际上就是句柄表的索引。</p>
<p>进程的句柄表是私有的，每个进程都有一个自己的句柄表。除此之外，系统还有一个全局句柄表：<code>PsdCidTable</code></p>
<h3 id="全局句柄表-1"><a href="#全局句柄表-1" class="headerlink" title="全局句柄表"></a>全局句柄表</h3><ul>
<li><p>1)  所有的进程和线程无论无论是否打开，都在这个表中。</p>
</li>
<li><p>2)  每个进程和线程都有一个唯一的编号：PID和CID    这两个值其实就是全局句柄表中的索引。<br>进程和线程的查询,主要是以下三个函数,按照给定的PID或CID从PspCidTable从查找相应的进线程对象：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PsLookupProcessThreadByCid()			</span><br><span class="line">PsLookupProcessByProcessId()			</span><br><span class="line">PsLookupThreadByThreadId()</span><br></pre></td></tr></table></figure>
<h3 id="全局句柄表结构"><a href="#全局句柄表结构" class="headerlink" title="全局句柄表结构"></a>全局句柄表结构</h3><p><img src="/2020/10/13/windows-huoge/image-78.png" width="700px"></p>
<h3 id="观察句柄表"><a href="#观察句柄表" class="headerlink" title="观察句柄表"></a>观察句柄表</h3><p>通过PID的值，在PspCidTable中找到内核对象.</p>
<p><img src="/2020/10/13/windows-huoge/image-79.png" width="1100px"></p>
<p>先找到计算器的pid是992, 得到十六进制是F8</p>
<p>winDbg找<code>PspCidTable</code>, 找到第一项为HandleTable, 其中第一个0x000位置就是TableCode</p>
<p>TableCode的位置 +<code>F8*8</code>的偏移就得到具体的地址</p>
<p><img src="/2020/10/13/windows-huoge/image-81.png" width="500px"></p>
<p>但是这里不需要加18, 私有的句柄表是指向了ObjectHead,并不是直接指向了EProcess所有这里, 但是全局句柄表直接指向了EProcess, 但是这个TableCode的位置后三位是因为属性所以要清0, 这点还是跟私有句柄表一致 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt _EProcess 860b2980</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是二级的TableCode该怎么找呢?  </p>
</blockquote>
<p>假如现在超过了512个句柄, 如何找呢？</p>
<p><img src="/2020/10/13/windows-huoge/image-82.png" width="900px"></p>
<p>可以看到现在末位是1了</p>
<p><img src="/2020/10/13/windows-huoge/image-83.png" width="600px"></p>
<p>那么现在进入了两级, </p>
<p><img src="/2020/10/13/windows-huoge/image-84.png" width="600px"></p>
<p>看我们现在3FC是第几个512, 然后选择具体的第几项</p>
<p>3FC - (需要转十六进制的512) = 1FC</p>
<p><img src="/2020/10/13/windows-huoge/image-85.png" width="600px"></p>
<p>最后数值再末尾属性位清零</p>
<blockquote>
<p><code>dt _EPROCESS 860b2968+18</code></p>
</blockquote>
<p><br><br><br></p>
<h1 id="多核同步"><a href="#多核同步" class="headerlink" title="多核同步"></a>多核同步</h1><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>补充知识</p>
<p>并发是指多个线程在同时执行：</p>
<ul>
<li>单核（是分时执行，不是真正的同时）</li>
<li>多核（在某一个时刻，会同时有多个线程再执行）</li>
</ul>
<p>同步则是保证在并发执行的环境中各个线程可以有序的执行    </p>
<h3 id="演示代码"><a href="#演示代码" class="headerlink" title="演示代码"></a>演示代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DWORD  dwVal = 0;	//全局变量</span><br><span class="line"></span><br><span class="line">线程中的代码：</span><br><span class="line"></span><br><span class="line">	dwVal ++;	//只有一行  安全吗?</span><br><span class="line"></span><br><span class="line">对应的汇编代码：</span><br><span class="line"></span><br><span class="line">	mov	eax,[0x12345678]</span><br><span class="line">	add	eax,1</span><br><span class="line">	mov	[0x12345678],eax</span><br></pre></td></tr></table></figure>
<h3 id="LOCK指令"><a href="#LOCK指令" class="headerlink" title="LOCK指令"></a>LOCK指令</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">INC DWORD PTR DS:[<span class="number">0x12345678</span>]	<span class="comment">//一行汇编代码，安全吗?</span></span><br><span class="line"></span><br><span class="line">改成</span><br><span class="line"></span><br><span class="line">LOCK INC DWORD PTR DS:[<span class="number">0x12345678</span>]	</span><br><span class="line"></span><br><span class="line">参考：kernel32.InterlockedIncrement</span><br><span class="line"></span><br><span class="line">原子操作相关的API：</span><br><span class="line">InterlockedIncrement		InterlockedExchangeAdd</span><br><span class="line">InterlockedDecrement		InterlockedFlushSList		</span><br><span class="line">InterlockedExchange		InterlockedPopEntrySList</span><br><span class="line">InterlockedCompareExchange	InterlockedPushEntrySList</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<h3 id="多行代码原子操作"><a href="#多行代码原子操作" class="headerlink" title="多行代码原子操作"></a>多行代码原子操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">关键代码A	//N行代码要求原子操作</span><br><span class="line">关键代码B	//单独加LOCK可以吗?</span><br><span class="line">关键代码C</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<h3 id="临界区-1"><a href="#临界区-1" class="headerlink" title="临界区"></a>临界区</h3><blockquote>
<p>一次只允许一个线程进入直到离开</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwFlag = <span class="number">0</span>;	<span class="comment">//实现临界区的方式就是加锁</span></span><br><span class="line">			<span class="comment">//锁：全局变量  进去加一 出去减一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dwFlag  == <span class="number">0</span>)		<span class="comment">//进入临界区	</span></span><br><span class="line">&#123;	</span><br><span class="line">	dwFlag   = <span class="number">1</span>	</span><br><span class="line">	.......</span><br><span class="line">	.......</span><br><span class="line">	.......</span><br><span class="line">		</span><br><span class="line">	dwFlag   = <span class="number">0</span>	<span class="comment">//离开临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自己实现临界区"><a href="#自己实现临界区" class="headerlink" title="自己实现临界区"></a>自己实现临界区</h3><p>全局变量：Flag = 0</p>
<blockquote>
<p>进入临界区 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lab：</span><br><span class="line">	mov eax,1</span><br><span class="line">	lock xadd [Flag],eax</span><br><span class="line">	cmp eax,0</span><br><span class="line">	jz endLab</span><br><span class="line">	dec [Flag]</span><br><span class="line">	//线程等待Sleep..</span><br><span class="line">endLab:</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>离开临界区    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock dec [Flag]</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>上一节课我们讲解了什么是临界区，并且自己实现了一个临界区    </p>
<p>全局变量：Flag = 0</p>
<p>进入临界区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lab：</span><br><span class="line">	mov eax,1</span><br><span class="line">	lock xadd [Flag],eax</span><br><span class="line">	cmp eax,0</span><br><span class="line">	jz endLab</span><br><span class="line">	dec [Flag]</span><br><span class="line">	//线程等待Sleep..</span><br><span class="line">endLab:</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure></p>
<p>离开临界区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock dec [Flag]</span><br></pre></td></tr></table></figure></p>
<h3 id="不同版本的内核文件"><a href="#不同版本的内核文件" class="headerlink" title="不同版本的内核文件"></a>不同版本的内核文件</h3><p>单核：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ntkrnlpa.exe	2-9-9-12分页</span><br><span class="line"></span><br><span class="line">ntoskrnl.exe	10-10-12分页</span><br></pre></td></tr></table></figure></p>
<p>多核：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ntkrnlpa.exe	2-9-9-12分页</span><br><span class="line"></span><br><span class="line">ntoskrnl.exe	10-10-12分页</span><br></pre></td></tr></table></figure></p>
<h3 id="Windows自旋锁"><a href="#Windows自旋锁" class="headerlink" title="Windows自旋锁"></a>Windows自旋锁</h3><blockquote>
<p>参考：KeAcquireSpinLockAtDpcLevel</p>
</blockquote>
<p>关键代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock bts dword ptr [ecx], 0</span><br></pre></td></tr></table></figure></p>
<p>LOCK是锁前缀，保证这条指令在同一时刻只能有一个CPU访问<br>BTS指令：设置并检测  将ECX指向数据的第0位置1<br>如果[ECX]原来的值==0  那么CF=1 否则CF=0</p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>1、自旋锁只对多核有意义。<br>(查看不同版本的KeAcquireSpinLockAtDpcLevel函数)</p>
</li>
<li><p>2、自旋锁与临界区、事件、互斥体一样，都是一种同步机制，都可以让当前线程处于等待状态，区别在于自旋锁不用切换线程。</p>
</li>
</ul>
<p><br></p>
<h2 id="线程等待与唤醒"><a href="#线程等待与唤醒" class="headerlink" title="线程等待与唤醒"></a>线程等待与唤醒</h2><p>要点回顾</p>
<p>我们在之前的课程里面讲解了如何自己实现临界区以及什么是Windows自旋锁，这两种同步方案在线程无法进入临界区时都会让当前线程进入等待状态，<br>一种是通过Sleep函数实现的，一种是通过让当前的CPU”空转”实现的，但这两种等待方式都有局限性：</p>
<ul>
<li>1) 通过Sleep函数进行等待，等待时间该如何确定呢?</li>
<li>2) 通过“空转”的方式进行等待，只有等待时间很短的情况下才有意义，否则对CPU资源是种浪费。而且自旋锁只能在多核的环境下才有意义。</li>
</ul>
<p>有没有更加合理的等待方式呢？只有在条件成熟的时候才将当前线程唤醒？</p>
<h3 id="等待与唤醒机制"><a href="#等待与唤醒机制" class="headerlink" title="等待与唤醒机制"></a>等待与唤醒机制</h3><p>在Windows中，一个线程可以通过等待一个或者多个可等待对象，从而进入等待状态，另一个线程可以在某些时刻唤醒等待这些对象的其他线程。</p>
<p><img src="/2020/10/13/windows-huoge/image-86.png" width="700px"></p>
<h3 id="可等待对象"><a href="#可等待对象" class="headerlink" title="可等待对象"></a>可等待对象</h3><p>在Windbg中查看如下结构体：            </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dt _KPROCESS			进程</span><br><span class="line">			</span><br><span class="line">dt _KTHREAD			线程</span><br><span class="line"></span><br><span class="line">dt _KTIMER			定时器</span><br><span class="line">			</span><br><span class="line">dt _KSEMAPHORE		信号量</span><br><span class="line">			</span><br><span class="line">dt _KEVENT			事件</span><br><span class="line">			</span><br><span class="line">dt _KMUTANT			互斥体</span><br><span class="line">			</span><br><span class="line">dt _FILE_OBJECT		文件</span><br></pre></td></tr></table></figure>
<h3 id="可等待对象的差异"><a href="#可等待对象的差异" class="headerlink" title="可等待对象的差异"></a>可等待对象的差异</h3><p><img src="/2020/10/13/windows-huoge/image-87.png" width="700px"></p>
<h3 id="一个线程等待一个对象"><a href="#一个线程等待一个对象" class="headerlink" title="一个线程等待一个对象"></a>一个线程等待一个对象</h3><p><img src="/2020/10/13/windows-huoge/image-88.png" width="700px"></p>
<h3 id="一个线程等待多个对象"><a href="#一个线程等待多个对象" class="headerlink" title="一个线程等待多个对象"></a>一个线程等待多个对象</h3><p><img src="/2020/10/13/windows-huoge/image-89.png" width="700px"></p>
<h3 id="等待网"><a href="#等待网" class="headerlink" title="等待网"></a>等待网</h3><p><img src="/2020/10/13/windows-huoge/image-90.png" width="700px"></p>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ul>
<li>1、等待中的线程，一定在等待链表中(KiWaitListHead)，同时也一定在这张网上(KTHREAD +5C的位置不为空)。</li>
<li>2、线程通过调用WaitForSingleObject/WaitForMultipleObjects函数将自己挂到这张网上。</li>
<li>3、线程什么时候会再次执行取决于其他线程何时调用相关函数，等待对象不同调用的函数也不同。</li>
</ul>
<p><br></p>
<h2 id="WaitForSingleObject函数分析"><a href="#WaitForSingleObject函数分析" class="headerlink" title="WaitForSingleObject函数分析"></a>WaitForSingleObject函数分析</h2><p>要点回顾</p>
<p>无论可等待对象是何种类型，线程都是通过：</p>
<ul>
<li>WaitForSingleObject</li>
<li>WaitForMultipleObjects<br>进入等待状态的，这两个函数是理解线程等待与唤醒进制的核心</li>
</ul>
<h3 id="WaitForSingleObject参数说明"><a href="#WaitForSingleObject参数说明" class="headerlink" title="WaitForSingleObject参数说明"></a>WaitForSingleObject参数说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_DISPATCHER_HEADER</span><br><span class="line">   +0x000 Type		//类型  </span><br><span class="line">   +0x001 Absolute         </span><br><span class="line">   +0x002 Size             </span><br><span class="line">   +0x003 Inserted         </span><br><span class="line">   +0x004 SignalState	//是否有信号(&gt;0)        </span><br><span class="line">   +0x008 WaitListHead     	//双向链表头  圈着所有等待块</span><br></pre></td></tr></table></figure>
<h3 id="WaitForSingleObject参数说明-1"><a href="#WaitForSingleObject参数说明-1" class="headerlink" title="WaitForSingleObject参数说明"></a>WaitForSingleObject参数说明</h3><p>WaitForSingleObject对应的内核函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS __<span class="function">stdcall <span class="title">NtWaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE Handle, </span></span></span><br><span class="line"><span class="function"><span class="params">BOOLEAN Alertable, </span></span></span><br><span class="line"><span class="function"><span class="params">PLARGE_INTEGER Timeout)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>Handle     用户层传递的等待对象的句柄(具体细节参加句柄表专题)</li>
<li>Alertable 对应KTHREAD结构体的Alertable属性  如果为1 在插入用户APC时，该线程将被吵醒  </li>
<li>Timeout 超时时间</li>
</ul>
<h3 id="NtWaitForSingleObject"><a href="#NtWaitForSingleObject" class="headerlink" title="NtWaitForSingleObject"></a>NtWaitForSingleObject</h3><ul>
<li>1)  调用ObReferenceObjectByHandle函数，通过对象句柄找到等待对象结构体地址。</li>
<li>2)  调用KeWaitForSingleObject函数，进入关键循环。</li>
</ul>
<h3 id="KeWaitForSingleObject：上半部分"><a href="#KeWaitForSingleObject：上半部分" class="headerlink" title="KeWaitForSingleObject：上半部分"></a>KeWaitForSingleObject：上半部分</h3><ul>
<li>1) 向_KTHREAD(+70)位置的等待块赋值。</li>
<li>2) 如果超时时间不为0，KTHREAD(+70)第四个等待块与第一个等待块关联起来：<br>第一个等待块指向第四个等待块，第四个等待块指向第一个等待块。</li>
<li>3) KTHREAD(+5C)指向第一个_KWAIT_BLOCK。</li>
<li>4) 进入关键循环</li>
</ul>
<blockquote>
<p>关键循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while(true)//每次线程被其他线程唤醒，都要进入这个循环</span><br><span class="line">&#123;</span><br><span class="line">	if(符合激活条件)//1、超时   2、等待对象SignalState&gt;0 </span><br><span class="line">	&#123;</span><br><span class="line">		//1) 修改SignalState</span><br><span class="line">		//2) 退出循环</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		if(第一次执行)</span><br><span class="line">		      将当前线程的等待块挂到等待对象的链表(WaitListHead)中;</span><br><span class="line"></span><br><span class="line">		//将自己挂入等待队列(KiWaitListHead)</span><br><span class="line">		//切换线程...再次获得CPU时，从这里开始执行</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>1) 线程将自己+5C位置清0</li>
<li>2) 释放_KWAIT_BLOCK所占内存</li>
</ul>
<p><img src="/2020/10/13/windows-huoge/image-91.png" width="900px"></p>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>不同的等待对象，用不同的方法来修改_DISPATCHER_HEADER(SignalState)<br>比如如果可等待对象是EVENT,其他线程通常使用SetEvent来设置SignalState = 1<br>并且将正在等待该对象的其他线程唤醒，也就是从等待链表(KiWaitListHead)中摘出来。但是，SetEvent函数并不会将线程从等待网上摘下来，是否要下来，由当前线程自己来决定。</p>
<p><code>symchk.exe /r C:\Users\Coderss\Desktop\x86os /s SRV*C:\Users\Coderss\Desktop\x86os\pdb\*http://msdl.microsoft.com/download/symbols</code></p>
<p><br></p>
<h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>要点回顾</p>
<p>在之前的课程里面讲过，线程在进入临界区之前会调用WaitForSingleObject<br>或者WaitForMultipleObjects,此时如果有信号，线程会从函数中退出并进入临界区，如果没有信号那么线程将自己挂入等待链表，然后将自己挂入等待网，最后切换线程。</p>
<p>其他线程在适当的时候，调用方法修改被等待对象的SignalState为有信号(不同的等待对象，会调用不同的函数)，并将等待该对象的其他线程从等待链表中摘掉，这样，当前线程便会在WaitForSingleObject或者WaitForMultipleObjects恢复执行(在哪切换在哪开始执行)，如果符合唤醒条件，此时会修改SignalState的值，并将自己从等待网上摘下来，此时的线程才是真正的唤醒。</p>
<h3 id="创建事件对象-信号"><a href="#创建事件对象-信号" class="headerlink" title="创建事件对象:信号"></a>创建事件对象:信号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CreateEvent(NULL, TRUE, FALSE, NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_DISPATCHER_HEADER</span><br><span class="line">   +0x000 Type</span><br><span class="line">   +0x001 Absolute</span><br><span class="line">   +0x002 Size</span><br><span class="line">   +0x003 Inserted</span><br><span class="line">   +0x004 SignalState</span><br><span class="line">   +0x008 WaitListHead</span><br></pre></td></tr></table></figure>
<h3 id="创建事件对象-类型"><a href="#创建事件对象-类型" class="headerlink" title="创建事件对象:类型"></a>创建事件对象:类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CreateEvent(NULL, TRUE, FALSE, NULL);</span><br><span class="line"></span><br><span class="line">TRUE  通知类型对象</span><br><span class="line">FALSE 事件同步对象</span><br><span class="line"></span><br><span class="line">_DISPATCHER_HEADER</span><br><span class="line">   +0x000 Type		//TRUE 0  FALSE 1</span><br><span class="line">   +0x001 Absolute</span><br><span class="line">   +0x002 Size</span><br><span class="line">   +0x003 Inserted</span><br><span class="line">   +0x004 SignalState</span><br><span class="line">   +0x008 WaitListHead</span><br></pre></td></tr></table></figure>
<h3 id="SetEvent函数分析"><a href="#SetEvent函数分析" class="headerlink" title="SetEvent函数分析"></a>SetEvent函数分析</h3><p>SetEvent对应的内核函数：KeSetEvent</p>
<ul>
<li>1) 修改信号值SignalState为1</li>
<li>2) 判断对象类型</li>
<li>3) 如果类型为通知类型对象(0)   唤醒所有等待该状态的线程</li>
<li>4) 如果类型为事件同步对象(1)   从链表头找到第一个 </li>
</ul>
<h3 id="WaitForSingleObject"><a href="#WaitForSingleObject" class="headerlink" title="WaitForSingleObject"></a>WaitForSingleObject</h3><blockquote>
<p>关键循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while(true)//每次线程被其他线程唤醒，都要进入这个循环</span><br><span class="line">&#123;</span><br><span class="line">	if(符合激活条件)//1、超时   2、等待对象SignalState&gt;0 </span><br><span class="line">	&#123;</span><br><span class="line">		//1) 修改SignalState</span><br><span class="line">		//2) 退出循环</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		if(第一次执行)</span><br><span class="line">		      将当前线程的等待块挂到等待对象的链表(WaitListHead)中;</span><br><span class="line"></span><br><span class="line">		//将自己挂入等待队列(KiWaitListHead)</span><br><span class="line">		//切换线程...再次获得CPU时，从这里开始执行</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>1) 如果类型为通知类型对象(0)  不修改SignalState</li>
<li>2) 如果类型为事件同步对象(1)   SignalState减1    </li>
</ul>
<p><br></p>
<h2 id="SEMAPHORE"><a href="#SEMAPHORE" class="headerlink" title="SEMAPHORE"></a>SEMAPHORE</h2><p>要点回顾</p>
<p>在上一节课我们讲到了事件(EVENT)对象，线程在进入临界区之前会通过调用WaitForSingleObject或者WaitForMultipleObjects来判断当前的事件对象是否有信号(SignalState&gt;0),只有当事件对象有信号时，才可以进入临界区(只允许一个线程进入直到退出的一段代码，不单指用EnterCriticalSection() 和 LeaveCriticalSection() 而形成的临界区)。</p>
<p>通过我们对EVENT对象相关函数的分析，我们发现，EVENT对象的SignalState值只有2种可能：</p>
<ul>
<li>1  初始化时  或者调用  SetEvent</li>
<li>0  WaitForSingleObject、WaitForMultipleObjects、ResetEvent </li>
</ul>
<h3 id="事件-EVENT"><a href="#事件-EVENT" class="headerlink" title="事件(EVENT)"></a>事件(EVENT)</h3><p><img src="/2020/10/13/windows-huoge/image-93.png" width="500px"></p>
<h3 id="信号量-SEMAPHORE"><a href="#信号量-SEMAPHORE" class="headerlink" title="信号量(SEMAPHORE)"></a>信号量(SEMAPHORE)</h3><p><img src="/2020/10/13/windows-huoge/image-94.png" width="700px"></p>
<h3 id="为什么要使用信号量"><a href="#为什么要使用信号量" class="headerlink" title="为什么要使用信号量"></a>为什么要使用信号量</h3><p><img src="/2020/10/13/windows-huoge/image-94.png" width="400px"></p>
<h3 id="创建信号量对象"><a href="#创建信号量对象" class="headerlink" title="创建信号量对象"></a>创建信号量对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateSemaphore</span><span class="params">(		</span></span></span><br><span class="line"><span class="function"><span class="params">		LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,	</span></span></span><br><span class="line"><span class="function"><span class="params">		LONG lInitialCount,		</span></span></span><br><span class="line"><span class="function"><span class="params">		LONG lMaximumCount,		</span></span></span><br><span class="line"><span class="function"><span class="params">		LPCTSTR lpName				</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">_KSEMAPHORE</span><br><span class="line">   +<span class="number">0x000</span> Header           : _DISPATCHER_HEADER</span><br><span class="line">   +<span class="number">0x010</span> Limit            : Int4B	<span class="comment">//lMaximumCount</span></span><br><span class="line">_DISPATCHER_HEADER</span><br><span class="line">   +<span class="number">0x000</span> Type 			<span class="comment">//信号量类型为5</span></span><br><span class="line">   +<span class="number">0x001</span> Absolute </span><br><span class="line">   +<span class="number">0x002</span> Size</span><br><span class="line">   +<span class="number">0x003</span> Inserted</span><br><span class="line">   +<span class="number">0x004</span> SignalState		<span class="comment">//lInitialCount</span></span><br><span class="line">   +<span class="number">0x008</span> WaitListHead</span><br></pre></td></tr></table></figure>
<h3 id="ReleaseSemaphore函数分析"><a href="#ReleaseSemaphore函数分析" class="headerlink" title="ReleaseSemaphore函数分析"></a>ReleaseSemaphore函数分析</h3><p><img src="/2020/10/13/windows-huoge/image-96.png" width="300px"></p>
<ul>
<li>1) 设置SignalState = SignalState  + N(参数)</li>
<li>2) 通过WaitListHead找到所有线程，并从等待链表中摘掉。</li>
</ul>
<p><br></p>
<h2 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h2><h3 id="为什么要有互斥体-等待对象被遗弃"><a href="#为什么要有互斥体-等待对象被遗弃" class="headerlink" title="为什么要有互斥体:等待对象被遗弃"></a>为什么要有互斥体:等待对象被遗弃</h3><p> 互斥体(MUTANT)与事件(EVENT)和信号量(SEMAPHORE)一样，都可以用来进行线程的同步控制。</p>
<p>但需要指出的是，这几个对象都是内核对象，这就意味着，通过这些对象可以进行跨进程的线程同步控制,比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A进程中的X线程</span><br><span class="line">	等待对象Z</span><br><span class="line">B进程中的Y线程</span><br></pre></td></tr></table></figure>
<blockquote>
<p>极端情况</p>
</blockquote>
<p>如果B进程的Y线程还没有来得及调用修改SignalState的函数(如SetEvent)<br>那么等待对象Z将被遗弃，这也就以为者X线程将永远等下去！</p>
<h3 id="为什么要有互斥体-重入"><a href="#为什么要有互斥体-重入" class="headerlink" title="为什么要有互斥体:重入"></a>为什么要有互斥体:重入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject(A)</span><br><span class="line">	.....</span><br><span class="line">	WaitForMultipleObjects(A,B,C)</span><br><span class="line">	.....</span><br><span class="line"></span><br><span class="line">SetEvent/ReleaseSemaphore</span><br></pre></td></tr></table></figure>
<p>死锁</p>
<h3 id="MUTANT结构体介绍"><a href="#MUTANT结构体介绍" class="headerlink" title="MUTANT结构体介绍"></a>MUTANT结构体介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_KMUTANT						</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER	</span><br><span class="line">   +0x010 MutantListEntry  : _LIST_ENTRY	</span><br><span class="line">   +0x018 OwnerThread      : Ptr32 _KTHREAD   </span><br><span class="line">   +0x01c Abandoned        : UChar		</span><br><span class="line">   +0x01d ApcDisable       : UChar</span><br></pre></td></tr></table></figure>
<blockquote>
<p>MutantListEntry<br>拥有互斥体线程(KTHREAD+0x010 MutantListHead)是个链表头 圈着所有互斥体<br>OwnerThread<br>正在拥有互斥体的线程<br>Abandoned<br>是否已经被放弃不用<br>ApcDisable<br>是否禁用内核APC</p>
</blockquote>
<h3 id="CreateMutex函数"><a href="#CreateMutex函数" class="headerlink" title="CreateMutex函数"></a>CreateMutex函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateMutex(</span><br><span class="line">	LPSECURITY_ATTRIBUTE SlpMutexAttributes, // 指向安全属性的指针</span><br><span class="line">	BOOL bInitialOwner, 	// 初始化互斥对象的所有者</span><br><span class="line">	LPCTSTR lpName 	// 指向互斥对象名的指针</span><br><span class="line">);</span><br><span class="line">CreateMutex      NtCreateMutant(内核函数)     KeInitializeMutant(内核函数)</span><br></pre></td></tr></table></figure>
<p>初始化MUTANT结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MUTANT.Header.Type=2;</span><br><span class="line">MUTANT.Header.SignalState=bInitialOwner?0:1;</span><br><span class="line">MUTANT.OwnerThread=当前线程 or NULL;</span><br><span class="line">MUTANT.Abandoned=0;</span><br><span class="line">MUTANT.ApcDisable=0;</span><br></pre></td></tr></table></figure></p>
<p>bInitialOwner==TRUE  将当前互斥体挂入到当前线程的互斥体链表<br>(KTHREAD+0x010 MutantListHead)</p>
<h3 id="ReleaseMutex函数"><a href="#ReleaseMutex函数" class="headerlink" title="ReleaseMutex函数"></a>ReleaseMutex函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI ReleaseMutex(HANDLE hMutex);</span><br><span class="line"></span><br><span class="line">ReleaseMutex   ----&gt;    NtReleaseMutant   ----&gt;    KeReleaseMutant</span><br></pre></td></tr></table></figure>
<p>正常调用时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUTANT.Header.SignalState++;</span><br></pre></td></tr></table></figure></p>
<p>如果SignalState=1 说明其他进程可用了  将该互斥体从线程链表中移除。</p>
<h3 id="如何解决重入问题"><a href="#如何解决重入问题" class="headerlink" title="如何解决重入问题"></a>如何解决重入问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_KMUTANT						</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER	</span><br><span class="line">   +0x010 MutantListEntry  : _LIST_ENTRY	</span><br><span class="line">   +0x018 OwnerThread      : Ptr32 _KTHREAD   </span><br><span class="line">   +0x01c Abandoned        : UChar		</span><br><span class="line">   +0x01d ApcDisable       : UChar</span><br></pre></td></tr></table></figure>
<p>OwnerThread：<br>正在拥有互斥体的线程</p>
<p>(参见KeWaitForSingleObject函数)</p>
<h3 id="如何解决等待对象被遗弃问题"><a href="#如何解决等待对象被遗弃问题" class="headerlink" title="如何解决等待对象被遗弃问题"></a>如何解决等待对象被遗弃问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_KMUTANT						</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER	</span><br><span class="line">   +0x010 MutantListEntry  : _LIST_ENTRY	</span><br><span class="line">   +0x018 OwnerThread      : Ptr32 _KTHREAD   </span><br><span class="line">   +0x01c Abandoned        : UChar		</span><br><span class="line">   +0x01d ApcDisable       : UChar</span><br></pre></td></tr></table></figure>
<p>MutantListEntry：<br>拥有互斥体线程(KTHREAD+0x010 MutantListHead)是个链表头 圈着所有互斥体<br>Abandoned：<br>是否已经被放弃不用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MmUnloadSystemImage  ----&gt;  KeReleaseMutant(X,Y,Abandon,Z) //是否被丢弃</span><br><span class="line"></span><br><span class="line">if(Abandon == false) //正常调用</span><br><span class="line">&#123;</span><br><span class="line">	MUTANT.Header.SignalState++;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">	MUTANT.Header.SignalState == 1;</span><br><span class="line">	MUTANT.OwnerThread == NULL;   	</span><br><span class="line">&#125;</span><br><span class="line">if(MUTANT.Header.SignalState==1)</span><br><span class="line">	MUTANT.OwnerThread == NULL;  </span><br><span class="line">	从当前线程互斥体链表中将当前互斥体移除</span><br></pre></td></tr></table></figure>
<p>(参见KeReleaseMutant函数)</p>
<h3 id="禁用内核APC"><a href="#禁用内核APC" class="headerlink" title="禁用内核APC"></a>禁用内核APC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_KMUTANT						</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER	</span><br><span class="line">   +0x010 MutantListEntry  : _LIST_ENTRY	</span><br><span class="line">   +0x018 OwnerThread      : Ptr32 _KTHREAD   </span><br><span class="line">   +0x01c Abandoned        : UChar		</span><br><span class="line">   +0x01d ApcDisable       : UChar</span><br><span class="line"></span><br><span class="line">ApcDisable：</span><br><span class="line">是否禁用内核APC</span><br><span class="line"></span><br><span class="line">Mutant     对应内核函数	NtCreateMutant   ApcDisable=0</span><br><span class="line">Mutex      对应内核函数	NtCreateMutex    ApcDisable=1</span><br></pre></td></tr></table></figure>
<p>(参见KeWaitForSingleObject函数)       </p>
<p><br><br><br></p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CPU 记录. 软件模拟<br>执行指令的时候没有识别或者运输出错称为异常<br>中断外部打断的,异常是自己触发 </p>
<p>x86的异常有三种: 错误类、陷阱类、终止</p>
<p><img src="/2020/10/13/windows-huoge/image-99.png" width="500px"></p>
<p>除0异常找idt的处理例程</p>
<p>陷阱类对错误类的区别是修复的地址是下一句的,而错误类是直接修复当前的地址 </p>
<blockquote>
<p>异常的类别</p>
<ul>
<li>（1）中断：中断是异步发生的，来自处理器外部IO设备的信号（区别于同步异常：执行一条指令的结果），它不是由任何一条专门的指令造成的。例如网络适配器、磁盘控制器通过向处理器芯片上的一个管脚发信号，并将异常号放在系统总线上，来触发中断，这个异常号标识了引起中断的设备。中断处理程序总是返回到当前指令的下一条指令。</li>
<li>（2）陷阱：陷阱是同步异常，是执行一条指令的结果。陷阱最重要的用途是在用户程序和内核之间提供系统调用接口。陷阱总返回到当前指令的下一条指令。<br>大家都知道，现代的CPU都是有优先级概念的，用户程序运行在低优先级，操作系统运行在高优先级。高优先级的一些指令低优先级无法执行。有一些操作只能由操作系统来执行，用户想要执行这些操作的时候就要通知操作系统，让操作系统来执行。用户态的程序就是用这种方法来通知操作系统的。</li>
<li>（3）故障：故障由错误引起，它可能被故障处理程序修正，如果修正成功，将返回到当前正在执行的指令，重新执行。否则处理程序返回到内核的abort历程，将终止故障程序。故障的一个典型是缺页异常。</li>
<li>（4）终止：由不可恢复的知名错误造成的结果，处理程序将返回到内核中的abort例程，终止应用程序。</li>
</ul>
</blockquote>
<p><code>0xcc == 0xcd 0x03</code></p>
<p><code>ExceptionRecord.ExceptionFlags</code>如果为1软件模拟异常,如果为0是CPU异常;<br>如果在throw则为软件模拟异常,如果遇到除0类的异常则为cpu记录异常</p>
<p><img src="/2020/10/13/windows-huoge/image-100.png" width="800px"><br>…  <img src="/2020/10/13/windows-huoge/image-101.png" width="800px"></p>
<h3 id="CPU异常的产生"><a href="#CPU异常的产生" class="headerlink" title="CPU异常的产生"></a>CPU异常的产生</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CPU指令检测到异常（如除0）</span><br><span class="line">查IDT表，执行中断处理函数</span><br><span class="line">CommonDispatchException(把异常相关的一些信息存储到一个结构体中)</span><br><span class="line">KiDispatchException（分发异常，目的是找到异常处理函数）</span><br></pre></td></tr></table></figure>
<p><code>CommonDispatchException</code>函数分析<br>该函数构造了一个_EXCEPTION_RECORD结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _EXCEPTION_RECORD</span><br><span class="line">ntdll!_EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : Int4B <span class="comment">//异常代码</span></span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : Uint4B <span class="comment">//异常状态</span></span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : Ptr32 _EXCEPTION_RECORD <span class="comment">//下一个异常</span></span><br><span class="line">   +<span class="number">0x00c</span> ExceptionAddress : Ptr32 Void <span class="comment">//异常发生地址</span></span><br><span class="line">   +<span class="number">0x010</span> NumberParameters : Uint4B <span class="comment">//附加参数个数</span></span><br><span class="line">   +<span class="number">0x014</span> ExceptionInformation : [<span class="number">15</span>] Uint4B <span class="comment">//附加参数指针</span></span><br></pre></td></tr></table></figure>
<h3 id="软件模拟异常的产生"><a href="#软件模拟异常的产生" class="headerlink" title="软件模拟异常的产生"></a>软件模拟异常的产生</h3><p>代码内部直接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>抛出异常</p>
<p><code>CxxThrowException</code>-&gt;<code>kernel32.RaiseException</code>-&gt;<code>Ntdll.RtlRaiseException</code>-&gt;<code>Ntdll.ZwRaiseException</code>-&gt;<code>Nt.NtRaiseException</code>-&gt;<code>Nt.KiRaiseException</code>-&gt;<code>KiDispatchException</code></p>
<h3 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h3><p>这里其实看张银奎的那本软件调试更加方便 </p>
<h2 id="VEH"><a href="#VEH" class="headerlink" title="VEH"></a>VEH</h2><h3 id="RtlAddVectoredExceptionHandler"><a href="#RtlAddVectoredExceptionHandler" class="headerlink" title="RtlAddVectoredExceptionHandler"></a>RtlAddVectoredExceptionHandler</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VEHXXXX.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	EXCEPTION_RECORD * pRecord;</span><br><span class="line">	CONTEXT * pContext;</span><br><span class="line"></span><br><span class="line">&#125;EXCEPTION_INFO,* PEXCEPTION_INFO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">PVOID</span> <span class="params">(__stdcall *RtlAddVectoredExceptionHandler)</span><span class="params">(<span class="keyword">int</span>,PVOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">VectorExpceptionHandler</span><span class="params">(PEXCEPTION_INFO  info )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"================\n"</span>);</span><br><span class="line">	<span class="keyword">if</span>(info-&gt;pRecord-&gt;ExceptionCode == <span class="number">0x80000003</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"=========VectorExpceptionHandler,%X=======\n"</span>,info-&gt;pContext-&gt;Eip);</span><br><span class="line">		info-&gt;pContext-&gt;Eip +=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HMODULE hInstance =  LoadLibrary(<span class="string">"ntdll.dll"</span>);</span><br><span class="line">	RtlAddVectoredExceptionHandler addFunc = (RtlAddVectoredExceptionHandler)GetProcAddress(hInstance,<span class="string">"RtlAddVectoredExceptionHandler"</span>);</span><br><span class="line">	addFunc(<span class="number">0</span>,(PVOID)VectorExpceptionHandler);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fisrt \n"</span>);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"last \n"</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h2><p>VEH是全局的, SEH是挂在KPCR,FS:[0]是跟CPU的任务有关,每个任务都有一个SEH, 所以间接得出SEH是跟线程有关</p>
<p>当前产出SEH只处理当前线程的异常, 而不是像VEH一样全局性的去处理异常 </p>
<h3 id="汇编塞入"><a href="#汇编塞入" class="headerlink" title="汇编塞入"></a>汇编塞入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MyExceptionStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">MyExceptionStruct</span> * <span class="title">next</span>;</span></span><br><span class="line">	DWORD handler;</span><br><span class="line">&#125;MyExceptionStruct;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyExceptionHandler</span><span class="params">(LPEXCEPTION_RECORD record, PVOID param1,</span></span></span><br><span class="line"><span class="function"><span class="params">	PCONTEXT context, EXCEPTION_DISPOSITION * pdispos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"333\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (record-&gt;ExceptionCode == <span class="number">0xC0000095</span> || record-&gt;ExceptionCode == <span class="number">0xC0000094</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"222\n"</span>);</span><br><span class="line">		context-&gt;Eip += <span class="number">2</span>; </span><br><span class="line">		<span class="keyword">return</span> ExceptionContinueExecution;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ExceptionContinueSearch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> WINAPI <span class="title">testException</span><span class="params">(PVOID p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD temp = <span class="number">0</span>; </span><br><span class="line">	MyExceptionStruct exceptionStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov eax, fs:[<span class="number">0</span>];</span><br><span class="line">		mov temp, eax;</span><br><span class="line">		lea ecx, dword ptr ds:[exceptionStruct];</span><br><span class="line">		mov dword ptr ds : [ecx], eax;</span><br><span class="line">		lea ebx, dword ptr ds : [MyExceptionHandler];</span><br><span class="line">		mov dword ptr ds : [ecx + <span class="number">4</span>], ebx;</span><br><span class="line">		mov fs : [<span class="number">0</span>], ecx;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	__asm</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		xor eax, eax;</span></span><br><span class="line"><span class="comment">		xor ecx, ecx;</span></span><br><span class="line"><span class="comment">		mov ecx, 1;</span></span><br><span class="line"><span class="comment">		idiv ecx; </span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	Sleep(<span class="number">5000</span>);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov eax, temp;</span><br><span class="line">		mov fs : [<span class="number">0</span>], eax;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"111\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	MyExceptionStruct * p = NULL;</span></span><br><span class="line"><span class="comment">	DWORD offset = (DWORD)&amp;p-&gt;handler;</span></span><br><span class="line"><span class="comment">	printf("%d\n",offset);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, testException, testException, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//testException();</span></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="try-except-逆向"><a href="#try-except-逆向" class="headerlink" title="try__except 逆向"></a>try__except 逆向</h3><p>分析try异常处理函数</p>
<p>所有的C++代码里面的try except编译器都很好的兼容了SEH的异常链处理函数<br>他的做法就是讲FS:[0]里面的EXCEPTION_REGISTRATION拿出来, 然后将当前函数栈ebp中的造一个_except_handler函数,并且把ebp-4的位置留做一个prev指针<br>等到时候三环的Ntdll.RtlDispatchException中的ExecuteHandler2再去处理这个函数栈中的_except_handler</p>
<p>编译器扩展的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION</span>&#123;</span></span><br><span class="line">	STRUCT _EXCEPTION_REGISTRATION *prev;			<span class="meta"># ebp - 10</span></span><br><span class="line">	<span class="keyword">void</span>(*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PEXCEPTION_RECORD); <span class="meta"># ebp-C</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scopetable_entry</span> *<span class="title">scopetable</span>;</span>	<span class="meta"># ebp-8</span></span><br><span class="line">	<span class="keyword">int</span> trylevel;		<span class="meta"># ebp - 4</span></span><br><span class="line">	<span class="keyword">int</span> _ebp;			# 重点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统原生的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_NT_TIB</span><br><span class="line">   +0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x004 StackBase        : Ptr32 Void</span><br><span class="line">   +0x008 StackLimit       : Ptr32 Void</span><br><span class="line">   +0x00c SubSystemTib     : Ptr32 Void</span><br><span class="line">   +0x010 FiberData        : Ptr32 Void</span><br><span class="line">   +0x010 Version          : Uint4B</span><br><span class="line">   +0x014 ArbitraryUserPointer : Ptr32 Void</span><br><span class="line">   +0x018 Self             : Ptr32 _NT_TIB</span><br><span class="line">-------------seperrator-------------</span><br><span class="line">typedef struct _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">&#123;</span><br><span class="line">  struct _EXCEPTION_REGISTRATION_RECORD *Next;	//指向下一个ERR</span><br><span class="line">  PEXCEPTION_ROUTINE Handler;					//异常处理函数</span><br><span class="line">&#125;EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">-------------seperrator-------------</span><br><span class="line">typedef enum _EXCEPTION_DISPOSITION</span><br><span class="line">&#123;</span><br><span class="line">         ExceptionContinueExecution = 0,</span><br><span class="line">         ExceptionContinueSearch = 1,</span><br><span class="line">         ExceptionNestedException = 2,</span><br><span class="line">         ExceptionCollidedUnwind = 3</span><br><span class="line">&#125; EXCEPTION_DISPOSITION;</span><br></pre></td></tr></table></figure>
<h3 id="scopetable"><a href="#scopetable" class="headerlink" title="scopetable"></a>scopetable</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scopetable_entry</span>&#123;</span></span><br><span class="line">	DWORD prevouseTryLevel;</span><br><span class="line">	PDWRD lpfnFilter;</span><br><span class="line">	PDWRD lpfnHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scopetable[<span class="number">0</span>].previousTryLevel =<span class="number">-1</span></span><br><span class="line">scopetable[<span class="number">0</span>].lpfnFilter = 过滤函数<span class="number">1</span></span><br><span class="line">scopetable[<span class="number">0</span>].lpfnHandler = 异常处理函数<span class="number">1</span></span><br><span class="line">scopetable[<span class="number">0</span>].previousTryLevel =<span class="number">-1</span></span><br><span class="line">scopetable[<span class="number">0</span>].lpfnFilter = 过滤函数<span class="number">2</span></span><br><span class="line">scopetable[<span class="number">0</span>].lpfnHandler = 异常处理函数<span class="number">2</span></span><br><span class="line">scopetable[<span class="number">0</span>].previousTryLevel =<span class="number">1</span></span><br><span class="line">scopetable[<span class="number">0</span>].lpfnFilter = 过滤函数<span class="number">3</span></span><br><span class="line">scopetable[<span class="number">0</span>].lpfnHandler = 异常处理函数<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="except-handler"><a href="#except-handler" class="headerlink" title="except_handler"></a>except_handler</h3><ul>
<li><p>CPU检测到异常, 查中断表执行处理函数CommonDispatchException-&gt;KiDispatchException -&gt; KiUserExceptionDispatch -&gt; RtlDispatchException VEH SEH</p>
</li>
<li><p>执行<code>_except_handler</code></p>
<ul>
<li>根据tryLevel选择scopetable数组</li>
<li>调用scopetable数组中对应的lpfnFilter函数<ul>
<li>EXCEPTION_EXECUTE_HANDLER(1) 执行except代码</li>
<li>EXCEPTION_CONTINUE_SEARCH(0) 寻找下一个</li>
<li>EXCEPTION_CONTINUE_EXECUTION(-1) 重新执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="try-finally"><a href="#try-finally" class="headerlink" title="try__finally"></a>try__finally</h3><p>编译器还提供了另一种程序块 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__try&#123;</span><br><span class="line">	<span class="comment">// 可能出错的代码</span></span><br><span class="line">	<span class="keyword">continue</span>; <span class="comment">// finally还是会执行</span></span><br><span class="line">&#125;</span><br><span class="line">__finally&#123;</span><br><span class="line">	<span class="comment">// 一定要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译器如何实现的呢?</p>
</blockquote>
<p>它如果出异常还是走对应scopetable里面,并且scopeentry里面的第二个为空就是过滤表达式为空, 那么处理函数从except转变为finally的代码块</p>
<p>它如果不出异常,那么会有一个局部展开<code>当出现Continue,Break,Return</code>的函数强制走一下finally</p>
<h4 id="局部展开"><a href="#局部展开" class="headerlink" title="局部展开"></a>局部展开</h4><p>局部展开, 当<code>__try__finally</code>中的__try代码提前退出流程代码块时会产生<br>比如<code>Continue</code>,<code>Break</code>,<code>Return</code>等操作的提前退出流程语句</p>
<p>所以再不出异常的情况下, 就是直接<code>call 一个局部展开</code>, 所以我们finally能够执行是因为我们使用了这个局部展开的函数 </p>
<h4 id="全局展开"><a href="#全局展开" class="headerlink" title="全局展开"></a>全局展开</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		__try</span><br><span class="line">		&#123;</span><br><span class="line">			*(<span class="keyword">int</span>*) <span class="number">0</span> = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		__finally </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"一定会执行的代码A\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	__finally </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"一定会执行的代码B\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">__except(<span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"异常处理函数\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当tryLevel发现这里的过滤函数为空就会继续往外找, 当找到except(1), 当他找到这里的时候, 之前语义约定finally必须执行, 这个时候编译器会怎么做? </p>
<p>那么当except(1)返回为1,在exceptHandler的函数内执行异常代码之前, 会逐个寻找到到之前内部finally代码块全部执行</p>
<p><br><br><br></p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><h2 id="调试对象"><a href="#调试对象" class="headerlink" title="调试对象"></a>调试对象</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_OBJECT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	KEVENT EventsPresent;</span><br><span class="line">	FAST_MUTEX Mutex;</span><br><span class="line">	LIST_ENTRY EventList;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		ULONG Flags;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			UCHAR DebuggerInactive:<span class="number">1</span>;</span><br><span class="line">			UCHAR KillProcessOnExit:<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; DEBUG_OBJECT, *PDEBUG_OBJECT;</span><br></pre></td></tr></table></figure>
<h3 id="如何在调试器与被调试程序之间建立联系"><a href="#如何在调试器与被调试程序之间建立联系" class="headerlink" title="如何在调试器与被调试程序之间建立联系?"></a>如何在调试器与被调试程序之间建立联系?</h3><blockquote>
<p>先介绍两种附加模式 </p>
</blockquote>
<ul>
<li>CreateProcess: 创建调试进程</li>
<li>DebugActiveProcess: 两个进程都已存在,利用Attach进行附加调试</li>
</ul>
<blockquote>
<p>具体建立流程</p>
</blockquote>
<p><img src="/2020/10/13/windows-huoge/image-102.png" width="700px"></p>
<p>先创建DebugObject这个0环对象, 它的句柄对象内容放到调试器进程的TEB中0xF24的地方<br>再存放被调试进程EPROCESS的DebugPort的位置,并且存储的是句柄对象的地址</p>
<h3 id="DebugActiveProcess执行流程"><a href="#DebugActiveProcess执行流程" class="headerlink" title="DebugActiveProcess执行流程"></a>DebugActiveProcess执行流程</h3><p>kernel32!DebugActiveProcess执行流程 </p>
<ul>
<li><p>kernel32!DbgUiConnectToDbg()</p>
<ul>
<li>ntdll!DbgUiConnectToDbg()</li>
<li>ntdll!ZwCreateDebugObject()</li>
<li>nt!NtCreateDebugObject() –&gt; 创建调试对象,并且把内核调试对象的句柄存放到调试进程的TEB偏移0xF24的位置上达到与调试器建立连接</li>
</ul>
</li>
<li><p>kernel32!DbgUiDebugActiveProcess(被调试进程句柄)</p>
<ul>
<li>ntdll!DbgUiDebugActiveProcess(被调试进程句柄)</li>
<li>ntdll!NtDebugActiveProcess(被调试进程句柄,调试器进程TEB+0xF24)</li>
<li>nt!NtDebugActiveProcess(HANDLE ProcessHandle, HANDLE DebugObjectHandle) </li>
</ul>
</li>
</ul>
<p><br></p>
<h2 id="调试事件的采集"><a href="#调试事件的采集" class="headerlink" title="调试事件的采集"></a>调试事件的采集</h2><h3 id="调试事件的种类"><a href="#调试事件的种类" class="headerlink" title="调试事件的种类"></a>调试事件的种类</h3><p>调试事件的种类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _DBGKM_APINUMBER&#123;</span><br><span class="line">	DbgkmException = <span class="number">0</span>, <span class="comment">//异常</span></span><br><span class="line">	DbgKmCreateThreadApi = <span class="number">1</span>,<span class="comment">//创建线程</span></span><br><span class="line">	DbgKmCreateProcessApi = <span class="number">2</span>, <span class="comment">//创建进程</span></span><br><span class="line">	DbgKmExitThreadApi = <span class="number">3</span>,<span class="comment">//线程退出</span></span><br><span class="line">	DbgKmExitProcessApi = <span class="number">4</span>,<span class="comment">//进程退出</span></span><br><span class="line">	DbgKmLoadDllApi = <span class="number">5</span>,<span class="comment">//加载Dll</span></span><br><span class="line">	DbgKmUnloadApi = <span class="number">6</span>,<span class="comment">//卸载Dll</span></span><br><span class="line">	DbgKmErrorReportApi = <span class="number">7</span>,<span class="comment">//已废弃</span></span><br><span class="line">	DbgKmMaxApiNumber = <span class="number">8</span>,<span class="comment">//最大值</span></span><br><span class="line">&#125; DBGKM_APINUMBER;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="调试事件采集函数"><a href="#调试事件采集函数" class="headerlink" title="调试事件采集函数"></a>调试事件采集函数</h3><h4 id="创建进程、线程必经之路"><a href="#创建进程、线程必经之路" class="headerlink" title="创建进程、线程必经之路"></a>创建进程、线程必经之路</h4><ul>
<li><code>PspUserThreadStartip</code><ul>
<li><code>DbgkCreateThread</code><ul>
<li><code>DbgkpSendApiMessage(x,x)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="退出线程、进程必经之路"><a href="#退出线程、进程必经之路" class="headerlink" title="退出线程、进程必经之路"></a>退出线程、进程必经之路</h4><ul>
<li><code>PspExitThread</code><ul>
<li><code>DbgkExitThread</code>/<code>DbgkExitProcess</code><ul>
<li><code>DbgkpSendApiMessage(x,x)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="加载模块的必经之路"><a href="#加载模块的必经之路" class="headerlink" title="加载模块的必经之路"></a>加载模块的必经之路</h4><ul>
<li><code>NtMapViewOfSection</code><ul>
<li><code>DbgkMapViewOfSection</code><ul>
<li><code>DbgkpSendApiMessage(x,x)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="卸载模块的必经之路"><a href="#卸载模块的必经之路" class="headerlink" title="卸载模块的必经之路"></a>卸载模块的必经之路</h4><ul>
<li><code>NtUnMapViewOfSection</code><ul>
<li><code>DbgkUnMapViewOfSection</code><ul>
<li><code>DbgkpSendApiMessage(x,x)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="异常的必经之路"><a href="#异常的必经之路" class="headerlink" title="异常的必经之路"></a>异常的必经之路</h4><ul>
<li><code>KiDispatchException</code><ul>
<li><code>DbgkForwardException</code><ul>
<li><code>DbgkpSendApiMessage(x,x)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="调试事件写入函数"><a href="#调试事件写入函数" class="headerlink" title="调试事件写入函数"></a>调试事件写入函数</h3><p>DbgkpSendApiMessasge(x,x)参数说明</p>
<ul>
<li>第一个参数: 消息结构, 每种消息都有自己的消息结构共有7种类型 </li>
<li>第二个参数: 要不要把本进程内除了自己之外的其他线程挂起<br>  有些消息需要把其他线程挂起,比如CC有些消息不需要把线程挂起,比如模块加载 </li>
</ul>
<p>DbgkSendApiMessage是调试事件收集的总入口, 如果在这里挂钩子, 调试器将无法调试 </p>
<p>写入的DebugEvent结构如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_EVENT</span> &#123;</span></span><br><span class="line">	DWORD dwDebugEventCode;</span><br><span class="line">	DWORD dwProcessId;</span><br><span class="line">	DWORD dwThreadId;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		EXCEPTION_DEBUG_INFO Exception;</span><br><span class="line">		CREATE_THREAD_DEBUG_INFO CreateThread;</span><br><span class="line">		CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;</span><br><span class="line">		EXIT_THREAD_DEBUG_INFO ExitThread;</span><br><span class="line">		EXIT_PROCESS_DEBUG_INFO ExitProcess;</span><br><span class="line">		LOAD_DLL_DEBUG_INFO LoadDll;</span><br><span class="line">		UNLOAD_DLL_DEBUG_INFO UnloadDll;</span><br><span class="line">		OUTPUT_DEBUG_STRING_INFO DebugString;</span><br><span class="line">		RIP_INFO RipInfo;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; DEBUG_EVENT *LPDEBUG_EVENT;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="调试事件的处理"><a href="#调试事件的处理" class="headerlink" title="调试事件的处理"></a>调试事件的处理</h2><h3 id="创建进程的方式"><a href="#创建进程的方式" class="headerlink" title="创建进程的方式"></a>创建进程的方式</h3><ul>
<li>第一步: 关联,通过调试对象进行关联<code>调试器</code>与<code>被调试进程</code></li>
<li>第二部: 调试循环 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BOOL bRet = TRUE;</span><br><span class="line">BOOL nIsContinue = TRUE;</span><br><span class="line">DEBUG_EVENT debugEvent = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建调试进程</span></span><br><span class="line">STARTUPINFO StartupInfo = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">PROCESS_INFORMATION pInfo = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">GetStartupInfo(&amp;StartupInfo);</span><br><span class="line">bRet = CreateProcess(DEBUGGEE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, DEBUG_PROCESS || DEBUG_ONLY_THIS_PROCESS, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;StartupInfo, &amp;pInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调试循环</span></span><br><span class="line"><span class="keyword">while</span>(nIsContinue)&#123;</span><br><span class="line">	<span class="comment">// 判断当debugEvent链表有没有事件,如果有的话则取出来</span></span><br><span class="line">	bRet = WaitForDebugEvent(&amp;debugEvent, INFINITE);</span><br><span class="line">	<span class="keyword">if</span>(!bRet)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"WaitForDebugEvent error:%d\n!"</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span>(debugEvent.dwDebugEventCode)&#123;</span><br><span class="line">		<span class="comment">// 1.异常</span></span><br><span class="line">		<span class="keyword">case</span> EXCEPTION_DEBUG_EVENT:</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.</span></span><br><span class="line">		<span class="keyword">case</span> EXIT_THREAD_DEBUG_EVENT:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"...."</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// DBG_CONTINUE 即表示调试器已处理了该异常</span></span><br><span class="line">	<span class="comment">// DBG_EXCEPTION_NOT_HANDLED 即表示调试器没有处理该异常,转回到用户态种执行, 寻找可以处理该异常的异常处理器</span></span><br><span class="line">	hRet = ContinueDebugEvent(debugEvent, dwProcessId, debugEvent, dwThreadId, DBG_CONTINUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取到的DebugEvent的信息如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_DEBUG_INFO</span>&#123;</span></span><br><span class="line">	EXCEPTION_RECORD ExceptionRecord;</span><br><span class="line">	DWORD dwFirstChance;	<span class="comment">//记录了第几次分发</span></span><br><span class="line">&#125; EXCEPTION_DEBUG_INFO *LPEXCEPTION_DEBUG_INFO;</span><br></pre></td></tr></table></figure>
<p>这个当一旦运行就会触发异常断点, 这个异常断点来源于系统断点int3 </p>
<p>系统断点的由来如下 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LdrInitializeThunk </span><br><span class="line">	LdrpInitializeProcess</span><br><span class="line">		DbgBreakPoint()找到LdrpInitializeProcess引用地址</span><br></pre></td></tr></table></figure>
<h3 id="附加进程的方式"><a href="#附加进程的方式" class="headerlink" title="附加进程的方式"></a>附加进程的方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BOOL bRet = TRUE;</span><br><span class="line">BOOL nIsContinue = TRUE;</span><br><span class="line">DEBUG_EVENT debugEvent = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 附加进程</span></span><br><span class="line"><span class="keyword">if</span>(!DebugActiveProcess(GetPorcessId(<span class="string">"进程名字"</span>)))&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调试循环</span></span><br><span class="line"><span class="keyword">while</span>(nIsContinue)&#123;</span><br><span class="line">	<span class="comment">// 判断当debugEvent链表有没有事件,如果有的话则取出来</span></span><br><span class="line">	bRet = WaitForDebugEvent(&amp;debugEvent, INFINITE);</span><br><span class="line">	<span class="keyword">if</span>(!bRet)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"WaitForDebugEvent error:%d\n!"</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span>(debugEvent.dwDebugEventCode)&#123;</span><br><span class="line">		<span class="comment">// 1.异常</span></span><br><span class="line">		<span class="keyword">case</span> EXCEPTION_DEBUG_EVENT:</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.</span></span><br><span class="line">		<span class="keyword">case</span> EXIT_THREAD_DEBUG_EVENT:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"...."</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// DBG_CONTINUE 即表示调试器已处理了该异常</span></span><br><span class="line">	<span class="comment">// DBG_EXCEPTION_NOT_HANDLED 即表示调试器没有处理该异常,转回到用户态种执行, 寻找可以处理该异常的异常处理器</span></span><br><span class="line">	hRet = ContinueDebugEvent(debugEvent, dwProcessId, debugEvent, dwThreadId, DBG_CONTINUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当附加一个进程的时候, 会发送杜撰的假消息<br>你会看到创建进程、创建线程、以及dll的加载各种调试信息都会出现<br>这个消息都是来源于<code>DbgkpPostFakeProcessCreateMessage(发送假的进程创建消息、假的模块加载的消息[遍历了PEB的LDR模块列表]、假的线程创建消息)</code><br>这样保证调试器无论是新创建进程的方式, 还是附加进程的方式, 调试器都想得到这些信息<br>这样调试器都能知道进程加载了多少模块, 调试事件就表明了多少模块, 这样写的目的就是给调试器提供必要的信息, 形成完整的调试形态</p>
<p><br></p>
<h2 id="异常的处理流程"><a href="#异常的处理流程" class="headerlink" title="异常的处理流程"></a>异常的处理流程</h2><h3 id="异常处理的大概"><a href="#异常处理的大概" class="headerlink" title="异常处理的大概"></a>异常处理的大概</h3><p><img src="/2020/10/13/windows-huoge/image-103.png" width="600px"></p>
<p>如果有调试器的话,一旦有异常, 结果对象不是异常流程而是调试流程 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">	__try&#123;</span><br><span class="line">		z = x/y;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"无法执行的代码"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	__except(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"SEH异常处理代码"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个程序以调试的状态在运行, 会先抛给调试器, 而不是异常处理代码 </p>
<p>如果调试器ignore忽略掉这个除0异常, 那么调试器对应的代码Api就是<code>ContinueDebugEvent</code>,代表这个异常会继续找异常处理函数, 如果异常处理函数没有, 则会找到SEH的默认<code>UnhandledExceptionFilter</code>去执行</p>
<p><code>DBG_EXCEPTION_NOT_HANDLE</code>:调试器没有处理该异常,转会到用户态中执行了, 寻找可以处理该异常的异常处理器</p>
<p><code>DBG_CONTINUE</code>:表示调试器已处理了该异常 </p>
<blockquote>
<p>UnhandledExceptionFilter的执行流程 </p>
</blockquote>
<ul>
<li><p>通过NtQueryInformationProcess查询当前进程是否正在被调试, 如果是, 返回EXCEPTION_CONTINUE_SEARCH, 此时会进入第二轮分发 </p>
</li>
<li><p>如果没有被调试</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查询是否通过SetUnhandledExceptionFilter注册处理函数, 如果有就调用</span><br><span class="line">如果没有通过SetUnhandledExceptionFilter注册处理函数, 弹出窗口让用户选择终止程序还是启动即时调试器</span><br><span class="line">如果用户没有启用即时调试器,那么该函数返回EXCEPTION_EXECUTE_HANDLER</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<h2 id="软件断点"><a href="#软件断点" class="headerlink" title="软件断点"></a>软件断点</h2><p>一旦被调试程序触发异常, 就会向DebugObject发送调试事件, 这就是调试的本质 </p>
<p>内存断点和硬件断点无非就是在被调试进程里面想方设法出现异常,所以调试就是异常触发和处理的过程 </p>
<blockquote>
<p>如果我们在调试器中下断点, 它具体实现的流程是怎么样的? </p>
</blockquote>
<p>当在某个代码按F2,就是把代码的汇编改成<code>0xCC</code>就是<code>int 3</code>, 但是调试器为了使用体验更好, 不会在代码上展现出<code>0xCC</code>的汇编指令, 但是内存的确是int3的汇编指令了</p>
<table>
<thead>
<tr>
<th>调试器进程</th>
<th>被调试进程 </th>
</tr>
</thead>
<tbody>
<tr>
<td>1:循环判断</td>
<td>1:CPU检测到INT 3指令</td>
</tr>
<tr>
<td>2:取出调试事件</td>
<td>2:查IDT表中对应的中断处理函数</td>
</tr>
<tr>
<td>3:列出信息<br>寄存器<br>内存</td>
<td>3:CommonDispatchException</td>
</tr>
<tr>
<td>4:用户处理</td>
<td>4:KiDispatchException</td>
</tr>
<tr>
<td>_</td>
<td>5:DbgkForwardException搜集并发送调试事件<br>DbgkpSendApiMessage(x,x)<br>第一个参数:消息结构,每种消息都有自己的消息结构共有7种类型<br>第二个参数:要不要把本进程内除了自己之外的其他线程挂起,有些消息需要把其他线程挂起,比如异常</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h2><p>这个数据进行内存访问的时候, 让程序停下来, 这个时候会用到内存断点 </p>
<h3 id="触发异常-调试器接管异常的过程"><a href="#触发异常-调试器接管异常的过程" class="headerlink" title="触发异常-调试器接管异常的过程"></a>触发异常-调试器接管异常的过程</h3><p><img src="/2020/10/13/windows-huoge/image-102.png" width="600px"></p>
<h3 id="内存断点-1"><a href="#内存断点-1" class="headerlink" title="内存断点"></a>内存断点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">VritualProtectEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hProcess,</span></span></span><br><span class="line"><span class="function"><span class="params">	LPVOID lpAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">	SIZE_T dwSize,</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD flNewProtect,</span></span></span><br><span class="line"><span class="function"><span class="params">	PDWORD lpflOldProtect</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>
<p>将被调试进程的某内存属性修改为</p>
<ul>
<li>PAGE_NOACCESS(PTE)</li>
<li>PAGE_EXECUTE_READ</li>
</ul>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2020/10/13/windows-huoge/';
        this.page.title = 'Windows-x86 内核相关 - 海哥';
        this.page.identifier = '2020/10/13/windows-huoge/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
