<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>STL - 详解笔记 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="STL 重点知识详解笔记
STL版本情况stl是一个框架,将数据结构和算法进一步抽象
容器、迭代器、算法
STL历史
1979年创造C++年代却不支持泛型,第一个支持泛型的是Ada,但Ada在美国国防工业以外未被广泛接受

1987年Alexander开发出Ada Library,接下来看到C++如此火热于是试验了多种架构和算法公式,先以C完成,后再以C++完成

1992年Meng Lee加入了Alex的项目成为早期STL另一位主要贡献者
1993年贝尔实验室的Andrew Koenig在19">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Go/Rust</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">系统内核</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">逆向知识</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">数据库</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#STL版本情况"><span class="toc-number">1.</span> <span class="toc-text">STL版本情况</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#STL历史"><span class="toc-number">1.1.</span> <span class="toc-text">STL历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL六大组件"><span class="toc-number">1.2.</span> <span class="toc-text">STL六大组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GNU开放精神"><span class="toc-number">1.3.</span> <span class="toc-text">GNU开放精神</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#空间配置器-Allocator"><span class="toc-number">2.</span> <span class="toc-text">空间配置器(Allocator)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#迭代器-Iterator"><span class="toc-number">3.</span> <span class="toc-text">迭代器(Iterator)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#容器-Container"><span class="toc-number">4.</span> <span class="toc-text">容器(Container)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#容器通用接口"><span class="toc-number">4.1.</span> <span class="toc-text">容器通用接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#array"><span class="toc-number">4.2.</span> <span class="toc-text">array</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器"><span class="toc-number">4.2.1.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元素访问"><span class="toc-number">4.2.2.</span> <span class="toc-text">元素访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector"><span class="toc-number">4.3.</span> <span class="toc-text">vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化"><span class="toc-number">4.3.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通用接口"><span class="toc-number">4.3.2.</span> <span class="toc-text">通用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#赋值"><span class="toc-number">4.3.3.</span> <span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#交换"><span class="toc-number">4.3.4.</span> <span class="toc-text">交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元素访问-1"><span class="toc-number">4.3.5.</span> <span class="toc-text">元素访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#移除新增"><span class="toc-number">4.3.6.</span> <span class="toc-text">移除新增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器-1"><span class="toc-number">4.3.7.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector异常"><span class="toc-number">4.3.8.</span> <span class="toc-text">vector异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deque"><span class="toc-number">4.4.</span> <span class="toc-text">deque</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通用接口-1"><span class="toc-number">4.4.1.</span> <span class="toc-text">通用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#赋值-1"><span class="toc-number">4.4.2.</span> <span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#交换-1"><span class="toc-number">4.4.3.</span> <span class="toc-text">交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元素访问-2"><span class="toc-number">4.4.4.</span> <span class="toc-text">元素访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#移除新增-1"><span class="toc-number">4.4.5.</span> <span class="toc-text">移除新增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器-2"><span class="toc-number">4.4.6.</span> <span class="toc-text">迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#forward-list"><span class="toc-number">4.5.</span> <span class="toc-text">forward_list</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-number">4.5.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器-3"><span class="toc-number">4.5.2.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新增移除"><span class="toc-number">4.5.3.</span> <span class="toc-text">新增移除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他函数"><span class="toc-number">4.5.4.</span> <span class="toc-text">其他函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法"><span class="toc-number">4.5.5.</span> <span class="toc-text">算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list"><span class="toc-number">4.6.</span> <span class="toc-text">list</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数-1"><span class="toc-number">4.6.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器-4"><span class="toc-number">4.6.2.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新增移除-1"><span class="toc-number">4.6.3.</span> <span class="toc-text">新增移除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他函数-1"><span class="toc-number">4.6.4.</span> <span class="toc-text">其他函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法-1"><span class="toc-number">4.6.5.</span> <span class="toc-text">算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stack"><span class="toc-number">4.7.</span> <span class="toc-text">stack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构"><span class="toc-number">4.7.1.</span> <span class="toc-text">结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queue"><span class="toc-number">4.8.</span> <span class="toc-text">queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构-1"><span class="toc-number">4.8.1.</span> <span class="toc-text">结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priority-queue"><span class="toc-number">4.9.</span> <span class="toc-text">priority_queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#示例"><span class="toc-number">4.9.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set"><span class="toc-number">4.10.</span> <span class="toc-text">set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特点"><span class="toc-number">4.10.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造"><span class="toc-number">4.10.2.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器-5"><span class="toc-number">4.10.3.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法-2"><span class="toc-number">4.10.4.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例-1"><span class="toc-number">4.10.5.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multiset"><span class="toc-number">4.11.</span> <span class="toc-text">multiset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构-2"><span class="toc-number">4.11.1.</span> <span class="toc-text">结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map"><span class="toc-number">4.12.</span> <span class="toc-text">map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特点-1"><span class="toc-number">4.12.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造-1"><span class="toc-number">4.12.2.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器-6"><span class="toc-number">4.12.3.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法-3"><span class="toc-number">4.12.4.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例-2"><span class="toc-number">4.12.5.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multimap"><span class="toc-number">4.13.</span> <span class="toc-text">multimap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介"><span class="toc-number">4.13.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例-3"><span class="toc-number">4.13.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-set"><span class="toc-number">4.14.</span> <span class="toc-text">unordered_set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构-3"><span class="toc-number">4.14.1.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本操作"><span class="toc-number">4.14.2.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例-4"><span class="toc-number">4.14.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-multiset"><span class="toc-number">4.15.</span> <span class="toc-text">unordered_multiset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-1"><span class="toc-number">4.15.1.</span> <span class="toc-text">简介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-map"><span class="toc-number">4.16.</span> <span class="toc-text">unordered_map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-2"><span class="toc-number">4.16.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#带上hash算法"><span class="toc-number">4.16.2.</span> <span class="toc-text">带上hash算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-multimap"><span class="toc-number">4.17.</span> <span class="toc-text">unordered_multimap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-3"><span class="toc-number">4.17.1.</span> <span class="toc-text">简介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tuple"><span class="toc-number">4.18.</span> <span class="toc-text">tuple</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算法-Algorithms"><span class="toc-number">5.</span> <span class="toc-text">算法(Algorithms)</span></a></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            STL - 详解笔记
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/01/25/stl/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-01-25T15:58:10.000Z" itemprop="datePublished">2016-01-25</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/stl/">stl</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>STL 重点知识详解笔记<br><a id="more"></a></p>
<h1 id="STL版本情况"><a href="#STL版本情况" class="headerlink" title="STL版本情况"></a>STL版本情况</h1><p>stl是一个框架,将数据结构和算法进一步抽象</p>
<p>容器、迭代器、算法</p>
<h2 id="STL历史"><a href="#STL历史" class="headerlink" title="STL历史"></a>STL历史</h2><ul>
<li><p>1979年创造C++年代却不支持泛型,第一个支持泛型的是Ada,但Ada在美国国防工业以外未被广泛接受</p>
</li>
<li><p>1987年Alexander开发出Ada Library,接下来看到C++如此火热于是试验了多种架构和算法公式,先以C完成,后再以C++完成</p>
</li>
<li>1992年Meng Lee加入了Alex的项目成为早期STL另一位主要贡献者</li>
<li>1993年贝尔实验室的Andrew Koenig在1993年知道这个研究计划后邀请Alex ander于11月ANSI/ISO c++标准委员会议上展示观念</li>
<li>1994年1月25日Alexander完成了提案报告提交到委员会,3月份在圣地亚哥会议,STL活得很好回响,投票结果压倒性给予提案机会</li>
<li>1998年STL正式成为9月C++标准规格,原本stream,string以template重写</li>
</ul>
<h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><ul>
<li><p>容器(containers):各种数据结构(vector,list,deque,set,map)</p>
<p>用以存放数据</p>
</li>
<li><p>算法(algorithms):常用算法如sort,search,copy,erase(抹去)…..</p>
</li>
<li><p>迭代器(iterators):扮演容器和算法之间的胶合剂,所谓的泛型指针</p>
</li>
<li><p>仿函数(functors):行为类似函数,可作为算法的某种策略</p>
</li>
<li><p>配接器(adapter):一种修饰容器或仿函数或迭代器接口的东西</p>
</li>
<li><p>配置器:负责空间配置与管理</p>
</li>
</ul>
<p><img src="/2016/01/25/stl/image-01.png" width="500px"></p>
<h2 id="GNU开放精神"><a href="#GNU开放精神" class="headerlink" title="GNU开放精神"></a>GNU开放精神</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">全世界所有STL实现版本由Alexander,meng lee完成</span><br><span class="line">这份原始代码由惠普公司拥有,每个头文件都有一份声明</span><br><span class="line">允许任何人运用,拷贝,传播,修改,贩卖这些代码,无需付费</span><br><span class="line">唯一的条件就是必须将该份声明置于使用者新开发的文件内。</span><br></pre></td></tr></table></figure>
<p>这种开源精神就是<code>open source</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此开源精神来源于美国人理察.史托曼,他认为私藏源代码是一种违反人性的罪恶行为</span><br><span class="line">开放分享源代码便可以让其他人从中学习,并回馈给原始作者</span><br></pre></td></tr></table></figure>
<p>GNU 代表<code>GNU is Not Unix</code>,Unix是当时计算机界主流操作系统,由AT&amp;T 贝尔实验室创造,原本只是学术型产品,AT&amp;T将它分享给许多研究人员，但是所有研究使得这个产品越来越美好，于是AT&amp;T开始考虑追加投资并要求不得公开或透露UNIX源代码,想从中获利,并赞助伯克利大学继续强化Unix,导致后来发展成BSD以及FreeBSD,OpenBSD,NetBSD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Unix类操作系统:FreeBSD、Solaris、MacOSX这都属于Unix类操作系统。</span><br><span class="line">确切的说FreeBSD是BSD内核的操作系统</span><br><span class="line">而MacOSX与Solaris都是基于FreeBSD演化而来的操作系统。</span><br><span class="line">Linux操作系统:Linux本身来说不是一个操作系统,而是内核</span><br><span class="line">所有基于linux内核的系统统称为linux</span><br></pre></td></tr></table></figure>
<p>Stallman认为AT&amp;T对大学的赞助只是微薄的施舍,于是进行反奴役计划称之为GNU</p>
<p>GNU早期计划是Gcc和EMacs,一个C/C++编译器,还有一个文本编辑器</p>
<p>GNU计划晚期著名的软件则由1991年芬兰人Linux Torvalds开发的Linux操作系统</p>
<p>GNU以GPL(广泛开放授权)来保护乘员:使用者可以阅读修改GPL软件的源代码,但是使用者要传播借助GPL软件而完成的软件必须遵守GPL规范,这类精神主要强迫人们分享并回馈他们对GPL软件的改善</p>
<p>后期衍生了不同的授权包括:Library GPL,Lesser GPL,Apache License,BSD License等,它们的共同原则就是“开放源代码”</p>
<h1 id="空间配置器-Allocator"><a href="#空间配置器-Allocator" class="headerlink" title="空间配置器(Allocator)"></a>空间配置器(Allocator)</h1><p>隐藏在一切组件背后,默默工作付出</p>
<p>整个STL操作对象都存放容器,容器需要配置空间存放资源</p>
<h1 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h1><p>迭代器扮演重要角色,将数据容器和算法分开彼此独立设计,再以胶合剂撮合一起,class template和function templates可分别达成目标</p>
<h1 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器(Container)"></a>容器(Container)</h1><p>C++ STL 的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1.vector      底层数据结构为数组 ，支持快速随机访问</span><br><span class="line"></span><br><span class="line">2.list            底层数据结构为双向链表，支持快速增删</span><br><span class="line"></span><br><span class="line">3.deque       底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问</span><br><span class="line">deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:</span><br><span class="line">[堆1] --&gt; [堆2] --&gt;[堆3] --&gt; ...</span><br><span class="line">每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.</span><br><span class="line"></span><br><span class="line">4.stack        底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</span><br><span class="line"></span><br><span class="line">5.queue     底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</span><br><span class="line"></span><br><span class="line">（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）</span><br><span class="line"></span><br><span class="line">6.priority_queue     的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</span><br><span class="line"></span><br><span class="line">7.set                   底层数据结构为红黑树，有序，不重复</span><br><span class="line"></span><br><span class="line">8.multiset         底层数据结构为红黑树，有序，可重复 </span><br><span class="line"></span><br><span class="line">9.map                底层数据结构为红黑树，有序，不重复</span><br><span class="line"></span><br><span class="line">10.multimap    底层数据结构为红黑树，有序，可重复</span><br><span class="line"></span><br><span class="line">11.hash_set     底层数据结构为hash表，无序，不重复</span><br><span class="line"></span><br><span class="line">12.hash_multiset 底层数据结构为hash表，无序，可重复 </span><br><span class="line"></span><br><span class="line">13.hash_map    底层数据结构为hash表，无序，不重复</span><br><span class="line"></span><br><span class="line">14.hash_multimap 底层数据结构为hash表，无序，可重复</span><br></pre></td></tr></table></figure>
<ul>
<li><p>序列式容器 </p>
<ul>
<li>array</li>
<li>vector</li>
<li>dequeue</li>
<li>list</li>
<li>forward_list</li>
</ul>
<p>这类都通过数组或者指针链表</p>
</li>
<li><p>关联类容器 </p>
<ul>
<li>set</li>
<li>map</li>
<li>multiset(类似hashset)</li>
<li>multimap(类似hashmap,第三方库已经起好,为避免冲突不起此类名字)</li>
</ul>
<p>关联式都是通过二叉树方式实现,set和map默认都是红黑树</p>
</li>
<li><p>无序容器 </p>
<ul>
<li>unordered_map </li>
<li>unordered_set </li>
<li>unordered_multimap </li>
<li>unordered_multiset</li>
</ul>
<p>无序容器都是通过hash_table,哈希表</p>
</li>
</ul>
<p>其他重要数据结构:stack,queue,priority_queue</p>
<p>字符串string,也是一个container</p>
<p>如果存入是否布尔值可用位集合:bitset</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">regex rand</span><br><span class="line"></span><br><span class="line">thread async future time</span><br></pre></td></tr></table></figure>
<ul>
<li>1:容器可以复制(copy)或者搬移(move)(隐含的条件是在拷贝和搬移的过程中没有副作用)</li>
</ul>
<p>基本数据类型:bool char int double pointer reference function</p>
<ul>
<li><p>2:元素可被赋值操作来复制和搬移</p>
</li>
<li><p>3:元素是可销毁的,析构不能使private,而且析构函数不允许抛出异常</p>
<p>对于序列式容器,元素必须有默认的构造函数</p>
<p>对于某些操作,元素需要定义== std::find</p>
<p>对于关联式容器,排序准则默认是&lt;, &gt; std::less</p>
<p>无顺序容器,必须要提供一个hash函数 也需要==符号</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; stl容器里面存的是元素的值而不是引用?</span><br><span class="line"></span><br><span class="line">bool char int double 基本存的是元素的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 那自己定义的类也是存值而不是引用?</span><br><span class="line"></span><br><span class="line">class Player自定义的类,也要定义==符号,拷贝</span><br><span class="line"></span><br><span class="line">player的大小也大,而且有些信息是独有的</span><br><span class="line"></span><br><span class="line">所以存指针也是ok的,也可以用智能指针存入容器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; stl对于错误怎么处理?</span><br><span class="line"></span><br><span class="line">stl的设计原则是效率优先,安全为次</span><br><span class="line"></span><br><span class="line">异常?stl自己却不怎么采用</span><br><span class="line"></span><br><span class="line">类似vector在移动元素,可能会引发元素的异常,所以具体的异常考虑STL没法考虑全</span><br><span class="line"></span><br><span class="line">还是得靠开发自己以当时处境去处理各自的异常</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li><p>向量(vector)<strong>连续存储的元素<vector></vector></strong></p>
</li>
<li><p><strong>列表(list)</strong>       <strong>由节点组成的双向链表，每个结点包含着一个元素<list></list></strong></p>
</li>
<li><p><strong>双队列(deque)</strong> <strong>连续存储的指向不同元素的指针所组成的数组<deque></deque></strong></p>
</li>
<li><p><strong>集合(set)</strong> <strong>由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序 <set></set></strong></p>
</li>
<li><p><strong>多重集合(multiset)</strong> <strong>允许存在两个次序相等的元素的集合 <set></set></strong></p>
</li>
<li><p><strong>栈(stack)</strong> <strong>后进先出的值的排列 <stack></stack></strong></p>
</li>
<li><p><strong>队列(queue)</strong> <strong>先进先出的执的排列 <queue></queue></strong></p>
</li>
<li><p><strong>优先队列(priority_queue)</strong> <strong>元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列 <queue></queue></strong></p>
</li>
<li><p><strong>映射(map)</strong> <strong>由{**</strong> const 键，值}<strong>**对组成的集合，以某种作用于键对上的谓词排列 <map></map></strong></p>
</li>
<li><p><strong>多重映射(multimap)</strong> <strong>允许键对有相等的次序的映射 <map></map></strong></p>
</li>
</ul>
<h2 id="容器通用接口"><a href="#容器通用接口" class="headerlink" title="容器通用接口"></a>容器通用接口</h2><p>类接口编程通过模板或者类派生</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">tempalte &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">containerAllInterface</span><span class="params">(T &amp;a, T&amp;b)</span></span>&#123;</span><br><span class="line">    T c;</span><br><span class="line">    <span class="function">T <span class="title">d</span><span class="params">(a)</span></span>; <span class="comment">//容器值的构造拷贝,值拷贝过去</span></span><br><span class="line">    T e = a; <span class="comment">//等号值拷贝</span></span><br><span class="line">    T f(std::move(a)); //右值引用 a不存在什么全部迁移到f 不是拷贝</span><br><span class="line">    b.begin(); <span class="comment">//返回迭代器的头</span></span><br><span class="line">    b.end(); <span class="comment">// 返回迭代器的尾</span></span><br><span class="line">    T g(b.begin(), b.end());  //g可以通过迭代器的模式值拷贝出来 </span><br><span class="line"></span><br><span class="line">    b.size();<span class="comment">// 表示当前container的元素数量</span></span><br><span class="line">    <span class="comment">//###############    只有一个forward_list不提供此功能</span></span><br><span class="line">    </span><br><span class="line">    b.empty();<span class="comment">//也不考虑forward_list,等价于return b.size() != 0</span></span><br><span class="line">    b.max_size(); <span class="comment">//最大存储值</span></span><br><span class="line">    <span class="keyword">if</span> (b == c)&#123;</span><br><span class="line">        <span class="comment">//先比较数量,再通过begin迭代器判断值是否一样</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b != c)&#123;</span><br><span class="line">        <span class="comment">//当然如上比较是否不一样等价于 !(b == c)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b &lt; c)&#123;</span><br><span class="line">        <span class="comment">//###############    unordered_set unordered_map无顺序无法进行此类操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    e.swap(g); <span class="comment">//还提供e和g元素互换 </span></span><br><span class="line">    <span class="comment">// std::array对于swap的算法时间复杂度是线性的</span></span><br><span class="line">    <span class="comment">//对于其他container都是O(1)非常高效</span></span><br><span class="line">    </span><br><span class="line">    swap(e, g);<span class="comment">//全局函数 对于其他也是O(1),但是std::array还是线性的</span></span><br><span class="line">    </span><br><span class="line">    e.cbegin();<span class="comment">// 相对于等于 const_iterator(); 等于const引用</span></span><br><span class="line">	e.begin(); <span class="comment">//如果e是const引用那也是const引用的begin，否则就是通常的引用</span></span><br><span class="line">    </span><br><span class="line">    e.cend();<span class="comment">//如上</span></span><br><span class="line">    </span><br><span class="line">    e.clear();<span class="comment">//清空所有元素,调用元素的析构函数</span></span><br><span class="line">    <span class="comment">//###############    std:array也不存在clear</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>array 是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin</td>
<td>返回指向数组容器中第一个元素的迭代器</td>
</tr>
<tr>
<td>end</td>
<td>返回指向数组容器中最后一个元素之后的理论元素的迭代器</td>
</tr>
<tr>
<td>rbegin</td>
<td>返回指向数组容器中最后一个元素的反向迭代器</td>
</tr>
<tr>
<td>rend</td>
<td>返回一个反向迭代器，指向数组中第一个元素之前的理论元素</td>
</tr>
<tr>
<td>cbegin</td>
<td>返回指向数组容器中第一个元素的常量迭代器（const_iterator）</td>
</tr>
<tr>
<td>cend</td>
<td>返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）</td>
</tr>
<tr>
<td>crbegin</td>
<td>返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator）</td>
</tr>
<tr>
<td>crend</td>
<td>返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator）</td>
</tr>
<tr>
<td>size</td>
<td>返回数组容器中元素的数量</td>
</tr>
<tr>
<td>max_size</td>
<td>返回数组容器可容纳的最大元素数</td>
</tr>
<tr>
<td>empty</td>
<td>返回一个布尔值，指示数组容器是否为空</td>
</tr>
<tr>
<td>operator[]</td>
<td>返回容器中第 n（参数）个位置的元素的引用</td>
</tr>
<tr>
<td>at</td>
<td>返回容器中第 n（参数）个位置的元素的引用</td>
</tr>
<tr>
<td>front</td>
<td>返回对容器中第一个元素的引用</td>
</tr>
<tr>
<td>back</td>
<td>返回对容器中最后一个元素的引用</td>
</tr>
<tr>
<td>data</td>
<td>返回指向容器中第一个元素的指针</td>
</tr>
<tr>
<td>fill</td>
<td>用 val（参数）填充数组所有元素</td>
</tr>
<tr>
<td>swap</td>
<td>通过 x（参数）的内容交换数组的内容</td>
</tr>
<tr>
<td>get（array）</td>
<td>形如 <code>std::get&lt;0&gt;(myarray)</code>；传入一个数组容器，返回指定位置元素的引用</td>
</tr>
<tr>
<td>relational operators (array)</td>
<td>形如 <code>arrayA &gt; arrayB</code>；依此比较数组每个元素的大小关系</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arrayPart</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//array实际上是对C/C++语言中原生数组进行封装</span></span><br><span class="line">    <span class="comment">//namespace std&#123;</span></span><br><span class="line">    <span class="comment">// template&lt;typename T, size_t N&gt;</span></span><br><span class="line">    <span class="comment">// class array;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//特点,内存分配在栈上(stack)它利用了C/C++数组, 绝对不会重新分配扩大减少容量,随机访问元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 100&gt; a;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 100&gt; b = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> abc[<span class="number">100</span>]; <span class="comment">//存放的内容没有初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 100&gt; a; <span class="comment">//这里也没有初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 100&gt; b = &#123;&#125;;<span class="comment">//这里初始化100个0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a.size() &lt;&lt; <span class="string">"\n"</span> &lt;&lt; b.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; obj = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 2&gt; obj2 = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"empty:"</span> &lt;&lt; a.empty() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; a.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max_size "</span> &lt;&lt; a.max_size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> data = obj;</span><br><span class="line">    data.swap(obj);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data.begin();</span><br><span class="line">data.end();</span><br><span class="line">data.cbegin(); <span class="comment">//const 迭代器头</span></span><br><span class="line">data.cend(); <span class="comment">//const 迭代器尾</span></span><br><span class="line"></span><br><span class="line">data.rbegin();</span><br><span class="line">data.rend();</span><br><span class="line"><span class="comment">//begin end 从头到尾, r就从end到begin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iterator = data.cbegin(); iterator != data.cend(); iterator ++) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(iterator) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接拿某个元素, array直接取下标</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">char</span>, 100&gt; carr;</span><br><span class="line"><span class="built_in">strcpy</span>(&amp;carr[<span class="number">0</span>], <span class="string">"helloWorld\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, &amp;carr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"front: "</span> &lt;&lt; obj.front() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"back: "</span> &lt;&lt; data.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>array是固定大小,无法进行插入元素操作</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector 是表示可以改变大小的数组的序列容器。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector</td>
<td>构造函数</td>
</tr>
<tr>
<td>~vector</td>
<td>析构函数，销毁容器对象</td>
</tr>
<tr>
<td>operator=</td>
<td>将新内容分配给容器，替换其当前内容，并相应地修改其大小</td>
</tr>
<tr>
<td>begin</td>
<td>返回指向容器中第一个元素的迭代器</td>
</tr>
<tr>
<td>end</td>
<td>返回指向容器中最后一个元素之后的理论元素的迭代器</td>
</tr>
<tr>
<td>rbegin</td>
<td>返回指向容器中最后一个元素的反向迭代器</td>
</tr>
<tr>
<td>rend</td>
<td>返回一个反向迭代器，指向中第一个元素之前的理论元素</td>
</tr>
<tr>
<td>cbegin</td>
<td>返回指向容器中第一个元素的常量迭代器（const_iterator）</td>
</tr>
<tr>
<td>cend</td>
<td>返回指向容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）</td>
</tr>
<tr>
<td>crbegin</td>
<td>返回指向容器中最后一个元素的常量反向迭代器（const_reverse_iterator）</td>
</tr>
<tr>
<td>crend</td>
<td>返回指向容器中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator）</td>
</tr>
<tr>
<td>size</td>
<td>返回容器中元素的数量</td>
</tr>
<tr>
<td>max_size</td>
<td>返回容器可容纳的最大元素数</td>
</tr>
<tr>
<td>resize</td>
<td>调整容器的大小，使其包含 n（参数）个元素</td>
</tr>
<tr>
<td>capacity</td>
<td>返回当前为 vector 分配的存储空间（容量）的大小</td>
</tr>
<tr>
<td>empty</td>
<td>返回 vector 是否为空</td>
</tr>
<tr>
<td>reserve</td>
<td>请求 vector 容量至少足以包含 n（参数）个元素</td>
</tr>
<tr>
<td>shrink_to_fit</td>
<td>要求容器减小其 capacity（容量）以适应其 size（元素数量）</td>
</tr>
<tr>
<td>operator[]</td>
<td>返回容器中第 n（参数）个位置的元素的引用</td>
</tr>
<tr>
<td>at</td>
<td>返回容器中第 n（参数）个位置的元素的引用</td>
</tr>
<tr>
<td>front</td>
<td>返回对容器中第一个元素的引用</td>
</tr>
<tr>
<td>back</td>
<td>返回对容器中最后一个元素的引用</td>
</tr>
<tr>
<td>data</td>
<td>返回指向容器中第一个元素的指针</td>
</tr>
<tr>
<td>assign</td>
<td>将新内容分配给 vector，替换其当前内容，并相应地修改其 size</td>
</tr>
<tr>
<td>push_back</td>
<td>在容器的最后一个元素之后添加一个新元素</td>
</tr>
<tr>
<td>pop_back</td>
<td>删除容器中的最后一个元素，有效地将容器 size 减少一个</td>
</tr>
<tr>
<td>insert</td>
<td>通过在指定位置的元素之前插入新元素来扩展该容器，通过插入元素的数量有效地增加容器大小</td>
</tr>
<tr>
<td>erase</td>
<td>从 vector 中删除单个元素（<code>position</code>）或一系列元素（<code>[first，last)</code>），这有效地减少了被去除的元素的数量，从而破坏了容器的大小</td>
</tr>
<tr>
<td>swap</td>
<td>通过 x（参数）的内容交换容器的内容，x 是另一个类型相同、size 可能不同的 vector 对象</td>
</tr>
<tr>
<td>clear</td>
<td>从 vector 中删除所有的元素（被销毁），留下 size 为 0 的容器</td>
</tr>
<tr>
<td>emplace</td>
<td>通过在 position（参数）位置处插入新元素 args（参数）来扩展容器</td>
</tr>
<tr>
<td>emplace_back</td>
<td>在 vector 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后</td>
</tr>
<tr>
<td>get_allocator</td>
<td>返回与vector关联的构造器对象的副本</td>
</tr>
<tr>
<td>swap(vector)</td>
<td>容器 x（参数）的内容与容器 y（参数）的内容交换。两个容器对象都必须是相同的类型（相同的模板参数），尽管大小可能不同</td>
</tr>
<tr>
<td>relational operators (vector)</td>
<td>形如 <code>vectorA &gt; vectorB</code>；依此比较每个元素的大小关系</td>
</tr>
</tbody>
</table>
<p>vector是c++98中引入的动态数组</p>
<p>特点随机访问元素,末端添加删除元素效率非常高</p>
<p>但是前端和中间效率低下,当超过容器容量会重新分配</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Group = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;;</span><br><span class="line"></span><br><span class="line">Group a;</span><br><span class="line">Group b = a;</span><br><span class="line"><span class="function">Group <span class="title">c</span><span class="params">(a)</span></span>;</span><br><span class="line"><span class="function">Group <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 10个float</span></span><br><span class="line"><span class="function">Group <span class="title">e</span><span class="params">(<span class="number">10</span>, <span class="number">1.0f</span>)</span></span>; <span class="comment">//10个float,每个值是1.0f</span></span><br><span class="line">Group f(e.begin(), e.end());//传入迭代器</span><br><span class="line"><span class="function">Group <span class="title">g</span><span class="params">(&#123;<span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>&#125;)</span></span>;<span class="comment">//c++11初始化的值直接赋值, initialize list</span></span><br><span class="line">Group h = &#123;<span class="number">1.0f</span>, <span class="number">2.0f</span> ,<span class="number">3.0f</span> ,<span class="number">4.0f</span>&#125;;<span class="comment">//c++11初始化的值直接赋值, initialize list</span></span><br></pre></td></tr></table></figure>
<h3 id="通用接口"><a href="#通用接口" class="headerlink" title="通用接口"></a>通用接口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d.empty();</span><br><span class="line">d.size();<span class="comment">//当前的vector中含有元素数量值</span></span><br><span class="line">d.max_size();<span class="comment">//返回容器可容纳的最大元素数</span></span><br><span class="line">d.capacity();<span class="comment">//保证不重分配的情况下最多能装入多少元素</span></span><br><span class="line">d.reserve(<span class="number">100</span>);<span class="comment">//请求 vector 容量至少足以包含 n（参数）个元素</span></span><br><span class="line">d.shrink_to_fit();<span class="comment">//要求容器减小其 capacity（容量）以适应其 size（元素数量）</span></span><br></pre></td></tr></table></figure>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = g;</span><br><span class="line">b.assign(<span class="number">3</span>, <span class="number">1.0f</span>);<span class="comment">// &#123;1.0f, 1.0f, 1.0f&#125;;</span></span><br></pre></td></tr></table></figure>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">b.swap(a); <span class="comment">//vector 高效且不抛出异常,对于container除了array,其他的交换全都是交换指针,把内容全部交换过来</span></span><br><span class="line"><span class="comment">// 类似如下</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> * data;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(A&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* temp = rhs.data;</span><br><span class="line">    rhs.data = data;</span><br><span class="line">    data = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="元素访问-1"><a href="#元素访问-1" class="headerlink" title="元素访问"></a>元素访问</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">0</span>];</span><br><span class="line">b.at(<span class="number">0</span>); <span class="comment">//[]不去检查越界,at会检测是否越界并且抛出out_of_range</span></span><br><span class="line">b.front();<span class="comment">//如果vector是空的情况下,会直接dumped</span></span><br><span class="line"><span class="comment">//array的话会预先分配,所以不会出现这个问题</span></span><br><span class="line">b.back();</span><br><span class="line">b.pop_back();<span class="comment">//移除元素,也要判定是否不为空</span></span><br></pre></td></tr></table></figure>
<h3 id="移除新增"><a href="#移除新增" class="headerlink" title="移除新增"></a>移除新增</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除</span></span><br><span class="line">b.pop_back();<span class="comment">//移除元素,也要判定是否不为空</span></span><br><span class="line">b.erase(b.begin());<span class="comment">//只移除头部,然后返回下一个位置的元素</span></span><br><span class="line">b.erase(b.begin(), b.end()); <span class="comment">//位置区间移除,返回下一个位置的元素</span></span><br><span class="line">b.push_back(<span class="number">1.0f</span>); <span class="comment">//尾部增加</span></span><br><span class="line"></span><br><span class="line">b.insert(b.end(), <span class="number">100.0f</span>);<span class="comment">//在某个位置插入1000.f</span></span><br><span class="line">b.insert(b.end(), <span class="number">10</span>, <span class="number">100.0f</span>);<span class="comment">//在某个位置插入10个1000.f</span></span><br><span class="line">b.insert(b.end(), b.begin(), b.end());<span class="comment">//在某个位置插入一个区间,用拷贝方式复制过来</span></span><br><span class="line"></span><br><span class="line">b.emplace(b.end(), <span class="number">10.f</span>);<span class="comment">//和insert在基本类型上是一样的</span></span><br><span class="line">b.emplace_back(<span class="number">10.0f</span>);<span class="comment">//和push_back在基本类型上是一样</span></span><br><span class="line"></span><br><span class="line">b.resize(<span class="number">10</span>);<span class="comment">// 强行调整大小,如果调小直接干掉数据</span></span><br><span class="line">b.resize(<span class="number">100</span>, <span class="number">1.0f</span>);<span class="comment">//调整vector的大小,默认以1.0f填充</span></span><br><span class="line"></span><br><span class="line">b.clear();<span class="comment">//清空所有元素,并调用元素的析构函数,但是capacity不会变</span></span><br><span class="line">b.shink_to_fit();<span class="comment">//清空元素之后,vector容量也降下来</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data.begin();</span><br><span class="line">data.end();</span><br><span class="line">data.cbegin(); <span class="comment">//const 迭代器头</span></span><br><span class="line">data.cend(); <span class="comment">//const 迭代器尾</span></span><br><span class="line"></span><br><span class="line">data.rbegin();</span><br><span class="line">data.rend();</span><br><span class="line"><span class="comment">//begin end 从头到尾, r就从end到begin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iterator = data.cbegin(); iterator != data.cend(); iterator ++) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(iterator) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="vector异常"><a href="#vector异常" class="headerlink" title="vector异常"></a>vector异常</h3><ul>
<li>push_back发生异常对vector不会变化</li>
<li>pop_back绝对不会出现异常</li>
<li>元素move/copy没有异常的话, erase insert emplace emplace_back push_back不会有异常</li>
<li>swap clear 不会有异常</li>
</ul>
<p>vector不要用bool </p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>deque（[‘dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。</p>
<p><img src="/2016/01/25/stl/image-12.png" width="450px"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deque和vector一样,采用线性表，与vector唯一不同的是，deque采用的分块的线性存储结构</span><br><span class="line">每块大小一般为512字节，称为一个deque块，所有的deque块使用一个Map块进行管理</span><br><span class="line">每个map数据项记录各个deque块的首地址</span><br><span class="line">这样以来，deque块在头部和尾部都可已插入和删除元素，而不需要移动其它元素。</span><br><span class="line"></span><br><span class="line">使用push_back()方法在尾部插入元素，使用push_front()方法在首部插入元素，使用insert()方法在中间插入元素。</span><br><span class="line">一般来说，当考虑容器元素的内存分配策略和操作的性能时，deque相对vectore更有优势。</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>deque</td>
<td>构造函数</td>
</tr>
<tr>
<td>push_back</td>
<td>在当前的最后一个元素之后 ，在 deque 容器的末尾添加一个新元素</td>
</tr>
<tr>
<td>push_front</td>
<td>在 deque 容器的开始位置插入一个新的元素，位于当前的第一个元素之前</td>
</tr>
<tr>
<td>pop_back</td>
<td>删除 deque 容器中的最后一个元素，有效地将容器大小减少一个</td>
</tr>
<tr>
<td>pop_front</td>
<td>删除 deque 容器中的第一个元素，有效地减小其大小</td>
</tr>
<tr>
<td>emplace_front</td>
<td>在 deque 的开头插入一个新的元素，就在其当前的第一个元素之前</td>
</tr>
<tr>
<td>emplace_back</td>
<td>在 deque 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后</td>
</tr>
</tbody>
</table>
<p>deque是c++98引入的动态数组(dynamic array)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespaces <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Allocator = allocator&lt;T&gt;&gt;</span><br><span class="line">    class <span class="built_in">deque</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点随机访问元素</p>
<p>末端和头部添加删除元素效率高,中间删除和添加元素效率低</p>
<p>元素的访问和迭代比vector要慢,迭代器不能使普通的指针</p>
<h3 id="通用接口-1"><a href="#通用接口-1" class="headerlink" title="通用接口"></a>通用接口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d.empty();</span><br><span class="line">d.size();<span class="comment">//当前的vector中含有元素数量值</span></span><br><span class="line">d.max_size();<span class="comment">//返回容器可容纳的最大元素数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不提供以下方法</span></span><br><span class="line"><span class="comment">//d.capacity();</span></span><br><span class="line"><span class="comment">//d.reserve(100);</span></span><br><span class="line">d.shrink_to_fit();<span class="comment">//要求容器减小其 capacity（容量）以适应其 size（元素数量）</span></span><br></pre></td></tr></table></figure>
<h3 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = g;</span><br><span class="line">b.assign(<span class="number">3</span>, <span class="number">1.0f</span>);<span class="comment">// &#123;1.0f, 1.0f, 1.0f&#125;;</span></span><br></pre></td></tr></table></figure>
<h3 id="交换-1"><a href="#交换-1" class="headerlink" title="交换"></a>交换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">b.swap(a); <span class="comment">//类似vector</span></span><br><span class="line"><span class="comment">// 类似如下</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> * data;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(A&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* temp = rhs.data;</span><br><span class="line">    rhs.data = data;</span><br><span class="line">    data = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="元素访问-2"><a href="#元素访问-2" class="headerlink" title="元素访问"></a>元素访问</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">0</span>];</span><br><span class="line">b.at(<span class="number">0</span>); <span class="comment">//[]不去检查越界,at会检测是否越界并且抛出out_of_range</span></span><br><span class="line">b.front();<span class="comment">//如果vector是空的情况下,会直接dumped</span></span><br><span class="line"><span class="comment">//array的话会预先分配,所以不会出现这个问题</span></span><br><span class="line">b.back();</span><br></pre></td></tr></table></figure>
<p>大多数功能和vector类似</p>
<p>deque的clear是释放空间的</p>
<h3 id="移除新增-1"><a href="#移除新增-1" class="headerlink" title="移除新增"></a>移除新增</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除</span></span><br><span class="line">b.pop_back();<span class="comment">//移除元素,也要判定是否不为空</span></span><br><span class="line">b.erase(b.begin());<span class="comment">//只移除头部,然后返回下一个位置的元素</span></span><br><span class="line">b.erase(b.begin(), b.end()); <span class="comment">//位置区间移除,返回下一个位置的元素</span></span><br><span class="line">b.push_back(<span class="number">1.0f</span>); <span class="comment">//尾部增加</span></span><br><span class="line"></span><br><span class="line">b.insert(b.end(), <span class="number">100.0f</span>);<span class="comment">//在某个位置插入1000.f</span></span><br><span class="line">b.insert(b.end(), <span class="number">10</span>, <span class="number">100.0f</span>);<span class="comment">//在某个位置插入10个1000.f</span></span><br><span class="line">b.insert(b.end(), b.begin(), b.end());<span class="comment">//在某个位置插入一个区间,用拷贝方式复制过来</span></span><br><span class="line"></span><br><span class="line">b.emplace(b.end(), <span class="number">10.f</span>);<span class="comment">//和insert在基本类型上是一样的</span></span><br><span class="line">b.emplace_back(<span class="number">10.0f</span>);<span class="comment">//和push_back在基本类型上是一样</span></span><br><span class="line"></span><br><span class="line">b.resize(<span class="number">10</span>);<span class="comment">// 强行调整大小,如果调小直接干掉数据</span></span><br><span class="line">b.resize(<span class="number">100</span>, <span class="number">1.0f</span>);<span class="comment">//调整vector的大小,默认以1.0f填充</span></span><br><span class="line"></span><br><span class="line">b.clear();<span class="comment">//清空所有元素,并调用元素的析构函数,但是capacity不会变</span></span><br><span class="line">b.shink_to_fit();<span class="comment">//清空元素之后,vector容量也降下来</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代器-2"><a href="#迭代器-2" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data.begin();</span><br><span class="line">data.end();</span><br><span class="line">data.cbegin(); <span class="comment">//const 迭代器头</span></span><br><span class="line">data.cend(); <span class="comment">//const 迭代器尾</span></span><br><span class="line"></span><br><span class="line">data.rbegin();</span><br><span class="line">data.rend();</span><br><span class="line"><span class="comment">//begin end 从头到尾, r就从end到begin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iterator = data.cbegin(); iterator != data.cend(); iterator ++) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(iterator) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h2><p>forward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>forward_list</td>
<td>返回指向容器中第一个元素之前的位置的迭代器</td>
</tr>
<tr>
<td>cbefore_begin</td>
<td>返回指向容器中第一个元素之前的位置的 const_iterator</td>
</tr>
</tbody>
</table>
<blockquote>
<p>特点几乎跟list一致,不支持随机访问函数,访问头部速度快</p>
</blockquote>
<p>特点不支持随机访问元素,访问头部元素速度快</p>
<p>forward_list和自己手写的C-style singly linked list相比</p>
<p>没有任何时间和空间上的额外开销,任何性质如果和这个目标抵触,我们放弃该特征</p>
<p>任何位置插入删除元素都很快,常量时间完成</p>
<p>插入和删除不会造成迭代器失效</p>
<p>对于异常支持的好,出现异常对于forward_list而言,要不成功,要不什么影响没有</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Group = <span class="built_in">std</span>::forward_list&lt;<span class="keyword">float</span>&gt;;</span><br><span class="line">Group a;</span><br><span class="line">Group b = a;</span><br><span class="line"><span class="function">Group <span class="title">c</span><span class="params">(a)</span></span>;</span><br><span class="line"><span class="function">Group <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 10个float</span></span><br><span class="line"><span class="function">Group <span class="title">e</span><span class="params">(<span class="number">10</span>, <span class="number">1.0f</span>)</span></span>; <span class="comment">//10个float,每个值是1.0f</span></span><br><span class="line">Group f(e.begin(), e.end());//传入迭代器</span><br><span class="line"><span class="function">Group <span class="title">g</span><span class="params">(&#123;<span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>&#125;)</span></span>;<span class="comment">//c++11初始化的值直接赋值, initialize list</span></span><br><span class="line">Group h = &#123;<span class="number">1.0f</span>, <span class="number">2.0f</span> ,<span class="number">3.0f</span> ,<span class="number">4.0f</span>&#125;;<span class="comment">//c++11初始化的值直接赋值, initialize list</span></span><br><span class="line"></span><br><span class="line">d.empty();</span><br><span class="line"><span class="comment">//d.size();不支持,如果维护一个计数,导致空间或时间上的额外开销,与目标抵触,所以放弃此特征</span></span><br><span class="line">d.max_size();</span><br><span class="line"></span><br><span class="line">b = g;</span><br><span class="line">b.assign(<span class="number">3</span>, <span class="number">1.0f</span>);<span class="comment">// &#123;1.0f, 1.0f, 1.0f&#125;;</span></span><br><span class="line">b.assign(g.begin(), g.end());</span><br><span class="line">b.assign(&#123;<span class="number">1.0f</span>, <span class="number">2.0f</span> ,<span class="number">3.0f</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//b[0]; b.at(0);不支持</span></span><br><span class="line">b.front();</span><br><span class="line"><span class="comment">//b.back();不支持</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代器-3"><a href="#迭代器-3" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">data.begin();</span><br><span class="line">data.end();</span><br><span class="line">data.cbegin(); <span class="comment">//const 迭代器头</span></span><br><span class="line">data.cend(); <span class="comment">//const 迭代器尾</span></span><br><span class="line"></span><br><span class="line">data.before_begin();<span class="comment">//返回指向第一个元素的前面位置 不是合法位置</span></span><br><span class="line">data.cbefore_begin();<span class="comment">//返回const第一个元素有效的前面位置 不是合法位置</span></span><br><span class="line"><span class="comment">//这些只为了自身的算法</span></span><br><span class="line"><span class="comment">//auto iter = a.before_begin();</span></span><br><span class="line"><span class="comment">// *iter //undenfined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//data.rbegin();不支持不提供</span></span><br><span class="line"><span class="comment">//data.rend();不支持不提供</span></span><br><span class="line"><span class="comment">//begin end 从头到尾, r就从end到begin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iterator = data.cbegin(); iterator != data.cend(); iterator ++) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(iterator) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="新增移除"><a href="#新增移除" class="headerlink" title="新增移除"></a>新增移除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除</span></span><br><span class="line">b.pop_back();<span class="comment">//移除元素,也要判定是否不为空</span></span><br><span class="line"></span><br><span class="line">b.erase_after(b.before_begin());<span class="comment">//只移除头部,然后返回下一个位置的元素</span></span><br><span class="line">b.erase_after(b.before_begin(), b.end());<span class="comment">//位置区间移除,返回下一个位置的元素</span></span><br><span class="line"></span><br><span class="line">b.push_back(<span class="number">1.0f</span>); <span class="comment">//尾部增加</span></span><br><span class="line"></span><br><span class="line">b.insert_after(b.before_begin(), <span class="number">100.0f</span>);<span class="comment">//在某个位置插入1000.f</span></span><br><span class="line">b.insert_after(b.before_begin(), <span class="number">10</span>, <span class="number">100.0f</span>);<span class="comment">//在某个位置插入10个1000.f</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b.emplace(b.end(), <span class="number">10.f</span>);<span class="comment">//和insert在基本类型上是一样的</span></span><br><span class="line">b.emplace_back(<span class="number">10.0f</span>);<span class="comment">//和push_back在基本类型上是一样</span></span><br><span class="line"></span><br><span class="line">b.resize(<span class="number">10</span>);<span class="comment">// 强行调整大小,如果调小直接干掉数据</span></span><br><span class="line">b.resize(<span class="number">100</span>, <span class="number">1.0f</span>);<span class="comment">//调整vector的大小,默认以1.0f填充</span></span><br><span class="line"></span><br><span class="line">b.clear();<span class="comment">//清空所有元素,并调用元素的析构函数,但是capacity不会变</span></span><br><span class="line">b.shink_to_fit();<span class="comment">//清空元素之后,vector容量也降下来</span></span><br></pre></td></tr></table></figure>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iterBegin = a.begin();</span><br><span class="line"><span class="built_in">std</span>::advance(iterBegin, <span class="number">4</span>);<span class="comment">//iterBegin移动4步</span></span><br><span class="line"></span><br><span class="line">a.pop_back();</span><br><span class="line"><span class="keyword">if</span>(!a.empty())a.pop_back();</span><br><span class="line"></span><br><span class="line">b.push_back(<span class="number">10.0f</span>);</span><br><span class="line">b.pop_back();</span><br><span class="line">b.push_front(<span class="number">1.2f</span>);</span><br><span class="line">b.emplace_front(<span class="number">1.3f</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> iter = b.insert(b.end(), <span class="number">100.0f</span>);</span><br><span class="line">iter = b.insert(b.end(), <span class="number">10</span>, <span class="number">-10.0f</span>);</span><br><span class="line">b.insert(b.end(), h.begin(), h.end());</span><br><span class="line">b.emplace(b.end(), <span class="number">10.0f</span>);</span><br><span class="line">b.emplace_back(<span class="number">10.0f</span>);</span><br><span class="line">b.resize(<span class="number">10</span>);</span><br><span class="line">b.resize(<span class="number">100</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">b.remove(<span class="number">1.0f</span>);</span><br><span class="line">b.remove_if([](<span class="keyword">auto</span> v(<span class="keyword">return</span> v &gt; <span class="number">100.0f</span>;)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.reverse(); 不支持逆转 1 2 3 4 -&gt; 4 3 2 1</span></span><br><span class="line">b.sort();<span class="comment">// 不支持&lt; 排序</span></span><br><span class="line">b.merge(g); <span class="comment">//合并</span></span><br><span class="line"></span><br><span class="line">b.unique();<span class="comment">//需要排好序的 去重 附近重复的去掉</span></span><br><span class="line"><span class="comment">// 1 1 2 3 3 4 -&gt; 1 2 3 4</span></span><br><span class="line"><span class="comment">// 1 1 2 2 1 1  3 4 -&gt; 1 2 1 3 4</span></span><br><span class="line"></span><br><span class="line">b.splice(c.begin(), b);<span class="comment">//把b的一块插入到c的某个位置上</span></span><br></pre></td></tr></table></figure>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>list，双向链表，是序列容器，允许在序列中的任何地方进行常数时间插入和擦除操作，并在两个方向上进行迭代。</p>
<p>c++98引入,双向串联</p>
<p>不支持随机访问函数,访问头部和尾部速度快</p>
<p>在任何位置插入删除元素都很快,常量时间完成</p>
<p>插入和删除不会造成迭代器失效</p>
<p>对于异常支持的好,出现异常对于list而言,要不成功,要不什么影响没有</p>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Group = <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">float</span>&gt;;</span><br><span class="line">Group a;</span><br><span class="line">Group b = a;</span><br><span class="line"><span class="function">Group <span class="title">c</span><span class="params">(a)</span></span>;</span><br><span class="line"><span class="function">Group <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 10个float</span></span><br><span class="line"><span class="function">Group <span class="title">e</span><span class="params">(<span class="number">10</span>, <span class="number">1.0f</span>)</span></span>; <span class="comment">//10个float,每个值是1.0f</span></span><br><span class="line">Group f(e.begin(), e.end());//传入迭代器</span><br><span class="line"><span class="function">Group <span class="title">g</span><span class="params">(&#123;<span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>&#125;)</span></span>;<span class="comment">//c++11初始化的值直接赋值, initialize list</span></span><br><span class="line">Group h = &#123;<span class="number">1.0f</span>, <span class="number">2.0f</span> ,<span class="number">3.0f</span> ,<span class="number">4.0f</span>&#125;;<span class="comment">//c++11初始化的值直接赋值, initialize list</span></span><br><span class="line"></span><br><span class="line">d.empty();</span><br><span class="line">d.size();</span><br><span class="line">d.max_size();</span><br><span class="line"></span><br><span class="line">b = g;</span><br><span class="line">b.assign(<span class="number">3</span>, <span class="number">1.0f</span>);<span class="comment">// &#123;1.0f, 1.0f, 1.0f&#125;;</span></span><br><span class="line">b.assign(g.begin(), g.end());</span><br><span class="line">b.assign(&#123;<span class="number">1.0f</span>, <span class="number">2.0f</span> ,<span class="number">3.0f</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//b[0]; b.at(0);不支持</span></span><br><span class="line">b.front();</span><br><span class="line">b.back();</span><br></pre></td></tr></table></figure>
<h3 id="迭代器-4"><a href="#迭代器-4" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data.begin();</span><br><span class="line">data.end();</span><br><span class="line">data.cbegin(); <span class="comment">//const 迭代器头</span></span><br><span class="line">data.cend(); <span class="comment">//const 迭代器尾</span></span><br><span class="line"></span><br><span class="line">data.rbegin();</span><br><span class="line">data.rend();</span><br><span class="line"><span class="comment">//begin end 从头到尾, r就从end到begin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iterator = data.cbegin(); iterator != data.cend(); iterator ++) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(iterator) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="新增移除-1"><a href="#新增移除-1" class="headerlink" title="新增移除"></a>新增移除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除</span></span><br><span class="line">b.pop_back();<span class="comment">//移除元素,也要判定是否不为空</span></span><br><span class="line">b.erase(b.begin());<span class="comment">//只移除头部,然后返回下一个位置的元素</span></span><br><span class="line">b.erase(b.begin(), b.end()); <span class="comment">//位置区间移除,返回下一个位置的元素</span></span><br><span class="line">b.push_back(<span class="number">1.0f</span>); <span class="comment">//尾部增加</span></span><br><span class="line"></span><br><span class="line">b.insert(b.end(), <span class="number">100.0f</span>);<span class="comment">//在某个位置插入1000.f</span></span><br><span class="line">b.insert(b.end(), <span class="number">10</span>, <span class="number">100.0f</span>);<span class="comment">//在某个位置插入10个1000.f</span></span><br><span class="line">b.insert(b.end(), b.begin(), b.end());<span class="comment">//在某个位置插入一个区间,用拷贝方式复制过来</span></span><br><span class="line"></span><br><span class="line">b.emplace(b.end(), <span class="number">10.f</span>);<span class="comment">//和insert在基本类型上是一样的</span></span><br><span class="line">b.emplace_back(<span class="number">10.0f</span>);<span class="comment">//和push_back在基本类型上是一样</span></span><br><span class="line"></span><br><span class="line">b.resize(<span class="number">10</span>);<span class="comment">// 强行调整大小,如果调小直接干掉数据</span></span><br><span class="line">b.resize(<span class="number">100</span>, <span class="number">1.0f</span>);<span class="comment">//调整vector的大小,默认以1.0f填充</span></span><br><span class="line"></span><br><span class="line">b.clear();<span class="comment">//清空所有元素,并调用元素的析构函数,但是capacity不会变</span></span><br><span class="line">b.shink_to_fit();<span class="comment">//清空元素之后,vector容量也降下来</span></span><br></pre></td></tr></table></figure>
<h3 id="其他函数-1"><a href="#其他函数-1" class="headerlink" title="其他函数"></a>其他函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iterBegin = a.begin();</span><br><span class="line"><span class="built_in">std</span>::advance(iterBegin, <span class="number">4</span>);<span class="comment">//iterBegin移动4步</span></span><br><span class="line"></span><br><span class="line">a.pop_back();</span><br><span class="line"><span class="keyword">if</span>(!a.empty())a.pop_back();</span><br><span class="line"></span><br><span class="line">b.push_back(<span class="number">10.0f</span>);</span><br><span class="line">b.pop_back();</span><br><span class="line">b.push_front(<span class="number">1.2f</span>);</span><br><span class="line">b.emplace_front(<span class="number">1.3f</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> iter = b.insert(b.end(), <span class="number">100.0f</span>);</span><br><span class="line">iter = b.insert(b.end(), <span class="number">10</span>, <span class="number">-10.0f</span>);</span><br><span class="line">b.insert(b.end(), h.begin(), h.end());</span><br><span class="line">b.emplace(b.end(), <span class="number">10.0f</span>);</span><br><span class="line">b.emplace_back(<span class="number">10.0f</span>);</span><br><span class="line">b.resize(<span class="number">10</span>);</span><br><span class="line">b.resize(<span class="number">100</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>
<h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">b.remove(<span class="number">1.0f</span>);</span><br><span class="line">b.remove_if([](<span class="keyword">auto</span> v(<span class="keyword">return</span> v &gt; <span class="number">100.0f</span>;)));</span><br><span class="line"></span><br><span class="line">b.reverse();<span class="comment">//逆转 1 2 3 4 -&gt; 4 3 2 1</span></span><br><span class="line">b.sort();<span class="comment">// &lt; 排序</span></span><br><span class="line">b.merge(g); <span class="comment">//合并</span></span><br><span class="line"></span><br><span class="line">b.unique();<span class="comment">//需要排好序的 去重 附近重复的去掉</span></span><br><span class="line"><span class="comment">// 1 1 2 3 3 4 -&gt; 1 2 3 4</span></span><br><span class="line"><span class="comment">// 1 1 2 2 1 1  3 4 -&gt; 1 2 1 3 4</span></span><br><span class="line"></span><br><span class="line">b.splice(c.begin(), b);<span class="comment">//把b的一块插入到c的某个位置上</span></span><br></pre></td></tr></table></figure>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>stack 是一种容器适配器，用于在LIFO（后进先出）的操作，其中元素仅从容器的一端插入和提取。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2016/01/25/stl/image-14.png" width="450px"></p>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>queue 是一种容器适配器，用于在FIFO（先入先出）的操作，其中元素插入到容器的一端并从另一端提取。</p>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2016/01/25/stl/image-15.png" width="450px"></p>
<p>queue有入队push（插入）、出队pop（删除）、读取队首元素front、读取队尾元素back、empty，size这几种方法</p>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p><img src="/2016/01/25/stl/image-15.png" width="450px"></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line"></span><br><span class="line">    pq.push(<span class="number">1</span>);</span><br><span class="line">    pq.push(<span class="number">3</span>);</span><br><span class="line">    pq.push(<span class="number">2</span>);</span><br><span class="line">    pq.push(<span class="number">8</span>);</span><br><span class="line">    pq.push(<span class="number">9</span>);</span><br><span class="line">    pq.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; pq.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pq.empty() != <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pq.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set 是按照特定顺序存储唯一元素的容器。</p>
<p>是c++98的二叉树数据结构,红黑树结构</p>
<p><img src="/2016/01/25/stl/image-09.png" width="450px"></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>元素自动排序</p>
</li>
<li><p>插入和删除查找,O(logN) 1000次查找只需要20</p>
</li>
<li><p>元素必须支持严格的弱顺序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1: x &lt; y == true, y &lt; x == false</span></span><br><span class="line"><span class="comment">//2: X &lt; Y == true, y &lt; z ==true, x &lt; z == true</span></span><br><span class="line"><span class="comment">//3: x &lt; x == false</span></span><br><span class="line"><span class="comment">//4: a == b, b == c, c == a</span></span><br><span class="line"><span class="comment">//不能改变元素的值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>辅助类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pair</span>&#123;</span></span><br><span class="line">        T1 first,</span><br><span class="line">        T2 second,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Group = <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">float</span>&gt;;</span><br><span class="line">Group a;</span><br><span class="line">Group b = a;</span><br><span class="line"><span class="function">Group <span class="title">c</span><span class="params">(a)</span></span>;</span><br><span class="line">Group d(c.begin(), c.end());</span><br><span class="line"><span class="function">Group <span class="title">g</span><span class="params">(&#123;<span class="number">1.0f</span>, <span class="number">4.0f</span>, <span class="number">3.0f</span>&#125;)</span></span>;</span><br><span class="line"><span class="comment">// 1.0f 3.0f 4.0f</span></span><br><span class="line">Group h = &#123;<span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>&#125;;</span><br><span class="line"></span><br><span class="line">d.empty();</span><br><span class="line">d.size();</span><br><span class="line">d.max_size();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> keycomp = c.key_comp();</span><br><span class="line"><span class="keyword">auto</span> valuecomp = c.value_comp();</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">b = g;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line">b.swap(a);</span><br><span class="line"><span class="built_in">std</span>::swap(a, b);</span><br></pre></td></tr></table></figure>
<h3 id="迭代器-5"><a href="#迭代器-5" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line">a.begin();</span><br><span class="line">a.end();</span><br><span class="line">a.cbegin();</span><br><span class="line">a.cend();</span><br><span class="line">a.rbegin();</span><br><span class="line">a.rend();</span><br><span class="line">a.crbegin();</span><br><span class="line">a.crend();</span><br></pre></td></tr></table></figure>
<h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法</span></span><br><span class="line"><span class="comment">//数量查找</span></span><br><span class="line"><span class="comment">// set count 0 不存在, 1 存在这样的值 ,同样类型的值只保留一个</span></span><br><span class="line"><span class="comment">// multiset count &gt;= 0 , 会找多个与set不同</span></span><br><span class="line"><span class="keyword">auto</span> num = a.count(<span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//find 寻找  迭代器返回</span></span><br><span class="line"><span class="keyword">auto</span> findIter = a.find(<span class="number">1.0f</span>);</span><br><span class="line"><span class="keyword">if</span> (findIter == a.end())&#123;</span><br><span class="line"><span class="comment">//not find</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//find</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *findIter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> lower = a.lower_bound(<span class="number">1.0f</span>); <span class="comment">//返回低端部分,比如插入1.0f,lower_bound的位置,能不能插入成功不一定</span></span><br><span class="line"><span class="keyword">if</span>(lower != a.end())&#123;</span><br><span class="line">    <span class="keyword">if</span>(*lower == <span class="number">1.0f</span>)&#123;</span><br><span class="line">	    <span class="comment">// has 1.0f</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说白了就是 &gt;= 的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> high = a.upper_bound(<span class="number">1.0f</span>); <span class="comment">//返回高端部分,最后一个可插入点</span></span><br><span class="line"><span class="comment">//而upper_bound就是 &gt; 的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> range = a.equal_range(<span class="number">1.0f</span>); </span><br><span class="line"><span class="comment">//而equal_range返回的是pair,一个是lower,一个是upper</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> eraseIter = b.erase(b.begin());</span><br><span class="line">eraseIter = b.erase(b.begin(), b.end());</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> state = b.insert(<span class="number">100.0f</span>); <span class="comment">//返回一个pari,&lt;Iterator,bool&gt;</span></span><br><span class="line"><span class="comment">//第一个迭代器,第二个布尔值</span></span><br><span class="line"><span class="keyword">auto</span> insertIter = b.insert(c.begin(), c.end());</span><br><span class="line">b.emplace(<span class="number">10.0f</span>);</span><br><span class="line">b.emplace_hint(b.end(), <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2016/01/25/stl/image-6.png" width="450px"></p>
<p><img src="/2016/01/25/stl/image-61.png" width="450px"></p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><img src="/2016/01/25/stl/image-02.png" width="450px"></p>
<p><img src="/2016/01/25/stl/image-03.png" width="450px"></p>
<p><img src="/2016/01/25/stl/image-04.png" width="450px"></p>
<h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h2><p>是c++98的二叉树数据结构</p>
<h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="/2016/01/25/stl/image-10.png" width="450px"></p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。红黑树结构</p>
<p><img src="/2016/01/25/stl/image-11.png" width="450px"></p>
<p>set，multisets，map，multimap使用相同的内部结构，因此可以将set和multiset当成特殊的map和multimap，只不过set的value和key指向的是同一元素</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>map</td>
<td>构造函数</td>
</tr>
<tr>
<td>begin</td>
<td>返回引用容器中第一个元素的迭代器</td>
</tr>
<tr>
<td>key_comp</td>
<td>返回容器用于比较键的比较对象的副本</td>
</tr>
<tr>
<td>value_comp</td>
<td>返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前</td>
</tr>
<tr>
<td>find</td>
<td>在容器中搜索具有等于 k（参数）的键的元素，如果找到则返回一个迭代器，否则返回 map::end 的迭代器</td>
</tr>
<tr>
<td>count</td>
<td>在容器中搜索具有等于 k（参数）的键的元素，并返回匹配的数量</td>
</tr>
<tr>
<td>lower_bound</td>
<td>返回一个非递减序列 <code>[first, last)</code>（参数）中的第一个大于等于值 val（参数）的位置的迭代器</td>
</tr>
<tr>
<td>upper_bound</td>
<td>返回一个非递减序列 <code>[first, last)</code>（参数）中第一个大于 val（参数）的位置的迭代器</td>
</tr>
<tr>
<td>equal_range</td>
<td>获取相同元素的范围，返回包含容器中所有具有与 k（参数）等价的键的元素的范围边界（<code>pair&lt; map&lt;char,int&gt;::iterator, map&lt;char,int&gt;::iterator &gt;</code>）</td>
</tr>
</tbody>
</table>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p><img src="/2016/01/25/stl/image-05.png" width="450px"></p>
<p>key是const的key</p>
<h3 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h3><p><img src="/2016/01/25/stl/image-06.png" width="450px"></p>
<h3 id="迭代器-6"><a href="#迭代器-6" class="headerlink" title="迭代器"></a>迭代器</h3><p><img src="/2016/01/25/stl/image-07.png" width="450px"></p>
<h3 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h3><p><img src="/2016/01/25/stl/image-08.png" width="450px"></p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cont/mapl.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/*create map/associative array</span></span><br><span class="line"><span class="comment">    *-keys are strings</span></span><br><span class="line"><span class="comment">    *-values are floats</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">float</span>&gt; StringFloatMap;</span><br><span class="line"></span><br><span class="line">   StringFloatMap stocks;      <span class="comment">// create empty container</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//insert some elements</span></span><br><span class="line">   stocks[<span class="string">"BASF"</span>] = <span class="number">369.50</span>;</span><br><span class="line">   stocks[<span class="string">"VW"</span>] = <span class="number">413.50</span>;</span><br><span class="line">   stocks[<span class="string">"Daimler"</span>] = <span class="number">819.00</span>;</span><br><span class="line">   stocks[<span class="string">"BMW"</span>] = <span class="number">834.00</span>;</span><br><span class="line">   stocks[<span class="string">"Siemens"</span>] = <span class="number">842.20</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//print all elements</span></span><br><span class="line">   StringFloatMap::iterator pos;</span><br><span class="line">   <span class="keyword">for</span> (pos = stocks.begin(); pos != stocks.end(); ++pos) &#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"stock: "</span> &lt;&lt; pos-&gt;first &lt;&lt; <span class="string">"\t"</span></span><br><span class="line">            &lt;&lt; <span class="string">"price: "</span> &lt;&lt; pos-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//boom (all prices doubled)</span></span><br><span class="line">   <span class="keyword">for</span> (pos = stocks.begin(); pos != stocks.end(); ++pos) &#123;</span><br><span class="line">       pos-&gt;second *= <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//print all elements</span></span><br><span class="line">   <span class="keyword">for</span> (pos = stocks.begin(); pos != stocks.end(); ++pos) &#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"stock: "</span> &lt;&lt; pos-&gt;first &lt;&lt; <span class="string">"\t"</span></span><br><span class="line">            &lt;&lt; <span class="string">"price: "</span> &lt;&lt; pos-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*rename key from "VW" to "Volkswagen"</span></span><br><span class="line"><span class="comment">    *-only provided by exchanging element</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   stocks[<span class="string">"Volkswagen"</span>] = stocks[<span class="string">"VW"</span>];</span><br><span class="line">   stocks.erase(<span class="string">"VW"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//print all elements</span></span><br><span class="line">   <span class="keyword">for</span> (pos = stocks.begin(); pos != stocks.end(); ++pos) &#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"stock: "</span> &lt;&lt; pos-&gt;first &lt;&lt; <span class="string">"\t"</span></span><br><span class="line">            &lt;&lt; <span class="string">"price: "</span> &lt;&lt; pos-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stock: BASF price: 369.5</span><br><span class="line">stock: BMW price: 834</span><br><span class="line">stock: Daimler price: 819</span><br><span class="line">stock: Siemens price: 842.2</span><br><span class="line">stock: VW price: 413.5</span><br><span class="line"></span><br><span class="line">stock: BASF price: 739</span><br><span class="line">stock: BMW price: 1668</span><br><span class="line">stock: Daimler price: 1638</span><br><span class="line">stock: Siemens price: 1684.4</span><br><span class="line">stock: VW price: 827</span><br><span class="line"></span><br><span class="line">stock: BASF price: 739</span><br><span class="line">stock: BMW price: 1668</span><br><span class="line">stock: Daimler price: 1638</span><br><span class="line">stock: Siemens price: 1684.4</span><br><span class="line">stock: Volkswagen price: 827</span><br></pre></td></tr></table></figure>
<h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>C++ stl  Multimap 和C++ stl  map 很相似，但是MultiMap允许重复的元素。</p>
<p>　map和multimap会根据key对元素进行自动排序，所以根据key值搜寻某个元素具有良好的性能，但是如果根据value来搜寻效率就很低了。</p>
<p>同样，自动排序使得你不能直接改变元素的key，因为这样会破坏正确次序，要修改元素的key，必须先移除拥有key的元素，然后插入拥有新的key/value的元素，从迭代器的观点来看，元素的key是常数，元素的value是可以直接修改的。</p>
<p>C++ stl  Multimap的基本操作类成员函数列表介绍如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">begin()返回指向第一个元素的迭代器</span><br><span class="line">clear()删除所有元素</span><br><span class="line"></span><br><span class="line">count()返回一个元素出现的次数</span><br><span class="line"></span><br><span class="line">empty()如果<span class="built_in">multimap</span>为空则返回真</span><br><span class="line"></span><br><span class="line">end()返回一个指向<span class="built_in">multimap</span>末尾的迭代器</span><br><span class="line"></span><br><span class="line">equal_range()返回指向元素的key为指定值的迭代器对</span><br><span class="line"></span><br><span class="line">erase()删除元素</span><br><span class="line"></span><br><span class="line">find()查找元素</span><br><span class="line"></span><br><span class="line">get_allocator()返回<span class="built_in">multimap</span>的配置器</span><br><span class="line"></span><br><span class="line">insert()插入元素</span><br><span class="line"></span><br><span class="line">key_comp()返回比较key的函数</span><br><span class="line"></span><br><span class="line">lower_bound()返回键值&gt;=给定元素的第一个位置</span><br><span class="line"></span><br><span class="line">max_size()返回可以容纳的最大元素个数</span><br><span class="line"></span><br><span class="line">rbegin()返回一个指向mulitmap尾部的逆向迭代器</span><br><span class="line"></span><br><span class="line">rend()返回一个指向<span class="built_in">multimap</span>头部的逆向迭代器</span><br><span class="line"></span><br><span class="line">size()返回<span class="built_in">multimap</span>中元素的个数</span><br><span class="line"></span><br><span class="line">swap()交换两个multimaps</span><br><span class="line"></span><br><span class="line">upper_bound()返回键值&gt;给定元素的第一个位置</span><br><span class="line"></span><br><span class="line">value_comp()返回比较元素value的函数</span><br></pre></td></tr></table></figure>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cont/mmap1.cpp</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="comment">//define multimap type as string/string dictionary</span></span><br><span class="line">     <span class="keyword">typedef</span> <span class="built_in">multimap</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; StrStrMMap;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//create empty dictionary</span></span><br><span class="line">     StrStrMMap dict;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//insert some elements in random order</span></span><br><span class="line">     dict.insert(make_pair(<span class="string">"day"</span>,<span class="string">"Tag"</span>));</span><br><span class="line">     dict.insert(make_pair(<span class="string">"strange"</span>,<span class="string">"fremd"</span>));</span><br><span class="line">     dict.insert(make_pair(<span class="string">"car"</span>,<span class="string">"Auto"</span>));</span><br><span class="line">     dict.insert(make_pair(<span class="string">"smart"</span>,<span class="string">"elegant"</span>));</span><br><span class="line">     dict.insert(make_pair(<span class="string">"trait"</span>,<span class="string">"Merkmal"</span>));</span><br><span class="line">     dict.insert(make_pair(<span class="string">"strange"</span>,<span class="string">"seltsam"</span>));</span><br><span class="line">     dict.insert(make_pair(<span class="string">"smart"</span>,<span class="string">"raffiniert"</span>));</span><br><span class="line">     dict.insert(make_pair(<span class="string">"smart"</span>,<span class="string">"klug"</span>));</span><br><span class="line">     dict.insert(make_pair(<span class="string">"clever"</span>,<span class="string">"raffiniert"</span>));</span><br><span class="line"></span><br><span class="line">     <span class="comment">//print all elements</span></span><br><span class="line">     StrStrMMap::iterator pos;</span><br><span class="line">     <span class="built_in">cout</span>.setf (ios::left, ios::adjustfield);</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; <span class="string">"english "</span></span><br><span class="line">          &lt;&lt; <span class="string">"german "</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; setfil(<span class="string">'-'</span>) &lt;&lt; setw(<span class="number">20</span>) &lt;&lt; <span class="string">""</span></span><br><span class="line">          &lt;&lt; setfil(<span class="string">' '</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">for</span> (pos = dict.begin(); pos != dict.end(); ++pos) &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; pos&gt;first.c_str()</span><br><span class="line">              &lt;&lt; pos-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//print all values for key "smart"</span></span><br><span class="line">     <span class="function"><span class="built_in">string</span> <span class="title">word</span><span class="params">(<span class="string">"smart"</span>)</span></span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="string">": "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (pos = dict.lower_bound(word);</span><br><span class="line">          pos != dict.upper_bound(word); ++pos) &#123;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; pos-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//print all keys for value "raffiniert"</span></span><br><span class="line">     word = (<span class="string">"raffiniert"</span>);</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="string">": "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">for</span> (pos = dict.begin(); pos != dict.end(); ++pos) &#123;</span><br><span class="line">         <span class="keyword">if</span> (pos-&gt;second == word) &#123;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; pos-&gt;first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">english   german</span><br><span class="line">--------------------</span><br><span class="line">car       Auto</span><br><span class="line">clever    raffiniert</span><br><span class="line">day       Tag</span><br><span class="line">smart     elegant</span><br><span class="line">smart     raffiniert</span><br><span class="line">smart     klug</span><br><span class="line">strange   fremd</span><br><span class="line">strange   seltsam</span><br><span class="line">trait     Merkmal</span><br><span class="line"></span><br><span class="line">smart:</span><br><span class="line">	elegant</span><br><span class="line">raffiniert</span><br><span class="line">	klug</span><br><span class="line">raffiniert:</span><br><span class="line">	clever</span><br><span class="line">	smart</span><br></pre></td></tr></table></figure>
<h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><p>unordered_set与与unordered_map相似</p>
<p>unordered_set它的实现基于hashtable,它的结构图仍然可以用下图表示,这时的空白格不在是单个value,而是set中的key与value的数据包</p>
<p>有unordered_set就一定有unordered_multiset.跟set和multiset一样,一个key可以重复一个不可以</p>
<h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="/2016/01/25/stl/image-17.png" width="450px"></p>
<p>unordered_set是一种无序集合,既然跟底层实现基于hashtable那么它一定拥有快速的查找和删除，添加的优点.基于hashtable当然就失去了基于rb_tree的自动排序功能</p>
<p>unordered_set无序,所以在迭代器的使用上,set的效率会高于unordered_set</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; c1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//operator=</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; c2;</span><br><span class="line">c2 = c1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line">c1.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素个数 size()</span></span><br><span class="line">c1.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取最大存储量 max_size()</span></span><br><span class="line">c1.max_size();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回头迭代器 begin()</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::iterator ite_begin = c1.begin();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回尾迭代器 end()</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::iterator ite_end = c1.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回const头迭代器 cbegin()</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::const_iterator const_ite_begin = c1.cbegin();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回const尾迭代器 cend()</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::const_iterator const_ite_end = c1.cend();</span><br><span class="line"></span><br><span class="line"><span class="comment">//槽迭代器</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::local_iterator local_iter_begin = c1.begin(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::local_iterator local_iter_end = c1.end(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找函数 find() 通过给定主键查找元素</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::iterator find_iter = c1.find(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//value出现的次数 count() 返回匹配给定主键的元素的个数</span></span><br><span class="line">    c1.count(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回元素在哪个区域equal_range() 返回值匹配给定搜索值的元素组成的范围</span></span><br><span class="line">pair&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt; pair_equal_range = c1.equal_range(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入函数 emplace()</span></span><br><span class="line">c1.emplace(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入函数 emplace_hint() 使用迭代器</span></span><br><span class="line">c1.emplace_hint(ite_begin, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入函数 insert()</span></span><br><span class="line">c1.insert(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 erase()</span></span><br><span class="line">c1.erase(<span class="number">1</span>);<span class="comment">//1.迭代器 value 区域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空 clear()</span></span><br><span class="line">c1.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换 swap()</span></span><br><span class="line">c1.swap(c2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//篮子操作 篮子个数 bucket_count() 返回槽（Bucket）数</span></span><br><span class="line">c1.bucket_count();</span><br><span class="line"></span><br><span class="line"><span class="comment">//篮子最大数量 max_bucket_count() 返回最大槽数</span></span><br><span class="line">c1.max_bucket_count();</span><br><span class="line"></span><br><span class="line"><span class="comment">//篮子个数 bucket_size() 返回槽大小</span></span><br><span class="line">c1.bucket_size(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回篮子 bucket() 返回元素所在槽的序号</span></span><br><span class="line">c1.bucket(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    load_factor    返回载入因子，即一个元素槽（Bucket）的最大元素数</span></span><br><span class="line">c1.load_factor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//    max_load_factor    返回或设置最大载入因子</span></span><br><span class="line">c1.max_load_factor();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    rehash    设置槽数</span></span><br><span class="line">c1.rehash(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    reserve    请求改变容器容量</span></span><br><span class="line">c1.reserve(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//hash_function() 返回与hash_func相同功能的函数指针</span></span><br><span class="line"><span class="keyword">auto</span> hash_func_test = c1.hash_function();</span><br><span class="line"></span><br><span class="line"><span class="comment">//key_eq() 返回比较key值得函数指针</span></span><br><span class="line"><span class="keyword">auto</span> key_eq_test = c1.key_eq();</span><br></pre></td></tr></table></figure>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> wzj001&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">coutUnorderedSet</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&amp; m, <span class="built_in">string</span> funcName)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; funcName &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="keyword">for</span> ( it = m.begin(); it != m.end(); it++ )</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initUnorderSet</span><span class="params">(<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            tmp.insert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">turnBoolToString</span><span class="params">(<span class="keyword">bool</span> tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tmp ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basicOperationUnorderedSet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//定义</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">        <span class="comment">// 普通插入,返回pair&lt;迭代器,插入是否成功&gt;</span></span><br><span class="line">        pair&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; c_insert = c.insert(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"指向key的迭代器: "</span> &lt;&lt; *c_insert.first  &lt;&lt; <span class="string">"   插入是否成功 "</span>&lt;&lt; turnBoolToString(c_insert.second)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        pair&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; c_insert2 = c.insert(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"指向key的迭代器: "</span> &lt;&lt; *c_insert2.first &lt;&lt; <span class="string">"   插入是否成功 "</span>&lt;&lt; turnBoolToString(c_insert2.second)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        pair&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; c_insert3 = c.insert(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"指向key的迭代器: "</span> &lt;&lt; *c_insert3.first &lt;&lt; <span class="string">"   插入是否成功 "</span>&lt;&lt; turnBoolToString(c_insert3.second)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//按指定区域插入</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; c_insert_region;</span><br><span class="line">        c_insert_region.insert(c.begin(), c.end());</span><br><span class="line">        coutUnorderedSet(c_insert_region, <span class="string">"按指定区域插入"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//构造插入</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; c_emplace;</span><br><span class="line">        c_emplace.emplace(<span class="number">1</span>);</span><br><span class="line">        c_emplace.emplace(<span class="number">2</span>);</span><br><span class="line">        c_emplace.emplace(<span class="number">3</span>);</span><br><span class="line">        coutUnorderedSet(c_emplace, <span class="string">"构造插入"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//迭代器插入</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; c_emplace_hint;</span><br><span class="line">        c_emplace_hint.emplace_hint(c_emplace_hint.begin(), <span class="number">1</span>);</span><br><span class="line">        c_emplace_hint.emplace_hint(c_emplace_hint.begin(), <span class="number">2</span>);</span><br><span class="line">        c_emplace_hint.emplace_hint(c_emplace_hint.begin(), <span class="number">3</span>);</span><br><span class="line">        coutUnorderedSet(c_emplace_hint, <span class="string">"迭代器插入"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; c_erase;</span><br><span class="line">        initUnorderSet(c_erase);</span><br><span class="line">        coutUnorderedSet(c_erase, <span class="string">"初始化c_erase"</span>);</span><br><span class="line">        <span class="comment">//指定位置删除</span></span><br><span class="line">        c_erase.erase(c_erase.begin());</span><br><span class="line">        coutUnorderedSet(c_erase, <span class="string">"指定位置删除"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//指定key删除</span></span><br><span class="line">        c_erase.erase(<span class="number">8</span>);</span><br><span class="line">        coutUnorderedSet(c_erase, <span class="string">"指定key删除"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//指定区域删除</span></span><br><span class="line">        c_erase.erase(c_erase.begin(), c_erase.end());</span><br><span class="line">        coutUnorderedSet(c_erase, <span class="string">"指定区域删除"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        c.swap(c_emplace);</span><br><span class="line">        coutUnorderedSet(c, <span class="string">"交换"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unorderSetElementLookup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//查找</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; c_find;</span><br><span class="line">        initUnorderSet(c_find);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::iterator find_iter = c_find.find(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(find_iter != c_find.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; <span class="string">"找到元素 : "</span>&lt;&lt; *find_iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; <span class="string">"没找到 !"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"value出现次数 :"</span> &lt;&lt;c_find.count(<span class="number">1</span>)&lt;&lt; <span class="built_in">endl</span>; <span class="comment">//set key不可重复</span></span><br><span class="line">        </span><br><span class="line">        pair&lt;<span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt; tmp = c_find.equal_range(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(tmp.first != c_find.end()&amp;&amp; tmp.second != c_find.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"该值所在区间为["</span> &lt;&lt; *tmp.first &lt;&lt; <span class="string">","</span> &lt;&lt; *tmp.second &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unorderSetBuckets</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//篮子操作</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; c_buckets;</span><br><span class="line">        initUnorderSet(c_buckets);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"篮子个数: "</span>    &lt;&lt; c_buckets.bucket_count()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"篮子大小: "</span> &lt;&lt; c_buckets.bucket_size(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"最大篮子个数: "</span> &lt;&lt; c_buckets.max_bucket_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"该值所在篮子序号: "</span> &lt;&lt; c_buckets.bucket(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unorderSetHashPolicy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; c_;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"负载: "</span>&lt;&lt; c_.load_factor()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        initUnorderSet(c_);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"负载: "</span>&lt;&lt; c_.load_factor()&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//使用的篮子数/篮子总数  默认的篮子数为11</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"最大负载: "</span>&lt;&lt; c_.max_load_factor() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        c_.reserve(<span class="number">100</span>);<span class="comment">//预设篮子数 ,但是还没有设定</span></span><br><span class="line">        c_.rehash(<span class="number">3</span>);<span class="comment">//设定篮子数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unorderSetObservers</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; c_;</span><br><span class="line">        initUnorderSet(c_);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::hasher xxx = c_.hash_function();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::key_equal zzz = c_.key_eq();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"hash_func: "</span> &lt;&lt; xxx(<span class="number">11111</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"key_eq: "</span> &lt;&lt; turnBoolToString(zzz(<span class="number">11111</span>,<span class="number">11111</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wzj001::basicOperationUnorderedSet();</span><br><span class="line">    wzj001::unorderSetElementLookup();</span><br><span class="line">    wzj001::unorderSetBuckets();</span><br><span class="line">    wzj001::unorderSetHashPolicy();</span><br><span class="line">    wzj001::unorderSetObservers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="unordered-multiset"><a href="#unordered-multiset" class="headerlink" title="unordered_multiset"></a>unordered_multiset</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>不排序的关联容器类，key和value为相同值，key不需要唯一。支持forward迭代器。</p>
<h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>unordered_set、unodered_multiset、unordered_map、unodered_multimap都是无序容器，都是以哈希表实现的。</p>
<p>因为用了hashtable所以查找,插入,删除时间复杂为1</p>
<p>效率惊人</p>
<p>元素是无序的,如果是要按照一定顺序遍历则不能提供</p>
<p>可能空间使用上会比红黑树之前的map用的多一点</p>
<p>元素在一千万以下set的性能不能unordered_set,但是基于一千万以上<br>unordered_set性能却不如set,因为key会用重复,所以要调整</p>
<p>一般存玩家信息和玩家物品能达到百万级已经不得了,如果得顺序不需要建议还是用上unordered无序容器 </p>
<p><img src="/2016/01/25/stl/image-18.png" width="400px"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Group = <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span> <span class="built_in">std</span>::<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="带上hash算法"><a href="#带上hash算法" class="headerlink" title="带上hash算法"></a>带上hash算法</h3><p><img src="/2016/01/25/stl/image-19.png" width="400px"></p>
<p>需要做个模板特化</p>
<p><img src="/2016/01/25/stl/image-20.png" width="400px"></p>
<p>要带上这个hash</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    tempate&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;Position&gt;&#123;</span></span><br><span class="line">        <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> Position&amp; p)<span class="keyword">const</span>&#123;</span><br><span class="line">            <span class="comment">//return p.x() + p.y();</span></span><br><span class="line">            <span class="comment">//(0, 4) (1, 3)</span></span><br><span class="line">            <span class="comment">//(2, 2),(3, 1)</span></span><br><span class="line">            <span class="comment">//return hash(p.x())^hash(p.y());</span></span><br><span class="line">            <span class="comment">//两个int做hash然后异或</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> key = hash&lt;<span class="keyword">int</span>&gt;(p.x());</span><br><span class="line">            hash_combine(key, p.y());</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">            <span class="comment">//这样的hash冲突较小,boost库的实现</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="unordered-multimap"><a href="#unordered-multimap" class="headerlink" title="unordered_multimap"></a>unordered_multimap</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>unordered_set、unodered_multiset、unordered_map、unodered_multimap都是无序容器，都是以哈希表实现的。</p>
<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。</p>
<h1 id="算法-Algorithms"><a href="#算法-Algorithms" class="headerlink" title="算法(Algorithms)"></a>算法(Algorithms)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单查找算法，要求输入迭代器（input iterator）</span></span><br><span class="line">find(beg, end, val); <span class="comment">// 返回一个迭代器，指向输入序列中第一个等于 val 的元素，未找到返回 end</span></span><br><span class="line">find_if(beg, end, unaryPred); <span class="comment">// 返回一个迭代器，指向第一个满足 unaryPred 的元素，未找到返回 end</span></span><br><span class="line">find_if_not(beg, end, unaryPred); <span class="comment">// 返回一个迭代器，指向第一个令 unaryPred 为 false 的元素，未找到返回 end</span></span><br><span class="line">count(beg, end, val); <span class="comment">// 返回一个计数器，指出 val 出现了多少次</span></span><br><span class="line">count_if(beg, end, unaryPred); <span class="comment">// 统计有多少个元素满足 unaryPred</span></span><br><span class="line">all_of(beg, end, unaryPred); <span class="comment">// 返回一个 bool 值，判断是否所有元素都满足 unaryPred</span></span><br><span class="line">any_of(beg, end, unaryPred); <span class="comment">// 返回一个 bool 值，判断是否任意（存在）一个元素满足 unaryPred</span></span><br><span class="line">none_of(beg, end, unaryPred); <span class="comment">// 返回一个 bool 值，判断是否所有元素都不满足 unaryPred</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找重复值的算法，传入向前迭代器（forward iterator）</span></span><br><span class="line">adjacent_find(beg, end); <span class="comment">// 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 end</span></span><br><span class="line">adjacent_find(beg, end, binaryPred); <span class="comment">// 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 end</span></span><br><span class="line">search_n(beg, end, count, val); <span class="comment">// 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 end</span></span><br><span class="line">search_n(beg, end, count, val, binaryPred); <span class="comment">// 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找子序列算法，除 find_first_of（前两个输入迭代器，后两个前向迭代器） 外，都要求两个前向迭代器</span></span><br><span class="line">search(beg1, end1, beg2, end2); <span class="comment">// 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1</span></span><br><span class="line">search(beg1, end1, beg2, end2, binaryPred); <span class="comment">// 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1</span></span><br><span class="line">find_first_of(beg1, end1, beg2, end2); <span class="comment">// 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1</span></span><br><span class="line">find_first_of(beg1, end1, beg2, end2, binaryPred); <span class="comment">// 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1</span></span><br><span class="line">find_end(beg1, end1, beg2, end2); <span class="comment">// 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1</span></span><br><span class="line">find_end(beg1, end1, beg2, end2, binaryPred); <span class="comment">// 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他只读算法，传入输入迭代器</span></span><br><span class="line">for_each(beg, end, unaryOp); <span class="comment">// 对输入序列中的每个元素应用可调用对象 unaryOp，unaryOp 的返回值被忽略</span></span><br><span class="line">mismatch(beg1, end1, beg2); <span class="comment">// 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素</span></span><br><span class="line">mismatch(beg1, end1, beg2, binaryPred); <span class="comment">// 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素</span></span><br><span class="line">equal(beg1, end1, beg2); <span class="comment">// 比较每个元素，确定两个序列是否相等。</span></span><br><span class="line">equal(beg1, end1, beg2, binaryPred); <span class="comment">// 比较每个元素，确定两个序列是否相等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分搜索算法，传入前向迭代器或随机访问迭代器（random-access iterator），要求序列中的元素已经是有序的。通过小于运算符（&lt;）或 comp 比较操作实现比较。</span></span><br><span class="line">lower_bound(beg, end, val); <span class="comment">// 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 end</span></span><br><span class="line">lower_bound(beg, end, val, comp); <span class="comment">// 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 end</span></span><br><span class="line">upper_bound(beg, end, val); <span class="comment">// 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 end</span></span><br><span class="line">upper_bound(beg, end, val, comp); <span class="comment">// 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 end</span></span><br><span class="line">equal_range(beg, end, val); <span class="comment">// 返回一个 pair，其 first 成员是 lower_bound 返回的迭代器，其 second 成员是 upper_bound 返回的迭代器</span></span><br><span class="line">binary_search(beg, end, val); <span class="comment">// 返回一个 bool 值，指出序列中是否包含等于 val 的元素。对于两个值 x 和 y，当 x 不小于 y 且 y 也不小于 x 时，认为它们相等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只写不读算法，要求输出迭代器（output iterator）</span></span><br><span class="line">fill(beg, end, val); <span class="comment">// 将 val 赋予每个元素，返回 void</span></span><br><span class="line">fill_n(beg, cnt, val); <span class="comment">// 将 val 赋予 cnt 个元素，返回指向写入到输出序列最有一个元素之后位置的迭代器</span></span><br><span class="line">genetate(beg, end, Gen); <span class="comment">// 每次调用 Gen() 生成不同的值赋予每个序列，返回 void</span></span><br><span class="line">genetate_n(beg, cnt, Gen); <span class="comment">// 每次调用 Gen() 生成不同的值赋予 cnt 个序列，返回指向写入到输出序列最有一个元素之后位置的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用输入迭代器的写算法，读取一个输入序列，将值写入到一个输出序列（dest）中</span></span><br><span class="line">copy(beg, end, dest); <span class="comment">// 从输入范围将元素拷贝所有元素到 dest 指定定的目的序列</span></span><br><span class="line">copy_if(beg, end, dest, unaryPred); <span class="comment">// 从输入范围将元素拷贝满足 unaryPred 的元素到 dest 指定定的目的序列</span></span><br><span class="line">copy_n(beg, n, dest); <span class="comment">// 从输入范围将元素拷贝前 n 个元素到 dest 指定定的目的序列</span></span><br><span class="line">move(beg, end, dest); <span class="comment">// 对输入序列中的每个元素调用 std::move，将其移动到迭代器 dest 开始始的序列中</span></span><br><span class="line">transform(beg, end, dest, unaryOp); <span class="comment">// 调用给定操作（一元操作），并将结果写到dest中</span></span><br><span class="line">transform(beg, end, beg2, dest, binaryOp); <span class="comment">// 调用给定操作（二元操作），并将结果写到dest中</span></span><br><span class="line">replace_copy(beg, end, dest, old_val, new_val); <span class="comment">// 将每个元素拷贝到 dest，将等于 old_val 的的元素替换为 new_val</span></span><br><span class="line">replace_copy_if(beg, end, dest, unaryPred, new_val); <span class="comment">// 将每个元素拷贝到 dest，将满足 unaryPred 的的元素替换为 new_val</span></span><br><span class="line">merge(beg1, end1, beg2, end2, dest); <span class="comment">// 两个输入序列必须都是有序的，用 &lt; 运算符将合并后的序列写入到 dest 中</span></span><br><span class="line">merge(beg1, end1, beg2, end2, dest, comp); <span class="comment">// 两个输入序列必须都是有序的，使用给定的比较操作（comp）将合并后的序列写入到 dest 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前向迭代器的写算法，要求前向迭代器</span></span><br><span class="line">iter_swap(iter1, iter2); <span class="comment">// 交换 iter1 和 iter2 所表示的元素，返回 void</span></span><br><span class="line">swap_ranges(beg1, end1, beg2); <span class="comment">// 将输入范围中所有元素与 beg2 开始的第二个序列中所有元素进行交换。返回递增后的的 beg2，指向最后一个交换元素之后的位置。</span></span><br><span class="line">replace(beg, end, old_val, new_val); <span class="comment">// 用 new_val 替换等于 old_val 的每个匹配元素</span></span><br><span class="line">replace_if(beg, end, unaryPred, new_val); <span class="comment">// 用 new_val 替换满足 unaryPred 的每个匹配元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用双向迭代器的写算法，要求双向选代器（bidirectional iterator）</span></span><br><span class="line">copy_backward(beg, end, dest); <span class="comment">// 从输入范围中拷贝元素到指定目的位置。如果范围为空,则返回值为 dest；否则，返回值表示从 *beg 中拷贝或移动的元素。</span></span><br><span class="line">move_backward(beg, end, dest);  <span class="comment">// 从输入范围中移动元素到指定目的位置。如果范围为空,则返回值为 dest；否则,返回值表示从 *beg 中拷贝或移动的元素。</span></span><br><span class="line">inplace_merge(beg, mid, end); <span class="comment">// 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用 &lt; 比较元素。</span></span><br><span class="line">inplace_merge(beg, mid, end, comp); <span class="comment">// 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用给定的 comp 操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 划分算法，要求双向选代器（bidirectional iterator）</span></span><br><span class="line">is_partitioned(beg, end, unaryPred); <span class="comment">// 如果所有满足谓词 unaryPred 的元素都在不满足 unarypred 的元素之前，则返回 true。若序列为空，也返回 true</span></span><br><span class="line">partition_copy(beg, end, dest1, dest2, unaryPred); <span class="comment">// 将满足 unaryPred 的元素拷贝到到 dest1，并将不满足 unaryPred 的元素拷贝到到 dest2。返回一个迭代器 pair，其 first 成员表示拷贝到 dest1 的的元素的末尾，second 表示拷贝到 dest2 的元素的末尾。</span></span><br><span class="line">partitioned_point(beg, end, unaryPred); <span class="comment">// 输入序列必须是已经用 unaryPred 划分过的。返回满足  unaryPred 的范围的尾后迭代器。如果返回的迭代器不是 end，则它指向的元素及其后的元素必须都不满足 unaryPred</span></span><br><span class="line">stable_partition(beg, end, unaryPred); <span class="comment">// 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 beg</span></span><br><span class="line">partition(beg, end, unaryPred); <span class="comment">// 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 beg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序算法，要求随机访问迭代器（random-access iterator）</span></span><br><span class="line">sort(beg, end); <span class="comment">// 排序整个范围</span></span><br><span class="line">stable_sort(beg, end); <span class="comment">// 排序整个范围（稳定排序）</span></span><br><span class="line">sort(beg, end, comp); <span class="comment">// 排序整个范围</span></span><br><span class="line">stable_sort(beg, end, comp); <span class="comment">// 排序整个范围（稳定排序）</span></span><br><span class="line">is_sorted(beg, end); <span class="comment">// 返回一个 bool 值，指出整个输入序列是否有序</span></span><br><span class="line">is_sorted(beg, end, comp); <span class="comment">// 返回一个 bool 值，指出整个输入序列是否有序</span></span><br><span class="line">is_sorted_until(beg, end); <span class="comment">// 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器</span></span><br><span class="line">is_sorted_until(beg, end, comp); <span class="comment">// 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器</span></span><br><span class="line">partial_sort(beg, mid, end); <span class="comment">// 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置</span></span><br><span class="line">partial_sort(beg, mid, end, comp); <span class="comment">// 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置</span></span><br><span class="line">partial_sort_copy(beg, end, destBeg, destEnd); <span class="comment">// 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中</span></span><br><span class="line">partial_sort_copy(beg, end, destBeg, destEnd, comp); <span class="comment">// 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中</span></span><br><span class="line">nth_element(beg, nth, end); <span class="comment">// nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它</span></span><br><span class="line">nth_element(beg, nth, end, comp); <span class="comment">// nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前向迭代器的重排算法。普通版本在输入序列自身内部重拍元素，_copy 版本完成重拍后写入到指定目的序列中，而不改变输入序列</span></span><br><span class="line">remove(beg, end, val); <span class="comment">// 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span></span><br><span class="line">remove_if(beg, end, unaryPred); <span class="comment">// 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span></span><br><span class="line">remove_copy(beg, end, dest, val); <span class="comment">// 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span></span><br><span class="line">remove_copy_if(beg, end, dest, unaryPred); <span class="comment">// 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span></span><br><span class="line">unique(beg, end); <span class="comment">// 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span></span><br><span class="line">unique (beg, end, binaryPred); <span class="comment">// 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span></span><br><span class="line">unique_copy(beg, end, dest); <span class="comment">// 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span></span><br><span class="line">unique_copy_if(beg, end, dest, binaryPred); <span class="comment">// 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span></span><br><span class="line">rotate(beg, mid, end); <span class="comment">// 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素</span></span><br><span class="line">rotate_copy(beg, mid, end, dest); <span class="comment">// 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用双向迭代器的重排算法</span></span><br><span class="line">reverse(beg, end); <span class="comment">// 翻转序列中的元素，返回 void</span></span><br><span class="line">reverse_copy(beg, end, dest);; <span class="comment">// 翻转序列中的元素，返回一个迭代器，指向拷贝到目的序列的元素的尾后位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用随机访问迭代器的重排算法</span></span><br><span class="line">random_shuffle(beg, end); <span class="comment">// 混洗输入序列中的元素，返回 void</span></span><br><span class="line">random_shuffle(beg, end, rand); <span class="comment">// 混洗输入序列中的元素，rand 接受一个正整数的随机对象，返回 void</span></span><br><span class="line">shuffle(beg, end, Uniform_rand); <span class="comment">// 混洗输入序列中的元素，Uniform_rand 必须满足均匀分布随机数生成器的要求，返回 void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小值和最大值，使用 &lt; 运算符或给定的比较操作 comp 进行比较</span></span><br><span class="line">min(val1, va12); <span class="comment">// 返回 val1 和 val2 中的最小值，两个实参的类型必须完全一致。参数和返回类型都是 const的引引用，意味着对象不会被拷贝。下略</span></span><br><span class="line">min(val1, val2, comp);</span><br><span class="line">min(init_list);</span><br><span class="line">min(init_list, comp);</span><br><span class="line">max(val1, val2);</span><br><span class="line">max(val1, val2, comp);</span><br><span class="line">max(init_list);</span><br><span class="line">max(init_list, comp);</span><br><span class="line">minmax(val1, val2); <span class="comment">// 返回一个 pair，其 first 成员为提供的值中的较小者，second 成员为较大者。下略</span></span><br><span class="line">minmax(vall, val2, comp);</span><br><span class="line">minmax(init_list);</span><br><span class="line">minmax(init_list, comp);</span><br><span class="line">min_element(beg, end); <span class="comment">// 返回指向输入序列中最小元素的迭代器</span></span><br><span class="line">min_element(beg, end, comp); <span class="comment">// 返回指向输入序列中最小元素的迭代器</span></span><br><span class="line">max_element(beg, end); <span class="comment">// 返回指向输入序列中最大元素的迭代器</span></span><br><span class="line">max_element(beg, end, comp); <span class="comment">// 返回指向输入序列中最大元素的迭代器</span></span><br><span class="line">minmax_element(beg, end); <span class="comment">// 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素</span></span><br><span class="line">minmax_element(beg, end, comp); <span class="comment">// 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典序比较，根据第一对不相等的元素的相对大小来返回结果。如果第一个序列在字典序中小于第二个序列，则返回 true。否则，返回 fa1se。如果个序列比另一个短，且所有元素都与较长序列的对应元素相等，则较短序列在字典序中更小。如果序列长度相等，且对应元素都相等，则在字典序中任何一个都不大于另外一个。</span></span><br><span class="line">lexicographical_compare(beg1, end1, beg2, end2);</span><br><span class="line">lexicographical_compare(beg1, end1, beg2, end2, comp);</span><br></pre></td></tr></table></figure>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2016/01/25/stl/';
        this.page.title = 'STL - 详解笔记';
        this.page.identifier = '2016/01/25/stl/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
