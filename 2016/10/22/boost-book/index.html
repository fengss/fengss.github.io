<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Boost相关知识点 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="Boost库编程相关详解笔记 
历史1998年,Deman G.Dawes(C++标准委员会成员之一)发起倡议并建立了Boost社区
目的是向C++程序员提供免费、同行审查、可移植的高质量C++源程序库
Bost发布采用Boost Software License不同于GPL，Apache的非常宽松许可证,允许用户将boost用于任何用途,既鼓励商业用途,也鼓励非商业用途,用户无须之父任何费用,不收任何限制享用Boost全部功能
结构123456789101112accumlators //累加">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Go/Rust</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">系统内核</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">逆向知识</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">数据库</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#历史"><span class="toc-number">1.</span> <span class="toc-text">历史</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#结构"><span class="toc-number">1.1.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链接方式"><span class="toc-number">1.2.</span> <span class="toc-text">链接方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#时间日期"><span class="toc-number">2.</span> <span class="toc-text">时间日期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#timer库"><span class="toc-number">2.1.</span> <span class="toc-text">timer库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#timer"><span class="toc-number">2.1.1.</span> <span class="toc-text">timer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#progress-timer"><span class="toc-number">2.1.2.</span> <span class="toc-text">progress_timer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#progress-display"><span class="toc-number">2.1.3.</span> <span class="toc-text">progress_display</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#date-time库"><span class="toc-number">2.2.</span> <span class="toc-text">date_time库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#日期"><span class="toc-number">2.2.1.</span> <span class="toc-text">日期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#访日日期"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">访日日期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#日期的输出"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">日期的输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#日期长度"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">日期长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#日期运算"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">日期运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#日期区间"><span class="toc-number">2.2.1.5.</span> <span class="toc-text">日期区间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#日期迭代器"><span class="toc-number">2.2.1.6.</span> <span class="toc-text">日期迭代器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间"><span class="toc-number">2.2.2.</span> <span class="toc-text">时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#操作时间长度"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">操作时间长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间长度精确度"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">时间长度精确度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建时间点"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">创建时间点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#操作时间点"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">操作时间点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间迭代器"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">时间迭代器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存管理"><span class="toc-number">3.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#智能指针简介"><span class="toc-number">3.1.</span> <span class="toc-text">智能指针简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scoped-ptr"><span class="toc-number">3.2.</span> <span class="toc-text">scoped_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用法"><span class="toc-number">3.2.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr区别"><span class="toc-number">3.2.2.</span> <span class="toc-text">unique_ptr区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scoped-array"><span class="toc-number">3.3.</span> <span class="toc-text">scoped_array</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用法-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr区别-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">unique_ptr区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shared-ptr"><span class="toc-number">3.4.</span> <span class="toc-text">shared_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#运用"><span class="toc-number">3.4.1.</span> <span class="toc-text">运用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工厂函数"><span class="toc-number">3.4.2.</span> <span class="toc-text">工厂函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用于标准容器"><span class="toc-number">3.4.3.</span> <span class="toc-text">应用于标准容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用于桥接模式"><span class="toc-number">3.4.4.</span> <span class="toc-text">应用于桥接模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用于工厂模式"><span class="toc-number">3.4.5.</span> <span class="toc-text">应用于工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除容器"><span class="toc-number">3.4.6.</span> <span class="toc-text">删除容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#别名构造函数"><span class="toc-number">3.4.7.</span> <span class="toc-text">别名构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shared-array"><span class="toc-number">3.5.</span> <span class="toc-text">shared_array</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#应用"><span class="toc-number">3.5.1.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weak-ptr"><span class="toc-number">3.6.</span> <span class="toc-text">weak_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用法-2"><span class="toc-number">3.6.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enable-shared-from-this"><span class="toc-number">3.6.2.</span> <span class="toc-text">enable_shared_from_this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enable-shared-from-raw"><span class="toc-number">3.6.3.</span> <span class="toc-text">enable_shared_from_raw</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打破循环引用"><span class="toc-number">3.6.4.</span> <span class="toc-text">打破循环引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#intrusive-ptr"><span class="toc-number">3.7.</span> <span class="toc-text">intrusive_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用法-3"><span class="toc-number">3.7.1.</span> <span class="toc-text">用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pool库"><span class="toc-number">3.8.</span> <span class="toc-text">pool库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pool"><span class="toc-number">3.8.1.</span> <span class="toc-text">pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#object-pool"><span class="toc-number">3.8.2.</span> <span class="toc-text">object_pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#singleton-pool"><span class="toc-number">3.8.3.</span> <span class="toc-text">singleton_pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pool-alloc"><span class="toc-number">3.8.4.</span> <span class="toc-text">pool_alloc</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串"><span class="toc-number">4.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lexical-cast"><span class="toc-number">4.1.</span> <span class="toc-text">lexical_cast</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用法-4"><span class="toc-number">4.1.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常处理"><span class="toc-number">4.1.2.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对转换对象的要求"><span class="toc-number">4.1.3.</span> <span class="toc-text">对转换对象的要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对比c-11标准"><span class="toc-number">4.1.4.</span> <span class="toc-text">对比c++11标准</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#format"><span class="toc-number">4.2.</span> <span class="toc-text">format</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类摘要"><span class="toc-number">4.2.1.</span> <span class="toc-text">类摘要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#格式化语法"><span class="toc-number">4.2.2.</span> <span class="toc-text">格式化语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高级用法"><span class="toc-number">4.2.3.</span> <span class="toc-text">高级用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-ref"><span class="toc-number">4.3.</span> <span class="toc-text">string_ref</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用法-5"><span class="toc-number">4.3.1.</span> <span class="toc-text">用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-algo"><span class="toc-number">4.4.</span> <span class="toc-text">string_algo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#大小写转换"><span class="toc-number">4.4.1.</span> <span class="toc-text">大小写转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断式-算法"><span class="toc-number">4.4.2.</span> <span class="toc-text">判断式(算法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断式-函数对象"><span class="toc-number">4.4.3.</span> <span class="toc-text">判断式(函数对象)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分类"><span class="toc-number">4.4.4.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修剪"><span class="toc-number">4.4.5.</span> <span class="toc-text">修剪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找"><span class="toc-number">4.4.6.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#替换与删除"><span class="toc-number">4.4.7.</span> <span class="toc-text">替换与删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分割"><span class="toc-number">4.4.8.</span> <span class="toc-text">分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#合并"><span class="toc-number">4.4.9.</span> <span class="toc-text">合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找-分隔-迭代器"><span class="toc-number">4.4.10.</span> <span class="toc-text">查找(分隔)迭代器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数学-数字"><span class="toc-number">5.</span> <span class="toc-text">数学/数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#math"><span class="toc-number">5.1.</span> <span class="toc-text">math</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#integer"><span class="toc-number">5.2.</span> <span class="toc-text">integer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#integer-traits"><span class="toc-number">5.2.1.</span> <span class="toc-text">integer_traits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准整数类型"><span class="toc-number">5.2.2.</span> <span class="toc-text">标准整数类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ratio"><span class="toc-number">5.3.</span> <span class="toc-text">ratio</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#random"><span class="toc-number">5.4.</span> <span class="toc-text">random</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算法"><span class="toc-number">6.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#foreach"><span class="toc-number">6.1.</span> <span class="toc-text">foreach</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#支持的序列类型"><span class="toc-number">6.1.1.</span> <span class="toc-text">支持的序列类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存在的问题"><span class="toc-number">6.1.2.</span> <span class="toc-text">存在的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#minmax"><span class="toc-number">6.2.</span> <span class="toc-text">minmax</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用法-6"><span class="toc-number">6.2.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存在的问题-1"><span class="toc-number">6.2.2.</span> <span class="toc-text">存在的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#minmax-element"><span class="toc-number">6.3.</span> <span class="toc-text">minmax_element</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用法-7"><span class="toc-number">6.3.1.</span> <span class="toc-text">用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#algorithm"><span class="toc-number">6.4.</span> <span class="toc-text">algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#clamp"><span class="toc-number">6.4.1.</span> <span class="toc-text">clamp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clamp-range"><span class="toc-number">6.4.2.</span> <span class="toc-text">clamp_range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hex和unhex"><span class="toc-number">6.4.3.</span> <span class="toc-text">hex和unhex</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#容器和数据结构"><span class="toc-number">7.</span> <span class="toc-text">容器和数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#array"><span class="toc-number">7.1.</span> <span class="toc-text">array</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#操作"><span class="toc-number">7.1.1.</span> <span class="toc-text">操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用法-8"><span class="toc-number">7.1.2.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺陷"><span class="toc-number">7.1.3.</span> <span class="toc-text">缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对比C-11标准"><span class="toc-number">7.1.4.</span> <span class="toc-text">对比C++11标准</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dynamic-bitset"><span class="toc-number">7.2.</span> <span class="toc-text">dynamic_bitset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建与赋值"><span class="toc-number">7.2.1.</span> <span class="toc-text">创建与赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器操作"><span class="toc-number">7.2.2.</span> <span class="toc-text">容器操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位运算与比较运算"><span class="toc-number">7.2.3.</span> <span class="toc-text">位运算与比较运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位运算"><span class="toc-number">7.2.4.</span> <span class="toc-text">位运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered"><span class="toc-number">7.3.</span> <span class="toc-text">unordered</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#散列集合简介-unordered-set"><span class="toc-number">7.3.1.</span> <span class="toc-text">散列集合简介(unordered_set)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#散列集合的用法"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">散列集合的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基本用法"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对比C-11标准-1"><span class="toc-number">7.3.1.3.</span> <span class="toc-text">对比C++11标准</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#散列映射-unordered-map"><span class="toc-number">7.3.2.</span> <span class="toc-text">散列映射(unordered_map)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#散列映射基本用法"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">散列映射基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对比c-11标准-1"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">对比c++11标准</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bimap"><span class="toc-number">7.4.</span> <span class="toc-text">bimap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类摘要-1"><span class="toc-number">7.4.1.</span> <span class="toc-text">类摘要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本用法-1"><span class="toc-number">7.4.2.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合类型值"><span class="toc-number">7.4.3.</span> <span class="toc-text">集合类型值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用标签类型"><span class="toc-number">7.4.4.</span> <span class="toc-text">使用标签类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用assign库"><span class="toc-number">7.4.5.</span> <span class="toc-text">使用assign库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找与替换"><span class="toc-number">7.4.6.</span> <span class="toc-text">查找与替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#投射"><span class="toc-number">7.4.7.</span> <span class="toc-text">投射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#circular-buffer"><span class="toc-number">7.5.</span> <span class="toc-text">circular_buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类摘要-2"><span class="toc-number">7.5.1.</span> <span class="toc-text">类摘要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用法-9"><span class="toc-number">7.5.2.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#环形缓冲区"><span class="toc-number">7.5.3.</span> <span class="toc-text">环形缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空间优化型缓冲区"><span class="toc-number">7.5.4.</span> <span class="toc-text">空间优化型缓冲区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tuple"><span class="toc-number">7.6.</span> <span class="toc-text">tuple</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#最简单的tuple-pair"><span class="toc-number">7.6.1.</span> <span class="toc-text">最简单的tuple:pair</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类摘要-3"><span class="toc-number">7.6.2.</span> <span class="toc-text">类摘要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建与赋值-1"><span class="toc-number">7.6.3.</span> <span class="toc-text">创建与赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问元素"><span class="toc-number">7.6.4.</span> <span class="toc-text">访问元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#比较操作"><span class="toc-number">7.6.5.</span> <span class="toc-text">比较操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输入输出"><span class="toc-number">7.6.6.</span> <span class="toc-text">输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用于assign库"><span class="toc-number">7.6.7.</span> <span class="toc-text">应用于assign库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部结构"><span class="toc-number">7.6.8.</span> <span class="toc-text">内部结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#any"><span class="toc-number">7.7.</span> <span class="toc-text">any</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#访问元素-1"><span class="toc-number">7.7.1.</span> <span class="toc-text">访问元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作函数"><span class="toc-number">7.7.2.</span> <span class="toc-text">操作函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保存指针"><span class="toc-number">7.7.3.</span> <span class="toc-text">保存指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输出"><span class="toc-number">7.7.4.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用于容器"><span class="toc-number">7.7.5.</span> <span class="toc-text">应用于容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#variant"><span class="toc-number">7.8.</span> <span class="toc-text">variant</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类摘要-4"><span class="toc-number">7.8.1.</span> <span class="toc-text">类摘要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问元素-2"><span class="toc-number">7.8.2.</span> <span class="toc-text">访问元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用法-10"><span class="toc-number">7.8.3.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问器"><span class="toc-number">7.8.4.</span> <span class="toc-text">访问器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与any的区别"><span class="toc-number">7.8.5.</span> <span class="toc-text">与any的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multi-array"><span class="toc-number">7.9.</span> <span class="toc-text">multi_array</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类摘要-5"><span class="toc-number">7.9.1.</span> <span class="toc-text">类摘要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用法-11"><span class="toc-number">7.9.2.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改变形状和大小"><span class="toc-number">7.9.3.</span> <span class="toc-text">改变形状和大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建子视图"><span class="toc-number">7.9.4.</span> <span class="toc-text">创建子视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适配普通数组"><span class="toc-number">7.9.5.</span> <span class="toc-text">适配普通数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#property-tree"><span class="toc-number">7.10.</span> <span class="toc-text">property_tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类摘要-6"><span class="toc-number">7.10.1.</span> <span class="toc-text">类摘要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读取配置信息"><span class="toc-number">7.10.2.</span> <span class="toc-text">读取配置信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写入配置信息"><span class="toc-number">7.10.3.</span> <span class="toc-text">写入配置信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他用法"><span class="toc-number">7.10.4.</span> <span class="toc-text">其他用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发编程"><span class="toc-number">8.</span> <span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#atomic"><span class="toc-number">8.1.</span> <span class="toc-text">atomic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本用法-2"><span class="toc-number">8.1.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#整数atomic用法"><span class="toc-number">8.1.2.</span> <span class="toc-text">整数atomic用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发顺序一致性"><span class="toc-number">8.1.3.</span> <span class="toc-text">并发顺序一致性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread"><span class="toc-number">8.2.</span> <span class="toc-text">thread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mutex"><span class="toc-number">8.2.1.</span> <span class="toc-text">mutex</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mutex-用法"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">mutex 用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock-guard"><span class="toc-number">8.2.2.</span> <span class="toc-text">lock_guard</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lock-guard-用法"><span class="toc-number">8.2.2.1.</span> <span class="toc-text">lock_guard 用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-lock"><span class="toc-number">8.2.3.</span> <span class="toc-text">unique_lock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工厂函数-1"><span class="toc-number">8.2.3.1.</span> <span class="toc-text">工厂函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-lock-使用"><span class="toc-number">8.2.3.2.</span> <span class="toc-text">unique_lock 使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock适配器"><span class="toc-number">8.2.4.</span> <span class="toc-text">lock适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lockable概念检查类"><span class="toc-number">8.2.4.1.</span> <span class="toc-text">lockable概念检查类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lock函数"><span class="toc-number">8.2.4.2.</span> <span class="toc-text">lock函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用线程"><span class="toc-number">8.2.5.</span> <span class="toc-text">使用线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#启动线程"><span class="toc-number">8.2.5.1.</span> <span class="toc-text">启动线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#join线程"><span class="toc-number">8.2.5.2.</span> <span class="toc-text">join线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#detach分离线程"><span class="toc-number">8.2.5.3.</span> <span class="toc-text">detach分离线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#thread-guard"><span class="toc-number">8.2.5.4.</span> <span class="toc-text">thread_guard</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scoped-thread"><span class="toc-number">8.2.5.5.</span> <span class="toc-text">scoped_thread</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断线程"><span class="toc-number">8.2.6.</span> <span class="toc-text">中断线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#中断点"><span class="toc-number">8.2.6.1.</span> <span class="toc-text">中断点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#启用-禁用线程中断"><span class="toc-number">8.2.6.2.</span> <span class="toc-text">启用/禁用线程中断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-group"><span class="toc-number">8.2.7.</span> <span class="toc-text">thread_group</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-once"><span class="toc-number">8.2.8.</span> <span class="toc-text">call_once</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件变量"><span class="toc-number">8.2.9.</span> <span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-mutex"><span class="toc-number">8.2.10.</span> <span class="toc-text">shared_mutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#future"><span class="toc-number">8.2.11.</span> <span class="toc-text">future</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#async函数"><span class="toc-number">8.2.11.1.</span> <span class="toc-text">async函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-future"><span class="toc-number">8.2.12.</span> <span class="toc-text">shared_future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#barrier"><span class="toc-number">8.2.13.</span> <span class="toc-text">barrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-local"><span class="toc-number">8.2.14.</span> <span class="toc-text">thread_local</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#at-thread-exit"><span class="toc-number">8.2.15.</span> <span class="toc-text">at_thread_exit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#asio"><span class="toc-number">8.3.</span> <span class="toc-text">asio</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介"><span class="toc-number">8.3.1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#handler"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">handler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-service"><span class="toc-number">8.3.1.2.</span> <span class="toc-text">io_service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strand"><span class="toc-number">8.3.1.3.</span> <span class="toc-text">strand</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#work"><span class="toc-number">8.3.1.4.</span> <span class="toc-text">work</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mutable-buffer和const-buffer"><span class="toc-number">8.3.1.5.</span> <span class="toc-text">mutable_buffer和const_buffer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unix信号"><span class="toc-number">8.3.2.</span> <span class="toc-text">unix信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-12"><span class="toc-number">8.3.2.1.</span> <span class="toc-text">用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定时器"><span class="toc-number">8.3.3.</span> <span class="toc-text">定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#basic-waitable-timer"><span class="toc-number">8.3.3.1.</span> <span class="toc-text">basic_waitable_timer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步定时器"><span class="toc-number">8.3.3.2.</span> <span class="toc-text">同步定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步定时器"><span class="toc-number">8.3.3.3.</span> <span class="toc-text">异步定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#案例"><span class="toc-number">8.3.3.4.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通信概述"><span class="toc-number">8.3.4.</span> <span class="toc-text">通信概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#address"><span class="toc-number">8.3.4.1.</span> <span class="toc-text">address</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#endpoint"><span class="toc-number">8.3.4.2.</span> <span class="toc-text">endpoint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#socket"><span class="toc-number">8.3.4.3.</span> <span class="toc-text">socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#acceptor"><span class="toc-number">8.3.4.4.</span> <span class="toc-text">acceptor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步tcp通信"><span class="toc-number">8.3.5.</span> <span class="toc-text">同步tcp通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#服务端"><span class="toc-number">8.3.5.1.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#客户端"><span class="toc-number">8.3.5.2.</span> <span class="toc-text">客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步tcp通信"><span class="toc-number">8.3.6.</span> <span class="toc-text">异步tcp通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#服务端-1"><span class="toc-number">8.3.6.1.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#客户端-1"><span class="toc-number">8.3.6.2.</span> <span class="toc-text">客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析网络地址"><span class="toc-number">8.3.7.</span> <span class="toc-text">解析网络地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-13"><span class="toc-number">8.3.7.1.</span> <span class="toc-text">用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协程"><span class="toc-number">8.3.8.</span> <span class="toc-text">协程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-14"><span class="toc-number">8.3.8.1.</span> <span class="toc-text">用法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#高阶工具"><span class="toc-number">9.</span> <span class="toc-text">高阶工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#optional"><span class="toc-number">9.1.</span> <span class="toc-text">optional</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#操作函数-1"><span class="toc-number">9.1.1.</span> <span class="toc-text">操作函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用法-15"><span class="toc-number">9.1.2.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工厂函数-2"><span class="toc-number">9.1.3.</span> <span class="toc-text">工厂函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#assign"><span class="toc-number">9.2.</span> <span class="toc-text">assign</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#list-inserter"><span class="toc-number">9.2.1.</span> <span class="toc-text">list_inserter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#operator"><span class="toc-number">9.2.1.1.</span> <span class="toc-text">operator+=</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#operator-1"><span class="toc-number">9.2.1.2.</span> <span class="toc-text">operator()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#generic-list"><span class="toc-number">9.2.2.</span> <span class="toc-text">generic_list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减少重复输入"><span class="toc-number">9.2.3.</span> <span class="toc-text">减少重复输入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#swap"><span class="toc-number">9.3.</span> <span class="toc-text">swap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#交换数组"><span class="toc-number">9.3.1.</span> <span class="toc-text">交换数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特化std-swap"><span class="toc-number">9.3.2.</span> <span class="toc-text">特化std::swap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#singleton"><span class="toc-number">9.4.</span> <span class="toc-text">singleton</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用法-16"><span class="toc-number">9.4.1.</span> <span class="toc-text">用法</span></a></li></ol></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            Boost相关知识点
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2016/10/22/boost-book/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2016-10-22T03:45:06.000Z" itemprop="datePublished">2016-10-22</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Boost库/">Boost库</a>, <a class="article-tag-link" href="/tags/Cpp编程/">Cpp编程</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>Boost库编程相关详解笔记<br><a id="more"></a> </p>
<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>1998年,Deman G.Dawes(C++标准委员会成员之一)发起倡议并建立了Boost社区</p>
<p>目的是向C++程序员提供免费、同行审查、可移植的高质量C++源程序库</p>
<p>Bost发布采用Boost Software License不同于GPL，Apache的非常宽松许可证,允许用户将boost用于任何用途,既鼓励商业用途,也鼓励非商业用途,用户无须之父任何费用,不收任何限制享用Boost全部功能</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">accumlators //累加器</span><br><span class="line">algorithm 	//算法库</span><br><span class="line">align 		//内存对齐库</span><br><span class="line">archive		//序列化库</span><br><span class="line">asio		//异步并法库</span><br><span class="line">assign		//赋值初始化库</span><br><span class="line">atomic		//院子操作库</span><br><span class="line">bitmap		//双向关联数组</span><br><span class="line">bind		//bind表达式</span><br><span class="line">chrono		//时间处理库</span><br><span class="line">circular_buffer//循环缓冲区容器</span><br><span class="line">xpressive	//正则表达式库</span><br></pre></td></tr></table></figure>
<h2 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h2><p>Boost大部分C++类的声明和实现都放在一个文件,而不分成两个文件,也就是”.h+.cpp”,故文件后缀是”.hpp”</p>
<p>剩下少量库都是要编译成静态库或者动态库</p>
<ul>
<li>chrono</li>
<li>date_time</li>
<li>regex</li>
<li>program_options</li>
<li>test</li>
<li>thread</li>
<li>python等</li>
</ul>
<h1 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h1><h2 id="timer库"><a href="#timer库" class="headerlink" title="timer库"></a>timer库</h2><p>提供简易的时间和进度显示</p>
<h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/timer.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; CLOCKS_PER_SEC &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"max timespan:"</span></span><br><span class="line">        &lt;&lt; t.elapsed_max() /<span class="number">3600</span> &lt;&lt; <span class="string">"h"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"min timespan:"</span></span><br><span class="line">        &lt;&lt; t.elapsed_min() &lt;&lt; <span class="string">"s"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"now time elapsed:"</span></span><br><span class="line">        &lt;&lt; t.elapsed() &lt;&lt;<span class="string">"s"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1000000</span></span><br><span class="line"><span class="comment">//max timespan:5.1241e+09h</span></span><br><span class="line"><span class="comment">//min timespan:1e-06s</span></span><br><span class="line"><span class="comment">//now time elapsed:0.000117s</span></span><br></pre></td></tr></table></figure>
<p>使用了标注库头<code>&lt;ctime&gt;</code>的<code>std::lock()</code>函数,返回自进程启动以来的<code>clock</code>数,每秒的<code>clock</code>数由宏定义<code>CLOCKS_PER_SEC</code>定义</p>
<ul>
<li>构造函数记录当前clock数作计时起点,保存私有成员变量_start_time</li>
<li>_elapsed获取此时的clock数减去计时起点_start_time<br>再除以CLOCKS_PER_SEC获得以秒为单位的已经流失时间</li>
<li>restart()重置开始计时</li>
<li>elapsed_min()返回timer能够测量的最小时间单位,是CLOCKS_PER_SEC的倒数</li>
<li>elapsed_max()使用数值极限类numeric_limits,获得clock_t类型的最大值,采用类似elapsed()方式计算可能的最大时间范围</li>
</ul>
<h3 id="progress-timer"><a href="#progress-timer" class="headerlink" title="progress_timer"></a>progress_timer</h3><p>但是其有一个析构函数，析构的时候会自动调用elapsed()输出从构造到析构所消耗的时间，所以利用这个类来测时间是非常方便的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/progress.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        boost::progress_timer t;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        boost::progress_timer t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">progress_timer <span class="title">t</span><span class="params">(ss)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ss.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0.00 s</span></span><br><span class="line"><span class="comment">//0.00 s</span></span><br><span class="line"><span class="comment">//0.00 s</span></span><br></pre></td></tr></table></figure>
<h3 id="progress-display"><a href="#progress-display" class="headerlink" title="progress_display"></a>progress_display</h3><p>独立的类,与timer库其他两个组件<code>timer</code>&amp;<code>progress_timer</code>没有任何联系</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/progress.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v(<span class="number">100</span>);</span><br><span class="line">    <span class="function">ofstream <span class="title">fs</span><span class="params">(<span class="string">"./test.txt"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//progress_display pd(v.size(),cout ,"%%%", "+++", "???");</span></span><br><span class="line">    progress_display pd(v.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : v)</span><br><span class="line">    &#123;</span><br><span class="line">        fs &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        ++pd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v(<span class="number">100</span>, <span class="string">"aaa"</span>);</span><br><span class="line"></span><br><span class="line">    v[<span class="number">10</span>] = <span class="string">""</span>;v[<span class="number">23</span>] = <span class="string">""</span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fs</span><span class="params">(<span class="string">"./test.txt"</span>)</span></span>;</span><br><span class="line">    progress_display pd(v.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pos = v.begin(); pos != v.end();++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        fs &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        ++pd;</span><br><span class="line">        <span class="keyword">if</span> (pos-&gt;empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"null string # "</span> </span><br><span class="line">                &lt;&lt; (pos - v.begin())&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    case1();</span><br><span class="line">    case2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>progress_display</code>构造函数接收一个long类型参数,作为进度显示的基数</p>
<p>另一种形式构造函数还接收(基数,std::cout类的输出流,进度描述,框描述,数值描述)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">progress_display pd(v.size(),cout ,"%%%", "+++", "???");</span><br><span class="line"></span><br><span class="line"><span class="comment">//%%%0%   10   20   30   40   50   60   70   80   90   100%</span></span><br><span class="line"><span class="comment">//+++|----|----|----|----|----|----|----|----|----|----|</span></span><br><span class="line"><span class="comment">//???***************************************************</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意事项</p>
</blockquote>
<p>boost的process_display采用了标准库的输出,不要和其他程序处理std::cout一起输出,否则会乱</p>
<h2 id="date-time库"><a href="#date-time库" class="headerlink" title="date_time库"></a>date_time库</h2><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define DATE_TIME_NO_DEFAULT_CONSTRUCTOR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/date_time/gregorian/gregorian.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::gregorian;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    date d1; <span class="comment">//无效的日期</span></span><br><span class="line">    <span class="function">date <span class="title">d2</span><span class="params">(<span class="number">2010</span>,<span class="number">1</span>,<span class="number">1</span>)</span></span>; <span class="comment">//使用数字构造的日期</span></span><br><span class="line">    <span class="function">date <span class="title">d3</span><span class="params">(<span class="number">2000</span>, Jan , <span class="number">1</span>)</span></span>; <span class="comment">//支持英文指定月份</span></span><br><span class="line">    <span class="function">date <span class="title">d4</span><span class="params">(d2)</span></span>; <span class="comment">//支持拷贝构造</span></span><br><span class="line"></span><br><span class="line">    assert(d1 == date(not_a_date_time)); <span class="comment">//比较零食对象</span></span><br><span class="line">    assert(d2 == d4); <span class="comment">//date支持比较操作</span></span><br><span class="line">    assert(d3 &lt;  d4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>day_lock</code>天级别的始终,工厂类调用了静态成员函数<code>local_day</code>或<code>universal_day</code>返回一个当天的日期对象,分别表示本地日期和UTC日期,<code>day_lock</code>内部使用了C标准库的<code>localtime</code>和<code>gmttime</code>函数,因此<code>local_day</code>依赖操作系统时区设置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    date d1 = from_string(<span class="string">"1999-12-31"</span>); <span class="comment">//字符串转换</span></span><br><span class="line">    date d2 ( from_string("2015/1/1") );</span><br><span class="line">    date d3 = from_undelimited_string(<span class="string">"20011118"</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d1 &lt;&lt; d2 &lt;&lt; d3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; day_clock::local_day()    &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; day_clock::universal_day() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>special_values</code>枚举来创建特殊的日期</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">date <span class="title">d1</span><span class="params">(neg_infin)</span></span>; <span class="comment">//负无限日期</span></span><br><span class="line">    <span class="function">date <span class="title">d2</span><span class="params">(pos_infin)</span></span>; <span class="comment">//正无限日期</span></span><br><span class="line">    <span class="function">date <span class="title">d3</span><span class="params">(not_a_date_time)</span></span>; <span class="comment">//无效日期</span></span><br><span class="line">    <span class="function">date <span class="title">d4</span><span class="params">(max_date_time)</span></span>; <span class="comment">//最大 9999-12-31</span></span><br><span class="line">    <span class="function">date <span class="title">d5</span><span class="params">(min_date_time)</span></span>;<span class="comment">// 最小 1400-01-01</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d1 &lt;&lt; d2 &lt;&lt; d3 &lt;&lt; d4 &lt;&lt; d5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//date d1(1399,12,1); //超过日期下限</span></span><br><span class="line">        <span class="comment">//date d2(10000,1,1); //超过日期上限</span></span><br><span class="line">        <span class="function">date <span class="title">d3</span><span class="params">(<span class="number">2017</span>,<span class="number">2</span>,<span class="number">29</span>)</span></span>; <span class="comment">//不存在的日期</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(<span class="built_in">std</span>::exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-infinity</span></span><br><span class="line"><span class="comment">//+infinity</span></span><br><span class="line"><span class="comment">//not-a-date-time</span></span><br><span class="line"><span class="comment">//9999-Dec-31</span></span><br><span class="line"><span class="comment">//1400-Jan-01</span></span><br><span class="line"><span class="comment">//Day of month is not valid for year</span></span><br></pre></td></tr></table></figure>
<h4 id="访日日期"><a href="#访日日期" class="headerlink" title="访日日期"></a>访日日期</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">date <span class="title">d</span><span class="params">(<span class="number">2017</span>,<span class="number">6</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    assert(d.year()  == <span class="number">2017</span>); </span><br><span class="line">    assert(d.month() == <span class="number">6</span>);</span><br><span class="line">    assert(d.day()   == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    date::ymd_type ymd =  d.year_month_day();</span><br><span class="line">    assert(ymd.year    == <span class="number">2017</span>);</span><br><span class="line">    assert(ymd.month   == <span class="number">6</span>);</span><br><span class="line">    assert(ymd.day     == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d.day_of_week() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d.day_of_year() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    assert(d.end_of_month() == date(<span class="number">2017</span>,<span class="number">6</span>,<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; date(<span class="number">2015</span>,<span class="number">1</span>,<span class="number">10</span>).week_number() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; date(<span class="number">2016</span>,<span class="number">1</span>,<span class="number">10</span>).week_number()  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; date(<span class="number">2017</span>,<span class="number">1</span>,<span class="number">10</span>).week_number()  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    assert(date(pos_infin).is_infinity()  );</span><br><span class="line">    assert(date(pos_infin).is_pos_infinity() );</span><br><span class="line">    assert(date(neg_infin).is_neg_infinity() );</span><br><span class="line">    assert(date(not_a_date_time).is_not_a_date() );</span><br><span class="line">    assert(date(not_a_date_time).is_special() );</span><br><span class="line">    assert(!date(<span class="number">2017</span>,<span class="number">5</span>,<span class="number">31</span>).is_special() );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="日期的输出"><a href="#日期的输出" class="headerlink" title="日期的输出"></a>日期的输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">date <span class="title">d</span><span class="params">(<span class="number">2017</span>,<span class="number">1</span>,<span class="number">23</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; to_simple_string(d) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//转换为YYYY-mmm-dd格式字符串,mmm为3字符英文字符串</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; to_iso_string(d) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出YYYYMMDD格式的数字字符串</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; to_iso_extended_string(d) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//转换为YYYY-MM-DD格式的数字字符串</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "input date:";</span></span><br><span class="line">    <span class="comment">//cin &gt;&gt;d;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; d;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="日期长度"><a href="#日期长度" class="headerlink" title="日期长度"></a>日期长度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    days dd1(10), dd2(-100), dd3(255); //各个天数</span><br><span class="line"></span><br><span class="line">    assert( dd1 &gt; dd2 &amp;&amp; dd1 &lt; dd3);</span><br><span class="line">    assert( dd1 + dd2 == days(<span class="number">-90</span>));</span><br><span class="line">    assert((dd1 + dd3).days() == <span class="number">265</span>);</span><br><span class="line">    assert( dd3 / <span class="number">5</span> == days(<span class="number">51</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function">weeks <span class="title">w</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">//3个星期</span></span><br><span class="line">    assert(w.days() == <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">months <span class="title">m</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">//5个月</span></span><br><span class="line">    <span class="function">years <span class="title">y</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">//2年</span></span><br><span class="line"></span><br><span class="line">    months m2 = y + m; <span class="comment">//2年5个月</span></span><br><span class="line">    assert(m2.number_of_months() == <span class="number">29</span>);</span><br><span class="line">    assert((y * <span class="number">2</span>).number_of_years() == <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="日期运算"><a href="#日期运算" class="headerlink" title="日期运算"></a>日期运算</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    date d1(2000,1,1),d2(2017,11,18);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d2 - d1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//5435天</span></span><br><span class="line">    assert(d1 + (d2 - d1) == d2);</span><br><span class="line"></span><br><span class="line">    d1 += days(<span class="number">10</span>);		<span class="comment">//2000-1-11</span></span><br><span class="line">    assert(d1.day() == <span class="number">11</span>);</span><br><span class="line">    d1 += months(<span class="number">2</span>);	<span class="comment">//2000-3-11</span></span><br><span class="line">    assert(d1.month() == <span class="number">3</span> &amp;&amp; d1.day() == <span class="number">11</span>);</span><br><span class="line">    d1 -= weeks(<span class="number">1</span>);		<span class="comment">//2000-03-04</span></span><br><span class="line">    assert(d1.day() == <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    d2 -= years(<span class="number">10</span>);<span class="comment">//2004-11-18</span></span><br><span class="line">    assert(d2.year() == d1.year() + <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">date <span class="title">d1</span><span class="params">(<span class="number">2017</span>,<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        date d2 = d1 + days(pos_infin);</span><br><span class="line">        assert(d2.is_pos_infinity());</span><br><span class="line"></span><br><span class="line">        d2 = d1 + days(not_a_date_time);</span><br><span class="line">        assert(d2.is_not_a_date());</span><br><span class="line">        d2 = date(neg_infin);</span><br><span class="line">        days dd = d1 - d2;</span><br><span class="line">        assert(dd.is_special() &amp;&amp; !dd.is_negative());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">date <span class="title">d</span><span class="params">(<span class="number">2017</span>,<span class="number">3</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">        d -= months(<span class="number">1</span>);	<span class="comment">//2017-2-28</span></span><br><span class="line">        d -= months(<span class="number">1</span>);	<span class="comment">//2014-1-31</span></span><br><span class="line">        d += months(<span class="number">2</span>);	<span class="comment">//2014-3-31</span></span><br><span class="line">        assert(d.day() == <span class="number">31</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="日期区间"><a href="#日期区间" class="headerlink" title="日期区间"></a>日期区间</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/date_time/gregorian/gregorian.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::gregorian;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    date_period dp(date(2017,1,1), days(20));</span><br><span class="line"></span><br><span class="line">    dp.shift(days(<span class="number">3</span>));</span><br><span class="line">    assert(dp.begin().day() == <span class="number">4</span>); </span><br><span class="line">    assert(dp.length().days() == <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    dp.expand(days(<span class="number">3</span>));</span><br><span class="line">    assert(dp.begin().day() == <span class="number">1</span>);</span><br><span class="line">    assert(dp.length().days() == <span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>date_period</code>还可以使用成员函数判断某个日期是否在区间，或者计算日期区间的交集</p>
<ul>
<li><code>is_before()/is_after();</code>日期区间是否在日期前或后</li>
<li><code>contains();</code>日期区间是否包含另一个区间或者日期</li>
<li><code>intersects()</code>两个日期区间是否存在交集</li>
<li><code>intersection()</code>返回两个区间的交集,如果无交集返回一个无效区间</li>
<li><code>is_adjacent()</code>两个日期区间是否相邻</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    date_period dp(date(2010,1,1), days(20));</span><br><span class="line">    <span class="comment">//1-1至1-20</span></span><br><span class="line"></span><br><span class="line">    assert(dp.is_after(date(<span class="number">2009</span>,<span class="number">12</span>,<span class="number">1</span>)));</span><br><span class="line">    assert(dp.is_before(date(<span class="number">2010</span>,<span class="number">2</span>,<span class="number">1</span>)));</span><br><span class="line">    assert(dp.contains(date(<span class="number">2010</span>,<span class="number">1</span>,<span class="number">10</span>)));</span><br><span class="line"></span><br><span class="line">    date_period dp2(date(2010,1,5), days(10));</span><br><span class="line">    <span class="comment">//1-5至1-15</span></span><br><span class="line">    assert(dp.contains(dp2));</span><br><span class="line"></span><br><span class="line">    assert(dp.intersects(dp2));</span><br><span class="line">    assert(dp.intersection(dp2) == dp2);</span><br><span class="line"></span><br><span class="line">    date_period dp3(date(2010,1,21), days(5));</span><br><span class="line">    <span class="comment">//1-21 到 1-26</span></span><br><span class="line">    assert(!dp3.intersects(dp2));</span><br><span class="line">    assert(dp3.intersection(dp2).is_null());</span><br><span class="line"></span><br><span class="line">    assert(dp.is_adjacent(dp3));</span><br><span class="line">    assert(!dp.intersects(dp3));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>merge()</code>返回两个区间的并集,如果区间无交集或不相邻返回无效区间</li>
<li><code>span()</code>合并两日期区间及两者间的间隔,</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    date_period dp1(date(2010,1,1), days(20));</span><br><span class="line">    date_period dp2(date(2010,1,5), days(10));</span><br><span class="line">    date_period dp3(date(2010,2,1), days(5));</span><br><span class="line">    date_period dp4(date(2010,1,15), days(10));</span><br><span class="line"></span><br><span class="line">    assert( dp1.contains(dp2) &amp;&amp; dp1.merge(dp2) == dp1);</span><br><span class="line">    assert(!dp1.intersects(dp3) &amp;&amp; dp1.merge(dp3).is_null());</span><br><span class="line">    assert( dp1.intersects(dp2) &amp;&amp; dp1.merge(dp4).end() == dp4.end());</span><br><span class="line">    assert( dp1.span(dp3).end() == dp3.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="日期迭代器"><a href="#日期迭代器" class="headerlink" title="日期迭代器"></a>日期迭代器</h4><ul>
<li><code>day_iterator</code>:天迭代器</li>
<li><code>week_iterator</code>:周迭代器</li>
<li><code>month_iterator</code>:月迭代器</li>
<li><code>year_iterator</code>:年迭代器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">date <span class="title">d</span><span class="params">(<span class="number">2007</span>,<span class="number">9</span>,<span class="number">28</span>)</span></span>;</span><br><span class="line">    <span class="function">day_iterator <span class="title">d_iter</span><span class="params">(d)</span></span>; <span class="comment">//增减步长默认为1天</span></span><br><span class="line"></span><br><span class="line">    assert(d_iter == d);</span><br><span class="line">    ++d_iter;  <span class="comment">//增长一天</span></span><br><span class="line">    assert(d_iter == date(<span class="number">2007</span>,<span class="number">9</span>,<span class="number">29</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function">year_iterator <span class="title">y_iter</span><span class="params">(*d_iter, <span class="number">10</span>)</span></span>; <span class="comment">//增减步长为 10年</span></span><br><span class="line">    assert(y_iter == d + days(<span class="number">1</span>));</span><br><span class="line">    ++y_iter;  <span class="comment">//递增10年</span></span><br><span class="line">    assert(y_iter-&gt;year() == <span class="number">2017</span>);</span><br><span class="line"></span><br><span class="line">    day_iterator iter(day_clock::local_day());</span><br><span class="line">    ++iter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iter += 5;</span></span><br><span class="line">    <span class="comment">//std::advance(iter, 5);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><h4 id="操作时间长度"><a href="#操作时间长度" class="headerlink" title="操作时间长度"></a>操作时间长度</h4><p><code>time_duration</code>构造函数指定时分秒和微妙来构造</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/date_time/gregorian/gregorian.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::gregorian;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/date_time/posix_time/posix_time.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::posix_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        time_duration td = duration_from_string(<span class="string">"1:10:30:001"</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; td &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">time_duration <span class="title">td1</span><span class="params">(<span class="number">1</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">1000</span>)</span></span>;<span class="comment">//1小时10分30秒1毫秒</span></span><br><span class="line">        <span class="function">time_duration <span class="title">td2</span><span class="params">(<span class="number">1</span>,<span class="number">60</span>,<span class="number">60</span>,<span class="number">1000</span>*<span class="number">1000</span>* <span class="number">6</span> + <span class="number">1000</span>)</span></span>;<span class="comment">//2小时01分06.001秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">hours <span class="title">h</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">//1小时</span></span><br><span class="line">    <span class="function">minutes <span class="title">m</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//10分钟</span></span><br><span class="line">    <span class="function">seconds <span class="title">s</span><span class="params">(<span class="number">30</span>)</span></span>;<span class="comment">//30秒钟</span></span><br><span class="line">    <span class="function">millisec <span class="title">ms</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//1毫秒</span></span><br><span class="line"></span><br><span class="line">    time_duration td = h + m + s + ms;<span class="comment">//可以赋值给time_duration</span></span><br><span class="line">    time_duration td2 = hours(<span class="number">2</span>) + seconds(<span class="number">10</span>);<span class="comment">//也可以直接赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; td &lt;&lt; td2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="时间长度精确度"><a href="#时间长度精确度" class="headerlink" title="时间长度精确度"></a>时间长度精确度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">time_duration <span class="title">td</span><span class="params">(<span class="number">1</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">1000</span>)</span></span>;</span><br><span class="line">    assert(td.hours() == <span class="number">1</span> &amp;&amp; td.minutes() == <span class="number">10</span> &amp;&amp; td.seconds() == <span class="number">30</span>);</span><br><span class="line">    assert(td.total_seconds() == <span class="number">1</span>*<span class="number">3600</span>+ <span class="number">10</span>*<span class="number">60</span> + <span class="number">30</span>);</span><br><span class="line">    assert(td.total_milliseconds() == td.total_seconds()*<span class="number">1000</span> + <span class="number">1</span>);</span><br><span class="line">    assert(td.fractional_seconds() == <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">hours <span class="title">h</span><span class="params">(<span class="number">-10</span>)</span></span>;</span><br><span class="line">    assert(h.is_negative());</span><br><span class="line"></span><br><span class="line">    time_duration h2 = h.invert_sign();</span><br><span class="line">    assert(!h2.is_negative() &amp;&amp; h2.hours() == <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">time_duration <span class="title">td1</span><span class="params">(not_a_date_time)</span></span>;</span><br><span class="line">    assert(td1.is_special() &amp;&amp; td1.is_not_a_date_time());</span><br><span class="line"></span><br><span class="line">    <span class="function">time_duration <span class="title">td2</span><span class="params">(neg_infin)</span></span>;</span><br><span class="line">    assert(td2.is_negative() &amp;&amp; td2.is_neg_infinity());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建时间点"><a href="#创建时间点" class="headerlink" title="创建时间点"></a>创建时间点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptime p(date(2017,7,7), hours(1));</span><br><span class="line">    ptime p1 = time_from_string(<span class="string">"2017-7-7 01:00:00"</span>);</span><br><span class="line">    ptime p2 = from_iso_string(<span class="string">"20170707T010000"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; p2;</span><br><span class="line">    &#123;</span><br><span class="line">        ptime p1 = second_clock::local_time(); <span class="comment">//秒精度</span></span><br><span class="line">        ptime p2 = microsec_clock::universal_time();<span class="comment">//微妙精度</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; p2; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="操作时间点"><a href="#操作时间点" class="headerlink" title="操作时间点"></a>操作时间点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptime p(date(2010,3,20), hours(12)+minutes(30));</span><br><span class="line"></span><br><span class="line">    date d = p.date();</span><br><span class="line">    time_duration td = p.time_of_day();</span><br><span class="line">    assert(d.month() == <span class="number">3</span> &amp;&amp; d.day() == <span class="number">20</span>);</span><br><span class="line">    assert(td.total_seconds() == <span class="number">12</span>*<span class="number">3600</span> + <span class="number">30</span>*<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    ptime p1(date(2010,3,20), hours(12)+minutes(30));</span><br><span class="line">    ptime p2 = p1 + hours(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    assert(p1 &lt; p2);</span><br><span class="line">    assert(p2 - p1 == hours(<span class="number">3</span>));</span><br><span class="line">    p2 += months(<span class="number">1</span>);</span><br><span class="line">    assert(p2.date().month() == <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        ptime p(date(2017,2,14), hours(20));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; to_simple_string(p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; to_iso_string(p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; to_iso_extended_string(p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="时间迭代器"><a href="#时间迭代器" class="headerlink" title="时间迭代器"></a>时间迭代器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case9</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptime p(date(2017,5,31),hours(10)) ;//10个小时的步长</span><br><span class="line">    <span class="keyword">for</span> (time_iterator t_iter(p, minutes(<span class="number">10</span>));</span><br><span class="line">            t_iter &lt; p + hours(<span class="number">1</span>); ++ t_iter)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *t_iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="智能指针简介"><a href="#智能指针简介" class="headerlink" title="智能指针简介"></a>智能指针简介</h2><p>程序员如果保证new和delete保证对应,四处编写异常捕获代码以释放资源</p>
<p>而智能指针则可以在退出作用于:(不管正常流程离开或是异常离开)，总调用delete来析构在堆上动态分配的对象</p>
<p>最著名是C++98标准中的”自动指针”,<code>std::auto_ptr</code>,它部分地解决了获取资源自动释放的问题</p>
<p>但是<code>std::auto_ptr</code>已经在C++11标准被声明废弃,现在应该使用最新的智能指针<code>std::unique_ptr</code>,<code>std::shared_ptr</code>,<code>std::weak_ptr</code></p>
<p>而boost.smart_ptr提供了六种智能指针</p>
<ul>
<li><code>scoped_ptr</code></li>
<li><code>scoped_array</code></li>
<li><code>shared_ptr</code></li>
<li><code>shared_array</code></li>
<li><code>weak_ptr</code></li>
<li><code>intrusive_ptr</code></li>
</ul>
<h2 id="scoped-ptr"><a href="#scoped-ptr" class="headerlink" title="scoped_ptr"></a>scoped_ptr</h2><p>只在作用域内生效，离开作用域既释放资源，不能复制和赋值。类似于标准库的auto_ptr，但它相对于auto_ptr的优势在于，他的要求更严格，使用起来更安全。auto_ptr拥有转移语义，当使用了赋值和复制操作时可能操作未定义行为。</p>
<blockquote>
<p>具体结构</p>
</blockquote>
<p><img src="/2016/10/22/boost-book/image-01.png" width="400px"></p>
<p><img src="/2016/10/22/boost-book/image-02.png" width="400px"></p>
<ul>
<li>构造函数:接收类型T*的指针p,创建scoped_ptr对象,内部保存指针参数p</li>
<li>析构函数:使用delete操作符自动销毁所保存的指针对象,从而正确回收资源</li>
<li>拷贝构造函数：声明为私有,不允许对智能指针拷贝操作</li>
<li>赋值操作符：声明为私有,不允许对智能指针拷贝操作</li>
<li>reset函数：重置,删除原指针，保存新指针值</li>
<li>operator*<em>()和operator</em>-&gt;():重置操作符*和箭头,模仿被代理的原指针</li>
<li>swap:高效操作，交换两个scoped_ptr的内部原始指针</li>
<li>bool语境:测试是否持有一个有效指针</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr/make_unique.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    scoped_ptr&lt;<span class="built_in">string</span>&gt; sp(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"text"</span>)); <span class="comment">//构造scoped_ptr对象</span></span><br><span class="line"></span><br><span class="line">    assert(sp);</span><br><span class="line">    assert(sp != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *sp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;  sp-&gt;size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不需要delete,scoped_ptr自动帮助释放资源</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    posix_file(<span class="keyword">const</span> <span class="keyword">char</span> * file_name) </span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt; <span class="string">"open file:"</span> &lt;&lt; file_name &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~posix_file()</span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt; <span class="string">"close file"</span> &lt;&lt; <span class="built_in">endl</span>;   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    scoped_ptr&lt;posix_file&gt; fp(<span class="keyword">new</span> posix_file(<span class="string">"/tmp/a.txt"</span>));</span><br><span class="line"></span><br><span class="line">    scoped_ptr&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>); <span class="comment">//一个int指针的scoped_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p) <span class="comment">//在bool语境中测试指针是否有效</span></span><br><span class="line">    &#123; </span><br><span class="line">        *p = <span class="number">100</span>; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    p.reset(); <span class="comment">// 置空scoped_ptr</span></span><br><span class="line"></span><br><span class="line">    assert(p == <span class="number">0</span>); <span class="comment">//确实p不持有任何指针</span></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt; <span class="string">"scoped_ptr == nullptr"</span> &lt;&lt; <span class="built_in">endl</span>;   &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">//这里发生scoped_ptr的析构,p和fp管理的指针自动删除</span></span><br></pre></td></tr></table></figure>
<h3 id="unique-ptr区别"><a href="#unique-ptr区别" class="headerlink" title="unique_ptr区别"></a>unique_ptr区别</h3><p><code>std::unique_ptr</code>是c++11定义的新智能指针,用来取代c++98中的<code>std::auto_ptr</code><br><code>std::unique_ptr</code>不仅能代理new创建的单个对象还能代理new[]创建的数组对象<br>也就是它结合了<code>scoped_array</code>和<code>scoped_ptr</code>两者的能力  </p>
<p><code>std::unique_ptr</code>基本能力和<code>scoped_ptr</code>相同,同样作用于管理指针,也不允许拷贝构造和拷贝赋值  </p>
<p>但<code>std::unique_ptr</code>比<code>scoped_ptr</code>功能要多,可以像原始指针一样进行比较,可以像<code>shared_ptr</code>一样定制删除器,也可以安全地放入标准容器</p>
<blockquote>
<p>make_unique</p>
</blockquote>
<p>boost提供了unique_ptr的工厂类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case_unique</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = boost::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    assert(p &amp;&amp; *p == <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    p.release();</span><br><span class="line">    assert(!p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> a = boost::make_unique&lt;<span class="keyword">int</span>[]&gt;(<span class="number">5</span>); </span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">500</span>;</span><br><span class="line">    <span class="comment">//a[5] = 1000;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="scoped-array"><a href="#scoped-array" class="headerlink" title="scoped_array"></a>scoped_array</h2><p><img src="/2016/10/22/boost-book/image-03.jpg" width="500px"></p>
<h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p>scoped_array与scoped_ptr源于相同设计思想,用法相似,但是scoped_array包装的是new[]产生的指针<br>并在析构的时候delete[]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    scoped_array&lt;<span class="keyword">int</span>&gt; sa(arr);</span><br><span class="line"></span><br><span class="line">    fill_n(&amp;sa[<span class="number">0</span>],<span class="number">100</span>, <span class="number">5</span>); <span class="comment">//填充数组</span></span><br><span class="line">    sa[<span class="number">10</span>] = sa[<span class="number">20</span>] + sa[<span class="number">30</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="unique-ptr区别-1"><a href="#unique-ptr区别-1" class="headerlink" title="unique_ptr区别"></a>unique_ptr区别</h3><p>unique_ptr的数组对象用法和scoped_array基本相同,但模板参数中需要声明为数组类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>[]&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]);</span><br><span class="line"></span><br><span class="line">    assert(up);</span><br><span class="line">    up[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; up[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    up.reset();</span><br><span class="line">    assert(!up);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>shared_ptr最像指针的智能指针,boost.smart_ptr库中最有价值最重要的组成部分,也是最有用  </p>
<p><img src="/2016/10/22/boost-book/image-04.png" width="400px"><br><img src="/2016/10/22/boost-book/image-05.png" width="400px"></p>
<p>shared_ptr与scoped_ptr功能相似<br>都重载了<code>*</code>和-&gt;操作符模仿原始指针的行为,提供了显式bool类型转换以判断指针的有效性<br>get()可以得到原始指针,并且没有提供指针算术操作,也不能管理new[]产生的数组动态指针  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; spi(<span class="keyword">new</span> <span class="keyword">int</span>);</span><br><span class="line">    assert(spi); <span class="comment">//bool语境</span></span><br><span class="line">    *spi = <span class="number">253</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;  sps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"smart"</span>));</span><br><span class="line">    assert(sps-&gt;size() == <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//shared_ptr&lt;int&gt; dont_do_this(new int[10]); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2016/10/22/boost-book/image-06.png" width="400px"></p>
<p>reset也只是引用计数减1,除非引用计数为0,否则不会发生删除操作  </p>
<h3 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="keyword">sp_t</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">sp_t</span>, <span class="keyword">int</span>&gt; m; <span class="comment">//标准映射容器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">sp_t</span> sp(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"one"</span>)); </span><br><span class="line">    m[sp] = <span class="number">111</span>; <span class="comment">//关联数组用法</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::exception&gt; sp1(<span class="keyword">new</span> <span class="built_in">std</span>::bad_exception());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> sp2 = dynamic_pointer_cast&lt;<span class="built_in">std</span>::bad_exception&gt;(sp1);</span><br><span class="line">    <span class="keyword">auto</span> sp3 = static_pointer_cast&lt;<span class="built_in">std</span>::exception&gt;(sp2);</span><br><span class="line">    assert(sp3 == sp1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));</span><br><span class="line">    assert(sp.unique()); <span class="comment">//是否指针唯一持有者</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp;  <span class="comment">//拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    assert(sp == sp2 &amp;&amp; </span><br><span class="line">     sp.use_count() == <span class="number">2</span>); <span class="comment">//引用计数为2,两个shared_ptr相等</span></span><br><span class="line"></span><br><span class="line">    *sp2 = <span class="number">100</span>; <span class="comment">//解引用操作符修改被指对象</span></span><br><span class="line">    assert(*sp == <span class="number">100</span>); <span class="comment">//另一个也同时修改</span></span><br><span class="line"></span><br><span class="line">    sp.reset(); <span class="comment">//停止shared_ptr使用</span></span><br><span class="line">    assert(!sp); <span class="comment">//空指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//######  复杂运用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p_):p(p_)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"count:"</span> &lt;&lt; p.use_count()</span><br><span class="line">            &lt;&lt; <span class="string">" v="</span> &lt;&lt;*p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_func</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"count:"</span> &lt;&lt; p.use_count()</span><br><span class="line">        &lt;&lt; <span class="string">" v="</span> &lt;&lt;*p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>));</span><br><span class="line">    shared s1(p), s2(p);</span><br><span class="line"></span><br><span class="line">    s1.print();</span><br><span class="line">    s2.print();</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    print_func(p);</span><br><span class="line"></span><br><span class="line">    s1.print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//count: 3 v=100</span></span><br><span class="line"><span class="comment">//count: 3 v=100</span></span><br><span class="line"><span class="comment">//count: 4 v=20</span></span><br><span class="line"><span class="comment">//count: 3 v=20</span></span><br></pre></td></tr></table></figure>
<h3 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h3><p>为了去除过多显式的new草祖父,应该使用工厂模式来解决</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp = make_shared&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"make_shared"</span>);</span><br><span class="line">    <span class="keyword">auto</span> spv = make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">    assert(spv-&gt;size() == <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用于标准容器"><a href="#应用于标准容器" class="headerlink" title="应用于标准容器"></a>应用于标准容器</h3><ul>
<li>shared_ptr&lt;list<t>&gt; 使得容器安全共享</t></li>
<li>vector&lt;shared_ptr<t>&gt; 因为shared_ptr支持拷贝语义和比较操作,符合标准容器对元素的要求,可以安全容纳元素的指针而不是拷贝</t></li>
</ul>
<p>但是容器不能容纳scoped_ptr,因为scoped_ptr不能拷贝和复制,标准容器可以容纳原始指针  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; &gt; vs;</span><br><span class="line">    <span class="function">vs <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pos = v.begin(); pos != v.end(); ++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        (*pos) = make_shared&lt;<span class="keyword">int</span>&gt;(++i); <span class="comment">//使用工厂模式</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(*pos) &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ptr : v)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = make_shared&lt;<span class="keyword">int</span>&gt;(++i); <span class="comment">//工厂函数赋值</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *ptr &lt;&lt; <span class="string">", "</span>; <span class="comment">//输出值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p = v[<span class="number">9</span>];</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *v[<span class="number">9</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="应用于桥接模式"><a href="#应用于桥接模式" class="headerlink" title="应用于桥接模式"></a>应用于桥接模式</h3><p>此模式具体实现细节对用户隐藏,达到类的最小耦合关系</p>
<p>scoped_ptr和shared_ptr都可以实现桥接模式,shared_ptr更适合</p>
<p>因为它支持拷贝和复制,可以配合容器工作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/core/ignore_unused.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">impl</span>;</span> <span class="comment">//不完整内部类声明</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;impl&gt; p; <span class="comment">//shared_ptr成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    sample(); <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>; <span class="comment">//提供给外界的接口</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span>:</span>:impl <span class="comment">//内部实现类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"impl print"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sample::sample():p(<span class="keyword">new</span> impl)&#123;&#125; <span class="comment">//构造函数初始化shared_ptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> sample::print()</span><br><span class="line">&#123;   p-&gt;print();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sample s;</span><br><span class="line">    s.print();<span class="comment">//调用pimpl实现print()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用于工厂模式"><a href="#应用于工厂模式" class="headerlink" title="应用于工厂模式"></a>应用于工厂模式</h3><p>工厂模式创造型设计模式  </p>
<p>包装了new操作符的使用,使得对象的创建工作集中在工厂类或者工厂函数</p>
<p>make_shared是工厂模式的一个好例子  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">abstract</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~abstract() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">impl</span>:</span><span class="keyword">public</span> abstract</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    impl() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~impl() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"class impl f"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"class impl g"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;abstract&gt; create()</span><br><span class="line"><span class="comment">//&#123;   return shared_ptr&lt;abstract&gt;(new impl);&#125;</span></span><br><span class="line">&#123;   <span class="keyword">return</span> make_shared&lt;impl&gt;();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = create();</span><br><span class="line">    p-&gt;f();</span><br><span class="line">    p-&gt;g();</span><br><span class="line"></span><br><span class="line">    abstract *q = p.get();</span><br><span class="line">    boost::ignore_unused(q);</span><br><span class="line">    <span class="comment">//delete q; //错误 abstract的保护析构函数</span></span><br><span class="line">    <span class="comment">//impl *q = (impl*)(p.get());//强制转 粗鲁的方法</span></span><br><span class="line">    <span class="comment">//delete q; ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>shared_ptr第一个参数是要被管理的指针,含义和其他构造函数参数相同,<br>第二个删除器参数d告诉析构的时候不是使用delete来操作指针p,而是用d来操作<br>delete p 换成了d(p)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">socket_t</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">socket_t</span>* open_socket() <span class="comment">//打开socket</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"open_socket"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">socket_t</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_socket</span><span class="params">(<span class="keyword">socket_t</span> * s)</span> <span class="comment">//关闭socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"close_socket"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">socket_t</span> *s = open_socket();</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">socket_t</span>&gt; p(s, close_socket);</span><br><span class="line">    <span class="comment">//shared_ptr&lt;socket_t&gt; p(s, &amp;close_socket);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除容器的高级用法   </p>
</blockquote>
<p>这样函数栈结束会自动执行这个方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">any_func</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"some operate"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">void</span>&gt; p(<span class="literal">nullptr</span>,any_func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="别名构造函数"><a href="#别名构造函数" class="headerlink" title="别名构造函数"></a>别名构造函数</h3><p>shared_ptr还有一个特殊的构造函数 如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">shared_ptr</span>&lt;shared_ptr&lt;Y&gt; const &amp; r, element_type *p);</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">void case6()</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    auto p1 = make_shared&lt;std::pair&lt;int, int&gt;&gt;(0,1);</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    shared_ptr&lt;int&gt; p2(p1, &amp;p1-&gt;<span class="title">second</span>);</span> <span class="comment">//别名构造</span></span><br><span class="line"></span><br><span class="line">    assert(p1.use_count() == <span class="number">2</span> &amp;&amp;</span><br><span class="line">           p1.use_count() == p2.use_count()); <span class="comment">//原引用计数增加</span></span><br><span class="line">    assert((<span class="keyword">void</span>*)p1.get() != (<span class="keyword">void</span>*)p2.get()); <span class="comment">//两者引用计数相同</span></span><br><span class="line">    assert(&amp;p1-&gt;second== p2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="shared-array"><a href="#shared-array" class="headerlink" title="shared_array"></a>shared_array</h2><p><img src="/2016/10/22/boost-book/image-07.png" width="500px">  </p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>]; <span class="comment">//一个动态数组</span></span><br><span class="line"></span><br><span class="line">    shared_array&lt;<span class="keyword">int</span>&gt; sa(p); <span class="comment">//shared_array 代理动态数组</span></span><br><span class="line">    assert(sa.unique()); <span class="comment">//唯一持有指针</span></span><br><span class="line"></span><br><span class="line">    shared_array&lt;<span class="keyword">int</span>&gt; sa2 = sa; <span class="comment">//共享数组,引用计数增加</span></span><br><span class="line">    assert(sa2.use_count() == <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    sa[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">//可以通过operator[]访问元素</span></span><br><span class="line">    assert(sa2[<span class="number">0</span>] == <span class="number">10</span>); </span><br><span class="line">&#125;   <span class="comment">//离开作用于,自动删除动态数组</span></span><br></pre></td></tr></table></figure>
<p>operator[]要小心,不提供数组索引范围检查</p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p><img src="/2016/10/22/boost-book/image-08.png" width="500px"><br><img src="/2016/10/22/boost-book/image-09.png" width="500px">  </p>
<h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><p>weak_ptr的设计为与shared_ptr协同工作,可以从一个shared_ptr或另一个weak_ptr对象构造  </p>
<p>获得资源的观测全,但它的构造不会引起指针引用计数的增加,同样weak_ptr析构也不会导致引用计数的减少，只是一个观察者  </p>
<p>weak_ptr没有重载operator<code>*</code>和-&gt;,这是特意的,因为它不共享指针,不能操作资源,</p>
<p>从而非常重要的成员函数就是lock()从被观测的shared_ptr获得一个可用的shared_ptr对象,<br>从而操作资源</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>)); <span class="comment">//一个shared_ptr</span></span><br><span class="line">    assert(sp.use_count() == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    weak_ptr&lt;<span class="keyword">int</span>&gt; wp(sp); <span class="comment">//从shared_ptr创建weak_ptr</span></span><br><span class="line">    assert(wp.use_count() == <span class="number">1</span>); <span class="comment">//weak_ptr不影响引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wp.expired()) <span class="comment">//判断weak_ptr观察的对象是否失效</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = wp.lock(); <span class="comment">//获得一个shared_ptr</span></span><br><span class="line">        *sp2 = <span class="number">100</span>;</span><br><span class="line">        assert(wp.use_count() == <span class="number">2</span>); </span><br><span class="line">    &#125; <span class="comment">//退出 sp2析构 引用计数减1</span></span><br><span class="line"></span><br><span class="line">    assert(wp.use_count() == <span class="number">1</span>);</span><br><span class="line">    sp.reset();</span><br><span class="line">    assert(wp.expired());</span><br><span class="line">    assert(!wp.lock());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="enable-shared-from-this"><a href="#enable-shared-from-this" class="headerlink" title="enable_shared_from_this"></a>enable_shared_from_this</h3><p>weak_ptr一个重要用途是获得this指针的shared_ptr,使得自己能够生产shared_ptr管理自己  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">self_shared</span>:</span></span><br><span class="line">    <span class="keyword">public</span> enable_shared_from_this&lt;self_shared&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    self_shared(<span class="keyword">int</span> n):x(n)&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"self_shared:"</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp = make_shared&lt;self_shared&gt;(<span class="number">313</span>);</span><br><span class="line">    sp-&gt;print();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> p = sp-&gt;shared_from_this();</span><br><span class="line"></span><br><span class="line">    p-&gt;x = <span class="number">1000</span>;</span><br><span class="line">    p-&gt;print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="enable-shared-from-raw"><a href="#enable-shared-from-raw" class="headerlink" title="enable_shared_from_raw"></a>enable_shared_from_raw</h3><p><img src="/2016/10/22/boost-book/image-10.png" width="450px"></p>
<p>enable_shared_from_raw同样需要继承使用,但他不是模板类,所以不需要指定模板参数<br>不提供成员函数shared_from_this(),而是用两个friend函数,shared_from_raw()和weak_from_raw()完成智能指针工作  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr/enable_shared_from_raw.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">raw_shared</span>:</span></span><br><span class="line">    <span class="keyword">public</span> enable_shared_from_raw</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    raw_shared()</span><br><span class="line">    &#123;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"raw_shared ctor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    &#125;</span><br><span class="line">    ~raw_shared()</span><br><span class="line">    &#123;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"raw_shared dtor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    raw_shared x;</span><br><span class="line">    assert(weak_from_raw(&amp;x).use_count() == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> px = shared_from_raw(&amp;x); <span class="comment">//获取shared_ptr</span></span><br><span class="line">    assert(px.use_count() == <span class="number">2</span>); <span class="comment">//引用计数为2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> p = <span class="keyword">new</span> raw_shared; <span class="comment">//原始指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> wp = weak_from_raw(p); <span class="comment">//weak_ptr</span></span><br><span class="line">    assert(wp.use_count() == <span class="number">1</span>); /此时无引用 <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">decltype</span>(shared_from_raw(p)) spx(p); <span class="comment">//获取shared_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> sp = shared_from_raw(p); <span class="comment">//</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; sp.use_count() &lt;&lt; std::endl;</span></span><br><span class="line">    assert(sp.use_count() == <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//decltype(sp) spx(p);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> sp2 = sp;</span><br><span class="line">    <span class="keyword">auto</span> wp2 = weak_from_raw(p);</span><br><span class="line">    assert(wp2.use_count() == <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打破循环引用"><a href="#打破循环引用" class="headerlink" title="打破循环引用"></a>打破循环引用</h3><p>两个节点互相持有对方引用,每个shared_ptr的引用计数都是2<br>因此析构引用计数没有减至0,不会调用删除操作,导致内存泄漏<br>这个时候可以用weak_ptr,因他不增加智能指针的引用计数,在真需要的shared_ptr的时候调用weak_ptr的lock函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~node()</span><br><span class="line">    &#123;     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deleted"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> weak_ptr&lt;node&gt; ptr_type;</span><br><span class="line">    <span class="comment">//typedef shared_ptr&lt;node&gt; ptr_type;</span></span><br><span class="line">    ptr_type next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p1 = make_shared&lt;node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> p2 = make_shared&lt;node&gt;();</span><br><span class="line"></span><br><span class="line">    p1-&gt;next = p2;</span><br><span class="line">    p2-&gt;next = p1;</span><br><span class="line"></span><br><span class="line">    assert(p1.use_count() == <span class="number">1</span>);</span><br><span class="line">    assert(p2.use_count() == <span class="number">1</span>); <span class="comment">//没了循环引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!p1-&gt;next.expired()) <span class="comment">//检查弱应用是否有效</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> p3 = p1-&gt;next.lock(); <span class="comment">//调用lock获得强引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//退出作用于,shared_ptr均正常析构</span></span><br></pre></td></tr></table></figure>
<h2 id="intrusive-ptr"><a href="#intrusive-ptr" class="headerlink" title="intrusive_ptr"></a>intrusive_ptr</h2><p>intrusive也是引用计数指针,所以他的接口和shared_ptr很像<br>支持static_pointer_cast、dynamic_pointer_cast转型操作  </p>
<p>它还支持  </p>
<ul>
<li>intrusive_ptr_add_ref增加引用计数</li>
<li>intrusive_ptr_release减少引用计数</li>
</ul>
<p><img src="/2016/10/22/boost-book/image-11.png" width="500px"><br><img src="/2016/10/22/boost-book/image-12.png" width="500px"></p>
<h3 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">counted_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> m_count = <span class="number">0</span>; </span><br><span class="line">    ~counted_data()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"dtor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intrusive_ptr_add_ref</span><span class="params">(counted_data* p)</span> <span class="comment">//增加引用计数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++p-&gt;m_count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intrusive_ptr_release</span><span class="params">(counted_data* p)</span> <span class="comment">//减少引用计数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(--p-&gt;m_count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> p; <span class="comment">//删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">counted_data2</span> :</span> <span class="keyword">public</span> intrusive_ref_counter&lt;counted_data2&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ~counted_data2()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"dtor2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> intrusive_ptr&lt;counted_data&gt; counted_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="function">counted_ptr <span class="title">p</span><span class="params">(<span class="keyword">new</span> counted_data)</span></span>;</span><br><span class="line">    assert(p);</span><br><span class="line">    assert(p-&gt;m_count == <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">    <span class="function">counted_ptr <span class="title">p2</span><span class="params">(p)</span></span>; <span class="comment">//指针拷贝构造</span></span><br><span class="line">    assert(p-&gt;m_count == <span class="number">2</span>);  <span class="comment">//引用计数增加</span></span><br><span class="line"></span><br><span class="line">    counted_ptr weak_p(p.get(), false); //弱引用</span><br><span class="line">    assert(weak_p-&gt;m_count == <span class="number">2</span>); <span class="comment">//引用计数不增加</span></span><br><span class="line"></span><br><span class="line">    p2.reset(); <span class="comment">//复位指针</span></span><br><span class="line">    assert(!p2); <span class="comment">//p2不持有指针</span></span><br><span class="line">    assert(p-&gt;m_count == <span class="number">1</span>); <span class="comment">//引用计数减小</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typedef</span> intrusive_ptr&lt;counted_data2&gt; counted_ptr;</span><br><span class="line"></span><br><span class="line">        <span class="function">counted_ptr <span class="title">p</span><span class="params">(<span class="keyword">new</span> counted_data2)</span></span>;</span><br><span class="line">        assert(p);</span><br><span class="line">        assert(p-&gt;use_count() == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pool库"><a href="#pool库" class="headerlink" title="pool库"></a>pool库</h2><p>内存池,boost.pool库基于简单分割存储思想实现了快速、紧凑的内存池库<br>不仅能够管理大量的对象，还可以用作stl的内存分配器，<br>它近似于一个小型垃圾回收机制，在大量的分配和释放小对象时非常有效率，而且完全不考虑delete</p>
<p>pool库包含四个部分</p>
<ul>
<li>简单的pool </li>
<li>object_pool,分配类实例  </li>
<li>singleton_pool,单例内存池</li>
<li>pool_alloc,标准库  </li>
</ul>
<h3 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h3><p><img src="/2016/10/22/boost-book/image-13.png" width="400px"><br><img src="/2016/10/22/boost-book/image-14.png" width="400px"></p>
<p>pool构造函数接收一个整数表示每次pool分配内存块大小,非内存池大小<br>pool会根据需要自动地向系统申请或归还使用的内存,在析构的时候自动释放他所持有的所有内存块  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/core/ignore_unused.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define BOOST_SYSTEM_NO_DEPRECATED</span></span><br><span class="line"><span class="comment">//#define BOOST_POOL_NO_MT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/pool/pool.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pool&lt;&gt; pl(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(pl.<span class="built_in">malloc</span>());</span><br><span class="line">    assert(pl.is_from(p));</span><br><span class="line"></span><br><span class="line">    pl.<span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">    &#123;   pl.ordered_malloc(<span class="number">10</span>);  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是它只适合普通数据类型int,double等内存池,不能应用复杂的类和对象  </p>
<h3 id="object-pool"><a href="#object-pool" class="headerlink" title="object_pool"></a>object_pool</h3><p>功能和pool类似,但析构时对所有已经分配内存块调用析构函数,从而正确地释放资源   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/pool/object_pool.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">demo_class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    demo_class(<span class="keyword">int</span> x = <span class="number">1</span>, <span class="keyword">int</span> y = <span class="number">2</span>, <span class="keyword">int</span> z = <span class="number">3</span>):</span><br><span class="line">        a(x),b(y),c(z)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    object_pool&lt;demo_class&gt; pl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> p = pl.<span class="built_in">malloc</span>();</span><br><span class="line">    assert(pl.is_from(p));</span><br><span class="line"></span><br><span class="line">    assert(p-&gt;a!=<span class="number">1</span> || p-&gt;b != <span class="number">2</span> || p-&gt;c !=<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    p = pl.construct(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">    assert(p-&gt;a == <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    object_pool&lt;<span class="built_in">string</span>&gt; pls;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> *ps = pls.construct(<span class="string">"hello object_pool"</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *ps &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="singleton-pool"><a href="#singleton-pool" class="headerlink" title="singleton_pool"></a>singleton_pool</h3><p><img src="/2016/10/22/boost-book/image-15.png" width="500px"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOST_POOL_NO_MT            <span class="comment">//不使用多线程</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/pool/singleton_pool.hpp&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_tag</span>&#123;</span>&#125;;                  <span class="comment">//仅仅标记的空类</span></span><br><span class="line"><span class="keyword">typedef</span> singleton_pool&lt;pool_tag, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)&gt; spl;  <span class="comment">//内存池定义 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)spl::<span class="built_in">malloc</span>(); <span class="comment">//分配一个整数内存块</span></span><br><span class="line">    assert(spl::is_from(p));</span><br><span class="line">    spl::release_memory(); <span class="comment">//释放所有未被分配的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pool-alloc"><a href="#pool-alloc" class="headerlink" title="pool_alloc"></a>pool_alloc</h3><p>标准容器模板参数的内存分配器   </p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="lexical-cast"><a href="#lexical-cast" class="headerlink" title="lexical_cast"></a>lexical_cast</h2><p>lexical_cast库进行了字面值的转换,类似C中的atoi函数,可以进行字符串和整数/浮点数之间的字面转换  </p>
<p><img src="/2016/10/22/boost-book/image-78.png" width="500px"></p>
<h3 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  x      = lexical_cast&lt;<span class="keyword">int</span>&gt;(<span class="string">"100"</span>);         <span class="comment">//字符串-&gt;整型</span></span><br><span class="line">    <span class="keyword">long</span> y      = lexical_cast&lt;<span class="keyword">long</span>&gt;(<span class="string">"2000"</span>);       <span class="comment">//字符串-&gt;长整型</span></span><br><span class="line">    <span class="keyword">float</span> pai   = lexical_cast&lt;<span class="keyword">float</span>&gt;(<span class="string">"3.14159e5"</span>); <span class="comment">//字符串-&gt;float</span></span><br><span class="line">    <span class="keyword">double</span> e    = lexical_cast&lt;<span class="keyword">double</span>&gt;(<span class="string">"2.71828"</span>);  <span class="comment">//字符串-&gt;double</span></span><br><span class="line">    <span class="keyword">double</span> r    = lexical_cast&lt;<span class="keyword">double</span>&gt;(<span class="string">"1.414,xyz"</span>, <span class="number">5</span>); <span class="comment">//C字符串-&gt;double</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; y &lt;&lt; pai &lt;&lt; e &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str = lexical_cast&lt;<span class="built_in">string</span>&gt;(<span class="number">456</span>);         <span class="comment">//整数-&gt;字符串</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lexical_cast&lt;<span class="built_in">string</span>&gt;(<span class="number">0.618</span>) &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">//float-&gt;字符串</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lexical_cast&lt;<span class="built_in">string</span>&gt;(<span class="number">0x10</span>) &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">//16进制整型-&gt;字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lexical_cast&lt;<span class="keyword">bool</span>&gt;(<span class="string">"1"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lexical_cast&lt;int&gt;("0x100");</span></span><br><span class="line">    <span class="comment">//lexical_cast&lt;int&gt;("123L");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//10020003141592.718281.414</span></span><br><span class="line"><span class="comment">//456</span></span><br><span class="line"><span class="comment">//0.61799999999999999</span></span><br><span class="line"><span class="comment">//16</span></span><br></pre></td></tr></table></figure>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>lexcical_cast 无法执行转换操作时抛出异常bad_lexical_cast,是std::bad_cast的派生类  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    lexical_cast&lt;T&gt;(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(bad_lexical_cast&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"error:"</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>lexical_cast在名字空间boost::conversion提供了  </p>
<ul>
<li>try_lexical_convert()函数,可以避免抛出异常,以bool返回值表示是否转换成功   </li>
</ul>
<p><img src="/2016/10/22/boost-book/image-79.png" width="500px"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">num_valid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp;</span><br><span class="line">    <span class="keyword">return</span> conversion::try_lexical_convert(str, tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对转换对象的要求"><a href="#对转换对象的要求" class="headerlink" title="对转换对象的要求"></a>对转换对象的要求</h3><p><img src="/2016/10/22/boost-book/image-80.png" width="500"></p>
<p>c++内建类型int,double等和std::string都满足以上条件  </p>
<h3 id="对比c-11标准"><a href="#对比c-11标准" class="headerlink" title="对比c++11标准"></a>对比c++11标准</h3><p>c++11标准增强了字符串与数字的互操作性,提供了</p>
<ul>
<li>stoX()函数  </li>
<li>to_string()函数   </li>
</ul>
<p>实现了std::string与数字之间的转换  </p>
<p><img src="/2016/10/22/boost-book/image-80.png" width="500"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">try</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(stoi(<span class="string">" 42 "</span>) == <span class="number">42</span>);</span><br><span class="line">    assert(stol(<span class="string">"100L"</span>) == <span class="number">100L</span>);</span><br><span class="line">    assert(stol(<span class="string">"1000 9"</span>) == <span class="number">1000L</span>);</span><br><span class="line">    assert(stod(<span class="string">"3.14ispai"</span>) == <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    assert(to_string(<span class="number">776u</span>l) == <span class="string">"776"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; stoul("100L");</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; stoul("x100");</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stoi(<span class="string">"9999999999"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="built_in">std</span>::exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"error:"</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><p>c++标准库输入输出操作符&lt;&lt;,&gt;&gt;不是完美无效,精确输出格式控制需要些大量的操作函数,而且会改变流的状态,用完还需及时回复,有时候显得十分烦琐  </p>
<p>因此很多程序员怀念C语言中经典的printf函数,但是缺少了类型安全检查  </p>
<p>boost.format库,摒弃了printf,实现了类似于printf()的格式化对象,可以把参数格式化到一个字符串,而且完全类型安全   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; format(<span class="string">"%s:%d+%d=%d\n"</span>) %<span class="string">"sum"</span> % <span class="number">1</span> % <span class="number">2</span> % (<span class="number">1</span>+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">format <span class="title">fmt</span><span class="params">(<span class="string">"(%1% + %2%) * %2% = %3%\n"</span>)</span></span>;</span><br><span class="line">    fmt % <span class="number">2</span> % <span class="number">5</span> ;</span><br><span class="line">    fmt % ((<span class="number">2</span>+<span class="number">5</span>)*<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sum:1+2=3</span></span><br><span class="line"><span class="comment">//(2 + 5) * 5 = 35</span></span><br></pre></td></tr></table></figure>
<p>通过操作符% 逐个”喂”给format对象,完成对参数的格式化  </p>
<h3 id="类摘要"><a href="#类摘要" class="headerlink" title="类摘要"></a>类摘要</h3><p>format不是一个真正的类,而是一个typedef,真正的实现是basic_format  </p>
<p><img src="/2016/10/22/boost-book/image-82.png" width="500px"></p>
<ul>
<li>str,返回已经格式化好的字符串  </li>
<li>size,获得已经格式化好的字符串长度   </li>
<li>parse,清空format对象内部的缓存,并运用新的字符串    </li>
<li>clear,则是清空缓存</li>
</ul>
<h3 id="格式化语法"><a href="#格式化语法" class="headerlink" title="格式化语法"></a>格式化语法</h3><p><img src="/2016/10/22/boost-book/image-83.png" width="500px">  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">format <span class="title">fmt</span><span class="params">(<span class="string">"%05d\n%-8.3f\n% 10s\n%05X\n"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt %<span class="number">62</span> % <span class="number">2.236</span> % <span class="string">"123456789"</span> % <span class="number">48</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">format <span class="title">fmt2</span><span class="params">(<span class="string">"%|05d|\n%|-8.3f|\n%| 10s|\n%|05X|\n"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt2 %<span class="number">62</span> % <span class="number">2.236</span> % <span class="string">"123456789"</span> % <span class="number">48</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> format <span class="title">fmt3</span><span class="params">(<span class="string">"%10d %020.8f %010X %10.5e\n"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; format(fmt3) %<span class="number">62</span> % <span class="number">2.236</span> % <span class="number">255</span> % <span class="number">0.618</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//输出值  </span><br><span class="line">00062</span><br><span class="line">2.236   </span><br><span class="line"> 123456789</span><br><span class="line">00030</span><br><span class="line">00062</span><br><span class="line">2.236   </span><br><span class="line"> 123456789</span><br><span class="line">00030</span><br><span class="line">        62 00000000002.23600000 00000000FF 6.18000e-01</span><br></pre></td></tr></table></figure>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><p>format提供了类似printf的功能,但并等同于printf函数  </p>
<ul>
<li>运行时修改格式化选项  </li>
<li>绑定输入参数  </li>
</ul>
<p><img src="/2016/10/22/boost-book/image-85.png" width="500px"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"><span class="keyword">using</span> boost::io::group;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">format <span class="title">fmt</span><span class="params">(<span class="string">"%1% %2% %3% %2% %1% \n"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt %<span class="number">1</span> % <span class="number">2</span> % <span class="number">3</span>;     <span class="comment">//绑定参数</span></span><br><span class="line"></span><br><span class="line">    fmt.bind_arg(<span class="number">2</span>, <span class="number">10</span>);          <span class="comment">//将第二个输入参数固定位数字10</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt %<span class="number">1</span> %<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    fmt.clear();            </span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt % group(showbase,oct,  <span class="number">111</span>) % <span class="number">333</span>; <span class="comment">//%操作符使用group(),指定输入/输出流操作纵符第一个参数显示为八进制</span></span><br><span class="line"></span><br><span class="line">    fmt.clear_binds();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fmt.modify_item(<span class="number">1</span>, group(hex, right, showbase,setw(<span class="number">8</span>), setfill(<span class="string">'*'</span>)));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt % <span class="number">49</span> % <span class="number">20</span> % <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1 2 3 2 1 </span></span><br><span class="line"><span class="comment">//1 10 3 10 1 </span></span><br><span class="line"><span class="comment">//0157 10 333 10 0157 </span></span><br><span class="line"><span class="comment">//****0x31 20 100 20 49</span></span><br></pre></td></tr></table></figure>
<h2 id="string-ref"><a href="#string-ref" class="headerlink" title="string_ref"></a>string_ref</h2><p>std::string经常要拷贝来拷贝去,内存开销大,影响程序效率  </p>
<p>使用<code>const std::string &amp;</code>可以避免一些问题,但是处理C字符串、提取子字符串又无能为力   </p>
<p>boost.string_ref就是这样的一种轻量级字符串,它只支持字符串的引用,没有内存拷贝的成本,运行效率很高  </p>
<p><img src="/2016/10/22/boost-book/image-86.png" width="500px"><br><img src="/2016/10/22/boost-book/image-87.png" width="500px"></p>
<p>原理简单粗暴,只用两个成员变量ptr_和len_标记字符串的起始位置和长度  </p>
<ul>
<li>remove_prefix(6); 删除前6个字符  </li>
<li>remove_suffix(5); 删除后5个字符  </li>
<li>……</li>
</ul>
<p>basic_string_ref 也定了几个typedef方便使用<br><img src="/2016/10/22/boost-book/image-88.png" width="500px">  </p>
<h3 id="用法-5"><a href="#用法-5" class="headerlink" title="用法"></a>用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/core/ignore_unused.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/utility/string_ref.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ch = <span class="string">"Days of Future Past"</span>;     <span class="comment">//字符数组</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(ch)</span></span>;                             <span class="comment">//标准字符串,有拷贝成本</span></span><br><span class="line"></span><br><span class="line">    <span class="function">string_ref <span class="title">s1</span><span class="params">(ch)</span></span>;                          <span class="comment">//字符数组构造,零拷贝</span></span><br><span class="line">    <span class="function">string_ref <span class="title">s2</span><span class="params">(str)</span></span>;                                 <span class="comment">//字符数组构造,零拷贝</span></span><br><span class="line">    assert(s1 == s2 &amp;&amp; s1 == ch &amp;&amp; s2 == str);</span><br><span class="line"></span><br><span class="line">    <span class="function">string_ref <span class="title">s3</span><span class="params">(ch, <span class="number">4</span>)</span></span>;       <span class="comment">//截取部分字符串构造</span></span><br><span class="line">    assert(s3 == str.substr(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    string_ref s4, s5;</span><br><span class="line">    s4  = ch;</span><br><span class="line">    s5 = str;</span><br><span class="line">    assert(s4 == s5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boost::ignore_unused(s4, s5);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const char* ch = "Apple iPhone iPad";</span></span><br><span class="line"></span><br><span class="line">    <span class="function">string_ref <span class="title">str</span><span class="params">(<span class="string">"Apple iPhone iPad"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    str.remove_prefix(<span class="number">6</span>);</span><br><span class="line">    assert(str.starts_with(<span class="string">"iP"</span>));</span><br><span class="line"></span><br><span class="line">    str.remove_suffix(<span class="number">5</span>);</span><br><span class="line">    assert(str.ends_with(<span class="string">"one"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="string-algo"><a href="#string-algo" class="headerlink" title="string_algo"></a>string_algo</h2><p>字符串标准类std::string有一些成员函数可以查找子串,访问字符,可以执行基本的字符串处理能力   </p>
<p>string_algo库非常全面的字符串算法库,提供了大量的字符串操作函数  </p>
<ul>
<li>大小写无关比较  </li>
<li>修剪  </li>
<li>特定模式的子串查找等  </li>
</ul>
<h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><p><img src="/2016/10/22/boost-book/image-89.png" width="500px"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"FireEmblem Heroes\n"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; to_upper_copy(str);     <span class="comment">//返回大写后的拷贝</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line">to_lower(str);          <span class="comment">//直接小写原值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str;</span><br></pre></td></tr></table></figure>
<h3 id="判断式-算法"><a href="#判断式-算法" class="headerlink" title="判断式(算法)"></a>判断式(算法)</h3><p><img src="/2016/10/22/boost-book/image-90.png" width="500px">  </p>
<p><img src="/2016/10/22/boost-book/image-91.png" width="500px"><br><img src="/2016/10/22/boost-book/image-92.png" width="500px">  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"Power Bomb"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    assert(iends_with(str, <span class="string">"bomb"</span>));        <span class="comment">//大小写无关检测后缀</span></span><br><span class="line">    assert(!ends_with(str, <span class="string">"bomb"</span>));        <span class="comment">//大小写敏感检测后缀</span></span><br><span class="line"></span><br><span class="line">    assert(starts_with(str, <span class="string">"Pow"</span>));        <span class="comment">//检测前缀</span></span><br><span class="line"></span><br><span class="line">    assert(contains(str, <span class="string">"er"</span>));        <span class="comment">//测试包含关系</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str2 = to_lower_copy(str);       <span class="comment">//转小写</span></span><br><span class="line">    assert(iequals(str, str2));     <span class="comment">//大小写无关判断相等</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str3</span><span class="params">(<span class="string">"power suit"</span>)</span></span>;</span><br><span class="line">    assert(ilexicographical_compare(str, str3));        <span class="comment">//大小写无关比较</span></span><br><span class="line"></span><br><span class="line">    assert(all(str2.substr(<span class="number">0</span>, <span class="number">5</span>), is_lower()));    <span class="comment">//检测字符串均小写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断式-函数对象"><a href="#判断式-函数对象" class="headerlink" title="判断式(函数对象)"></a>判断式(函数对象)</h3><p>string_algo增强了标准库的equal_to和less函数对象,允许不同类型的参数进行比较  </p>
<p><img src="/2016/10/22/boost-book/image-93.png" width="500px">  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1("Samus"), str2("samus");</span><br><span class="line"></span><br><span class="line">    assert(!is_equal()(str1, str2));</span><br><span class="line">    assert( is_less()(str1, str2));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; (to_upper_copy(str1) == to_upper_copy(str2)) &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; is_iequal()(str1, str2) &lt;&lt; endl; </span></span><br><span class="line">    assert(!is_equal()(str1, string_ref(str2)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个括号调用了函数对象的构造函数,产生临时对象,第二个括号才是真正的函数调用操作符operator();  </p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>string_algo提供了一组分类函数,用于检测一个字符是否符合某种特性,主要用于搭配其他算法   </p>
<p><img src="/2016/10/22/boost-book/image-94.png" width="500px"><br><img src="/2016/10/22/boost-book/image-95.png" width="500px">  </p>
<h3 id="修剪"><a href="#修剪" class="headerlink" title="修剪"></a>修剪</h3><p>string_algo提供三个修剪算法:trim_left,trim_right和trim   </p>
<p><img src="/2016/10/22/boost-book/image-96.png" width="500px"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/format.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_zero_or_one</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="keyword">return</span> x == <span class="string">'0'</span> || x == <span class="string">'1'</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> is01 = [](<span class="keyword">char</span> x)</span><br><span class="line">    &#123;   <span class="keyword">return</span> x == <span class="string">'0'</span> || x == <span class="string">'1'</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">format <span class="title">fmt</span><span class="params">(<span class="string">"|%s|\n"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"  samus aran   "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt % trim_copy(str);           <span class="comment">//删除两端空格</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt % trim_left_copy(str);      <span class="comment">//删除左端空格</span></span><br><span class="line"></span><br><span class="line">    trim_right(str);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt % str;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str2 = <span class="string">"2015 Happy new Year!!!"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt % trim_left_copy_if(str2, is_digit());      <span class="comment">//删除左端数组</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt % trim_right_copy_if(str2, is_punct());     <span class="comment">//删除右端标点</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt % trim_copy_if(str2,</span><br><span class="line">            is_punct() || is_digit() || is_space());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|samus aran|</span><br><span class="line">|samus aran   |</span><br><span class="line">|  samus aran|</span><br><span class="line">| Happy <span class="keyword">new</span> Year!!!|</span><br><span class="line">|<span class="number">2015</span> Happy <span class="keyword">new</span> Year|</span><br><span class="line">|Happy <span class="keyword">new</span> Year|</span><br></pre></td></tr></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>string_algo的查找算法提供与std::search()类似的功能,但接口不一样  </p>
<p>它不返回一个迭代器(查找到的位置),而使用了boost.range库的iterator_range返回查找到的整个区间  </p>
<p><img src="/2016/10/22/boost-book/image-97.png" width="500px"><br><img src="/2016/10/22/boost-book/image-98.png" width="500px">  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">format <span class="title">fmt</span><span class="params">(<span class="string">"|%s|. pos = %d\n"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"Long long ago, there was a king."</span>;</span><br><span class="line"></span><br><span class="line">    iterator_range&lt;<span class="built_in">string</span>::iterator&gt; rge;</span><br><span class="line"></span><br><span class="line">    rge = find_first(str, <span class="string">"long"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt % rge % (rge.begin() - str.begin());</span><br><span class="line"></span><br><span class="line">    rge = ifind_first(str, <span class="string">"long"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt % rge % (rge.begin() - str.begin());</span><br><span class="line"></span><br><span class="line">    rge = find_nth(str, <span class="string">"ng"</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt % rge % (rge.begin() - str.begin());</span><br><span class="line"></span><br><span class="line">    rge = find_head(str, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt % rge % (rge.begin() - str.begin());</span><br><span class="line"></span><br><span class="line">    rge = find_tail(str, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fmt % rge % (rge.begin() - str.begin());</span><br><span class="line"></span><br><span class="line">    rge = find_first(str, <span class="string">"samus"</span>);</span><br><span class="line">    assert(rge.empty() &amp;&amp; !rge);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|<span class="keyword">long</span>|. pos = <span class="number">5</span></span><br><span class="line">|Long|. pos = <span class="number">0</span></span><br><span class="line">|ng|. pos = <span class="number">29</span></span><br><span class="line">|Long|. pos = <span class="number">0</span></span><br><span class="line">|king.|. pos = <span class="number">27</span></span><br></pre></td></tr></table></figure>
<h3 id="替换与删除"><a href="#替换与删除" class="headerlink" title="替换与删除"></a>替换与删除</h3><p>替换、删除与查找算法接近,对查找到的结果进行字符串处理  </p>
<p><img src="/2016/10/22/boost-book/image-99.png" width="500px"><br><img src="/2016/10/22/boost-book/image-100.png" width="500px"><br><img src="/2016/10/22/boost-book/image-101.png" width="500px">  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"Samus beat the monster.\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; replace_first_copy(str, <span class="string">"Samus"</span>, <span class="string">"samus"</span>);</span><br><span class="line"></span><br><span class="line">    replace_last(str, <span class="string">"beat"</span>, <span class="string">"kill"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line"></span><br><span class="line">    replace_tail(str, <span class="number">9</span>, <span class="string">"ridley.\n"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ierase_all_copy(str, <span class="string">"samus"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; replace_nth_copy(str, <span class="string">"l"</span>, <span class="number">1</span>, <span class="string">"L"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; erase_tail_copy(str, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">samus beat the monster.</span><br><span class="line">Samus kill the monster.</span><br><span class="line">Samus kill the ridley.</span><br><span class="line"> kill the ridley.</span><br><span class="line">Samus kilL the ridley.</span><br><span class="line">Samus kill the</span><br></pre></td></tr></table></figure>
<h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>string_algo提供了两个字符串分割算法,find_all和split  </p>
<p><img src="/2016/10/22/boost-book/image-102.png" width="500px">   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"Samus,Link.Zelda::Mario-Luigi+zelda"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; d;</span><br><span class="line">    ifind_all(d, str, <span class="string">"zELDA"</span>);</span><br><span class="line">    assert(d.size() == <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : d)</span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span>&lt;&lt; x &lt;&lt; <span class="string">"] "</span>;    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;iterator_range&lt;<span class="built_in">string</span>::iterator&gt; &gt; l;</span><br><span class="line">    split(l, str, is_any_of(<span class="string">",.:-+"</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : l)</span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span>&lt;&lt; x &lt;&lt; <span class="string">"]"</span>; &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    l.clear();</span><br><span class="line">    split(l, str, is_any_of(<span class="string">".:-"</span>), token_compress_on);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : l)</span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span>&lt;&lt; x &lt;&lt; <span class="string">"]"</span>; &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Zelda] [zelda] </span><br><span class="line">[Samus][Link][Zelda][][Mario][Luigi][zelda]</span><br><span class="line">[Samus,Link][Zelda][Mario][Luigi+zelda]</span><br></pre></td></tr></table></figure>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>合并算法join是分割算法的逆运算<br>把容器连接成新字符串,并指定连接的分隔符  </p>
<p><img src="/2016/10/22/boost-book/image-103.png" width="500px">   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/assign.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case9</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::assign;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v = list_of(<span class="string">"Samus"</span>)(<span class="string">"Link"</span>)(<span class="string">"Zelda"</span>)(<span class="string">"Mario"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; join(v, <span class="string">"+"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; join_if(v, "**", is_contains_a());</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; join_if(v, <span class="string">"**"</span>,</span><br><span class="line">                    [](string_ref s)</span><br><span class="line">                    &#123; <span class="keyword">return</span> contains(s, <span class="string">"a"</span>); &#125;</span><br><span class="line">                    );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找-分隔-迭代器"><a href="#查找-分隔-迭代器" class="headerlink" title="查找(分隔)迭代器"></a>查找(分隔)迭代器</h3><p>通用的find_all或split之外, string_algo库提供了两个查找迭代器find_iterator和split_iterator  </p>
<p>可实现字符串中像迭代器那样遍历匹配，执行查找或分割,无需使用容器来容纳  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case10</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"Samus||samus||mario||||Link"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//typedef find_iterator&lt;string::iterator&gt; string_find_iterator;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//string_find_iterator pos, end;</span></span><br><span class="line">    <span class="comment">//for (pos = make_find_iterator(str, first_finder("samus", is_iequal()));</span></span><br><span class="line">    <span class="comment">//        pos != end; ++pos)</span></span><br><span class="line">    <span class="comment">//&#123;   cout &lt;&lt; "[" &lt;&lt; *pos &lt;&lt; "]" ;    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pos = make_find_iterator(str, first_finder(<span class="string">"samus"</span>, is_iequal()));     </span><br><span class="line">    <span class="keyword">decltype</span>(pos) end;</span><br><span class="line">    <span class="keyword">for</span>(; pos != end; ++pos)</span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; *pos &lt;&lt; <span class="string">"]"</span> ;    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> split_iterator&lt;<span class="built_in">string</span>::iterator&gt; string_split_iterator;</span><br><span class="line"></span><br><span class="line">    string_split_iterator p, endp;</span><br><span class="line">    <span class="keyword">for</span> (p = make_split_iterator(str, first_finder(<span class="string">"||"</span>, is_iequal()));</span><br><span class="line">            p != endp;  ++p) <span class="comment">//声明分割迭代器变量  </span></span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; *p &lt;&lt; <span class="string">"]"</span> ;  &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用first_finder()函数,用于判断匹配对象,然后在用make_find_iterator()火make_split_iterator来真正创建迭代器  </p>
<p>查找函数除了first_finder还有如下  </p>
<ul>
<li>last_finder </li>
<li>nth_finder  </li>
<li>token_finder  </li>
</ul>
<h1 id="数学-数字"><a href="#数学-数字" class="headerlink" title="数学/数字"></a>数学/数字</h1><h2 id="math"><a href="#math" class="headerlink" title="math"></a>math</h2><p><img src="/2016/10/22/boost-book/image-132.png" width="500px"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/math/constants/constants.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::math;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> a = float_constants::pi * <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"area \t\t= "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> double_constants;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> x = root_two * root_three;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"root 2 * 3 \t= "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"root pi \t= "</span> &lt;&lt; root_pi &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pi pow e \t= "</span> &lt;&lt; pi_pow_e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">area        = <span class="number">12.56637096405029296875</span></span><br><span class="line">root <span class="number">2</span> * <span class="number">3</span>  = <span class="number">2.449489742783178325424842114443890750408172607421875</span></span><br><span class="line">root pi     = <span class="number">1.7724538509055161039640324815991334617137908935546875</span></span><br><span class="line">pi <span class="built_in">pow</span> e    = <span class="number">22.459157718361044686616878607310354709625244140625</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>高级用法  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/multiprecision/cpp_dec_float.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> constants;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(pi&lt;<span class="keyword">float</span>&gt;)</span> pi_t</span>;</span><br><span class="line">    assert(is_function&lt;<span class="keyword">pi_t</span>&gt;::value);</span><br><span class="line"></span><br><span class="line">    assert(pi&lt;<span class="keyword">float</span>&gt;() == float_constants::pi);</span><br><span class="line">    assert(pi&lt;<span class="keyword">double</span>&gt;() == double_constants::pi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> boost::multiprecision::cpp_dec_float_100 float_100;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">100</span>)</span><br><span class="line">         &lt;&lt; pi&lt;float_100&gt;() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068</span></span><br></pre></td></tr></table></figure>
<p>高精度数组库<code>boost::multiprecision</code>  </p>
<h2 id="integer"><a href="#integer" class="headerlink" title="integer"></a>integer</h2><p>integer库提供了一组有关整数处理的头文件和类,具有良好的可移植性  </p>
<h3 id="integer-traits"><a href="#integer-traits" class="headerlink" title="integer_traits"></a>integer_traits</h3><p>integer_traits 整数特征类,由于继承自<code>std::numeric_limits&lt;&gt;</code>,因此拥有<code>std::numeric_limits</code>的全部能力   </p>
<ul>
<li>min最小值  </li>
<li>max最大值  </li>
<li>const_min静态最小    </li>
<li>const_max静态最大   </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/integer_traits.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; integer_traits&lt;<span class="keyword">int</span> &gt;::const_max &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; integer_traits&lt;<span class="keyword">bool</span>&gt;::const_min &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; integer_traits&lt;<span class="keyword">long</span>&gt;::is_signed &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2147483647</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="标准整数类型"><a href="#标准整数类型" class="headerlink" title="标准整数类型"></a>标准整数类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/cstdint.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span>         u8;</span><br><span class="line">    <span class="keyword">int_fast16_t</span>    i16;</span><br><span class="line">    <span class="keyword">int_least32_t</span>   i32;</span><br><span class="line">    <span class="keyword">uintmax_t</span>       um;</span><br><span class="line"></span><br><span class="line">    u8  = <span class="number">255</span>;</span><br><span class="line">    i16 = <span class="number">32000</span>;</span><br><span class="line">    i32 = i16;</span><br><span class="line">    um  = u8 + i16 + i32;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"u8 :"</span> &lt;&lt; <span class="keyword">sizeof</span>(u8) </span><br><span class="line">        &lt;&lt; <span class="string">" v = "</span>&lt;&lt; (<span class="keyword">short</span>)u8 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"i16 :"</span> &lt;&lt; <span class="keyword">sizeof</span>(i16) </span><br><span class="line">        &lt;&lt; <span class="string">" v = "</span>&lt;&lt; i16 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"i32 :"</span> &lt;&lt; <span class="keyword">sizeof</span>(i32) </span><br><span class="line">        &lt;&lt; <span class="string">" v = "</span>&lt;&lt; i32 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"um :"</span> &lt;&lt; <span class="keyword">sizeof</span>(um) </span><br><span class="line">        &lt;&lt; <span class="string">" v = "</span>&lt;&lt; um &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">short</span>)numeric_limits&lt;<span class="keyword">int8_t</span>&gt;::max() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; numeric_limits&lt;<span class="keyword">uint_least16_t</span>&gt;::max() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; numeric_limits&lt;<span class="keyword">int_fast32_t</span>&gt;::max() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; numeric_limits&lt;<span class="keyword">intmax_t</span>&gt;::min() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u8 :<span class="number">1</span> v = <span class="number">255</span></span><br><span class="line">i16 :<span class="number">2</span> v = <span class="number">32000</span></span><br><span class="line">i32 :<span class="number">4</span> v = <span class="number">32000</span></span><br><span class="line">um :<span class="number">8</span> v = <span class="number">64255</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">65535</span></span><br><span class="line"><span class="number">2147483647</span></span><br><span class="line"><span class="number">-9223372036854775808</span></span><br></pre></td></tr></table></figure>
<h2 id="ratio"><a href="#ratio" class="headerlink" title="ratio"></a>ratio</h2><p>小时、千克、尺等待为,</p>
<h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><p><img src="/2016/10/22/boost-book/image-133.png" width="500px">  </p>
<p><img src="/2016/10/22/boost-book/image-134.png" width="500px">  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/random.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mt19937 rng(time(0));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mt19937::min() &lt;&lt; <span class="string">"&lt;-&gt;"</span></span><br><span class="line">        &lt;&lt; mt19937::max() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rng() &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rng.discard(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>);</span><br><span class="line">    rng.generate(vec.begin(), vec.end());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mt19937 rng(time(0));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  rng() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">mt19937 <span class="title">rng2</span><span class="params">(rng)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;++i)</span><br><span class="line">    &#123;   assert(rng() == rng2());    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//using namespace boost::random;</span></span><br><span class="line">    mt19937 rng(time(0));</span><br><span class="line"></span><br><span class="line">    random::uniform_int_distribution&lt;&gt; ui(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;++i)</span><br><span class="line">    &#123;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ui(rng) &lt;&lt; <span class="string">","</span>; &#125;</span><br><span class="line">    assert(ui.a() == <span class="number">0</span> &amp;&amp; ui.b() == <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    uniform_01&lt;&gt; u01;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;++i)</span><br><span class="line">    &#123;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u01(rng) &lt;&lt; <span class="string">","</span>;    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    normal_distribution&lt;&gt; nd(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10000</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(nd(rng) - <span class="number">1</span>) &lt;= <span class="number">2.0</span>)</span><br><span class="line">        &#123;   ++count;    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1.0</span> * count / <span class="number">10000</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mt19937 rng((int32_t)time(0));</span><br><span class="line">    uniform_smallint&lt;&gt;  us(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    variate_generator&lt;mt19937&amp;, uniform_smallint&lt;&gt;&gt; gen(rng, us);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; ++i)</span><br><span class="line">    &#123;       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; gen() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Rng &gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rand_bytes</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> buf_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> variate_generator&lt;Rng, uniform_smallint&lt;&gt;&gt; <span class="keyword">var_gen_t</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var_gen_t</span></span><br><span class="line">        gen(Rng((<span class="keyword">typename</span> Rng::result_type)time(<span class="number">0</span>)),</span><br><span class="line">                uniform_smallint&lt;&gt;(<span class="number">1</span>,<span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    generate_n(buf, buf_len, <span class="built_in">std</span>::ref(gen));</span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt; buf_len; ++i)</span></span><br><span class="line">    <span class="comment">//&#123;   buf[i] = gen();&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    rand_bytes&lt;mt19937&gt;(buf, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span> ;++i)</span><br><span class="line">    &#123;       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">short</span>)buf[i] &lt;&lt; <span class="string">","</span>;   &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    rand_bytes&lt;rand48&gt;(buf, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span> ;++i)</span><br><span class="line">    &#123;       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">short</span>)buf[i] &lt;&lt; <span class="string">","</span>;   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/nondet_random.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">boost</span>:</span>:random_device::impl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        rand48 rng;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        impl():rng(time(<span class="number">0</span>))</span><br><span class="line">    &#123;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"random_device::impl ctor\n"</span>;   &#125;</span><br><span class="line"></span><br><span class="line">    ~impl() </span><br><span class="line">    &#123;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"random_device::impl dtor\n"</span>;   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="keyword">return</span> rng();   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">boost::random_device::random_device()</span><br><span class="line">: pimpl(<span class="keyword">new</span> impl)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">boost::random_device::~random_device()</span><br><span class="line">&#123;   <span class="keyword">delete</span> pimpl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> boost::random_device::entropy() <span class="keyword">const</span></span><br><span class="line">&#123;   <span class="keyword">return</span> <span class="number">10</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> boost::random_device::<span class="keyword">operator</span>()()</span><br><span class="line">&#123;   <span class="keyword">return</span> (*pimpl)();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    random_device rng;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">10</span> ; ++i)</span><br><span class="line">    &#123;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rng() &lt;&lt; <span class="string">","</span>;   &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    uniform_real&lt;&gt; ur(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">10</span> ; ++i)</span><br><span class="line">    &#123;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ur(rng) &lt;&lt; <span class="string">","</span>; &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    variate_generator&lt;random_device&amp;, uniform_smallint&lt;&gt;&gt; </span><br><span class="line">        gen(rng, uniform_smallint&lt;&gt;(<span class="number">0</span>,<span class="number">255</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">10</span> ; ++i)</span><br><span class="line">    &#123;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; gen() &lt;&lt; <span class="string">","</span>;   &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    case1();</span><br><span class="line">    case2();</span><br><span class="line">    case3();</span><br><span class="line">    case4();</span><br><span class="line">    case5();</span><br><span class="line">    case6();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>c++98提供大量算法,超过100个,可以对容器执行统计、查找、赋值、排序等操作  </p>
<p>c++11、14增强了标准算法,增加了all_of、any_of、none_of等算法  </p>
<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>foreach库提供了两个宏,BOOST_FOREACH和BOOST_REVERSE_FOREACH分别实现对序列的正向遍历和反向遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/foreach.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/assign.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::assign;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = (list_of(<span class="number">1</span>),<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    BOOST_FOREACH(<span class="keyword">auto</span> x, v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"boost foreach"</span>)</span></span>;</span><br><span class="line">    BOOST_REVERSE_FOREACH(<span class="keyword">auto</span>&amp; c, str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">"-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s = list_of(<span class="number">10</span>)(<span class="number">20</span>)(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    BOOST_FOREACH (x, s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (++x % <span class="number">7</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,</span><br><span class="line">h-c-a-e-r-o-f- -t-s-o-o-b-</span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>
<p>BOOST_FOREACH虽然是个宏,但内部不使用动态内存分配、虚拟函数、函数指针调用等降低效率收发,其循环执行效率几乎和手写循环同样高效   </p>
<p>BOOST_FOREACH不能改变序列的长度，也不能增减序列的元素，否则会导致遍历使用的迭代器失效，发生未定义错误  </p>
<p>循环体也可以用<code>break</code>,<code>continue</code>,<code>return</code>函数调用,也可以再嵌入一个BOOST_FOREACH  </p>
<p>当然BOOST_FOREACH可以用小写<code>foreach</code>,它只是个宏定义  </p>
<h3 id="支持的序列类型"><a href="#支持的序列类型" class="headerlink" title="支持的序列类型"></a>支持的序列类型</h3><p>BOOST_FOREACH是建立在boost.range的概念上,任何符合range概念的容器序列就会自动被支持  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/array.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/circular_buffer.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/unordered_set.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::assign;</span><br><span class="line"></span><br><span class="line">    boost::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; ar = (list_of(<span class="number">1</span>), <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    foreach(<span class="keyword">auto</span> x, ar)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    pair&lt;<span class="keyword">decltype</span>(ar.begin()), <span class="keyword">decltype</span>(ar.end())&gt;</span><br><span class="line">        rng(ar.begin(), ar.end() <span class="number">-2</span>);</span><br><span class="line">    foreach(<span class="keyword">auto</span> x, rng)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    boost::circular_buffer&lt;<span class="keyword">int</span>&gt; cb = list_of(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br><span class="line">    foreach(<span class="keyword">auto</span> x, cb)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    boost::<span class="built_in">unordered_set</span>&lt;<span class="keyword">double</span>&gt; us = list_of(<span class="number">3.14</span>)(<span class="number">2.717</span>)(<span class="number">0.618</span>);</span><br><span class="line">    foreach(<span class="keyword">auto</span> x, us)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>他是宏定义所以一旦有”含逗号的模板”就会失效  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOST_FOREACH(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; x, m); <span class="comment">//错认为有三个宏参数</span></span><br></pre></td></tr></table></figure>
<p>可使用下面解决方案</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOST_FOREACH(BOOST_INDENTITY_TYPE((pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;)) x, <span class="built_in">map</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="minmax"><a href="#minmax" class="headerlink" title="minmax"></a>minmax</h2><p>minmax是对c++98标准中的算法std::min/max和std::min_element/max_element的增强  </p>
<p>minmax()函数改进了std::min/max函数,可同时返回两个参数的最大最小值,位于名字空间boost,为了使用minmax组件需要包含头&lt;boost/algorithm/minmax.hpp&gt;   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boolst/algorithm/minmax.hpp&gt;</span></span></span><br><span class="line">usering <span class="keyword">namespace</span> boost;</span><br></pre></td></tr></table></figure>
<p><img src="/2016/10/22/boost-book/image-128.png" width="500px"> </p>
<h3 id="用法-6"><a href="#用法-6" class="headerlink" title="用法"></a>用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/algorithm/minmax.hpp&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace boost;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="number">200</span>, <span class="number">12</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="number">200</span>, <span class="number">12</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> x = boost::minmax(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; boost::get&lt;<span class="number">0</span>&gt;(x) &lt;&lt; <span class="string">" "</span> &lt;&lt; boost::get&lt;<span class="number">1</span>&gt;(x);</span><br><span class="line">    <span class="comment">//第一个元素是小值,第二个元素是大值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="存在的问题-1"><a href="#存在的问题-1" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>minmax()在内部使用make_tuple和cref来生成比较结果的tuple,但并没有使用名字空间的boost限定,这导致在与C++11标准库混用时可能产生问题  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s1("5000"), s2("123");</span><br><span class="line"></span><br><span class="line">    <span class="comment">//auto xx = boost::minmax(s1, s2); //因为内部std命名空间混乱了 </span></span><br><span class="line">    <span class="keyword">auto</span> x = <span class="built_in">std</span>::minmax(s1, s2) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; get&lt;<span class="number">0</span>&gt;(x) &lt;&lt; <span class="string">" "</span> &lt;&lt; get&lt;<span class="number">1</span>&gt;(x) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> y = <span class="built_in">std</span>::minmax(&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">1</span>&#125;) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; get&lt;<span class="number">0</span>&gt;(y) &lt;&lt; <span class="string">" "</span> &lt;&lt; get&lt;<span class="number">1</span>&gt;(y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以推荐使用std::minmax </p>
<h2 id="minmax-element"><a href="#minmax-element" class="headerlink" title="minmax_element"></a>minmax_element</h2><p>minmax_element并不是一个算法,而是一个算法族,包括first_min_element()、last_min_element()、first_min_first_max_element()、first_min_last_max_element()等一系列算法  </p>
<h3 id="用法-7"><a href="#用法-7" class="headerlink" title="用法"></a>用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/algorithm/minmax_element.hpp&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace boost;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">633</span>, <span class="number">90</span>, <span class="number">67</span>,<span class="number">83</span>, <span class="number">2</span>, <span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> x = boost::minmax_element(v.begin(), v.end());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"min : "</span> &lt;&lt; *x.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"max : "</span>&lt;&lt; *x.second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">min : <span class="number">2</span></span><br><span class="line">max : <span class="number">633</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">decltype</span>(v.begin()) pos;</span><br><span class="line">    pos = boost::first_min_element(v.begin(),v.end());      <span class="comment">//找第一个最小值</span></span><br><span class="line">    assert(pos - v.begin() == <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    pos = boost::last_min_element(v.begin(),v.end());       <span class="comment">//找最后一个最小值</span></span><br><span class="line">    assert(pos - v.begin() == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> x = boost::first_min_last_max_element(v.begin(),v.end());</span><br><span class="line">    <span class="comment">//第一个最小值和最后一个最大值</span></span><br><span class="line"></span><br><span class="line">    assert(x.first - v.begin() == <span class="number">2</span> &amp;&amp;</span><br><span class="line">            x.second - v.begin() == <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><p>algorithm库是一个算法的集合,包含了C++11/14算法的实现和很多有用的小算法,如all_of,none_of,equal,KMP,Boyer-Moore等等   </p>
<h3 id="clamp"><a href="#clamp" class="headerlink" title="clamp"></a>clamp</h3><p>clamp算法位于名字空间boost::algorithm </p>
<p><img src="/2016/10/22/boost-book/image-129.png" width="500px">  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/algorithm/clamp.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::algorithm;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(clamp(<span class="number">5</span>, <span class="number">1</span>, <span class="number">10</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(clamp(<span class="number">5</span>, <span class="number">5</span>, <span class="number">10</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(clamp(<span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    assert(clamp(<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(clamp(<span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>) == <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="clamp-range"><a href="#clamp-range" class="headerlink" title="clamp_range"></a>clamp_range</h3><p>可以操作迭代器或容器的版本clamp_range,它可以对一组元素执行clamp算法,然后把结果写入到一个输出迭代器  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    clamp_range(v, ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">","</span>), <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3,4,6,8,9</span></span><br></pre></td></tr></table></figure>
<h3 id="hex和unhex"><a href="#hex和unhex" class="headerlink" title="hex和unhex"></a>hex和unhex</h3><p>hex算法用来执行十六进制编码和解码,包含两个互逆操作:hex和unhex  </p>
<p><img src="/2016/10/22/boost-book/image-130.png" width="500px"></p>
<p><img src="/2016/10/22/boost-book/image-131.png" width="500px"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/algorithm/hex.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::algorithm;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">    hex(<span class="string">"123"</span>, ostream_iterator&lt;<span class="keyword">char</span>&gt;(<span class="built_in">cout</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    hex(<span class="string">"ABC"</span>, <span class="built_in">std</span>::back_inserter(s));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    unhex(s, ostream_iterator&lt;<span class="keyword">char</span>&gt;(<span class="built_in">cout</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    hex(<span class="string">"+-*/"</span>, ostream_iterator&lt;<span class="keyword">char</span>&gt;(<span class="built_in">cout</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    hex_lower(<span class="string">"+-*/"</span>, ostream_iterator&lt;<span class="keyword">char</span>&gt;(<span class="built_in">cout</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">313233</span></span><br><span class="line"><span class="number">414243</span></span><br><span class="line">ABC</span><br><span class="line"><span class="number">2B</span>2D2A2F</span><br><span class="line"><span class="number">2b</span>2d2a2f</span><br></pre></td></tr></table></figure>
<h1 id="容器和数据结构"><a href="#容器和数据结构" class="headerlink" title="容器和数据结构"></a>容器和数据结构</h1><h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>包装C++语言内建数组,为期提供标准的容器接口  </p>
<p><img src="/2016/10/22/boost-book/image-16.png" width="500px"></p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>array重载了[]操作符,可以像普通数组和std::vector一样用下标访问内部元素</p>
<p><img src="/2016/10/22/boost-book/image-17.png" width="500px"><br><img src="/2016/10/22/boost-book/image-18.png" width="500px"></p>
<h3 id="用法-8"><a href="#用法-8" class="headerlink" title="用法"></a>用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/array.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ar;       <span class="comment">//一个大小为10的int数组</span></span><br><span class="line"></span><br><span class="line">    ar[<span class="number">0</span>] = <span class="number">1</span>;      <span class="comment">//使用operator[]操作</span></span><br><span class="line">    ar.back() = <span class="number">10</span>; <span class="comment">//back访问最后一个元素</span></span><br><span class="line">    assert(ar[ar.max_size() - <span class="number">1</span>] == <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    ar.assign(<span class="number">777</span>); <span class="comment">//数组所有元素赋值为777 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : ar)<span class="comment">// for auto 遍历</span></span><br><span class="line">    &#123;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">","</span>;   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = ar.c_array(); <span class="comment">//获得原始数组指针</span></span><br><span class="line">    *(p + <span class="number">5</span>) = <span class="number">253</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ar[<span class="number">5</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    ar.at(<span class="number">8</span>) = <span class="number">666</span>; <span class="comment">//使用at函数访问元素</span></span><br><span class="line">    <span class="built_in">std</span>::sort(ar.begin(), ar.end()); <span class="comment">//使用标准算法排序</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p><img src="/2016/10/22/boost-book/image-19.png" width="500px"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/assign.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, 3&gt; ar = &#123;<span class="string">"alice"</span>,<span class="string">"bob"</span>, <span class="string">"carl"</span>&#125;;</span><br><span class="line">    <span class="comment">//它没有构造函数，但是可以使用与普通数组一样的风格进行初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ar1 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    assert(<span class="built_in">std</span>::equal(ar1.begin(), ar1.end(), a));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, 3&gt; ar2 = &#123;<span class="string">"racer"</span>&#125;;</span><br><span class="line">    assert(ar2.at(<span class="number">1</span>).empty());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::assign;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt; arr(list_of(<span class="number">2</span>)(<span class="number">4</span>)(<span class="number">6</span>)) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0u</span>;i&lt; arr.size() ;++i)</span><br><span class="line">    &#123;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">","</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对比C-11标准"><a href="#对比C-11标准" class="headerlink" title="对比C++11标准"></a>对比C++11标准</h3><p><img src="/2016/10/22/boost-book/image-20.png" width="500px"></p>
<h2 id="dynamic-bitset"><a href="#dynamic-bitset" class="headerlink" title="dynamic_bitset"></a>dynamic_bitset</h2><p>vector<bool> 对元素类型bool的vector特化,内部并不真正存储bool,而是以bit来压缩保存,使用代理技术操作bit,造成的结果是很像容器  </bool></p>
<p><img src="/2016/10/22/boost-book/image-104.png" width="500px"><br><img src="/2016/10/22/boost-book/image-105.png" width="500px"></p>
<p>dynamic_bitset几乎和std::bitset相同,包括接口和行为,唯一区别是dynamic_bitset的大小在构造函数中由参数指定的,而且运行时是可变的  </p>
<h3 id="创建与赋值"><a href="#创建与赋值" class="headerlink" title="创建与赋值"></a>创建与赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/core/lightweight_test.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/utility.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/dynamic_bitset.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dynamic_bitset&lt;&gt; db1;</span><br><span class="line">    dynamic_bitset&lt;&gt; db2(<span class="number">10</span>);       <span class="comment">//大小为10的dynamic_bitset</span></span><br><span class="line">    dynamic_bitset&lt;&gt; db3(<span class="number">0x16</span>,      </span><br><span class="line">    BOOST_BINARY(<span class="number">10101</span>));       <span class="comment">//注意这里      //大小为20的dynamic_bitset</span></span><br><span class="line">    dynamic_bitset&lt;&gt; db4(<span class="built_in">string</span>(<span class="string">"0100"</span>));   <span class="comment">//字符串构造</span></span><br><span class="line">    dynamic_bitset&lt;&gt; db5(db3);      <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">    dynamic_bitset&lt;&gt; db6;</span><br><span class="line">    db6 = db4;                      <span class="comment">//赋值操作符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; db5.to_ulong() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//转换为整数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; db4[<span class="number">0</span>] &lt;&lt; db4[<span class="number">1</span>] &lt;&lt; db4[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//使用operator[]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dynamic_bitset&lt;&gt; db;        <span class="comment">//空的dynamic_bitset</span></span><br><span class="line"></span><br><span class="line">    db.resize(<span class="number">10</span>, <span class="literal">true</span>);    <span class="comment">//扩展10个二进制,值全为1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; db &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//输出1111111111</span></span><br><span class="line"></span><br><span class="line">    db.resize(<span class="number">5</span>);       <span class="comment">//缩小容量5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; db &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//输出11111</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        dynamic_bitset&lt;&gt; db(<span class="number">5</span>,BOOST_BINARY(<span class="number">01110</span>));     </span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; db &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// 01110</span></span><br><span class="line">        assert(db.size() == <span class="number">5</span>);     <span class="comment">//目前有5个二进制位</span></span><br><span class="line"></span><br><span class="line">        db.clear();     <span class="comment">//清空dynamic_bitset</span></span><br><span class="line">        assert(db.empty()&amp;&amp; db.size()==<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(dynamic_bitset&lt;&gt;(<span class="number">64</span>).num_blocks()==<span class="number">1</span>);       <span class="comment">//64位linux占用一个区块</span></span><br><span class="line">    assert(dynamic_bitset&lt;&gt;(<span class="number">65</span>).num_blocks()==<span class="number">2</span>);        <span class="comment">//64位linux占用2个区块</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        dynamic_bitset&lt;&gt; db(<span class="number">5</span>,BOOST_BINARY(<span class="number">01001</span>));</span><br><span class="line">        db.push_back(<span class="literal">true</span>);</span><br><span class="line">        assert(db.to_ulong() == BOOST_BINARY_UL(<span class="number">101001</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        dynamic_bitset&lt;&gt; db(<span class="number">5</span>,BOOST_BINARY(<span class="number">01001</span>));</span><br><span class="line">        db.append(BOOST_BINARY(<span class="number">101</span>));</span><br><span class="line">        assert(db.size() == <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)*<span class="number">8</span> + <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; db &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">//0000000000000000000000000000010101001</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="位运算与比较运算"><a href="#位运算与比较运算" class="headerlink" title="位运算与比较运算"></a>位运算与比较运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dynamic_bitset&lt;&gt; db1(<span class="number">4</span>, BOOST_BINARY(<span class="number">1010</span>));</span><br><span class="line"></span><br><span class="line">    db1[<span class="number">0</span>] &amp;= <span class="number">1</span>;</span><br><span class="line">    db1[<span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; db1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    dynamic_bitset&lt;&gt; db2(<span class="number">4</span>, BOOST_BINARY(<span class="number">0101</span>));</span><br><span class="line">    assert(db1 &gt; db2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (db1 ^ db2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (db1 | db2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>除了使用operator[]直接访问容器内元素外,dynamic_bitset还有数个成员函数用于测试或者翻转二进制位  </p>
<p><img src="/2016/10/22/boost-book/image-106.png" width="500px"><br><img src="/2016/10/22/boost-book/image-107.png" width="500px"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dynamic_bitset&lt;&gt; db(<span class="number">4</span>, BOOST_BINARY(<span class="number">0101</span>));</span><br><span class="line"></span><br><span class="line">    assert(db.test(<span class="number">0</span>) &amp;&amp; !db.test(<span class="number">1</span>));</span><br><span class="line">    assert(db.any() &amp;&amp; !db.none());</span><br><span class="line">    assert(db.count() == <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        dynamic_bitset&lt;&gt; db(<span class="number">4</span>, BOOST_BINARY(<span class="number">0101</span>));</span><br><span class="line"></span><br><span class="line">        db.flip();</span><br><span class="line">        assert(db.to_ulong() == BOOST_BINARY(<span class="number">1010</span>));</span><br><span class="line"></span><br><span class="line">        db.<span class="built_in">set</span>();</span><br><span class="line">        assert(!db.none());</span><br><span class="line"></span><br><span class="line">        db.reset();</span><br><span class="line">        assert(!db.any() );</span><br><span class="line"></span><br><span class="line">        db.<span class="built_in">set</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        assert(db.count() == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        dynamic_bitset&lt;&gt; db(<span class="number">5</span>, BOOST_BINARY(<span class="number">00101</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> pos = db.find_first();</span><br><span class="line">        assert(pos == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        pos = db.find_next(pos);</span><br><span class="line">        assert(pos == <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2016/10/22/boost-book/image-108.png" width="500px">  </p>
<h2 id="unordered"><a href="#unordered" class="headerlink" title="unordered"></a>unordered</h2><p>散列容器,hash容器,非常重要的容器类型,比二叉树的存储方式提高更高的访问效率 </p>
<p>c++98并未规定散列容器,等c++标准委员会整理的时候,hash_xxx名字都被占领了,于是就用了unordered_xxx的名字…..  </p>
<p>boost.unordered库完全符合c++11标准的散列容器实现  </p>
<p>只需要头部  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;boost/unordered_set.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;boost/unordered_map.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br></pre></td></tr></table></figure>
<h3 id="散列集合简介-unordered-set"><a href="#散列集合简介-unordered-set" class="headerlink" title="散列集合简介(unordered_set)"></a>散列集合简介(unordered_set)</h3><p>unordered库提供了两个散列集合类unordered_set和unordered_multiset  </p>
<p><img src="/2016/10/22/boost-book/image-109.png" width="500px"><br><img src="/2016/10/22/boost-book/image-110.png" width="500px">  </p>
<h4 id="散列集合的用法"><a href="#散列集合的用法" class="headerlink" title="散列集合的用法"></a>散列集合的用法</h4><p>unordered_set具有与std::set相同的功能,可以用size()获得容器的大小,用empty()判空,支持比较操作符,可以用count(),find(),大多数应用std::Set的场景都能用unordered_set替换  </p>
<p>由于hash容器是无序,所以不能使用binary_search、lower_bound和upper_bound用于已序区间的算法  </p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/assign.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/unordered_set.hpp&gt;      </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/unordered_map.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span> &gt; s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;        <span class="comment">//初始化数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : s)        <span class="comment">//for遍历集合</span></span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;   &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//获取容器大小</span></span><br><span class="line"></span><br><span class="line">    s.clear();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.empty() &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//判断是否为空</span></span><br><span class="line"></span><br><span class="line">    s.insert(<span class="number">8</span>);                    <span class="comment">//插入元素</span></span><br><span class="line">    s.insert(<span class="number">45</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *s.find(<span class="number">8</span>) &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//查找元素</span></span><br><span class="line"></span><br><span class="line">    s.erase(<span class="number">45</span>);            <span class="comment">//删除元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::assign;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; us1 = list_of(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);  <span class="comment">//assign库赋值</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; us2 = list_of(<span class="number">3</span>)(<span class="number">2</span>)(<span class="number">1</span>);</span><br><span class="line">    assert(us1 == us2 );        <span class="comment">//容器相等  </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对比C-11标准-1"><a href="#对比C-11标准-1" class="headerlink" title="对比C++11标准"></a>对比C++11标准</h4><p>unordered_set与c++11标准定义的hash散列容器完全兼容  </p>
<p>支持转移(move)语义,和新的emplace方法  </p>
<p>emplace两中形式: </p>
<ul>
<li>emplace_hint():使用若干参数创建对象插入到容器中,避免拷贝对象的代价     </li>
<li>emplace(直接放入)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; <span class="keyword">complex_t</span>;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">complex_t</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    s.emplace(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">    s.emplace(<span class="number">3.0</span>, <span class="number">4.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : s)</span><br><span class="line">    &#123;    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">","</span>;&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    s.emplace_hint(s.begin(), <span class="number">5.0</span>, <span class="number">6.0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : s)</span><br><span class="line">    &#123;    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">","</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="散列映射-unordered-map"><a href="#散列映射-unordered-map" class="headerlink" title="散列映射(unordered_map)"></a>散列映射(unordered_map)</h3><p>unordered库提供两个散列映射unordered_map和unordered_multimap,他们的接口和用法与c++11标准关联容器map/multimap相同  </p>
<p>只是内部使用了散列表代替了二叉树实现,比较谓语用equal_to&lt;&gt;  </p>
<p><img src="/2016/10/22/boost-book/image-111.png" width="500px"><br><img src="/2016/10/22/boost-book/image-112.png" width="500px"></p>
<h4 id="散列映射基本用法"><a href="#散列映射基本用法" class="headerlink" title="散列映射基本用法"></a>散列映射基本用法</h4><p>因为unorder_multomap有重复的key-value映射,因此不提供operator[]操作符  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::assign;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; um =</span><br><span class="line">        map_list_of(<span class="number">1</span>,<span class="string">"one"</span>)(<span class="number">2</span>, <span class="string">"two"</span>)(<span class="number">3</span>, <span class="string">"three"</span>); <span class="comment">//assign初始化</span></span><br><span class="line"></span><br><span class="line">    um.insert(make_pair(<span class="number">10</span>,<span class="string">"ten"</span>));     <span class="comment">//insert函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; um[<span class="number">10</span>] &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">//operator[]访问元素</span></span><br><span class="line">    um[<span class="number">11</span>] = <span class="string">"eleven"</span>;              <span class="comment">//关联数组用法</span></span><br><span class="line">    um[<span class="number">15</span>] = <span class="string">"fifteen"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> p = um.begin();</span><br><span class="line">    <span class="keyword">for</span> (; p != um.end(); ++p)          <span class="comment">//使用auto获得迭代器</span></span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt; p-&gt;first &lt;&lt; <span class="string">"-"</span> &lt;&lt; p-&gt;second &lt;&lt; <span class="string">","</span>;    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    um.erase(<span class="number">11</span>);                   <span class="comment">//删除键值为11的元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; um.size() &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//输出5</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; um1 = map_list_of(<span class="number">1</span>,<span class="string">"11"</span>)(<span class="number">2</span>,<span class="string">"22"</span>);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; um2 = map_list_of(<span class="number">1</span>,<span class="string">"one"</span>)(<span class="number">2</span>,<span class="string">"two"</span>);</span><br><span class="line">    assert(um1 != um2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对比c-11标准-1"><a href="#对比c-11标准-1" class="headerlink" title="对比c++11标准"></a>对比c++11标准</h4><p>unordered_map同样支持emplace方法,但因为它持有的是pair,所以用法不同  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; <span class="keyword">complex_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">complex_t</span>&gt; <span class="keyword">um_t</span>;</span><br><span class="line">    <span class="keyword">um_t</span> s;</span><br><span class="line"></span><br><span class="line">    s.emplace(boost::unordered::piecewise_construct,        <span class="comment">//分段构造pair</span></span><br><span class="line">        make_tuple(<span class="number">1</span>),make_tuple(<span class="number">1.0</span>, <span class="number">2.0</span>));               <span class="comment">//使用make_tuple</span></span><br><span class="line">    s.emplace(boost::unordered::piecewise_construct,        <span class="comment">//分段构造pair</span></span><br><span class="line">        make_tuple(<span class="number">3</span>),make_tuple(<span class="number">3.0</span>, <span class="number">4.0</span>));                <span class="comment">//使用make_tuple</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x: s)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; x.first &lt;&lt; <span class="string">"&lt;-&gt;"</span> &lt;&lt; x.second &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    s.emplace_hint(s.begin(),               <span class="comment">//前端放置元素</span></span><br><span class="line">    boost::unordered::piecewise_construct,  </span><br><span class="line">        make_tuple(<span class="number">5</span>),make_tuple(<span class="number">5.0</span>, <span class="number">6.0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x: s)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; x.first &lt;&lt; <span class="string">"&lt;-&gt;"</span> &lt;&lt; x.second &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bimap"><a href="#bimap" class="headerlink" title="bimap"></a>bimap</h2><p>c++标准提供了映射型容器map和multi_map,它们就像关联数组,一个元素的key映射到另一个元素的value,<br>但是这种映射是单向的,只能key到value,而不能反过来  </p>
<p>boost.bimap扩展了标准库的映射型容器,提供双向映射的能力,功能强大  </p>
<h3 id="类摘要-1"><a href="#类摘要-1" class="headerlink" title="类摘要"></a>类摘要</h3><p><img src="/2016/10/22/boost-book/image-113.png" width="500px"><br><img src="/2016/10/22/boost-book/image-114.png" width="500px">  </p>
<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>bimap容纳两个类型的元素,这个关系有左视图和右视图两个视图,分别用left和right访问,相当于两个不同方向的std::map,其用法也同std::map一样  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bimap.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bimap&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; bm;          <span class="comment">//定义一个双向视图的对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bm.left.insert(make_pair(<span class="number">1</span>, <span class="string">"111"</span>));        <span class="comment">//插入数据</span></span><br><span class="line">    bm.left.insert(make_pair(<span class="number">2</span>, <span class="string">"222"</span>));</span><br><span class="line">    <span class="comment">//bm.left.insert(make_pair(2, "555"));  无效操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bm.right.insert(make_pair(<span class="string">"string"</span>, <span class="number">10</span>));       <span class="comment">//插入数据</span></span><br><span class="line">    bm.right.insert(make_pair(<span class="string">"bimap"</span>, <span class="number">20</span>));</span><br><span class="line">    bm.right.insert(make_pair(<span class="string">"bimap"</span>, <span class="number">2</span>)); <span class="comment">//无效操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//左视图map&lt;int,string&gt; 使用迭代器迭代</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pos = bm.left.begin();        <span class="comment">//auto</span></span><br><span class="line">            pos != bm.left.end();++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"left["</span> &lt;&lt; pos-&gt;first &lt;&lt; <span class="string">"]="</span></span><br><span class="line">            &lt;&lt; pos-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//bm.right.begin()-&gt;second = 234;</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        bimap&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; bm;</span><br><span class="line">        typedef decltype(bm)::value_type vt;</span><br><span class="line">        bm.insert(vt(<span class="number">3</span>, <span class="string">"333"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集合类型值"><a href="#集合类型值" class="headerlink" title="集合类型值"></a>集合类型值</h3><p>bimap以自然的方式扩展了映射的语义,将std::map的key/value值的映射关系分为左右两个集合映射关系  </p>
<p>bimap定义的集合类型有如下  </p>
<p><img src="/2016/10/22/boost-book/image-115.png" width="500px"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::bimaps;</span><br><span class="line">bimap&lt;<span class="keyword">int</span>, unordered_set_of&lt; <span class="built_in">string</span>&gt; &gt; bm1;</span><br><span class="line"></span><br><span class="line">bimap&lt; multiset_of&lt;<span class="keyword">int</span>&gt;, multiset_of&lt; <span class="built_in">string</span>&gt; &gt; bm2;</span><br><span class="line"></span><br><span class="line">bimap&lt; unordered_set_of&lt;<span class="keyword">int</span>&gt;, list_of&lt; <span class="built_in">string</span>&gt; &gt; bm3;</span><br><span class="line"></span><br><span class="line">bimap&lt; vector_of&lt;<span class="keyword">int</span>&gt;, unconstrained_set_of&lt; <span class="built_in">string</span>&gt; &gt; bm4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_map</span><span class="params">(T &amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : m)</span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt; x.first &lt;&lt; <span class="string">"&lt;--&gt;"</span>&lt;&lt; x.second &lt;&lt; <span class="built_in">endl</span>;   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bimap&lt;unordered_multiset_of&lt;<span class="keyword">int</span>&gt;, unordered_multiset_of&lt; <span class="built_in">string</span>&gt; &gt; bm;</span><br><span class="line"></span><br><span class="line">    bm.left.insert(make_pair(<span class="number">1</span>, <span class="string">"111"</span>));</span><br><span class="line">    bm.left.insert(make_pair(<span class="number">2</span>, <span class="string">"222"</span>));</span><br><span class="line">    bm.left.insert(make_pair(<span class="number">2</span>, <span class="string">"555"</span>));</span><br><span class="line"></span><br><span class="line">    bm.right.insert(make_pair(<span class="string">"string"</span>, <span class="number">10</span>));</span><br><span class="line">    bm.right.insert(make_pair(<span class="string">"bimap"</span>, <span class="number">20</span>));</span><br><span class="line">    bm.right.insert(make_pair(<span class="string">"bimap"</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    print_map(bm.left);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        bimap&lt;set_of&lt;<span class="keyword">int</span>&gt;, vector_of&lt;<span class="built_in">string</span>&gt; &gt; bm;</span><br><span class="line"></span><br><span class="line">        bm.left.insert(make_pair(<span class="number">1</span>, <span class="string">"111"</span>));</span><br><span class="line">        bm.left[<span class="number">2</span>] = <span class="string">"222"</span>;</span><br><span class="line">        bm.left[<span class="number">300</span>] = <span class="string">"bimap"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//bm.right.insert(make_pair("string", 10));</span></span><br><span class="line"></span><br><span class="line">        print_map(bm.left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用标签类型"><a href="#使用标签类型" class="headerlink" title="使用标签类型"></a>使用标签类型</h3><p>bimap的左视图和右视图分别用bimap.left和bimap.right来访问<br>但是缺乏具体的含义不能表达左右视图的用途  </p>
<p>bimap可以使用bimaps::tagged类给左组和右组数据在语法层面上贴”标签”,从而更清晰说明左右视图的含义  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bimap&lt;tagged&lt;<span class="keyword">int</span>, <span class="class"><span class="keyword">struct</span> <span class="title">id</span>&gt;, <span class="title">vector_of</span>&lt;string&gt; &gt;       <span class="title">bm11</span>;</span></span><br><span class="line">bimap&lt;multiset_of&lt;tagged&lt;<span class="keyword">int</span>, <span class="class"><span class="keyword">struct</span> <span class="title">id</span>&gt; &gt;,</span></span><br><span class="line"><span class="class">        <span class="title">unordered_set_of</span>&lt;tagged&lt; string, struct name&gt; &gt; &gt;       <span class="title">bm12</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bimap&lt;tagged&lt;<span class="keyword">int</span>, <span class="class"><span class="keyword">struct</span> <span class="title">id</span>&gt;, <span class="title">tagged</span>&lt; string, struct name&gt; &gt; <span class="title">bm</span>;</span></span><br><span class="line"></span><br><span class="line">    bm.by&lt;id&gt;().insert(make_pair(<span class="number">1</span>, <span class="string">"samus"</span>));</span><br><span class="line">    bm.by&lt;id&gt;().insert(make_pair(<span class="number">2</span>, <span class="string">"adam"</span>));</span><br><span class="line"></span><br><span class="line">    bm.by&lt;name&gt;().insert(make_pair(<span class="string">"link"</span>, <span class="number">10</span>));</span><br><span class="line">    bm.by&lt;name&gt;().insert(make_pair(<span class="string">"zelda"</span>, <span class="number">11</span>));</span><br><span class="line"></span><br><span class="line">    print_map(bm.by&lt;name&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用assign库"><a href="#使用assign库" class="headerlink" title="使用assign库"></a>使用assign库</h3><p>用以下语法赋值  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/assign.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::bimaps;</span><br><span class="line">    <span class="keyword">typedef</span> bimap&lt;multiset_of&lt;<span class="keyword">int</span>&gt;, vector_of&lt;<span class="built_in">string</span>&gt; &gt; <span class="keyword">bm_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bm_t</span> bm = assign::list_of&lt;<span class="keyword">bm_t</span>::relation&gt;(<span class="number">1</span>, <span class="string">"111"</span>)(<span class="number">2</span>, <span class="string">"222"</span>); <span class="comment">//可以使用这类方式赋值</span></span><br><span class="line">    <span class="comment">//bm_t bm = &#123;&#123;1, "111"&#125;,&#123;2, "222"&#125;&#125;;</span></span><br><span class="line"></span><br><span class="line">    assign::insert(bm.left)(<span class="number">3</span>, <span class="string">"333"</span>)(<span class="number">4</span>, <span class="string">"444"</span>);</span><br><span class="line">    assign::push_back(bm.right)(<span class="string">"555"</span>, <span class="number">5</span>)(<span class="string">"666"</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> left_pos  = bm.left.find(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">auto</span> right_pos = bm.project_right(left_pos);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"right:["</span> &lt;&lt; right_pos-&gt;first </span><br><span class="line">        &lt;&lt; <span class="string">"]="</span> &lt;&lt; right_pos-&gt;second;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h3><p>以键值为索引查找元素  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bimap/support/lambda.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::bimaps;</span><br><span class="line">    <span class="keyword">typedef</span> bimap&lt;<span class="keyword">int</span>, <span class="built_in">string</span> &gt; <span class="keyword">bm_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::assign;</span><br><span class="line">    <span class="keyword">bm_t</span> bm = assign::list_of&lt;<span class="keyword">bm_t</span>::relation&gt;</span><br><span class="line">        (<span class="number">1</span>, <span class="string">"mario"</span>)(<span class="number">2</span>, <span class="string">"peach"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pos = bm.left.find(<span class="number">1</span>);         <span class="comment">//左视图查找键值1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pos-&gt;first</span><br><span class="line">        &lt;&lt; <span class="string">"]="</span> &lt;&lt; pos-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> pos2 = bm.right.find(<span class="string">"peach"</span>);     <span class="comment">//右视图查找键值peach</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pos2-&gt;first</span><br><span class="line">        &lt;&lt; <span class="string">"]="</span> &lt;&lt; pos2-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pos = bm.left.find(1);</span></span><br><span class="line">    <span class="comment">//bm.left.replace_key(pos, 111);</span></span><br><span class="line">    <span class="comment">//bm.left.replace_data(pos, "luigi");</span></span><br><span class="line"></span><br><span class="line">    pos = bm.left.find(<span class="number">1</span>);</span><br><span class="line">    bm.left.modify_key(pos,_key = <span class="number">111</span>);     <span class="comment">//修改key为11</span></span><br><span class="line">    bm.left.modify_data(pos,_data = <span class="string">"luigi"</span>);</span><br><span class="line"></span><br><span class="line">    print_map(bm.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>]=mario</span><br><span class="line">[peach]=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>&lt;--&gt;peach</span><br><span class="line"><span class="number">111</span>&lt;--&gt;luigi</span><br></pre></td></tr></table></figure>
<h3 id="投射"><a href="#投射" class="headerlink" title="投射"></a>投射</h3><p>bitmap提供了三个成员函数 project_left,project_right,project_up可以把bimap的迭代器分别投射到左、右、关系视图上   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::bimaps;</span><br><span class="line">    <span class="keyword">typedef</span> bimap&lt;set_of&lt;tagged&lt;<span class="keyword">int</span>,<span class="class"><span class="keyword">struct</span> <span class="title">id</span>&gt; &gt;, </span></span><br><span class="line"><span class="class">            <span class="title">multiset_of</span>&lt; tagged&lt;string,struct name&gt; &gt; &gt; <span class="title">bm_t</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::assign;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bm_t</span> bm = assign::list_of&lt;<span class="keyword">bm_t</span>::relation&gt;(<span class="number">1</span>, <span class="string">"mario"</span>)(<span class="number">2</span>, <span class="string">"peach"</span>);</span><br><span class="line">        insert(bm.by&lt;id&gt;())(<span class="number">3</span>, <span class="string">"wario"</span>)(<span class="number">4</span>, <span class="string">"luigi"</span>);</span><br><span class="line">        insert(bm.by&lt;name&gt;())(<span class="string">"yoshi"</span>, <span class="number">5</span>)(<span class="string">"olima"</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> right_pos = bm.by&lt;name&gt;().find(<span class="string">"yoshi"</span>);</span><br><span class="line">    <span class="keyword">auto</span> left_pos  = bm.project&lt;id&gt;(right_pos);</span><br><span class="line">    ++left_pos;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"left:["</span> &lt;&lt; left_pos-&gt;get&lt;id&gt;() </span><br><span class="line">        &lt;&lt; <span class="string">"]="</span> &lt;&lt; left_pos-&gt;get&lt;name&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">left:[<span class="number">6</span>]=olima</span><br></pre></td></tr></table></figure>
<h2 id="circular-buffer"><a href="#circular-buffer" class="headerlink" title="circular_buffer"></a>circular_buffer</h2><p>circular_buffer实现了循环缓冲区的数据结构,支持标准的容器操作(如push_back)但大小是固定的,当到达容器末尾时将自动循环利用容器另一端空间   </p>
<h3 id="类摘要-2"><a href="#类摘要-2" class="headerlink" title="类摘要"></a>类摘要</h3><p><img src="/2016/10/22/boost-book/image-116.png" width="400px">  </p>
<h3 id="用法-9"><a href="#用法-9" class="headerlink" title="用法"></a>用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/assign.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/circular_buffer.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    circular_buffer&lt;<span class="keyword">int</span>&gt; cb(<span class="number">5</span>);         <span class="comment">//声明一个大小为5的循环缓冲区</span></span><br><span class="line">    assert(cb.empty());                 <span class="comment">//缓冲区目前无数据</span></span><br><span class="line"></span><br><span class="line">    cb.push_back(<span class="number">1</span>);            <span class="comment">//向后端添加元素1</span></span><br><span class="line">    cb.push_front(<span class="number">2</span>);           <span class="comment">//向前端添加元素1</span></span><br><span class="line">    assert(cb.front() == <span class="number">2</span>);   </span><br><span class="line">    cb.insert(cb.begin(), <span class="number">3</span>);   <span class="comment">//向前端添加元素3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以使用迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pos = cb.begin(); pos != cb.end();++pos)</span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt; *pos &lt;&lt; <span class="string">","</span>;    &#125;       <span class="comment">//输出3，2，1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    cb.pop_front();         <span class="comment">//弹出首元素3</span></span><br><span class="line">    assert(cb.size() == <span class="number">2</span>);</span><br><span class="line">    cb.push_back();     <span class="comment">//淡出末元素1</span></span><br><span class="line">    assert(cb[<span class="number">0</span>] = <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//using namespace boost::assign;</span></span><br><span class="line">    circular_buffer&lt;<span class="keyword">int</span>&gt; cb1 = (assign::list_of(<span class="number">1</span>),<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    circular_buffer&lt;<span class="keyword">int</span>&gt; cb2 = (assign::list_of(<span class="number">3</span>),<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    circular_buffer&lt;<span class="keyword">int</span>&gt; cb3 = cb1;     <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">    assert(cb1 &lt; cb2);          </span><br><span class="line">    assert(cb1 == cb3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="环形缓冲区"><a href="#环形缓冲区" class="headerlink" title="环形缓冲区"></a>环形缓冲区</h3><p><code>circular_uffer</code> 特殊之处在于它内部存储数据的方式,内部空间不是动态增长的,而是循环使用的  </p>
<p>可以把circular_buffer内部想象成一个首尾相连的环,当元素数量达到容器的容量上限时将自动重用最初的空间  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T&amp; cb)</span>           <span class="comment">//for + auto</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: cb)</span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">","</span>;   &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//assign库初始化</span></span><br><span class="line">    circular_buffer&lt;<span class="keyword">int</span>&gt; cb = (assign::list_of(<span class="number">1</span>),<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    print(cb);          <span class="comment">//1,2,3 此时缓冲区已满</span></span><br><span class="line"></span><br><span class="line">    cb.push_back(<span class="number">4</span>);        <span class="comment">//4将覆盖最开始的1</span></span><br><span class="line">    print(cb);      <span class="comment">//2,3,4, begin()从2开始</span></span><br><span class="line"></span><br><span class="line">    cb.push_back(<span class="number">5</span>);        <span class="comment">//5将覆盖最开始的2</span></span><br><span class="line">    print(cb);      <span class="comment">//3,4,5 begin()从3开始</span></span><br><span class="line"></span><br><span class="line">    cb.pop_front();         <span class="comment">//弹出最开始的3</span></span><br><span class="line">    print(cb);      <span class="comment">//4,5 现在circular_buffer只有两个元素  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2016/10/22/boost-book/image-117.png" width="500px">  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    circular_buffer&lt;<span class="keyword">int</span>&gt; cb =(assign::list_of(<span class="number">1</span>),<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    assert(cb.full());</span><br><span class="line">    print(cb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = cb.linearize();            <span class="comment">//获取线性数组</span></span><br><span class="line">    assert(p[<span class="number">0</span>]== <span class="number">1</span> &amp;&amp; p[<span class="number">3</span>] == <span class="number">4</span>);</span><br><span class="line">    assert(cb.is_linearized());</span><br><span class="line"></span><br><span class="line">    cb.rotate(cb.begin()+ <span class="number">2</span>);           <span class="comment">//从第三个位置开始旋转</span></span><br><span class="line">    print(cb);          <span class="comment">//  3,4,5,1,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空间优化型缓冲区"><a href="#空间优化型缓冲区" class="headerlink" title="空间优化型缓冲区"></a>空间优化型缓冲区</h3><p>circular_buffer在创建时一次性分配所需内存,这是标准容器的通常做法,但对于循环缓冲区数据结构不适合,因此circular_buffer提供circular_buffer_space_optimized类,是circular_buffer适配器,只有在确实需要时才分配内存空间,而且当容器内元素减少时自动释放内存  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::assign;</span><br><span class="line"></span><br><span class="line">    circular_buffer_space_optimized&lt;<span class="keyword">int</span>&gt; cb( <span class="number">10</span>);</span><br><span class="line">    push_back(cb)(<span class="number">1</span>),<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    assert(cb.size() == <span class="number">4</span>);</span><br><span class="line">    assert(cb.capacity() == <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cb.resize(<span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line">    assert(cb.size() == cb.capacity());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>tuple元组,定义了一个有序有固定数目的元素容器,每个元素的类型都可以不相同,这与其他容器有区别</p>
<p>已被收入c++11标准,tuple位于boost::tuples名字空间,大部分功能被using语句引入名字空间boost  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;boost/tuple/tuple.hpp&gt;</span><br><span class="line">using namespace boost;</span><br></pre></td></tr></table></figure>
<h3 id="最简单的tuple-pair"><a href="#最简单的tuple-pair" class="headerlink" title="最简单的tuple:pair"></a>最简单的tuple:pair</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span>&#123;</span></span><br><span class="line">    T first;</span><br><span class="line">    U second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; a_pair;</span><br></pre></td></tr></table></figure>
<h3 id="类摘要-3"><a href="#类摘要-3" class="headerlink" title="类摘要"></a>类摘要</h3><p><img src="/2016/10/22/boost-book/image-118.png" width="500px"></p>
<h3 id="创建与赋值-1"><a href="#创建与赋值-1" class="headerlink" title="创建与赋值"></a>创建与赋值</h3><p>tuple最多支持10个模板类型参数,也就是它最多容纳10个不同类型的元素   </p>
<p>tuple对元素的类型没有特殊的要求,但如果类型不支持缺省构造或者赋值操作,那么tuple也会相应地缺失功能</p>
<p>make_tuple  </p>
<p>为了方便创建tuple对象,tuple库提供了与make_park类似的make_tuple()函数  </p>
<p>它同样可以根据参数类型推到出要创建的tuple类型,默认的类型是非引用类型  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/core/ignore_unused.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/tuple/tuple.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/tuple/tuple_comparison.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/tuple/tuple_io.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;    my_tuple1;</span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="keyword">int</span>, my_tuple1&gt; my_tuple2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="keyword">void</span>&gt;             no_instance_t1;</span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="keyword">double</span>(<span class="keyword">int</span>)&gt;  no_instance_t2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">double</span>&gt; my_tuple;       <span class="comment">//3-tuple</span></span><br><span class="line">    my_tuple t1;</span><br><span class="line">    <span class="function">my_tuple <span class="title">t2</span><span class="params">(<span class="number">1</span>, <span class="string">"123"</span>)</span></span>;          <span class="comment">//构造</span></span><br><span class="line">    <span class="function">my_tuple <span class="title">t3</span><span class="params">(t1)</span></span>;                <span class="comment">//拷贝构造</span></span><br><span class="line">    t2 = t3;                        <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    tuple&lt;<span class="keyword">int</span>&amp;&gt; t4(x);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        tuple&lt;<span class="keyword">void</span>*&gt; t1;</span><br><span class="line">        tuple&lt;<span class="keyword">double</span>(*)(<span class="keyword">int</span>)&gt; t2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        boost::make_tuple(<span class="number">2</span>, <span class="number">3.0</span>);</span><br><span class="line">        boost::make_tuple(<span class="built_in">std</span>::<span class="built_in">string</span>(), <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">        tuple&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&amp;&gt;     t1       = boost::make_tuple(i, boost::ref(s));</span><br><span class="line">        tuple&lt;<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="built_in">std</span>::<span class="built_in">string</span>&amp;&gt;  t2   = boost::make_tuple(boost::cref(i),boost::ref(s));</span><br><span class="line"></span><br><span class="line">        boost::ignore_unused(t1, t2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = make_tuple(<span class="number">1</span>, <span class="string">"char[]"</span>, <span class="number">100.0</span>);</span><br><span class="line"></span><br><span class="line">    assert(t.get&lt;<span class="number">0</span>&gt;() == <span class="number">1</span>);            <span class="comment">//取第一个元素 int类型</span></span><br><span class="line">    assert(t.get&lt;<span class="number">2</span>&gt;() == <span class="number">100.0</span>);        <span class="comment">//取第三个元素,double类型</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t.get&lt;<span class="number">1</span>&gt;();            <span class="comment">//第二个元素 const char类型</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ++t.get&lt;<span class="number">0</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    get&lt;<span class="number">0</span>&gt;(t);</span><br><span class="line">    get&lt;<span class="number">1</span>&gt;(t);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h3><p>tuple 全面支持比较操作,包括相等和不等的各种测试,他将比较操作符转发到内部的各个元素进行比较,因此要求tuple元素必须能够执行比较操作,否则会引发编译错误  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> boost::tuple&lt;<span class="keyword">int</span> ,<span class="keyword">double</span> ,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; my_tuple;    <span class="comment">//3-tuple</span></span><br><span class="line"></span><br><span class="line">    my_tuple t1 = boost::make_tuple(<span class="number">1</span>, <span class="number">100.0</span>, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"abc"</span>));</span><br><span class="line">    my_tuple t2 = boost::make_tuple(<span class="number">1</span>, <span class="number">200.0</span>, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"def"</span>));</span><br><span class="line">    assert(t1 &lt; t2);</span><br><span class="line"></span><br><span class="line">    <span class="function">my_tuple <span class="title">t3</span><span class="params">(t2)</span></span>;</span><br><span class="line">    assert(t2 == t3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> boost::tuple&lt;<span class="keyword">int</span> ,<span class="keyword">double</span> ,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; my_tuple;</span><br><span class="line"></span><br><span class="line">    <span class="function">my_tuple <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">"string"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; "please input tuple:";</span></span><br><span class="line">    <span class="comment">//std::cin &gt;&gt; t1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; t1 &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tuples::set_open(<span class="string">'['</span>) &lt;&lt; tuples::set_close(<span class="string">']'</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tuples::set_delimiter(<span class="string">','</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- set_open(<span class="keyword">char</span>) : 设置tuple开始时的字符</span><br><span class="line">- set_close(<span class="keyword">char</span>) : 设置tuple结束时的字符  </span><br><span class="line">- set_delimiter(<span class="keyword">char</span>) : 设置元素之间的分隔符  </span><br><span class="line"></span><br><span class="line">### 联结变量  </span><br><span class="line"></span><br><span class="line">类似make_tuple()的函数tie(),可以把变量联结到tuple上,生成一个元素类型全是引用的tuple   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="keyword">int</span> ,<span class="keyword">double</span> ,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; my_tuple;</span><br><span class="line"></span><br><span class="line"><span class="function">my_tuple <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="keyword">return</span> boost::make_tuple(<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">"string"</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;<span class="keyword">double</span> d;<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">    tie(i, d, s) = func();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line"></span><br><span class="line">    tie(tuples::ignore, d, tuples::ignore) = func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用于assign库"><a href="#应用于assign库" class="headerlink" title="应用于assign库"></a>应用于assign库</h3><p>tuple_list_of,初始化元素类型为tuple的容器,用法类似 map_list_of和pari_list_of  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/assign.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> boost::tuple&lt;<span class="keyword">int</span> ,<span class="keyword">double</span> ,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; my_tuple;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::assign;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;my_tuple&gt; v = tuple_list_of(<span class="number">1</span>, <span class="number">1.0</span>, <span class="string">"123"</span>)(<span class="number">2</span>, <span class="number">2.0</span>, <span class="string">"456"</span>);</span><br><span class="line">    assert(v.size() == <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    v += boost::make_tuple(<span class="number">3</span>, <span class="number">3.0</span>, <span class="string">"789"</span>),boost::make_tuple(<span class="number">4</span>, <span class="number">4.0</span>, <span class="string">"abc"</span>);</span><br><span class="line">    assert(v.size() == <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><p><img src="/2016/10/22/boost-book/image-119.png" width="500px"></p>
<h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>any一个特殊容器,只能容纳一个元素,但这个元素可以是任意类型的int,double,string，标准容器或者任何的自定义类型   </p>
<p>在需要的时候将它取出,这种功能与shared_ptr<void>有些类似,但any是类型安全，已经被加入c++17的标准</void></p>
<p><img src="/2016/10/22/boost-book/image-120.png" width="500px">  </p>
<h3 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a>访问元素</h3><p>any类本身不提供任何对内部元素访问的函数,而是提供了一个friend函数any_cast(),模仿了标准库的转型操作符  </p>
<p><img src="/2016/10/22/boost-book/image-121.png" width="500px"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">any <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = any_cast&lt;<span class="keyword">int</span>&gt;(a);           <span class="comment">//获得一个值拷贝</span></span><br><span class="line">    assert(n == <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    any_cast&lt;<span class="keyword">int</span>&amp;&gt;(a) = <span class="number">20</span>;     <span class="comment">//获得一个引用,被运用左值</span></span><br><span class="line">    assert(any_cast&lt;<span class="keyword">int</span>&gt;(a) == <span class="number">20</span>);;            </span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        any a;</span><br><span class="line">        any_cast&lt;<span class="keyword">int</span>&gt;(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(boost::exception&amp;)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; current_exception_diagnostic_information();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    any a1, a2(<span class="number">2.0</span>);</span><br><span class="line">    assert(any_cast&lt;<span class="keyword">int</span>*&gt;(&amp;a1) == <span class="literal">nullptr</span>);</span><br><span class="line">    assert(any_cast&lt;<span class="built_in">string</span>*&gt;(&amp;a2) == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h3><p>any类很有用,操作函数为any_case(),但自己可以编写一些辅助类和函数   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can_case</span><span class="params">(any &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeid</span>(T) == a.type();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp; <span class="title">get</span><span class="params">(any &amp;a)</span>s</span>&#123;</span><br><span class="line">    BOOST_ASSERT(can_case&lt;T&gt;(a));</span><br><span class="line">    <span class="keyword">return</span> *any_cast&lt;T&gt;(&amp;a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T* <span class="title">get_pointer</span><span class="params">(any &amp;a)</span></span>&#123;</span><br><span class="line">    BOOST_ASSERT(can_cast&lt;T&gt;(a));</span><br><span class="line">    <span class="keyword">return</span> any_cast&lt;T&gt;(&amp;a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="保存指针"><a href="#保存指针" class="headerlink" title="保存指针"></a>保存指针</h3><p>any可以持有原始指针,但怕不安全,希望智能指针包裹,这样any析构的时候智能指针会自动调用delete,从而安全释放资源   </p>
<blockquote>
<p>不是所有智能指针都可以作为any寸处对象,scoped_ptr不行,因为它不能被拷贝,不符合any类型要求  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can_cast</span><span class="params">(any &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="keyword">return</span> <span class="keyword">typeid</span>(T) == a.type();&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp; <span class="title">get</span><span class="params">(any &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(can_cast&lt;T&gt;(a));</span><br><span class="line">    <span class="keyword">return</span> *any_cast&lt;T&gt;(&amp;a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T* <span class="title">get_pointer</span><span class="params">(any &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(can_cast&lt;T&gt;(a));</span><br><span class="line">    <span class="keyword">return</span> any_cast&lt;T&gt;(&amp;a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//make_ptr_any 工厂函数,封装了any使用shared_ptr的用法  </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">any <span class="title">make_ptr_any</span><span class="params">(T *p = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="keyword">return</span> any(boost::<span class="built_in">shared_ptr</span>&lt;T&gt;(p));&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">boost::<span class="built_in">shared_ptr</span>&lt;T&gt;&amp; get_shared(any &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    assert(can_cast&lt;boost::<span class="built_in">shared_ptr</span>&lt;T&gt; &gt;(a));</span><br><span class="line">    <span class="keyword">return</span> *any_cast&lt;boost::<span class="built_in">shared_ptr</span>&lt;T&gt; &gt;(&amp;a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    any a;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    a = x;</span><br><span class="line">    assert(can_cast&lt;<span class="keyword">int</span>&gt;(a));</span><br><span class="line">    get&lt;<span class="keyword">int</span>&gt;(a) = <span class="number">10</span>;</span><br><span class="line">    *get_pointer&lt;<span class="keyword">int</span>&gt;(a) = <span class="number">20</span>;      </span><br><span class="line"></span><br><span class="line">    a = make_ptr_any&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"long"</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *get_shared&lt;<span class="built_in">string</span>&gt;(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    a = make_ptr_any&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;(<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>any 不支持内部值流输出或者转为字符串,这是它所缺乏又很常用的功能,特别是在调用的时候  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T &gt; <span class="class"><span class="keyword">struct</span> <span class="title">any_print</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(any &amp;a)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">try</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *any_cast&lt;T&gt;(&amp;a) &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(bad_any_cast &amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"print error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">any_print</span>&lt;boost::shared_ptr&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(any &amp;a)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">try</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; **any_cast&lt;boost::<span class="built_in">shared_ptr</span>&lt;T&gt; &gt;(&amp;a) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(bad_any_cast &amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"print error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    any a;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    any_print&lt;<span class="keyword">int</span>&gt;()(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ps = boost::make_shared&lt;<span class="built_in">string</span>&gt;(<span class="string">"metroid"</span>);</span><br><span class="line">    a = ps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这样使用就简单多了</span></span><br><span class="line">    any_print&lt; boost::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; &gt;()(a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用于容器"><a href="#应用于容器" class="headerlink" title="应用于容器"></a>应用于容器</h3><p>any可以容纳一个不同类型的元素,所以当应用于容器可以如下做法   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;any&gt; v;</span><br><span class="line">    v.push_back(<span class="number">10</span>);                                    <span class="comment">//int</span></span><br><span class="line">    v.push_back(<span class="number">1.414</span>);                                 <span class="comment">//double</span></span><br><span class="line">    v.push_back(boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>) ));    <span class="comment">//shared_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::assign;</span><br><span class="line">    <span class="built_in">vector</span>&lt;any&gt; v2 = list_of&lt;any&gt;(<span class="number">10</span>)(<span class="number">0.618</span>)(<span class="built_in">string</span>(<span class="string">"char"</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v2.size();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="variant"><a href="#variant" class="headerlink" title="variant"></a>variant</h2><p>variant与any有些类似,是一种可变类型,是对c/C++中union概念的增强和扩展,普通的union只有持有POD(普通数据类型),而不能持有如string、vecotr等复杂类型   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/variant.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br></pre></td></tr></table></figure>
<h3 id="类摘要-4"><a href="#类摘要-4" class="headerlink" title="类摘要"></a>类摘要</h3><p><img src="/2016/10/22/boost-book/image-122.png" width="400px">  </p>
<h3 id="访问元素-2"><a href="#访问元素-2" class="headerlink" title="访问元素"></a>访问元素</h3><p>variant的操作要比any方便,能够直接访问元素的值  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/assign.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/variant.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    variant&lt;<span class="keyword">int</span>, <span class="keyword">float</span>, <span class="built_in">string</span>&gt; v;          <span class="comment">//可容纳int,float和string</span></span><br><span class="line">    v = <span class="string">"123"</span>;                              <span class="comment">//v持有一个string对象</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;                      <span class="comment">//无需cast</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用法-10"><a href="#用法-10" class="headerlink" title="用法"></a>用法</h3><p>get操作室必须查询variant当前值的类型   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> variant&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="built_in">string</span>&gt; <span class="keyword">var_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var_t</span> v(<span class="number">1</span>);                                     <span class="comment">//v-&gt;int</span></span><br><span class="line">    v = <span class="number">2.13</span>;                                       <span class="comment">//v-&gt;double</span></span><br><span class="line">    assert(v.type() == <span class="keyword">typeid</span>(<span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var_t</span> v2(<span class="string">"string type"</span>);                        <span class="comment">//v2-&gt;string</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; get&lt;<span class="built_in">string</span>&gt;(v2);</span><br><span class="line"></span><br><span class="line">    v2 = v;                                         <span class="comment">//v2-&gt;double</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; get&lt;<span class="keyword">int</span>&gt;(<span class="keyword">var_t</span>(<span class="number">108</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h3><p>在运行时通过type()检测variant类型,再施以必要的操作   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> variant&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="built_in">string</span>&gt; <span class="keyword">var_t</span>;         <span class="comment">//if-elase分支语句检测类型</span></span><br><span class="line">    <span class="keyword">var_t</span> v;</span><br><span class="line">    assert(v.type() == <span class="keyword">typeid</span>(<span class="keyword">int</span>));</span><br><span class="line">    assert(v.which() == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    v = <span class="string">"variant demo"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *get&lt;<span class="built_in">string</span>&gt;(&amp;v) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; get&lt;<span class="keyword">double</span>&gt;(v) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (bad_get &amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"bad_get"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>variant基于访问者模式提供了模板类static_visitor,解耦了variant的数据存储和访问操作,把访问操作集中在访问器类<br>易于增加新的访问操作,使两者彼此独立的变化   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">var_print</span> :</span> <span class="keyword">public</span> static_visitor&lt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T &amp;i)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        v.reserve(v.size()*<span class="number">2</span>);</span><br><span class="line">        copy(v.begin(),v.end(),back_inserter(v)) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">","</span>;                       <span class="comment">//输出以验证</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> variant&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="keyword">var_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var_t</span> v(<span class="number">1</span>);</span><br><span class="line">    var_print vp;</span><br><span class="line"></span><br><span class="line">    apply_visitor(vp, v);</span><br><span class="line">    v = <span class="number">3.414</span>;</span><br><span class="line">    apply_visitor(vp, v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//using namespace boost::assign;</span></span><br><span class="line">    <span class="comment">//v = vector&lt;int&gt;(&#123;1,2&#125;);</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    v = tmp;</span><br><span class="line">    apply_visitor(vp, v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> vp2 = apply_visitor(vp);</span><br><span class="line">    vp2(v);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="与any的区别"><a href="#与any的区别" class="headerlink" title="与any的区别"></a>与any的区别</h3><p>variant很像any,容纳一个可变类型元素,但variant是有界类型,元素类型范围由用户指定,而any是误解类型,可以容纳任一类型   </p>
<p>很多人认为variant没有存在的必要,但是any任意类型自由往往会让程序员犯错,灵活付出的代价就是更多的安全检查代价,所以variant有了出现的必要,在编译器进行类型检查,充分利用c++静态强类型语言的好处  </p>
<h2 id="multi-array"><a href="#multi-array" class="headerlink" title="multi_array"></a>multi_array</h2><p>C++标准库提供了string,array和vector,但是他们都是一维数组, vector&lt;vector<t>&gt;虽然可以用,但是不方便  </t></p>
<p>multi_array可以解决这个问题,多维容器,高效实现了STL风格的多维数组,比原始多维数组或vector of vector更好   </p>
<h3 id="类摘要-5"><a href="#类摘要-5" class="headerlink" title="类摘要"></a>类摘要</h3><p><img src="/2016/10/22/boost-book/image-123.png" width="500px"><br><img src="/2016/10/22/boost-book/image-124.png" width="500px">    </p>
<h3 id="用法-11"><a href="#用法-11" class="headerlink" title="用法"></a>用法</h3><p>multi_array的模板参数很像标准容器,除了容纳的元素类型外,多了一个维数的末班参数,用来指定多维数组的维数   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multi_array&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt; ma;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int ma[x][y][z];</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>extents_gen类和预定义一个实例extents,重载了operator[],用起来就像一个原始多维数组   </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi_array&lt;<span class="keyword">int</span>,<span class="number">3</span>&gt; ma(extents[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>num_dimensions()获得multi_array总维数,返回值就是模板参数中的NumDims  </p>
</li>
<li><p>multi_array重载了operator[]操作符,使用普通数组那样访问内部元素  </p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/assign.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/multi_array.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//声明一个三维数组,维度2/3/4</span></span><br><span class="line">    multi_array&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt; ma(extents[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> shape = ma.shape();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ma.num_dimensions(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; shape[i] &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; ma.num_elements() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,  v = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>;++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;++k)</span><br><span class="line">            &#123;</span><br><span class="line">                ma[i][j][k] = v++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; ma[i][j][k] &lt;&lt; <span class="string">","</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; ma[2][3][4];      //引发越界错误</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">size_t</span>, 3&gt; idx = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    ma(idx) = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ma(idx) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多维数组另一种形式提供了位置索引序列,传递给operator()可直接访问元素,某些时候比operator[]效率更高  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">size_t</span>,3&gt; idx = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">ma(idx) = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ma(idx);</span><br></pre></td></tr></table></figure>
<h3 id="改变形状和大小"><a href="#改变形状和大小" class="headerlink" title="改变形状和大小"></a>改变形状和大小</h3><p>multi_array可以在运行时使用</p>
<ul>
<li><p>成员函数reshape()改变多维数组的形状,即变动各个维度的大小,但总维数和元素数量保持不变<br>  变动前的维度乘积和变动后的维度乘积必须相同   </p>
</li>
<li><p>成员函数resize()改变某维度的数组大小,但是维度无法改变   </p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">multi_array&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt; ma(extents[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]);</span><br><span class="line">assert(ma.shape()[<span class="number">0</span>] == <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt; arr = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把[2][3][4]变为[4][3][2]</span></span><br><span class="line">ma.reshape(arr);</span><br><span class="line">assert(ma.shape()[<span class="number">0</span>] == <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">ma.resize(extents[<span class="number">2</span>][<span class="number">9</span>][<span class="number">9</span>]);</span><br><span class="line"><span class="comment">//调整大小</span></span><br><span class="line"></span><br><span class="line">assert(ma.num_elements() == <span class="number">2</span>*<span class="number">9</span>*<span class="number">9</span>);</span><br><span class="line">assert(ma.shape()[<span class="number">1</span>] == <span class="number">9</span>);</span><br></pre></td></tr></table></figure>
<h3 id="创建子视图"><a href="#创建子视图" class="headerlink" title="创建子视图"></a>创建子视图</h3><p>multi_array库允许用户为多维数组创建一个只查看其中一部分数据的子视图,子视图既可以与原数组拥有相同维数,也可以少于原维数,被称为切片(slice)   </p>
<ul>
<li>indices用法类似extents对象,重载了operator[]操作符来限定范围,但参数不是单个整数,而是一个multi_array&lt;T,N&gt;::index_range对象,用来指定多维数组中抽取的维度范围  </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> multi_array&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt; ma_type;</span><br><span class="line">    multi_array&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt; ma(extents[<span class="number">3</span>][<span class="number">4</span>]) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> ma_type::index_range range;</span><br><span class="line">    <span class="comment">//indices[range(0,2)][range(0,2)];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> view = ma[indices[range(<span class="number">0</span>,<span class="number">2</span>)][range(<span class="number">0</span>,<span class="number">2</span>)] ]; <span class="comment">//抽取2*2的子视图 </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; view.num_elements() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//一共四个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; view[i][j] &lt;&lt; <span class="string">","</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *view.shape() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//0,0,</span></span><br><span class="line"><span class="comment">//0,0,</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h3 id="适配普通数组"><a href="#适配普通数组" class="headerlink" title="适配普通数组"></a>适配普通数组</h3><p>multi_array是多维数组常用类,自己管理内存,动态增长,但有时候需要将一维数组适配成多维数组处理  </p>
<p>multi_array提供了multi_array_ref和const_multi_array_ref来满足这一需求,把一段连续内存(原始数组)适配多维数组,用法类似smart_ptr的scope_array   </p>
<p>适配后不能用动态增长外,其他与multi_array完全相同,支持operator[]访问和reshape改变维度  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">12</span>;++i)      <span class="comment">//宿主赋初值</span></span><br><span class="line">    &#123;   arr[i] = i; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//是配成3*4二维数组 </span></span><br><span class="line">    multi_array_ref&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt; mar(arr, extents[<span class="number">3</span>][<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mar[i][j]++;        <span class="comment">//可以修改内布置 </span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (j!=<span class="number">3</span>?<span class="string">','</span>:<span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//适配2*6数组 </span></span><br><span class="line">    const_multi_array_ref&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt; cmar(arr, extents[<span class="number">2</span>][<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">0</span>;j &lt; <span class="number">6</span>;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cmar[i][j];</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (j!=<span class="number">5</span>?<span class="string">','</span>:<span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> )</span><br><span class="line">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span> )</span><br><span class="line">(<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span> )</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> )</span><br><span class="line">(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span> )</span><br></pre></td></tr></table></figure>
<h2 id="property-tree"><a href="#property-tree" class="headerlink" title="property_tree"></a>property_tree</h2><p>property_tree 是一个保存了许多个属性值的树形数据结构,可以用类似路径的简单方式访问任意节点的树形<br>而且每个节点类似STL的风格遍历子节点,property_tree特别适合于应用程序的配置数据处理,可以解析xml,ini,json和info四种格式的文本数据,使用它能够减轻自己的开发配置管理工作  </p>
<h3 id="类摘要-6"><a href="#类摘要-6" class="headerlink" title="类摘要"></a>类摘要</h3><p><img src="/2016/10/22/boost-book/image-125.png" width="500px"><br><img src="/2016/10/22/boost-book/image-126.png" width="500px">  </p>
<p>basic_ptree接口很像标准容器std::list  </p>
<p>两个重要的内部类型定义  </p>
<ul>
<li>self_type是自身类型也是子节点类型  </li>
<li>value_type是节点的数据结构,一个std::pair,含属性名(first)和节点自身(second)   </li>
</ul>
<h3 id="读取配置信息"><a href="#读取配置信息" class="headerlink" title="读取配置信息"></a>读取配置信息</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">conf</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf comment --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gui</span>&gt;</span>1<span class="tag">&lt;/<span class="name">gui</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">theme</span> <span class="attr">id</span>=<span class="string">"001"</span>&gt;</span>matrix<span class="tag">&lt;/<span class="name">theme</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">urls</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- urls comment --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.url1.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.url2.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.url3.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">urls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">clock_style</span> <span class="attr">name</span>=<span class="string">"local"</span>&gt;</span>24<span class="tag">&lt;/<span class="name">clock_style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">conf</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要解析这个配置文件,得有read_xml函数解析并初始化ptree<br>他有两个函数定义  </p>
<p><img src="/2016/10/22/boost-book/image-127.png" width="500px">  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/property_tree/ptree.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/property_tree/xml_parser.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::property_tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptree pt;               <span class="comment">//声明一个ptree对象</span></span><br><span class="line">    read_xml(<span class="string">"conf.xml"</span>, pt);       <span class="comment">//读取xml配置信息</span></span><br><span class="line"></span><br><span class="line">    pt.get&lt;<span class="built_in">string</span>&gt;(<span class="string">"conf.theme"</span>);       <span class="comment">//获取conf.theme节点信息</span></span><br><span class="line">    pt.get&lt;<span class="keyword">int</span>&gt;(<span class="string">"conf.clock_style"</span>);    <span class="comment">//获取conf.clock_style的int值</span></span><br><span class="line">    pt.get(<span class="string">"conf.no_prop"</span>, <span class="number">100</span>);        <span class="comment">//获取config.no_prop值,不存在返回100</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pt.get&lt;<span class="built_in">string</span>&gt;(<span class="string">"conf.theme"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pt.get&lt;<span class="keyword">int</span>&gt;(<span class="string">"conf.clock_style"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pt.get&lt;<span class="keyword">long</span>&gt;(<span class="string">"conf.gui"</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pt.get(<span class="string">"conf.no_prop"</span>, <span class="number">100</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> child = pt.get_child(<span class="string">"conf.urls"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : child)</span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt;  x.second.get_value&lt;<span class="built_in">string</span>&gt;() &lt;&lt; <span class="string">","</span>;   &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : pt.get_child(<span class="string">"conf.urls"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;  x.second.data() &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">matrix</span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"> urls comment ,http:<span class="comment">//www.url1.com,http://www.url2.com,http://www.url3.com,</span></span><br><span class="line"> urls comment ,http:<span class="comment">//www.url1.com,http://www.url2.com,http://www.url3.com,</span></span><br></pre></td></tr></table></figure>
<h3 id="写入配置信息"><a href="#写入配置信息" class="headerlink" title="写入配置信息"></a>写入配置信息</h3><p>property_tree不仅能够读取配置信息,也可以写入配置信息,操作具有对称性  </p>
<p>使用模板成员函数put()可以修改属性树的节点值,如果子节点不存在就当新增节点  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptree pt;</span><br><span class="line">    read_xml(<span class="string">"conf.xml"</span>, pt);</span><br><span class="line"></span><br><span class="line">    pt.put(<span class="string">"conf.theme"</span>, <span class="string">"Matrix Reloaded"</span>);</span><br><span class="line">    pt.put(<span class="string">"conf.clock_style"</span>, <span class="number">12</span>);</span><br><span class="line">    pt.put(<span class="string">"conf.gui"</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//pt.put("conf.urls.url", "http://www.url4.org");</span></span><br><span class="line">    pt.add(<span class="string">"conf.urls.url"</span>, <span class="string">"http://www.url4.org"</span>);</span><br><span class="line"></span><br><span class="line">    write_xml(<span class="built_in">cout</span> , pt);       <span class="comment">//向标准输出流写入数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><blockquote>
<p>find寻找某节点值  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;a&gt;string&lt;/a&gt;</span></span><br><span class="line"><span class="comment">//&lt;b&gt;100&lt;/b&gt;</span></span><br><span class="line"><span class="comment">//&lt;c&gt;false&lt;/c&gt;</span></span><br><span class="line"></span><br><span class="line">ptree pt;</span><br><span class="line">read_xml(<span class="string">"a.xml"</span>, pt);</span><br><span class="line"><span class="keyword">auto</span> pos = pt.find(<span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pos-&gt;second.data() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>这样的缺点就是没有get的深层次去查找,也没有get方便  </p>
<blockquote>
<p>json  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/property_tree/json_parser.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptree pt;</span><br><span class="line">    read_json(<span class="string">"conf.json"</span>, pt);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pt.get&lt;<span class="built_in">string</span>&gt;(<span class="string">"conf.theme"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pt.get&lt;<span class="keyword">int</span>&gt;(<span class="string">"conf.clock_style"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pt.get&lt;<span class="keyword">long</span>&gt;(<span class="string">"conf.gui"</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pt.get(<span class="string">"conf.no_prop"</span>, <span class="number">100</span>)&lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : pt.get_child(<span class="string">"conf.urls"</span>))</span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt;  x.second.data() &lt;&lt; <span class="string">","</span>;    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><p>atomic封装了C++11标准定义的原子操作库,封装了不同计算机硬件的底层操作原语,<br>提供了跨平台的原子操作功能</p>
<p><img src="/2016/10/22/boost-book/image-21.png" width="500px"><br><img src="/2016/10/22/boost-book/image-22.png" width="500px"></p>
<ul>
<li>load显式调用load取值  </li>
<li>store显式调用store取值  </li>
</ul>
<h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    atomic&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>);</span><br><span class="line">    assert(a == <span class="number">10</span>); <span class="comment">//隐式转换</span></span><br><span class="line"></span><br><span class="line">    atomic&lt;<span class="keyword">long</span>&gt; l;</span><br><span class="line">    l = <span class="number">100L</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    atomic&lt;<span class="keyword">double</span>&gt; d(<span class="number">2.414</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    atomic&lt;<span class="keyword">bool</span>&gt; b&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    assert(!b.load());<span class="comment">//显式调用load取值</span></span><br><span class="line"> </span><br><span class="line">    b.store(<span class="literal">true</span>); <span class="comment">//显式调用store存值</span></span><br><span class="line">    assert(b);</span><br><span class="line"></span><br><span class="line">    atomic&lt;<span class="keyword">int</span>&gt; n(<span class="number">100</span>);</span><br><span class="line">    assert(n.exchange(<span class="number">200</span>) == <span class="number">100</span>); <span class="comment">//存值的同时返回原值</span></span><br><span class="line">    assert(n == <span class="number">200</span>);<span class="comment">//隐式类型转换、等价于load</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>compare_exchange_weak()和chage_exchange_strong()是exchage()的增强版本<br>也就是常说的CAS操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    atomic&lt;<span class="keyword">long</span>&gt; l(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> v = <span class="number">100</span>;               <span class="comment">//设置变量expected 左值</span></span><br><span class="line">    <span class="keyword">if</span> (l.compare_exchange_weak(v, <span class="number">313</span>)) <span class="comment">//比较并交换</span></span><br><span class="line">    &#123;</span><br><span class="line">        assert(l == <span class="number">313</span> &amp;&amp; v == <span class="number">100</span>); <span class="comment">//如果成功值改变,输出原值100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v = <span class="number">200</span>;                <span class="comment">//设置expected=200</span></span><br><span class="line">    <span class="keyword">auto</span> b = l.compare_exchange_strong(v, <span class="number">99</span>); <span class="comment">//比较并减缓</span></span><br><span class="line">    assert(!b &amp;&amp; v == <span class="number">313</span>); <span class="comment">//交换失败并输出原值313</span></span><br><span class="line"></span><br><span class="line">    l.compare_exchange_weak(v, <span class="number">99</span>); <span class="comment">//再次交换</span></span><br><span class="line">    assert(l == <span class="number">99</span> &amp;&amp; v == <span class="number">313</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>atomic的成员函数storage()可以直接获得atomic内部值的引用,能够以任意方式操作数据<br>但他也因此无法提供原子保证,在并发环境里我们应该尽量不使用它  </p>
<h3 id="整数atomic用法"><a href="#整数atomic用法" class="headerlink" title="整数atomic用法"></a>整数atomic用法</h3><p>fetch_xx原酸操作,执行对应的数学运算后,返回原值而不是运算后的值    </p>
<p>atomic重载了operator++、operator+=等操作符,这些操作符重载函数内部也是调用了fetch__xx函数,但返回运算后的值  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/utility.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    atomic&lt;<span class="keyword">int</span>&gt; n(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    assert(n.fetch_add(<span class="number">10</span>) == <span class="number">100</span>); <span class="comment">//加法操作,返回原值</span></span><br><span class="line">    assert(n == <span class="number">110</span>);</span><br><span class="line"></span><br><span class="line">    assert(++n == <span class="number">111</span>);   <span class="comment">//前置++,返回运算后值</span></span><br><span class="line">    assert(n++ ==<span class="number">111</span>);   <span class="comment">//后置++,返回原值</span></span><br><span class="line">    assert(n == <span class="number">112</span>); </span><br><span class="line"></span><br><span class="line">    assert((n -= <span class="number">10</span>) == <span class="number">102</span>);  <span class="comment">//相当于fetch_sub,返回运算后值</span></span><br><span class="line"></span><br><span class="line">    atomic&lt;<span class="keyword">int</span>&gt; b&#123;BOOST_BINARY(<span class="number">1101</span>)&#125;; <span class="comment">//二进制1101</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> x = b.fetch_and(BOOST_BINARY(<span class="number">0110</span>)); <span class="comment">//逻辑与运算 返回原值1101</span></span><br><span class="line">    assert(x == BOOST_BINARY(<span class="number">1101</span>) &amp;&amp;</span><br><span class="line">           b == BOOST_BINARY(<span class="number">0100</span>)); <span class="comment">//b运算后是0100</span></span><br><span class="line">    assert((b |= BOOST_BINARY(<span class="number">1001</span>)) <span class="comment">//相当于fetch_or,返回运算后值</span></span><br><span class="line">            == BOOST_BINARY(<span class="number">1101</span>)); <span class="comment">//b运算后是1101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并发顺序一致性"><a href="#并发顺序一致性" class="headerlink" title="并发顺序一致性"></a>并发顺序一致性</h3><p>现代多CPU核心并发的环境里,编译器和cpu都有可能打乱指令的执行顺序,虽然可能会获得更高的执行效率,<br>但是也可能产生副作用,导致程序的流程不一定按照代码的顺序执行</p>
<p><img src="/2016/10/22/boost-book/image-23.png" width="500px"><br><img src="/2016/10/22/boost-book/image-24.png" width="500px"></p>
<p>atomic<t>的每个成员函数都有一个meeory_order缺省参数  </t></p>
<p>指定了原子操作的内存顺序要求</p>
<p>memory_order_seq_cst 是最严格的顺序一致性约束<br>不允许编译器或cpu核心为优化而调整代码和指令的执行顺序<br>保证并发环境任何cpu核心看到的指令顺序是相同的  </p>
<p>如果memory_order修改其他枚举值,name多核心并发执行同一段代码会有不同的执行顺序  </p>
<p>下面代码是使用atomic结合恰当的内存顺序,实现的一个高效的引用技术适配器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/intrusive_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ref_count</span>                 //泛型的引用计数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> boost::atomic&lt;<span class="keyword">int</span>&gt; atomic_type; <span class="comment">//atomic类型</span></span><br><span class="line">    <span class="keyword">mutable</span> atomic_type m_count&#123;<span class="number">0</span>&#125;;         <span class="comment">//mutable类型</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ref_count() &#123;&#125;</span><br><span class="line">    ~ref_count() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> boost::intrusive_ptr&lt;T&gt; counted_ptr;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_ref</span><span class="params">()</span> <span class="keyword">const</span>                    <span class="comment">//增加引用计数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_count.fetch_add(<span class="number">1</span>, boost::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sub_ref</span><span class="params">()</span> <span class="keyword">const</span>                    <span class="comment">//减少引用计数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_count.fetch_sub(<span class="number">1</span>, boost::memory_order_release) == <span class="number">1</span>)</span><br><span class="line">        &#123;<span class="comment">//释放,值的修改后续操作可见</span></span><br><span class="line"></span><br><span class="line">            boost::atomic_thread_fence(boost::memory_order_acquire);</span><br><span class="line">            <span class="comment">//原子级别的线程防护,获取之前的修改</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//删除指针,需要转型</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">decltype</span>(m_count.load()) count() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_count.load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> counted_ptr <span class="title">make_ptr</span><span class="params">(Args&amp;&amp; ... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counted_ptr(<span class="keyword">new</span> T(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">intrusive_ptr_add_ref</span><span class="params">(<span class="keyword">const</span> T* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p-&gt;add_ref();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">intrusive_ptr_release</span><span class="params">(<span class="keyword">const</span> T* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p-&gt;sub_ref();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>:</span> <span class="keyword">public</span> ref_count&lt;demo&gt;  <span class="comment">//添加引用计数的能力</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"demo ctor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~demo()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"demo dtor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//demo::counted_ptr p(new demo);  //创建智能指针</span></span><br><span class="line">    <span class="keyword">auto</span> p = demo::make_ptr();</span><br><span class="line"></span><br><span class="line">    p-&gt;x = <span class="number">10</span>;</span><br><span class="line">    assert(p-&gt;x == <span class="number">10</span>);</span><br><span class="line">    assert(p-&gt;count() == <span class="number">1</span>); <span class="comment">//检查引用计数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h2><p>thread库为c++增加了线程处理能力</p>
<ul>
<li>互斥</li>
<li>线程</li>
<li>条件变量等</li>
</ul>
<p>很容易创建多线程应用程序,thread库也是高度可移植,兼容了c++11/14标准<br>支持使用最广泛的POSIX和Windows线程,不需要修改代码就可以在UNIX,Windows操作系统上编译运行   </p>
<h3 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h3><p>互斥量,线程同步工具,多线程环境防治多个线程同时操作共享资源,一旦一个线程锁住了互斥量<br>那么其他线程必须等待它解锁互斥量才能在访问共享资源   </p>
<p><img src="/2016/10/22/boost-book/image-25.png" width="500px"></p>
<p><img src="/2016/10/22/boost-book/image-26.png" width="500px">  </p>
<p>mutex在创建后表示一个互斥量</p>
<ul>
<li>lock用于线程阻塞等待直至获得互斥量的所有权即锁定  </li>
<li>unlock解除对互斥量的锁定  </li>
<li>try_lock 尝试锁定互斥量,如果锁定成功返回true,否则返回false,它是非阻塞    </li>
<li>try_lock_for 增加了时间等待功能,相对时间长度  </li>
<li>try_lock_until 增加了时间等待功能,绝对时间点   </li>
</ul>
<h4 id="mutex-用法"><a href="#mutex-用法" class="headerlink" title="mutex 用法"></a>mutex 用法</h4><p>普通mutex用法  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mutex mu;           <span class="comment">//声明一个互斥量对象</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        mu.lock();        <span class="comment">//锁定互斥量</span></span><br><span class="line">        <span class="built_in">cout</span>  &lt;&lt; <span class="string">"some operations"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//操作共享资源</span></span><br><span class="line">        mu.unlock();      <span class="comment">//解锁互斥量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...)           <span class="comment">//必须使用try-catch块保证解锁互斥量</span></span><br><span class="line">    &#123;</span><br><span class="line">        mu.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        lock_guard&lt;mutex&gt; g(mu); <span class="comment">//函数栈退出撤销mutex</span></span><br><span class="line">        <span class="built_in">cout</span>  &lt;&lt; <span class="string">"some operations"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>timed_mutex用法  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timed_mutex mu;         <span class="comment">//定时互斥量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> flag = mu.try_lock_for(<span class="number">100</span>_ms); <span class="comment">//等待100毫秒</span></span><br><span class="line">    <span class="keyword">if</span>(flag)                            <span class="comment">//检查是否成功锁定互斥量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"lock timed mutex"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//访问共享资源</span></span><br><span class="line">        mu.unlock();                    <span class="comment">//解锁互斥量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mu.try_lock_for(<span class="number">100</span>_ms))         <span class="comment">//等到100毫秒</span></span><br><span class="line">        &#123;</span><br><span class="line">            lock_guard&lt;timed_mutex&gt; g(mu, adopt_lock); <span class="comment">//自动解锁</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"lock timed mutex"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h3><p>thread库提供了lock_guard辅助锁互斥量  </p>
<ul>
<li>构造的时候锁定  </li>
<li>析构的时候自动解锁   </li>
</ul>
<p><img src="/2016/10/22/boost-book/image-27.png" width="500px"></p>
<p>lock_guard的第二种形式的构造器是为了配合timed_mutex使用<br>允许传入一个标志,类型为adopt_lock_t的常量,让lock_guard认为线程之前已经锁定了mutex,只负责析构的时候解锁  </p>
<h4 id="lock-guard-用法"><a href="#lock-guard-用法" class="headerlink" title="lock_guard 用法"></a>lock_guard 用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timed_mutex mu;                     <span class="comment">//声明互斥量对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> flag = mu.try_lock_for(<span class="number">100</span>_ms); <span class="comment">// lock_guard</span></span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"lock timed mutex"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        mu.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mu.try_lock_for(<span class="number">100</span>_ms))</span><br><span class="line">        &#123;</span><br><span class="line">            lock_guard&lt;timed_mutex&gt; g(mu, adopt_lock);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"lock timed mutex"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h3><p>thread库还有一个用法更复杂的unique_lock</p>
<p><img src="/2016/10/22/boost-book/image-28.png" width="500px"></p>
<p>unique_lock的工作机制和lock_guard相同</p>
<ul>
<li>构造函数锁定  </li>
<li>析构函数解锁  </li>
</ul>
<p>但它的构造函数还可以接收其他选项,从而有不同的行为   </p>
<p><img src="/2016/10/22/boost-book/image-29.png" width="500px">  </p>
<h4 id="工厂函数-1"><a href="#工厂函数-1" class="headerlink" title="工厂函数"></a>工厂函数</h4><p><img src="/2016/10/22/boost-book/image-30.png" width="500px">  </p>
<p>也可以一次性产生多个unique_lock,以std::tuple返回  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::tuple&lt;unique_lock&lt;Lockable&gt; ...&gt; make_unique_locks(Lockable&amp; ...mtx);</span><br></pre></td></tr></table></figure>
<h4 id="unique-lock-使用"><a href="#unique-lock-使用" class="headerlink" title="unique_lock 使用"></a>unique_lock 使用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/lock_factories.hpp&gt;          //工厂函数头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Lockable, <span class="keyword">typename</span> D&gt;</span><br><span class="line">unique_lock&lt;Lockable&gt; my_make_lock(Lockable&amp; mtx, D d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> unique_lock&lt;Lockable&gt; (mtx, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mutex mu;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> g = make_unique_lock(mu);      <span class="comment">//锁定互斥量</span></span><br><span class="line">        assert(g.owns_lock());              <span class="comment">//断言已经锁定</span></span><br><span class="line">        <span class="built_in">cout</span>  &lt;&lt; <span class="string">"some operations"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> g = make_unique_lock(mu, defer_lock);  <span class="comment">//暂不锁定互斥量</span></span><br><span class="line">        assert(!g);                     <span class="comment">//断言没有锁定</span></span><br><span class="line"></span><br><span class="line">        assert(g.try_lock());   <span class="comment">//尝试锁定</span></span><br><span class="line">        assert(g);              <span class="comment">//断言已经锁定</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>  &lt;&lt; <span class="string">"some operations"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timed_mutex tm;</span><br><span class="line">    <span class="comment">//typedef unique_lock&lt;timed_mutex&gt; lock_type;  </span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//lock_type g(tm, 100_ms);</span></span><br><span class="line">        <span class="keyword">auto</span> g = my_make_lock(tm, <span class="number">100</span>_ms);  <span class="comment">//限时100毫秒锁定</span></span><br><span class="line">        <span class="keyword">if</span>(g)  <span class="comment">//检查是否成功锁定</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"lock timed mutex"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> g = make_unique_locks(mu, tm);    <span class="comment">//同时锁定多个互斥量  </span></span><br><span class="line">    assert(<span class="built_in">std</span>::tuple_size&lt;<span class="keyword">decltype</span>(g)&gt;::value == <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lock适配器"><a href="#lock适配器" class="headerlink" title="lock适配器"></a>lock适配器</h3><p>lock_guard和unique_lock大多数情况搭配mutex使用,用于锁定互斥量<br>但因为他们是模板类,所以只要符合Lockable概念,也就是有“lock/unlock/try_lock”接口的类<br>都可以用于lock_guard和unique_lock,这样能够很容易锁定整个对象,实现原子性的事务操作   </p>
<p><img src="/2016/10/22/boost-book/image-31.png" width="500px"><br><img src="/2016/10/22/boost-book/image-32.png" width="500px"></p>
<p>适配器类需要模板参数指定适配的mutex类型,以继承方式使用<br>子类自动获取他们的lock接口,然后就可以应用于lock_guard和unique_lock  </p>
<p>以下是一个储蓄账户类,记录金额的案例  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/atomic.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/lockable_adapter.hpp&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">account</span> <span class="title">final</span> :</span> <span class="keyword">public</span> lockable_adapter&lt;mutex&gt;   <span class="comment">//mutex适配</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    boost::atomic&lt;<span class="keyword">int</span>&gt; m_money&#123;<span class="number">0</span>&#125;; <span class="comment">//账户金额</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    account() &#123;&#125;</span><br><span class="line">    ~account() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> <span class="keyword">const</span>     <span class="comment">//当前金额获取</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> x)</span>    <span class="comment">//取款</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_money -= x;   <span class="comment">//操作符重载</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//存款</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_money += x;  <span class="comment">//操作符重载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    account a;      <span class="comment">//账户实例,可锁定</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> g = make_unique_lock(a);    <span class="comment">//无需其他mutex,自身可lock</span></span><br><span class="line">        a.deposit(<span class="number">100</span>);</span><br><span class="line">        a.withdraw(<span class="number">20</span>);</span><br><span class="line">        assert(a.sum() == <span class="number">80</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> b = make_unique_lock(a, try_to_lock); <span class="comment">//可以try_lock</span></span><br><span class="line">        <span class="keyword">if</span>(b)</span><br><span class="line">        &#123;</span><br><span class="line">            a.withdraw(a.sum());        <span class="comment">//取出全部存款</span></span><br><span class="line">            assert(a.sum() == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lockable概念检查类"><a href="#lockable概念检查类" class="headerlink" title="lockable概念检查类"></a>lockable概念检查类</h4><p>检查类型是否可锁定  </p>
<p><img src="/2016/10/22/boost-book/image-33.png" width="500px"></p>
<h4 id="lock函数"><a href="#lock函数" class="headerlink" title="lock函数"></a>lock函数</h4><p>除了使用mutex的成员函数或者lock_guard/unique_lock,我们还可以使用两个自由函数   </p>
<ul>
<li>lock</li>
<li>try_lock  </li>
</ul>
<p>以上两个操作mutex,类似make_unique_locks,可以一次性锁定多个互斥量,而且保证不会出现死锁  </p>
<p><img src="/2016/10/22/boost-book/image-34.png" width="500px"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mutex m1, m2;           <span class="comment">//两个互斥量</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> g1 = make_unique_lock(m1, adopt_lock); <span class="comment">//使用adopt_lock</span></span><br><span class="line">        <span class="keyword">auto</span> g2 = make_unique_lock(m2, adopt_lock);</span><br><span class="line"></span><br><span class="line">        lock(m1, m2);           <span class="comment">//锁定两个mutex</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> g1 = make_unique_lock(m1, defer_lock);<span class="comment">//使用defer_lock</span></span><br><span class="line">        <span class="keyword">auto</span> g2 = make_unique_lock(m2, defer_lock);</span><br><span class="line"></span><br><span class="line">        try_lock(g1, g2);       <span class="comment">//锁定两个unique_lock</span></span><br><span class="line">    &#125;   <span class="comment">//unique_lock自动解锁   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h3><p>thread实现了操作系统的线程表示,负责启动和管理线程对象与posix线程很相似  </p>
<p><img src="/2016/10/22/boost-book/image-35.png" width="500px"></p>
<p><img src="/2016/10/22/boost-book/image-36.png" width="500px">  </p>
<p>thread对象不可拷贝不可比较,但支持c++11标准的转移move语义<br>有转移构造函数和转移赋值函数,允许从工厂函数产生  </p>
<p>某种程度来讲,线程就是在进程的另一个空间里运行的一个函数<br>因此线程的创建需要传递给thread对象一个无参的可调函数、函数对象、或者lambda/bind表达式，<br>他必须具有operator()以供线程执行  </p>
<p>如果函数不是无参,thread也可以传递   </p>
<p>std::terminate结束线程的执行,并不关心线程是否执行完毕,所以如果要保证函数正确运行必须调用join等待线程执行结束，或者调用detach()分离线程体      </p>
<h4 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h4><p>thread不提供start,begin那样的方法,当城管创建一个thread对象就立刻开始执行  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dummy</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//空循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(dummy, <span class="number">100</span>)</span></span>;   <span class="comment">//想函数传递参数启动线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(dummy, <span class="number">500</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    this_thread::sleep_for(<span class="number">200</span>_ms); <span class="comment">//等待200毫秒</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="join线程"><a href="#join线程" class="headerlink" title="join线程"></a>join线程</h4><p>thread的成员函数joinable可以判断thread对象是否标识了一个可执行的线程体 </p>
<p>如果joinable返回true,我们就可以调用成员函数join或者try_join_for/try_join_util()来阻塞等待线程执行结束  </p>
<p>两者区别是  </p>
<ul>
<li>join()一直阻塞等待,直到线程技术  </li>
<li>try_join_for/try_join_util阻塞等待一定的时间段,然后不管现场是否结束都返回   </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread t1(bind(dummy, 100));    //使用bind表达式启动线程</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">([]&#123;dummy(<span class="number">500</span>)</span></span>;&#125;);     <span class="comment">//使用lambda表达式启动线程</span></span><br><span class="line"></span><br><span class="line">t1.try_join_for(<span class="number">100</span>_ms);</span><br><span class="line">t2.join();</span><br></pre></td></tr></table></figure>
<p>join可以这样操作thread对象  </p>
<h4 id="detach分离线程"><a href="#detach分离线程" class="headerlink" title="detach分离线程"></a>detach分离线程</h4><p>detach将thread与线程执行体手动分离，此后thread对象不代表任何线程体<br>joinable() == false，从而失去了对线程体的控制  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(dummy, <span class="number">100</span>)</span></span>; <span class="comment">//启动线程</span></span><br><span class="line"></span><br><span class="line">t1.detach();    <span class="comment">//与线程执行体分离，但线程继续运行</span></span><br><span class="line">assert(!t1.joinable());</span><br></pre></td></tr></table></figure>
<p>分离线程将不受影响继续执行,直到函数结束,或者随主进程一起结束   </p>
<p>因此当不再需要操作线程体时,可以使用临时对象来启动线程,随机调用它的detach   </p>
<h4 id="thread-guard"><a href="#thread-guard" class="headerlink" title="thread_guard"></a>thread_guard</h4><p>thread库在c++标准之外提供了类似lock_guard的thread_guard辅助类,可以让我们方便地控制thread对象析构时的行为  </p>
<p><img src="/2016/10/22/boost-book/image-37.png" width="500px"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/thread_guard.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(dummy, <span class="number">200</span>)</span></span>;  <span class="comment">//启动线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(dummy, <span class="number">300</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread_guard&lt;detach&gt; g1(t1);   <span class="comment">//析构后线程继续运行</span></span><br><span class="line">    thread_guard&lt;&gt;       g2(t2);   <span class="comment">//析构时等待线程结束</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="scoped-thread"><a href="#scoped-thread" class="headerlink" title="scoped_thread"></a>scoped_thread</h4><p>thread库还有一个与thread接口功能一致的线程类 scoped_thread,它可以使用模板参数定值析构的动作  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/scoped_thread.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        scoped_thread&lt;detach&gt; t1(dummy, <span class="number">10</span>);    <span class="comment">//析构后线程继续运行</span></span><br><span class="line">        scoped_thread&lt;&gt;       t2(dummy, <span class="number">20</span>);    <span class="comment">//析构时等待线程结束</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this_thread::sleep_for(<span class="number">100</span>_ms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p>boost::thread库提供了非c++11标准的成员函数interrupt()和interruption_requested()</p>
<p><img src="/2016/10/22/boost-book/image-38.png" width="500px"></p>
<p>被中断的线程会抛出一个thread_interrupted异常<br>它是一个空类,不是std::exception或者boost::exception的子类<br>thread_interrupted异常应该在线程执行函数里捕获并处理<br>如果线程不处理这个异常,默认动作是中止线程   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">to_interrupt</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">try</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; x; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//this_thread::sleep_for(400_ms); </span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        this_thread::interruption_point();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">const</span> thread_interrupted&amp; )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"thread_interrupted"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//捕获中断异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(to_interrupt,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//this_thread::sleep_for(1_s);</span></span><br><span class="line"></span><br><span class="line">    t.interrupt();              <span class="comment">//要求线程中断</span></span><br><span class="line">    assert(t.interruption_requested()); <span class="comment">//断言线程被要求中断</span></span><br><span class="line"></span><br><span class="line">    t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中断点"><a href="#中断点" class="headerlink" title="中断点"></a>中断点</h4><p>线程不是在任意时刻都可以被中断  </p>
<p><img src="/2016/10/22/boost-book/image-39.png" width="500px"></p>
<h4 id="启用-禁用线程中断"><a href="#启用-禁用线程中断" class="headerlink" title="启用/禁用线程中断"></a>启用/禁用线程中断</h4><p>默认情况下线程是允许中断,但是thread库允许进一步控制线程的中断行为   </p>
<ul>
<li>interruption_enable()函数检测当前线程是否允许中断  </li>
<li>interruption_requested()函数检测当前线程是否被要求中断  </li>
<li>类disable_interruption,在构造时关闭线程中断,析构时回复线程的中断状态  </li>
<li>restore_interruption只能在disable_interruption的作用域内使用,它是在构造是临时打开线程的中断状态,在析构时关闭中断状态  </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">to_interrupt2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">try</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> this_thread;  <span class="comment">//打开this_thread命名空间</span></span><br><span class="line">    assert(interruption_enabled()); <span class="comment">//允许中断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; x; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        disable_interruption di;        <span class="comment">//关闭中断</span></span><br><span class="line">        assert(!interruption_enabled()); <span class="comment">//此时中断不可用</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; this_thread::interruption_requested() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        this_thread::interruption_point();  <span class="comment">//中断点被禁用</span></span><br><span class="line"></span><br><span class="line">        <span class="function">restore_interruption <span class="title">ri</span><span class="params">(di)</span></span>;        <span class="comment">//临时恢复中断</span></span><br><span class="line">        assert(interruption_enabled());     <span class="comment">//此时中断可用</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"can interrupted"</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; this_thread::interruption_requested() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        this_thread::interruption_point();  <span class="comment">//可被中断</span></span><br><span class="line">    &#125;       <span class="comment">//离开作用于,di/ri都被析构</span></span><br><span class="line">            <span class="comment">//恢复现场最初的可中断状态</span></span><br><span class="line">    assert(interruption_enabled()); <span class="comment">//此时允许中断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">const</span> thread_interrupted&amp; )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[thread_interrupted]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(to_interrupt2,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//this_thread::sleep_for(1_s);</span></span><br><span class="line"></span><br><span class="line">    t.interrupt();</span><br><span class="line">    assert(t.interruption_requested());</span><br><span class="line"></span><br><span class="line">    t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="thread-group"><a href="#thread-group" class="headerlink" title="thread_group"></a>thread_group</h3><p>thread库提供了thread_group用于管理一组现场,就像一个线程池  </p>
<p>内部是靠一个std::list<thread>来容纳创建的thread对象  </thread></p>
<p><img src="/2016/10/22/boost-book/image-40.png" width="500px"><br><img src="/2016/10/22/boost-book/image-41.png" width="500px"></p>
<ul>
<li><p>create_thread是一个工厂函数,可以创建thread对象并允许线程,同时加入内部的list  </p>
<p>  但是它不支持thread构造函数的传参,这里要用lambda或者bind包装执行函数  </p>
</li>
<li><p>成员函数is_this_thread_in和is_thread_in可以判断当前线程或者某个线程是否属于本线程组  </p>
</li>
<li><p>join_all和interrupt_all来操作list李所有线程对象等待或中断这些线程  </p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread_group tg;</span><br><span class="line">    tg.create_thread(bind(dummy, <span class="number">100</span>));  <span class="comment">//使用bind创建线程</span></span><br><span class="line">    tg.create_thread(bind(dummy, <span class="number">200</span>)); </span><br><span class="line">    tg.join_all();  <span class="comment">//等待所有线程执行结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="call-once"><a href="#call-once" class="headerlink" title="call_once"></a>call_once</h3><p>多线程环境中初始化函数正确调用一次,所以thread库提供了仅调用一次机制call_once  </p>
<p>这个机制首先要使用一个once_flag对象,它将作为初始化标志，然后在使用call_once来调用函数,完成仅一次的初始化  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_count;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_count</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"should call once."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    g_count = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> once_flag once; <span class="comment">//不能使用临时变量,否则无效</span></span><br><span class="line">    call_once(once, init_count, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (scoped_thread&lt;&gt;(call_func));</span><br><span class="line">    (scoped_thread&lt;&gt;(call_func)); <span class="comment">//最后线程只会调用一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量是一种等待同步机制,可以实现线程间通信,他必须与互斥量配合使用,等待另一个线程中某个事件的发送  </p>
<p>thread库提供了两种条件变量对象</p>
<ul>
<li>condition_variable </li>
<li>condition_variable_any   </li>
</ul>
<p>使用方法,拥有条件变量的线程先锁定互斥量,然后循环检查某个条件,如果条件不满足就wait等待直至条件满足  </p>
<p>其他线程处理变量要求条件,当条件满足时调用它的成员函数 notify_one或notify_all </p>
<p>以通知一个或所有正在等待条件变量的线程停止等待继续执行  </p>
<p><img src="/2016/10/22/boost-book/image-42.png" width="500px"></p>
<p>wait(lock, predicate);  </p>
<p>它比普通形式多接受一个谓语函数,当喂鱼predicate不满足时持续等待,也就是当谓语predicate返回true时退出等待</p>
<blockquote>
<p>案例  </p>
</blockquote>
<p>描述生产者-&gt;消费者模式,后进先出型缓冲区   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        mutex mu;       <span class="comment">//互斥量</span></span><br><span class="line">        condition_variable_any cond_put;        <span class="comment">//写入条件变量</span></span><br><span class="line">        condition_variable_any cond_get;        <span class="comment">//读取条件变量</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;     <span class="comment">//缓冲区对象</span></span><br><span class="line">        <span class="keyword">int</span> un_read,capacity;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">is_full</span><span class="params">()</span>          <span class="comment">//缓冲区满判断</span></span></span><br><span class="line"><span class="function">        </span>&#123;   <span class="keyword">return</span> un_read == capacity; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">()</span>         <span class="comment">//缓冲区空判断</span></span></span><br><span class="line"><span class="function">        </span>&#123;   <span class="keyword">return</span> un_read == <span class="number">0</span> ;   &#125;</span><br><span class="line">    <span class="keyword">public</span>:                     <span class="comment">//构造函数</span></span><br><span class="line">        buffer(<span class="keyword">size_t</span> n):un_read(<span class="number">0</span>),capacity(n)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> x)</span>         </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            &#123;           </span><br><span class="line">                <span class="keyword">auto</span> lock = make_unique_lock(mu);       <span class="comment">//开始锁定互斥量</span></span><br><span class="line">                cond_put.wait(lock,</span><br><span class="line">                    [<span class="keyword">this</span>]&#123;<span class="keyword">return</span> un_read &lt; capacity;&#125;); <span class="comment">//条件变量等待</span></span><br><span class="line">                <span class="comment">//for(;is_full();)</span></span><br><span class="line">                <span class="comment">//&#123;</span></span><br><span class="line">                <span class="comment">//    cout &lt;&lt; "full waiting... "  &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">//    cond_put.wait(lock);</span></span><br><span class="line">                <span class="comment">//&#125;</span></span><br><span class="line">                stk.push(x);        <span class="comment">//压栈,写入数据</span></span><br><span class="line">                ++un_read; </span><br><span class="line">            &#125;       <span class="comment">//解锁互斥,条件变量的通知不需要互斥量的锁定</span></span><br><span class="line">            cond_get.notify_one();      <span class="comment">//通知可以读取数据</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> lock = make_unique_lock(mu);   <span class="comment">//锁定互斥量</span></span><br><span class="line">                cond_get.wait(lock,</span><br><span class="line">                    [<span class="keyword">this</span>]&#123;<span class="keyword">return</span> un_read &gt; <span class="number">0</span>;&#125;);   <span class="comment">//条件变量等待</span></span><br><span class="line">                <span class="comment">//for(;is_empty();)</span></span><br><span class="line">                <span class="comment">//&#123;</span></span><br><span class="line">                <span class="comment">//    cout &lt;&lt; "empty waiting... " &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">//    cond_get.wait(lock);</span></span><br><span class="line">                <span class="comment">//&#125;</span></span><br><span class="line">                --un_read;  </span><br><span class="line">                *x = stk.top(); <span class="comment">//读取数据</span></span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            cond_put.notify_one();      <span class="comment">//通知可以写数据了</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">buffer <span class="title">buf</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">int</span> n)</span>        <span class="comment">//生产者</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"put "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//输出信息</span></span><br><span class="line">        buf.put(i);             <span class="comment">//写入数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">( <span class="keyword">int</span> n)</span>       <span class="comment">//消费者</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        buf.get(&amp;x);            <span class="comment">//读取数据</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"get "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread_group tg;            <span class="comment">//使用程序组</span></span><br><span class="line"></span><br><span class="line">    tg.create_thread(bind(producer, <span class="number">20</span>));<span class="comment">//一个生产者线程</span></span><br><span class="line">    tg.create_thread(bind(consumer, <span class="number">10</span>));<span class="comment">//两个消费者线程</span></span><br><span class="line">    tg.create_thread(bind(consumer, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    tg.join_all();                  <span class="comment">//等待所有线程结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shared-mutex"><a href="#shared-mutex" class="headerlink" title="shared_mutex"></a>shared_mutex</h3><p>shared_mutex具有mutex全部功能,可以像mutext一样使用lock和unlock<br>不同于mutext的和recursive_mutex(递归锁),它允许线程获取多个共享所有权和一个专享所有权<br>实现了读写锁，即多个读线程一个写线程  </p>
<p><img src="/2016/10/22/boost-book/image-43.png" width="500px"><br><img src="/2016/10/22/boost-book/image-44.png" width="500px"></p>
<p>如果要获得共享所有权需要使用lock_shared(),try_lock_shared(),同时unlock_shared()释放共享所有权<br>如果要获得专享所有权需要使用lock和unlock  </p>
<p>当然 lock_guard和unique_lock也适用于shared_mutex，但只能获得写锁定   </p>
<p>读锁定需要使用shared_lock_guard或shared_lock,但很可惜thread库没有make_shared_lock  </p>
<p>同样的 适配器 shared_lockable_adapter 可以把一个类适配为符合shared_lockable概念   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/shared_lock_guard.hpp&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rw_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> m_x;</span><br><span class="line">        shared_mutex rw_mu;         <span class="comment">//共享互斥量</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        rw_data():m_x(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            unique_lock&lt;shared_mutex&gt; g(rw_mu); <span class="comment">//写锁定</span></span><br><span class="line">            ++m_x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//shared_lock_guard&lt;shared_mutex&gt; g(rw_mu);</span></span><br><span class="line">            shared_lock&lt;shared_mutex&gt; g(rw_mu); <span class="comment">//读锁定</span></span><br><span class="line">            *x = m_x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">(rw_data &amp;d)</span>         <span class="comment">//写线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        this_thread::sleep_for(<span class="number">3</span>_ms);  </span><br><span class="line">        d.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">(rw_data &amp;d)</span> <span class="comment">//读线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        this_thread::sleep_for(<span class="number">5</span>_ms);</span><br><span class="line">        d.read(&amp;x);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"reader:"</span>&lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rw_data d;</span><br><span class="line">    thread_group pool;</span><br><span class="line"></span><br><span class="line">    pool.create_thread(bind(writer,boost::ref(d)));</span><br><span class="line">    pool.create_thread(bind(writer,boost::ref(d)));</span><br><span class="line"></span><br><span class="line">    pool.create_thread(bind(reader,boost::ref(d)));</span><br><span class="line">    pool.create_thread(bind(reader,boost::ref(d)));</span><br><span class="line">    pool.create_thread(bind(reader,boost::ref(d)));</span><br><span class="line">    pool.create_thread(bind(reader,boost::ref(d)));</span><br><span class="line"></span><br><span class="line">    pool.join_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="future"><a href="#future" class="headerlink" title="future"></a>future</h3><p>线程不仅仅要执行一些任务,可能要返回一些计算结果,thread使用future范式提供了异步操作线程返回值的方法  </p>
<p>因为这个返回值在线程开始执行时还是不可用的，是一个未来的期待值  </p>
<p><img src="/2016/10/22/boost-book/image-45.png" width="500px">  </p>
<p>future的wait()类似thread.join(),可以阻塞等待线程的执行,直至获取future值  </p>
<p>wait_for/wait_until增加了超时的功能,返回futures_status枚举值表示是否可以执行成功  </p>
<p>get()用来获取future值,默认调用wait等待线程计算完成,  </p>
<p>get只能被调用一次,多次调用会抛出异常future_error  </p>
<p>valid(),is_ready(),has_value()和has_exception()分别用来测试future是否可用,是否有值,是否发生了异常  </p>
<h4 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h4><p>async用于产生future对象,异步地启动一个线程运行函数,返回future对象,这样可以利用future获取计算结果  </p>
<p><img src="/2016/10/22/boost-book/image-46.png" width="500px"></p>
<p>为了支持多个future使用,future还提供了c++11标准之外的两个自由函数<br>wait_for_any和wait_for_all,他们可以阻塞等待多个future对象,知道一个或者所有future对象都可用</p>
<p><img src="/2016/10/22/boost-book/image-47.png" width="500px">  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fab</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">    &#123;   <span class="keyword">return</span> <span class="number">1</span>;   &#125;</span><br><span class="line">    <span class="keyword">return</span> fab(n<span class="number">-1</span>) + fab(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f5 = async(fab, <span class="number">5</span>);            <span class="comment">//计算fab(5),时机不确定</span></span><br><span class="line">    <span class="keyword">auto</span> f7 = async(launch::async, fab, <span class="number">7</span>); <span class="comment">//要求立即开始计算fab(7)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f5.get() + f7.get() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//要求计算出future值</span></span><br><span class="line">    assert(!f5.valid() &amp;&amp; !f7.valid());     <span class="comment">//此时future无效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f10 = async(fab, <span class="number">10</span>);              <span class="comment">//计算fab(10)</span></span><br><span class="line">    <span class="keyword">auto</span> s = f10.wait_for(<span class="number">100</span>_ms);          <span class="comment">//future等到100毫秒计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(f10.valid())                         <span class="comment">//已经完成计算</span></span><br><span class="line">    &#123;</span><br><span class="line">        assert(s == future_status::ready);  <span class="comment">//future</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f10.get() &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//计算结果89</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//多个future</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;boost::future&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.push_back(async(fab, i + <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait_for_any(vec[<span class="number">3</span>], vec[<span class="number">4</span>], vec[<span class="number">2</span>]); <span class="comment">//等待任意一个future值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : vec)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x.valid())</span><br><span class="line">        &#123;   <span class="built_in">cout</span> &lt;&lt; x.get() &lt;&lt; <span class="built_in">endl</span>;        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//wait_for_all(vec.begin(), vec.end()); //等待所有计算结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//for(auto&amp; x : vec)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; x.get() &lt;&lt; ',';</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shared-future"><a href="#shared-future" class="headerlink" title="shared_future"></a>shared_future</h3><p>future在thread早期版本名字unique_future,因为get只能获取一次,不能被多个线程访问,不够方便  </p>
<p>shared_future是future增强版本,类似future,但是可以线程安全地多次调用get获取计算结果  </p>
<p><img src="/2016/10/22/boost-book/image-48.png" width="500px"></p>
<p>async()函数可以返回shared_future对象,但需要明确声明类型,例如  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_future&lt;<span class="keyword">int</span>&gt; f5 = async(fab, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>使用future的shared函数可以产生shared_future对象,或者明确声明类型也可行</p>
<blockquote>
<p>案例 </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//shared_future&lt;int&gt; f5 = async(fab, 5);</span></span><br><span class="line">    <span class="keyword">auto</span> f5 = async(fab, <span class="number">5</span>).share();</span><br><span class="line">    <span class="comment">//cout &lt;&lt; f5.get() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> func = [](<span class="keyword">decltype</span>(f5) f)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; f.get() &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    async(func, f5);</span><br><span class="line">    async(func, f5);</span><br><span class="line"></span><br><span class="line">    this_thread::sleep_for(<span class="number">100</span>_ms);</span><br><span class="line"></span><br><span class="line">    assert(f5.valid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h3><p>barrier另一种基于条件变量提供的同步机制<br>当线程执行到barrier必须等待,直到所有的线程都达到这个点才能继续执行  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boost::atomic&lt;<span class="keyword">int</span>&gt; x;</span><br><span class="line">    <span class="function">barrier <span class="title">br</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> func = [&amp;]()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"thread"</span>&lt;&lt; ++x &lt;&lt;<span class="string">" arrived barrier."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        br.wait();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"thread run."</span>  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    thread_group tg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        tg.create_thread(func);</span><br><span class="line">    &#125;</span><br><span class="line">    tg.join_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="thread-local"><a href="#thread-local" class="headerlink" title="thread_local"></a>thread_local</h3><p>c++11引入新关键字 thread_local,而thread库使用thread_specific_ptr实现了可移植的线程本地存储机制   </p>
<p>使得这一的变量用起来像是每个线程独立拥有的,简化多线程应用  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread_specific_ptr&lt;<span class="keyword">int</span>&gt; pi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> func = [&amp;]&#123;</span><br><span class="line">        pi.reset(<span class="keyword">new</span> <span class="keyword">int</span>());</span><br><span class="line"></span><br><span class="line">        ++(*pi);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"thread v="</span> &lt;&lt; *pi &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    async(func);</span><br><span class="line">    async(func);</span><br><span class="line"></span><br><span class="line">    this_thread::sleep_for(<span class="number">100</span>_ms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="at-thread-exit"><a href="#at-thread-exit" class="headerlink" title="at_thread_exit"></a>at_thread_exit</h3><p>this_thread在线程结束的时候执行可调用函数,无论线程是否被中断  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_msg</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; msg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printing</span><span class="params">()</span></span>&#123;</span><br><span class="line">    at_thread_exit(bind(end_msg, <span class="string">"end"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="asio"><a href="#asio" class="headerlink" title="asio"></a>asio</h2><p>asio库基于操作系统提供的异步机制,采用前摄器(Proactor)设模式实现了可移植的异步IO操作<br>而且并不要求使用多线程和锁,有效避免了多线程编程带来的诸多副作用(条件竞争、死锁等)</p>
<p>asio基于前摄器模式,封装了操作系统的select、kqueue、poll/epoll、overlapped I/O等机制,<br>实现了异步IO模型,它的核心类是io_service,相当于前摄器模式中的Proactor角色,<br>asio的任何操作都需要io_service的参与  </p>
<blockquote>
<p>同步模式    </p>
</blockquote>
<p>程序发起一个IO操作,向io_service提交请求, io_service把操作转交给操作系统,同步等待<br>当IO操作完成时,操作系统通知io_service,然后io_service再把结果发回程序<br>完成整个同步流程与多线程的join类似</p>
<blockquote>
<p>异步模式   </p>
</blockquote>
<p>程序除了要发起IO操作,还要定义一个回调的完成处理函数,io_service同样把io操作转交给操作系统执行<br>但他不同步等待而是立即返回,调用io_service的run()成员函数可以等待异步操作完成<br>当异步操作完成时候io_service从操作系统获取结果，再调用handler执行后续的逻辑  </p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h4><p>handler是asio库重要概念,符合某种函数签名的回调函数,handler必须可拷贝,io_service会存储handler的拷贝，当异步时间发送io_service回调用事件对应的handler  </p>
<p>handler不一定是函数和函数指针也可以是函数对象、function对象、bind/lambda表达式等  </p>
<p><img src="/2016/10/22/boost-book/image-49.png" width="500px"></p>
<p>可以使用bind把任意函数适配成asio要求的handler形式  </p>
<p>boost::asio::placeholders定义了几个占位符</p>
<p><img src="/2016/10/22/boost-book/image-50.png" width="500px">  </p>
<h4 id="io-service"><a href="#io-service" class="headerlink" title="io_service"></a>io_service</h4><p><img src="/2016/10/22/boost-book/image-51.png" width="500px"><br><img src="/2016/10/22/boost-book/image-52.png" width="500px">  </p>
<p>io_service类代表了系统里的异步处理机制(如epoll),必须在asio库里的其他对象之前初始化  </p>
<p>其他对象则向io_service提交一步操作handler  </p>
<ul>
<li>run()启动时间循环,阻塞等待所有注册到io_service的事件完成  </li>
</ul>
<h4 id="strand"><a href="#strand" class="headerlink" title="strand"></a>strand</h4><p>asio库基于操作系统的异步IO模型,不直接使用系统线程,而是定义了一个自己的线程概念:strand  </p>
<p>它序列化异步操作,保证异步代码在多线程的环境正确地执行,无需使用互斥量  </p>
<p><img src="/2016/10/22/boost-book/image-53.png" width="500px">  </p>
<ul>
<li>wrap(),包装一个函数,返回一个相同签名的函数对象,保证线程安全地在strand中执行  </li>
</ul>
<p>strand可以理解对一组handler加了锁,这组handler不会存在线程并发访问的问题  </p>
<h4 id="work"><a href="#work" class="headerlink" title="work"></a>work</h4><p>当io_service里注册的事件完成时它就退出时间循环,有的时候希望io_service继续运行,处理将来可能发生的异步时间<br>这时候需要让io_service始终有事可做  </p>
<p>work就是做这样的目的  </p>
<p>构造函数启动一个可用的任务,析构函数停止任务,像一个guard,于是在work生命周期李io_service就永远不会因其他异步事件完成而结束事件循环  </p>
<p><img src="/2016/10/22/boost-book/image-54.png" width="500px"></p>
<h4 id="mutable-buffer和const-buffer"><a href="#mutable-buffer和const-buffer" class="headerlink" title="mutable_buffer和const_buffer"></a>mutable_buffer和const_buffer</h4><p>IO操作经常会使用到数据缓冲区,相当于一片指定的内存区域   </p>
<p>asio提供了两个mutable_buffer和const_buffer  </p>
<p><img src="/2016/10/22/boost-book/image-55.png" width="500px"><br><img src="/2016/10/22/boost-book/image-56.png" width="500px">  </p>
<p>为适配容器概念,还提供了begin和end操作  </p>
<p><img src="/2016/10/22/boost-book/image-59.png" width="500px">  </p>
<blockquote>
<p>工厂函数  </p>
</blockquote>
<p>buffer()工厂函数产生buffer对象,包装常用C++容器类型,如原始数组、array、vector、string等  </p>
<p>返回mutable_buffers_1或const_buffers_1</p>
<p><img src="/2016/10/22/boost-book/image-57.png" width="500px">  </p>
<p>asio还提供了几个自由函数操作buffer  </p>
<p><img src="/2016/10/22/boost-book/image-58.png" width="500px">  </p>
<h3 id="unix信号"><a href="#unix信号" class="headerlink" title="unix信号"></a>unix信号</h3><p>UNIX信号是常用的进程间异步通信手段  </p>
<p>asio库提供了signal_set,利用异步IO地方式很好处理unix信号  </p>
<p><img src="/2016/10/22/boost-book/image-60.png" width="500px"><br><img src="/2016/10/22/boost-book/image-61.png" width="500px">  </p>
<p>signal_set构造函数需要传入io_service对象,用于提交异步操作,第二种形式的构造函数还可以传入三个整数信号值,在构造的同时加入信号集   </p>
<p>add/remove/clear成员函数理解为添加、删除信号量,同时也向io_service注册了信号事件,cancel取消了所有handler的执行,实际上是向他们传入boost::asio::error::operation_aborted错误,要求handler执行自己的cancel逻辑  </p>
<h4 id="用法-12"><a href="#用法-12" class="headerlink" title="用法"></a>用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::system;</span><br><span class="line"><span class="keyword">using</span> boost::function;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kill -10 xxxx</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    io_service io;          <span class="comment">//io_service对象</span></span><br><span class="line">    <span class="comment">//io_service::work w(io);      </span></span><br><span class="line"></span><br><span class="line">    <span class="function">signal_set <span class="title">sig</span><span class="params">(io, SIGINT, SIGUSR1)</span></span>;    <span class="comment">//捕获两个信号</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"add:"</span> &lt;&lt; SIGINT &lt;&lt; <span class="string">","</span> &lt;&lt; SIGUSR1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sig.add(SIGINT);          //等价与signal_set构造函数</span></span><br><span class="line">    <span class="comment">//sig.add(SIGUSR1);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> handler1 =                 <span class="comment">//定义一个handler,使用lambda</span></span><br><span class="line">        [&amp;](<span class="keyword">const</span> error_code&amp; ec, <span class="keyword">int</span> n)    <span class="comment">//函数签名必须符合要求</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "enter sigint" &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(ec)              <span class="comment">//检查错误码</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; ec.message() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(n != SIGINT)     <span class="comment">//检查信号是否要处理</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"handler1 recv = "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"do something"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">//w.~work();</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(handler_type)</span><span class="params">(<span class="keyword">const</span> error_code&amp;, <span class="keyword">int</span>)</span></span>;     <span class="comment">//定义第二个handler,使用function</span></span><br><span class="line">    function&lt;handler_type&gt;</span><br><span class="line">        handler2 =</span><br><span class="line">        [&amp;](<span class="keyword">const</span> error_code&amp; ec, <span class="keyword">int</span> n)            <span class="comment">//函数签名必须符合要求</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n != SIGUSR1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"handler2 recv = "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            sig.async_wait(handler1);          <span class="comment">//异步添加处理handler</span></span><br><span class="line">            sig.async_wait(handler2);           <span class="comment">//异步添加处理handler</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    sig.async_wait(handler1);           <span class="comment">//异步添加处理handler</span></span><br><span class="line">    sig.async_wait(handler2);           <span class="comment">//异步添加处理handler</span></span><br><span class="line"></span><br><span class="line">    io.run();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"io stoped"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>signal_set捕获sigint和sigusr1,并使用lambda定义了对应的两个处理函数   </li>
<li>async_wait通知io_service异步地执行IO操作,并且注册了handler回调函数  </li>
<li>run,启动前摄器事件处理循环,否则程序会因为不等待事件发生,进入阻塞状态,等待信号事件并分派事件,直至所有操作完成然后退出run  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -30 pid </span><br><span class="line">handler2 recv = 30</span><br></pre></td></tr></table></figure>
<p>程序捕获了信号SIGUSR1后执行handler,如果想让程序持续捕捉信号,只在收到SIGINT时才退出则信号处理完毕后重新添加handler  </p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>asio库,提供了deadline_timer,steady_timer,system_timer和high_resolution_timer四个定时器  </p>
<p>定时器非常重要的功能,指定某个时刻调用函数,实现异步操作   </p>
<p>deadline_timer是asio早期版本提供的定时器,使用boost.date_time库提供时间才支持   </p>
<p>而后三个定时器则使用std::chrono或者boost::chrono里的时钟类提供时间支持   </p>
<p>但是后三个不在boost/asio.hpp,而在额外的头文件  </p>
<p><img src="/2016/10/22/boost-book/image-62.png" width="500px"></p>
<h4 id="basic-waitable-timer"><a href="#basic-waitable-timer" class="headerlink" title="basic_waitable_timer"></a>basic_waitable_timer</h4><p><img src="/2016/10/22/boost-book/image-63.png" width="500px"><br><img src="/2016/10/22/boost-book/image-64.png" width="500px"></p>
<p>steady_timer,system_timer和high_resolution_time是basic_waitable_timer的模板特化typedef  </p>
<p><img src="/2016/10/22/boost-book/image-65.png" width="500px"></p>
<p>定时器的三种形式构造函数,同signal_set一样要求有io_service对象,用于提交io请求,第二个参数是定时器的终止时间,可以是绝对时间点和相对当前时间长度  </p>
<p>一旦定时器创建就开始计时  </p>
<ul>
<li><p>成员函数wait来同步等待定时器终止,或者async_wait异步等待,当定时器终止会调用handler函数     </p>
</li>
<li><p>成员函数expires_at或expires_from_now分别设置定时器终止的时间点和相对时间,然后wait或async_wait等待  </p>
</li>
<li><p>成员函数calcen,传递error::operation_aborted错误码通知所有异步操作取消,返回已经取消的handler数量  </p>
</li>
<li><p>cancel_one功能如同cancel,但它一次只取消一个handler  </p>
</li>
</ul>
<p>async_wait异步等待的handler形式要求是  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">const</span> error_code&amp; ec)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="同步定时器"><a href="#同步定时器" class="headerlink" title="同步定时器"></a>同步定时器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/chrono.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::chrono;</span><br><span class="line">seconds <span class="keyword">operator</span><span class="string">""</span> _s(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> seconds(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">milliseconds <span class="keyword">operator</span><span class="string">""</span> _ms(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> milliseconds(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/steady_timer.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    io_service io;</span><br><span class="line"></span><br><span class="line">    <span class="function">steady_timer <span class="title">t</span><span class="params">(io, <span class="number">500</span>_ms)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t.expires_at() &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//查看终止时间点,单位纳秒</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t.expires_from_now() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//查看终止时间长度,单位纳秒</span></span><br><span class="line"></span><br><span class="line">    t.wait();           <span class="comment">//wait同步等待</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello asio1"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与thread的sleep对比,两者都是等待,但内部机制不一样,thread的sleep使用了互斥量和条件变量<br>在线程中等待,而asio则调用了操作系统的一步机制如select、epoll完成没有多线程竞争  </p>
<h4 id="异步定时器"><a href="#异步定时器" class="headerlink" title="异步定时器"></a>异步定时器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    io_service io;</span><br><span class="line"></span><br><span class="line">    <span class="function">steady_timer <span class="title">t</span><span class="params">(io, <span class="number">500</span>_ms)</span></span>;</span><br><span class="line"></span><br><span class="line">    t.async_wait(</span><br><span class="line">        [](<span class="keyword">const</span> error_code&amp; ec) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello asio2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    io.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样当定时器到期时,io_service会回调处理函数,完成异步操作  </p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">timer_with_func</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> timer_with_func this_type;          <span class="comment">//定义别名</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_count = <span class="number">0</span>;                <span class="comment">//计数器成员</span></span><br><span class="line">    <span class="keyword">int</span> m_count_max = <span class="number">0</span>;            <span class="comment">//计数器上限</span></span><br><span class="line">    function&lt;<span class="keyword">void</span>()&gt; m_f;           <span class="comment">//function对象,持有无参无返回的可调物</span></span><br><span class="line">    steady_timer <span class="keyword">m_t</span>;               <span class="comment">//asio定时器对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;            </span><br><span class="line">    timer_with_func(io_service&amp; io, <span class="keyword">int</span> x, F func):     </span><br><span class="line">        m_count_max(x),         <span class="comment">//初始化计数器</span></span><br><span class="line">        m_f(func),              <span class="comment">//初始化回调函数</span></span><br><span class="line">        <span class="keyword">m_t</span>(io, <span class="number">200</span>_ms)         <span class="comment">//启动计时器</span></span><br><span class="line">    &#123;</span><br><span class="line">        init();                 <span class="comment">//异步等待计时器,注册回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(handler_type)</span><span class="params">(<span class="keyword">const</span> error_code&amp;)</span></span>;</span><br><span class="line">    function&lt;handler_type&gt; m_handler =</span><br><span class="line">        [&amp;](<span class="keyword">const</span> error_code&amp;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_count++ &gt;= m_count_max)</span><br><span class="line">            &#123;   <span class="keyword">return</span>;  &#125;</span><br><span class="line">            m_f();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">m_t</span>.expires_from_now(<span class="number">200</span>_ms);</span><br><span class="line">            <span class="keyword">m_t</span>.async_wait(m_handler);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>        </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">m_t</span>.async_wait(m_handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//m_t.async_wait(bind(              //bind绑定成员函数</span></span><br><span class="line">        <span class="comment">//        &amp;this_type::handler, this,        //传递this指针</span></span><br><span class="line">        <span class="comment">//        boost::asio::placeholders::error));   //error占位符传递错误码</span></span><br><span class="line">        <span class="comment">//        //_1));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">const</span> error_code&amp;)</span>     </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_count++ &gt;= m_count_max)       <span class="comment">//计时器到达上限退出</span></span><br><span class="line">        &#123;   <span class="keyword">return</span>;  &#125;</span><br><span class="line"></span><br><span class="line">        m_f();              <span class="comment">//调用function对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">m_t</span>.expires_from_now(<span class="number">200</span>_ms);       <span class="comment">//设置定时器的终止时间为0.2秒之后</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">m_t</span>.async_wait(bind(                <span class="comment">//再次启动定时器,异步等待</span></span><br><span class="line">                &amp;this_type::handler, <span class="keyword">this</span>,</span><br><span class="line">                boost::asio::placeholders::error));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    io_service io;</span><br><span class="line"></span><br><span class="line">    <span class="function">timer_with_func <span class="title">t1</span><span class="params">(io, <span class="number">5</span>,           <span class="comment">//启动第一个定时器</span></span></span></span><br><span class="line"><span class="function"><span class="params">        []&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello timer1"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//timer_with_func t2(io, 5,</span></span><br><span class="line">    <span class="comment">//    []&#123;cout &lt;&lt; "hello timer2"&lt;&lt;endl;&#125;);</span></span><br><span class="line"></span><br><span class="line">    io.run();           <span class="comment">//io_service等待异步调用结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通信概述"><a href="#通信概述" class="headerlink" title="通信概述"></a>通信概述</h3><p>asio库支持TCP、UDP、ICMP通信协议,它的名字空间boost::asio:ip里提供了大量的网络通信方面的函数和类<br>很好封装了伯克利SocketAPI  </p>
<ul>
<li>ip::tcp是asio网络通信部分主要的类,表示TCP协议<br>  但它本身并没有太多功能,而是定义了数个用于TCP通信的typedef类型,用来协作完成网络通信  </li>
<li>typedef:包括端点类endpoint、套接字类socket、流类iostream、接收器acceptor、解析器resolver等</li>
</ul>
<p>ip::tcp更像一个名字空间   </p>
<p><img src="/2016/10/22/boost-book/image-66.png" width="500px"><br><img src="/2016/10/22/boost-book/image-67.png" width="500px">  </p>
<p>ip::tcp内部类型endpoint、socket、acceptor和resolver是asio库TCP通信中最核心的一组类  </p>
<p>封装了socket的链接、断开和数据收发等功能,使他们可以容易编写出socket程序  </p>
<h4 id="address"><a href="#address" class="headerlink" title="address"></a>address</h4><p>IP地址独立于TCP、UDP等通信协议  </p>
<p>asio库使用ip::address表示ip地址,可以同时支持ipv4和ipv6两种地址   </p>
<p><img src="/2016/10/22/boost-book/image-68.png" width="500px">  </p>
<blockquote>
<p>工厂函数  </p>
</blockquote>
<p>address静态成员函数from_string(),可以从字符串产生IP地址</p>
<p>is_v4(),is_v6()可以用来检测地址的版本   </p>
<p>to_string()函数可以将ip地址转换成字符串  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::system;</span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ip::address addr;           <span class="comment">//声明一个ip地址对象</span></span><br><span class="line">    addr = addr.from_string(<span class="string">"127.0.0.1"</span>);       <span class="comment">//字符串产生ip地址</span></span><br><span class="line">    assert(addr.is_v4());                       <span class="comment">//ipv4的地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; addr.to_string() &lt;&lt; <span class="built_in">endl</span>;           <span class="comment">//转换成字符串输出</span></span><br><span class="line">    addr = addr.from_string(<span class="string">"ab::12:34:56"</span>);    <span class="comment">//ipv6的地址</span></span><br><span class="line">    assert(addr.is_v6());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="endpoint"><a href="#endpoint" class="headerlink" title="endpoint"></a>endpoint</h4><p>有了ip地址,再加上通信的端口号就构成了一个socket端点,在asio库中用了ip::tcp::endpoint表示   </p>
<p><img src="/2016/10/22/boost-book/image-69.png" width="500px"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ip::address addr;          </span><br><span class="line">    addr = addr.from_string(<span class="string">"127.0.0.1"</span>);   <span class="comment">//ipv4地址</span></span><br><span class="line">    ip::tcp::<span class="function">endpoint <span class="title">ep</span><span class="params">(addr, <span class="number">6688</span>)</span></span>;          <span class="comment">//端点对象,端口6688</span></span><br><span class="line">    assert(ep.address() == addr);</span><br><span class="line">    assert(ep.port() == <span class="number">6688</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><p>socket类是tcp通信的基本类，basic_stream_socket的tcp协议特化  </p>
<p><img src="/2016/10/22/boost-book/image-70.png" width="500px">  </p>
<p><img src="/2016/10/22/boost-book/image-71.png" width="500px">  </p>
<p>socket构造时指定使用的协议和endpoint,或者稍后调用connect()  </p>
<p>连接成功后可以用local_endpoint()和remote_endpoint()获得连接两端的端点信息  </p>
<p>available()获取可读取的字节数  </p>
<p>receive()/read_some()和send()/write_some()读写数据  </p>
<p>close()函数关闭socket,如果不关闭socket,那么在socket对象析构也会自动调用close()关闭 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">send()/receive()和wirte_some()/read_some()函数功能完全相同,只是名字不同  </span><br><span class="line">内部调用的是系统函数::sendmsg()和::recvmsg()</span><br><span class="line">但send()/receive()函数要多出一种使用socket_base::message_flags参数的重载形式</span><br></pre></td></tr></table></figure>
<p>socket读写函数都是buffer类型,buffer()函数包装各种容器适配  </p>
<ul>
<li>send、wiite_some需要可读的buffer  </li>
<li>receive、read_some需要可写的buffer   </li>
</ul>
<h4 id="acceptor"><a href="#acceptor" class="headerlink" title="acceptor"></a>acceptor</h4><p>acceptor类对应Socket Api的accept()函数功能  </p>
<p>它用于服务器端,在指定的端口接收连接,必须配合socket类才能完成通信  </p>
<p><img src="/2016/10/22/boost-book/image-72.png" width="500px"><br><img src="/2016/10/22/boost-book/image-73.png" width="500px"></p>
<p>acceptor可以像传统socket api,open()打开端口,bind()端口绑定,listen()监听端口  </p>
<p>更方便是使用它的构造函数, 传入endpoint直接完成三个动作  </p>
<p>在开始监听之后,调用accept()就可以接收新的连接,连接成功的socket在函数参数里以引用的形式输出  </p>
<h3 id="同步tcp通信"><a href="#同步tcp通信" class="headerlink" title="同步tcp通信"></a>同步tcp通信</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">try</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> ip::tcp::acceptor acceptor_type;        <span class="comment">//简化类型定义</span></span><br><span class="line">    <span class="keyword">typedef</span> ip::tcp::endpoint endpoint_type;</span><br><span class="line">    <span class="keyword">typedef</span> ip::tcp::socket socket_type;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"server start."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    io_service io;                              <span class="comment">//io_service对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function">acceptor_type <span class="title">acceptor</span><span class="params">(io,</span></span></span><br><span class="line">            endpoint_type(ip::tcp::v4(), 6688));    //一套完成bind,listen</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; acceptor.local_endpoint().address() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">socket_type <span class="title">sock</span><span class="params">(io)</span></span>;       <span class="comment">//一个socket对象</span></span><br><span class="line"></span><br><span class="line">        acceptor.accept(sock);      <span class="comment">//accept阻塞等待socket连接</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"client:"</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sock.remote_endpoint().address() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        sock.send(buffer(<span class="string">"hello asio"</span>));        <span class="comment">//send发送回去</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="built_in">std</span>::exception&amp; e)</span><br><span class="line">&#123;                                       <span class="comment">//捕捉异常</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::system;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">try</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> ip::tcp::endpoint endpoint_type;</span><br><span class="line">    <span class="keyword">typedef</span> ip::tcp::socket socket_type;</span><br><span class="line">    <span class="keyword">typedef</span> ip::address address_type;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"client start."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    io_service io;          <span class="comment">//io_service对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function">socket_type <span class="title">sock</span><span class="params">(io)</span></span>;</span><br><span class="line">    endpoint_type ep(address_type::from_string("127.0.0.1"), 6688);</span><br><span class="line">        <span class="comment">//创建连接端点</span></span><br><span class="line"></span><br><span class="line">    sock.connect(ep);           <span class="comment">//socket进行连接端点</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sock.available() &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//获取可读取的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//vector&lt;char&gt; str(sock.available() + 1, 0);</span></span><br><span class="line">    <span class="comment">//sock.receive(buffer(str));</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "recive from " &lt;&lt; sock.remote_endpoint().address();</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &amp;str[0] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; str(<span class="number">5</span>,<span class="number">0</span>);      <span class="comment">//创建vector缓冲区</span></span><br><span class="line">    error_code ec;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        sock.read_some(buffer(str), ec);        <span class="comment">//使用buffer包装缓冲区接收数据,并使用错误码形式    </span></span><br><span class="line">        <span class="keyword">if</span>(ec)      <span class="comment">//检查错误码</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; &amp;str[<span class="number">0</span>];        <span class="comment">//输出接收到的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="built_in">std</span>::exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步tcp通信"><a href="#异步tcp通信" class="headerlink" title="异步tcp通信"></a>异步tcp通信</h3><p>原有的同步调用函数换成前缀async_的异步调用函数,并增加回调函数  </p>
<p>回调函数中在启动一个异步调用确保io_service继续处理socket事件  </p>
<h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::system;</span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">server</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> server this_type;                   <span class="comment">//简化类型定义</span></span><br><span class="line">    <span class="keyword">typedef</span> ip::tcp::acceptor     acceptor_type;</span><br><span class="line">    <span class="keyword">typedef</span> ip::tcp::endpoint   endpoint_type;</span><br><span class="line">    <span class="keyword">typedef</span> ip::tcp::socket   socket_type;</span><br><span class="line">    <span class="keyword">typedef</span> boost::<span class="built_in">shared_ptr</span>&lt;socket_type&gt;     sock_ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    io_service m_io;</span><br><span class="line">    acceptor_type m_acceptor;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    server():</span><br><span class="line">      m_acceptor(m_io,endpoint_type(ip::tcp::v4(), <span class="number">6688</span>))</span><br><span class="line">    &#123;   accept();    &#125;          <span class="comment">//构造启动异步函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_io.run(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//void accept()</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    sock_ptr sock(new socket_type(m_io));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  可用bind的方式去绑定一个函数处理</span></span><br><span class="line">    <span class="comment">//    m_acceptor.async_accept(*sock,</span></span><br><span class="line">    <span class="comment">//            bind(&amp;this_type::accept_handler, this,</span></span><br><span class="line">    <span class="comment">//            boost::asio::placeholders::error, sock));</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">()</span>       <span class="comment">//用于启动异步接收连接</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sock_ptr sock(new socket_type(m_io));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要调用acceptor的saync_accept函数启动异步接收连接</span></span><br><span class="line">        <span class="comment">//使用了lambda方式去回调处理</span></span><br><span class="line">        m_acceptor.async_accept(*sock,</span><br><span class="line">            [<span class="keyword">this</span>, sock](<span class="keyword">const</span> error_code&amp; ec)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ec)</span><br><span class="line">                &#123;   <span class="keyword">return</span>;     &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//又异步发回去</span></span><br><span class="line">                sock-&gt;async_send(</span><br><span class="line">                    buffer(<span class="string">"hello asio"</span>),</span><br><span class="line">                    [](<span class="keyword">const</span> error_code&amp; ec, <span class="built_in">std</span>::<span class="keyword">size_t</span>)</span><br><span class="line">                    &#123;   <span class="built_in">cout</span> &lt;&lt; <span class="string">"send msg complete."</span> &lt;&lt; <span class="built_in">endl</span>;   &#125;</span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">                <span class="comment">//再次启动异步接收连接</span></span><br><span class="line">                accept();</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept_handler</span><span class="params">(<span class="keyword">const</span> error_code&amp; ec, sock_ptr sock)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ec)</span><br><span class="line">        &#123;   <span class="keyword">return</span>;     &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"client:"</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sock-&gt;remote_endpoint().address() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sock-&gt;async_write_some(buffer(<span class="string">"hello asio"</span>),</span><br><span class="line">                bind(&amp;this_type::write_handler2, <span class="keyword">this</span>,</span><br><span class="line">                boost::asio::placeholders::error,</span><br><span class="line">                boost::asio::placeholders::bytes_transferred));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步发送数据,腰围这个异步调用编写回调函数write_handler</span></span><br><span class="line">        <span class="comment">//发送完勿忘再次启动服务器接收连接,否则完成数据发送后io_service将因为没有事件处理而结束运行  </span></span><br><span class="line"></span><br><span class="line">        accept();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write_handler</span><span class="params">(<span class="keyword">const</span> error_code&amp;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="built_in">cout</span> &lt;&lt; <span class="string">"send msg complete."</span> &lt;&lt; <span class="built_in">endl</span>;   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write_handler2</span><span class="params">(<span class="keyword">const</span> error_code&amp;, <span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="built_in">cout</span> &lt;&lt; <span class="string">"send msg "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    server svr;</span><br><span class="line">    svr.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOST_ASIO_DISABLE_STD_CHRONO</span></span><br><span class="line"><span class="comment">//#define BOOST_ASIO_ENABLE_HANDLER_TRACKING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::system;</span><br><span class="line"><span class="keyword">using</span> boost::<span class="built_in">shared_ptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">client</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> client                        this_type;            <span class="comment">//简化类型定义</span></span><br><span class="line">    <span class="keyword">typedef</span> ip::tcp::endpoint           endpoint_type;</span><br><span class="line">    <span class="keyword">typedef</span> ip::address               address_type;</span><br><span class="line">    <span class="keyword">typedef</span> ip::tcp::socket             socket_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">shared_ptr</span>&lt;socket_type&gt;   sock_ptr;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;                buffer_type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    io_service                          m_io;           <span class="comment">//io_service对象</span></span><br><span class="line">    buffer_type                         m_buf;          <span class="comment">//接收缓冲区</span></span><br><span class="line">    endpoint_type                       m_ep;           <span class="comment">//tcp端点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    client():</span><br><span class="line">        <span class="comment">//m_buf(100,0),</span></span><br><span class="line">        m_buf(<span class="number">5</span>,<span class="number">0</span>),</span><br><span class="line">        m_ep(address_type::from_string(<span class="string">"127.0.0.1"</span>), <span class="number">6688</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        start();                <span class="comment">//启动异步连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_io.run();         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//void start()</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    sock_ptr sock(new socket_type (m_io));</span></span><br><span class="line">    <span class="comment">//    sock-&gt;async_connect(m_ep,</span></span><br><span class="line">    <span class="comment">//            bind(&amp;this_type::conn_handler,this,</span></span><br><span class="line">    <span class="comment">//                boost::asio::placeholders::error, sock));</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sock_ptr sock(new socket_type (m_io));      //创建socket对象</span><br><span class="line"></span><br><span class="line">        <span class="comment">//function&lt;void(const error_code&amp;,std::size_t)&gt; handler =</span></span><br><span class="line">        <span class="comment">//    [this, sock, handler](const error_code&amp; ec, std::size_t)</span></span><br><span class="line">        <span class="comment">//    &#123;</span></span><br><span class="line">        <span class="comment">//        if (ec)</span></span><br><span class="line">        <span class="comment">//        &#123;   return;     &#125;</span></span><br><span class="line">        <span class="comment">//        cout &lt;&lt; &amp;m_buf[0] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//        //sock-&gt;async_read_some(buffer(m_buf), handler);</span></span><br><span class="line">        <span class="comment">//    &#125;;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步连接</span></span><br><span class="line">        sock-&gt;async_connect(m_ep,               </span><br><span class="line">            [<span class="keyword">this</span>, sock](<span class="keyword">const</span> error_code&amp; ec)      </span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="keyword">if</span> (ec)         <span class="comment">//处理错误码</span></span><br><span class="line">                &#123;   <span class="keyword">return</span>;     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//异步读取数据</span></span><br><span class="line">                sock-&gt;async_read_some(buffer(m_buf),        </span><br><span class="line">                    [<span class="keyword">this</span>, sock](<span class="keyword">const</span> error_code&amp; ec,<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        read_handler(ec, sock);</span><br><span class="line">                    &#125;</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">conn_handler</span><span class="params">(<span class="keyword">const</span> error_code&amp; ec, sock_ptr sock)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ec)</span><br><span class="line">        &#123;   <span class="keyword">return</span>;     &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"recive from "</span> &lt;&lt; sock-&gt;remote_endpoint().address();</span><br><span class="line"></span><br><span class="line">        sock-&gt;async_read_some(buffer(m_buf),</span><br><span class="line">                bind(&amp;client::read_handler, <span class="keyword">this</span>, </span><br><span class="line">                    boost::asio::placeholders::error,</span><br><span class="line">                    <span class="comment">//boost::asio::placeholders::bytes_transferred,</span></span><br><span class="line">                    sock));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//start();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read_handler</span><span class="params">(<span class="keyword">const</span> error_code&amp; ec, <span class="comment">/*std::size_t n,*/</span> sock_ptr sock)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ec)                 <span class="comment">//处理错误代码</span></span><br><span class="line">        &#123;   <span class="keyword">return</span>;     &#125;           <span class="comment">//输出接收到的数据</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; &amp;m_buf[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//继续异步读取数据</span></span><br><span class="line">        sock-&gt;async_read_some(buffer(m_buf),</span><br><span class="line">                bind(&amp;client::read_handler, <span class="keyword">this</span>, </span><br><span class="line">                    boost::asio::placeholders::error,</span><br><span class="line">                    <span class="comment">//boost::asio::placeholders::bytes_transferred,</span></span><br><span class="line">                    sock));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"client start."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    client cl;</span><br><span class="line">    cl.run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解析网络地址"><a href="#解析网络地址" class="headerlink" title="解析网络地址"></a>解析网络地址</h3><p>resolver类对用socketApi的getaddrinfo()函数,用于解析网址获得可用的ip地址  </p>
<p>解析得到的ip地址可以使用socket对象连接  </p>
<p>resolver类通过域名获得可用的ip,实现与ip版本无关的网址解析   </p>
<p><img src="/2016/10/22/boost-book/image-74.png" width="500px"><br><img src="/2016/10/22/boost-book/image-75.png" width="500px">  </p>
<h4 id="用法-13"><a href="#用法-13" class="headerlink" title="用法"></a>用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::system;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/chrono.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::chrono;</span><br><span class="line">seconds <span class="keyword">operator</span><span class="string">""</span> _s(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> seconds(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">milliseconds <span class="keyword">operator</span><span class="string">""</span> _ms(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> milliseconds(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resolve_connect</span><span class="params">(ip::tcp::socket &amp;sock,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ip::tcp::resolver r(sock.get_io_service());     //创建一个resolver对象</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个query对象</span></span><br><span class="line">    ip::tcp::resolver::query q(name, boost::lexical_cast&lt;string&gt;(port));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> iter = r.resolve(q);       <span class="comment">//使用resolve()迭代端点</span></span><br><span class="line">    <span class="keyword">decltype</span>(iter) end;             <span class="comment">//逾尾迭代器</span></span><br><span class="line">    error_code ec = error::host_not_found;</span><br><span class="line">    <span class="keyword">for</span> ( ;ec &amp;&amp; iter != end; ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        sock.close();</span><br><span class="line">        sock.connect(*iter,ec);         <span class="comment">//尝试连接端点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ec)         <span class="comment">//有错误发生</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"can't connect."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">throw</span> system_error(ec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"connect success."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">try</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    io_service io;</span><br><span class="line">    ip::tcp::<span class="function">socket <span class="title">sock</span><span class="params">(io)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//resolve不仅能够解析域名,也支持使用Ip地址和服务名</span></span><br><span class="line">    resolve_connect(sock,<span class="string">"www.boost.org"</span>, <span class="number">80</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sock.remote_endpoint() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ios.run();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="built_in">std</span>::exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>resolve_connect()函数中使用了lexical_cast,这是因为query对象只接受字符串参数,所以需要把端口号由整型转换成字符串  </p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程是泛化的例程,例程只有一个入口和多个出口  </p>
<p>函数入口开始,可以在某个时刻用return返回,例程就结束了,而协程不同,有多个入口个多个出口  </p>
<p>最开始的入口进入之后可以随时用yield调用返回,之后再调用协程就会从刚才返回的地方继续执行  </p>
<p><img src="/2016/10/22/boost-book/image-76.png" width="500px">  </p>
<p>asio的协程功能主要使用类yield_context,它是basic_yield_context的typedef  </p>
<p>yield_context的接口很简单,保存了协程的运行环境,交替执行主协程(caller)和从协程(callee),达到异步地目的  </p>
<p>operator[]用于外部获取发生的错误码,如果不使用operator[]则会抛出system_error异常来报告错误  </p>
<blockquote>
<p>创建  </p>
</blockquote>
<p>无法直接创建yield_context对象,而是使用函数spawn(),它产生yield_context对象,  </p>
<p>spawn()多个重载形式  </p>
<p>boost::asio::spawn(my_strand, do_echo);<br>一般输入2个参数，参数1是 io_service 或者是 strand，<br>参数2是协程函数，类型如下：<br>void coroutine(boost::asio::yield_context yield);</p>
<p><img src="/2016/10/22/boost-book/image-77.png" width="500px"> </p>
<h4 id="用法-14"><a href="#用法-14" class="headerlink" title="用法"></a>用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio/spawn.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::system;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> ip::tcp::acceptor acceptor_type;        <span class="comment">//类型定义</span></span><br><span class="line">    <span class="keyword">typedef</span> ip::tcp::endpoint endpoint_type;</span><br><span class="line">    <span class="keyword">typedef</span> ip::tcp::socket socket_type;</span><br><span class="line"></span><br><span class="line">    io_service io;              <span class="comment">//必需的io_Service对象</span></span><br><span class="line"></span><br><span class="line">    spawn(io,                   <span class="comment">//使用spawn函数产生协程</span></span><br><span class="line">        [&amp;](yield_context yield)        <span class="comment">//lambda表达式</span></span><br><span class="line">        &#123;</span><br><span class="line">            acceptor_type acceptor(io,          <span class="comment">//acceptor对象</span></span><br><span class="line">                endpoint_type(ip::tcp::v4(), <span class="number">6688</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(;;)</span><br><span class="line">            &#123;</span><br><span class="line">                socket_type sock(io);</span><br><span class="line">                error_code ec;</span><br><span class="line"></span><br><span class="line">                acceptor.async_accept(sock, yield[ec]);     <span class="comment">//使用协程 无handler</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ec)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> len = sock.async_write_some(           <span class="comment">//异步写数据,获取字节数</span></span><br><span class="line">                    buffer(<span class="string">"hello coroutine"</span>), yield);  <span class="comment">//使用协程,无handler</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"send "</span> &lt;&lt; len &lt;&lt; <span class="string">" bytes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;           <span class="comment">//监听服务结束</span></span><br><span class="line">        &#125;       <span class="comment">//服务lambda结束   </span></span><br><span class="line">    );          <span class="comment">//服务协程结束</span></span><br><span class="line"></span><br><span class="line">    io.run();           <span class="comment">//启动事件循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个操作看起来像是同步的,没有放handle回调处理  </p>
<p>在协程函数中调用各个异步IO，异步操作将挂起协程，待异步操作完成后会自动继续协程。</p>
<h1 id="高阶工具"><a href="#高阶工具" class="headerlink" title="高阶工具"></a>高阶工具</h1><h2 id="optional"><a href="#optional" class="headerlink" title="optional"></a>optional</h2><p>经常遇到无效值的情况,或函数并不能总返回有效值,很多函数正确执行,但结果不合理  </p>
<p><img src="/2016/10/22/boost-book/image-135.png" width="500px"></p>
<h3 id="操作函数-1"><a href="#操作函数-1" class="headerlink" title="操作函数"></a>操作函数</h3><p><img src="/2016/10/22/boost-book/image-136.png" width="500px">  </p>
<p><img src="/2016/10/22/boost-book/image-137.png" width="500px">  </p>
<h3 id="用法-15"><a href="#用法-15" class="headerlink" title="用法"></a>用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    optional&lt;<span class="keyword">int</span>&gt; op0;          <span class="comment">//未初始化的optinal对象</span></span><br><span class="line">    optional&lt;<span class="keyword">int</span>&gt; op1(none);    <span class="comment">//同上 none赋予未初始化值</span></span><br><span class="line"></span><br><span class="line">    assert(!op0);               <span class="comment">//bool测试</span></span><br><span class="line">    assert(op0 == op1);         <span class="comment">//比较两个optional对象</span></span><br><span class="line">    assert(op1.value_or(<span class="number">253</span>) == <span class="number">253</span>);   <span class="comment">//获得缺省值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; op1.value_or_eval(          <span class="comment">//获得lambda定义的返回缺省值</span></span><br><span class="line">            []()&#123;<span class="keyword">return</span> <span class="number">874</span>;&#125;) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    optional&lt;<span class="built_in">string</span>&gt; ops(<span class="string">"test"</span>);   <span class="comment">//初始化字符串test</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *ops &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    ops.emplace(<span class="string">"monado"</span>, <span class="number">3</span>);       <span class="comment">//就地创建一个字符串,无拷贝代价</span></span><br><span class="line">    assert(*ops == <span class="string">"mon"</span>);          <span class="comment">//只用了前三个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">10</span>);</span><br><span class="line">    optional&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; &gt; opv(v);    </span><br><span class="line">    assert(opv);</span><br><span class="line"></span><br><span class="line">    opv-&gt;push_back(<span class="number">5</span>);      <span class="comment">//箭头操作容器</span></span><br><span class="line">    assert(opv-&gt;size() == <span class="number">11</span>);      </span><br><span class="line"></span><br><span class="line">    opv = none;         <span class="comment">//置为未初始化状态</span></span><br><span class="line">    assert(!opv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="工厂函数-2"><a href="#工厂函数-2" class="headerlink" title="工厂函数"></a>工厂函数</h3><p><img src="/2016/10/22/boost-book/image-138.png" width="500px">  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> x = make_optional(<span class="number">5</span>);</span><br><span class="line">    assert(*x == <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> y = make_optional&lt;<span class="keyword">double</span>&gt;((*x &gt; <span class="number">10</span>), <span class="number">1.0</span>);</span><br><span class="line">    assert(!y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h2><p>为容器初始化或赋值,填入大量数据  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/assign.hpp&gt;</span></span></span><br><span class="line">usng <span class="keyword">namespace</span> boost:assign;</span><br></pre></td></tr></table></figure>
<h3 id="list-inserter"><a href="#list-inserter" class="headerlink" title="list_inserter"></a>list_inserter</h3><p>list_inserter是assign库中用来操作容器的工具类,类似std::back_inserter,但增加了许多操作符重载和助手类简化代码  </p>
<p><img src="/2016/10/22/boost-book/image-139.png" width="500px"><br><img src="/2016/10/22/boost-book/image-140.png" width="500px">  </p>
<h4 id="operator"><a href="#operator" class="headerlink" title="operator+="></a>operator+=</h4><p>由于list_inserter重载了+=操作符和逗号,可以用简洁的语法完成插入  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/assign.hpp&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace boost::assign;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::assign;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v += <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>, <span class="number">6</span>*<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : v)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s;                      <span class="comment">//标准集合容器</span></span><br><span class="line">    s += <span class="string">"c"</span>, <span class="string">"cpp"</span>, <span class="string">"lua"</span>, <span class="string">"swift"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : s)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; ms;                <span class="comment">//标准映射容器</span></span><br><span class="line">    ms += make_pair(<span class="number">1</span>, <span class="string">"one"</span>),make_pair(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="operator-1"><a href="#operator-1" class="headerlink" title="operator()"></a>operator()</h4><p>operator +=仅用于标准容器,在处理map容器显得的麻烦,所以直接用工厂函数insert()/push_front()/push_back(),直接利用他们返回的list_inserter对象填入数据  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::assign;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    push_back(v)(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; l;</span><br><span class="line">    push_front(l)(<span class="string">"c"</span>)(<span class="string">"cpp"</span>)(<span class="string">"lua"</span>)(<span class="string">"swift"</span>);</span><br><span class="line"></span><br><span class="line">    forward_list&lt;<span class="built_in">string</span>&gt; fl;</span><br><span class="line">    push_front(l)(<span class="string">"matrix"</span>)(<span class="string">"reload"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">double</span>&gt; s;</span><br><span class="line">    insert(s)(<span class="number">3.14</span>)(<span class="number">0.618</span>)(<span class="number">1.732</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line">    insert(m)(<span class="number">1</span>, <span class="string">"one"</span>)(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="generic-list"><a href="#generic-list" class="headerlink" title="generic_list"></a>generic_list</h3><p>list_inserter解决了赋值问题,但是有时候需要在构造函数完成数据填充  </p>
<p>这个时候c++11引入了std::initializer_list,而boost.assign库提供功能类似的generic_list  </p>
<p><img src="/2016/10/22/boost-book/image-141.png" width="500px"><br><img src="/2016/10/22/boost-book/image-142.png" width="500px">   </p>
<p>assign 库提供三个工厂函数list_of(),map_list_of()/pair_list_of()和tuple_list_of(),<br>能够产生generic_list对象,然后就可以像list_inserter一样使用operator()和operator来填充数据  </p>
<p>和之前的insert(),push_back()等函数相似  </p>
<p><img src="/2016/10/22/boost-book/image-143.png" width="500px">     </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::assign;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = list_of(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// v = [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; d =</span><br><span class="line">        (list_of(<span class="string">"power"</span>)(<span class="string">"bomb"</span>),<span class="string">"phazon"</span>,<span class="string">"suit"</span>);</span><br><span class="line">    <span class="comment">// d = [power bomb phazon suit]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s = (list_of(<span class="number">10</span>), <span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>);</span><br><span class="line">    <span class="comment">// s = &#123;10 20 30 40 50&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m = list_of(make_pair(<span class="number">1</span>, <span class="string">"one"</span>))(make_pair(<span class="number">2</span>, <span class="string">"two"</span>));</span><br><span class="line">    <span class="comment">// m = [(1, “one”) (2, “two”)]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m1 = map_list_of(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="comment">//m1 = [(1, 2)(3, 4)(5, 6)]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m2 = map_list_of(<span class="number">1</span>, <span class="string">"one"</span>)(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">    <span class="comment">//m2 = [(1, "one")(2, "two")]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="减少重复输入"><a href="#减少重复输入" class="headerlink" title="减少重复输入"></a>减少重复输入</h3><p>list_inserter和generic_list都提供成员函数repeat()、repeat_fun()和range()减轻工作量  </p>
<p><img src="/2016/10/22/boost-book/image-144.png" width="500px">  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::assign;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = list_of(<span class="number">1</span>).repeat(<span class="number">3</span>, <span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//v = 1,2,2,2,3,4,5</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : v)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms ;</span><br><span class="line">    insert(ms).repeat_fun(<span class="number">5</span>, &amp;rand).repeat(<span class="number">2</span>, <span class="number">1</span>), <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//ms = x,x,x,x,x,1,1,10</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : ms)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    push_front(d).range(v.begin(), v.begin() + <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//d = 3,2,2,2,1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : d)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><p>交换两个变量(int等内置数据类型,或类实例、容器)的值提供了便捷方法   </p>
<p>c++98的std::swap()  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">tmp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码上看出std::swap要求交换的对象是可拷贝构造和可拷贝赋值的<br>它提供的最通用同时也效率低,需要进行一次复制构造和两次赋值操作,如果交换对象打,运行代价大  </p>
<p>C++11标准使用了转移语义,对std::swap()进行了优化,避免了拷贝的代价<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp;a, T&amp;b)</span></span>&#123;</span><br><span class="line">    T tmp = <span class="built_in">std</span>::move(a);           <span class="comment">//move语义,把a偷到tmp</span></span><br><span class="line">    a = <span class="built_in">std</span>::move(b);               <span class="comment">//move语义,把b偷到a</span></span><br><span class="line">    b = <span class="built_in">std</span>::move(tmp);             <span class="comment">//move语义,把tmp偷到b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但不是所有类都实现了自己的转移构造和赋值函数,所以自己写的类最好能够实现swap()来提供效率  </p>
<p>解决方案有两种   </p>
<ul>
<li><p>第一种直接利用函数重载,编写一个同名的swap函数,swap在调用内部的高效成员交换函数,这样就不用std::swap函数了  </p>
</li>
<li><p>第二种利用ADL查找模板特化的std::swap   </p>
</li>
</ul>
<p>boost::swap就利用了上面两个方案,查找有无针对类型T的std::swap()特化或通过ADL查找模板特化的swap(),如果有则调用  </p>
<h3 id="交换数组"><a href="#交换数组" class="headerlink" title="交换数组"></a>交换数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/core/swap.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/assign.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::assign;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a1[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> a2[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::fill_n(a1, <span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">std</span>::fill_n(a2, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    boost::swap(a1, a2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果boost::swap交换两个长度不相同的数组,那么无法通过编译  </p>
<h3 id="特化std-swap"><a href="#特化std-swap" class="headerlink" title="特化std::swap"></a>特化std::swap</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit point(int a=0, int b=0, int c=0):x(a),y(b),z(c)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;       <span class="built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="string">","</span>&lt;&lt; y &lt;&lt;<span class="string">","</span>&lt;&lt; z &lt;&lt; <span class="built_in">endl</span>;  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//内置高效交换函数  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(point &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(x, p.x);</span><br><span class="line">        <span class="built_in">std</span>::swap(y, p.y);</span><br><span class="line">        <span class="built_in">std</span>::swap(z, p.z);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"inner swap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//namespace std</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//template&lt;&gt;</span></span><br><span class="line"><span class="comment">//void swap(point &amp;x, point &amp;y)               //模板特化swap函数</span></span><br><span class="line"><span class="comment">//&#123;   x.swap(y);&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> boost &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(point &amp;x, point &amp;y)</span>       <span class="comment">//模板特化swap函数</span></span></span><br><span class="line"><span class="function"></span>&#123;   x.swap(y);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    point a(1,2,3), b(4,5,6);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::swap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::swap(a,b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"boost::swap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    boost::swap(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h2><p>单例模式   </p>
<p><img src="/2016/10/22/boost-book/image-145.png" width="500px"> </p>
<p>singoleton把模板参数T实现为一个单例,对类型T要求是有缺省构造函数,而且析构和构造都不能抛出异常  </p>
<h3 id="用法-16"><a href="#用法-16" class="headerlink" title="用法"></a>用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/serialization/singleton.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> boost::serialization::singleton; </span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span> :</span> <span class="keyword">public</span> singleton&lt;point&gt;           <span class="comment">//继承singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point(<span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>, <span class="keyword">int</span> c=<span class="number">0</span>):x(a),y(b),z(c)</span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt; <span class="string">"point ctor"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">    ~point()</span><br><span class="line">    &#123;   <span class="built_in">cout</span> &lt;&lt; <span class="string">"point dtor"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;       <span class="built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="string">","</span>&lt;&lt; y &lt;&lt;<span class="string">","</span>&lt;&lt; z &lt;&lt; <span class="built_in">endl</span>;  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> singleton&lt;point&gt; origin;            <span class="comment">//单例定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"main() start"</span> &lt;&lt; <span class="built_in">endl</span>;     </span><br><span class="line"></span><br><span class="line">    origin::get_const_instance().print();           <span class="comment">//常对象</span></span><br><span class="line">    origin::get_mutable_instance().print();         <span class="comment">//可变对象</span></span><br><span class="line"></span><br><span class="line">    point::get_const_instance().print();</span><br><span class="line">    point::get_mutable_instance().print();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"main() finish"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2016/10/22/boost-book/';
        this.page.title = 'Boost相关知识点';
        this.page.identifier = '2016/10/22/boost-book/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
