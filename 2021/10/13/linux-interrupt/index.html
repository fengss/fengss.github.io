<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Linux-中断笔记 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="Linux-Interrupt笔记知识详解笔记
中断中断是外围设备通知处理器的一种机制
典型的例子是:网卡从网络收到报文,把报文放到接收环,然后发送中断请求通知处理器,接着处理器响应中断请求,执行中断处理程序,从网卡的接收环取走报文;网卡驱动程序发送报文的时候,把报文放到网卡的发送环,当网卡从发送环取出报文发送的时候,发送中断请求通知处理器发送完成。
中断控制器外围设备不是把中断请求直接发给处理器,而是发给中断控制器,由中断控制器转发给处理器。ARM公司提供了一种标准的中断控制器,称为通用中断控">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java后端</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">Cpp嵌入式</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Go云原生</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">Linux安全</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">Win安全</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">数据与算法</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/work">工作相关</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">文章标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Net/">Net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nosql/">Nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rust/">Rust</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/嵌入式/">嵌入式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">历史归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#中断"><span class="toc-number">1.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#中断控制器"><span class="toc-number">1.1.</span> <span class="toc-text">中断控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断域"><span class="toc-number">1.2.</span> <span class="toc-text">中断域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建中断域"><span class="toc-number">1.2.1.</span> <span class="toc-text">创建中断域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建映射"><span class="toc-number">1.2.2.</span> <span class="toc-text">创建映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找映射"><span class="toc-number">1.2.3.</span> <span class="toc-text">查找映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux中断处理"><span class="toc-number">1.3.</span> <span class="toc-text">Linux中断处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断线程化"><span class="toc-number">1.4.</span> <span class="toc-text">中断线程化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#禁止-开启中断"><span class="toc-number">1.5.</span> <span class="toc-text">禁止/开启中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#禁止-开启单个中断"><span class="toc-number">1.6.</span> <span class="toc-text">禁止/开启单个中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断亲和性"><span class="toc-number">1.7.</span> <span class="toc-text">中断亲和性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理器间中断"><span class="toc-number">1.8.</span> <span class="toc-text">处理器间中断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#中断下半部"><span class="toc-number">2.</span> <span class="toc-text">中断下半部</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#软中断"><span class="toc-number">2.1.</span> <span class="toc-text">软中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#软中断的种类"><span class="toc-number">2.1.1.</span> <span class="toc-text">软中断的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册软中断的处理函数"><span class="toc-number">2.1.2.</span> <span class="toc-text">注册软中断的处理函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#触发软中断"><span class="toc-number">2.1.3.</span> <span class="toc-text">触发软中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行软中断"><span class="toc-number">2.1.4.</span> <span class="toc-text">执行软中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抢占计数器"><span class="toc-number">2.1.5.</span> <span class="toc-text">抢占计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#禁止-开启软中断"><span class="toc-number">2.1.6.</span> <span class="toc-text">禁止/开启软中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tasklet"><span class="toc-number">2.2.</span> <span class="toc-text">tasklet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构"><span class="toc-number">2.2.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编程接口"><span class="toc-number">2.2.2.</span> <span class="toc-text">编程接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#技术原理"><span class="toc-number">2.2.3.</span> <span class="toc-text">技术原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#调度小任务"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">调度小任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行小任务"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">执行小任务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作队列"><span class="toc-number">2.3.</span> <span class="toc-text">工作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编程接口-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">编程接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义工作项"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">定义工作项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全局工作队列"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">全局工作队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#专用工作队列"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">专用工作队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他编程接口"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">其他编程接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#技术原理-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">技术原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据结构-1"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#添加工作项"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">添加工作项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工人处理工作"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">工人处理工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工人池动态管理工人"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">工人池动态管理工人</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#系统调用"><span class="toc-number">3.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义系统调用"><span class="toc-number">3.1.</span> <span class="toc-text">定义系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行系统调用"><span class="toc-number">3.2.</span> <span class="toc-text">执行系统调用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#中断细节"><span class="toc-number">4.</span> <span class="toc-text">中断细节</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#中断的硬件框架"><span class="toc-number">4.1.</span> <span class="toc-text">中断的硬件框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PIC与软件中断号"><span class="toc-number">4.2.</span> <span class="toc-text">PIC与软件中断号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通用的中断处理函数"><span class="toc-number">4.3.</span> <span class="toc-text">通用的中断处理函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do-IRQ函数"><span class="toc-number">4.4.</span> <span class="toc-text">do_IRQ函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#irq-desc"><span class="toc-number">4.4.1.</span> <span class="toc-text">irq_desc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#irq-data"><span class="toc-number">4.4.2.</span> <span class="toc-text">irq_data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kstat-irqs"><span class="toc-number">4.4.3.</span> <span class="toc-text">kstat_irqs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handle-irq"><span class="toc-number">4.4.4.</span> <span class="toc-text">handle_irq</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#action"><span class="toc-number">4.4.5.</span> <span class="toc-text">action</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-irq-chip"><span class="toc-number">4.5.</span> <span class="toc-text">struct irq_chip</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-irqaction"><span class="toc-number">4.6.</span> <span class="toc-text">struct irqaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#irq-set-handler"><span class="toc-number">4.7.</span> <span class="toc-text">irq_set_handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#handle-irq-event"><span class="toc-number">4.8.</span> <span class="toc-text">handle_irq_event</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#request-irq"><span class="toc-number">4.9.</span> <span class="toc-text">request_irq</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#desc-gt-action为空"><span class="toc-number">4.9.1.</span> <span class="toc-text">desc-&gt;action为空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#desc-gt-action不为空"><span class="toc-number">4.9.2.</span> <span class="toc-text">desc-&gt;action不为空</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断处理的irq-thread机制"><span class="toc-number">4.10.</span> <span class="toc-text">中断处理的irq_thread机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#free-irq"><span class="toc-number">4.11.</span> <span class="toc-text">free_irq</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SOFTIRQ"><span class="toc-number">4.12.</span> <span class="toc-text">SOFTIRQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#irq的自动探测"><span class="toc-number">4.13.</span> <span class="toc-text">irq的自动探测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断处理例程"><span class="toc-number">4.14.</span> <span class="toc-text">中断处理例程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断共享"><span class="toc-number">4.15.</span> <span class="toc-text">中断共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">4.16.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#中断下半部细节"><span class="toc-number">5.</span> <span class="toc-text">中断下半部细节</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tasklet-1"><span class="toc-number">5.1.</span> <span class="toc-text">tasklet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tasklet机制初始化"><span class="toc-number">5.1.1.</span> <span class="toc-text">tasklet机制初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提交一个tasklet"><span class="toc-number">5.1.2.</span> <span class="toc-text">提交一个tasklet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tasklet-action"><span class="toc-number">5.1.3.</span> <span class="toc-text">tasklet_action</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tasklet的其他操作"><span class="toc-number">5.1.4.</span> <span class="toc-text">tasklet的其他操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tasklet-enable"><span class="toc-number">5.1.4.1.</span> <span class="toc-text">tasklet_enable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tasklet-kill"><span class="toc-number">5.1.4.2.</span> <span class="toc-text">tasklet_kill</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作队列work-queue"><span class="toc-number">5.2.</span> <span class="toc-text">工作队列work queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构-2"><span class="toc-number">5.2.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#create-singlethread-workqueue和create-workqueue"><span class="toc-number">5.2.2.</span> <span class="toc-text">create_singlethread_workqueue和create_workqueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工人线程worker-thread"><span class="toc-number">5.2.3.</span> <span class="toc-text">工人线程worker_thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#destroy-workqueue"><span class="toc-number">5.2.4.</span> <span class="toc-text">destroy_workqueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提交工作节点queue-work"><span class="toc-number">5.2.5.</span> <span class="toc-text">提交工作节点queue_work</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核创建的工作队列"><span class="toc-number">5.2.6.</span> <span class="toc-text">内核创建的工作队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结-1"><span class="toc-number">5.3.</span> <span class="toc-text">小结</span></a></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
           Linux-中断笔记
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2021/10/13/linux-interrupt/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-10-13T03:46:11.000Z" itemprop="datePublished">2021-10-13</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Linux/">Linux</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>Linux-Interrupt笔记知识详解笔记<br><a id="more"></a></p>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>中断是外围设备通知处理器的一种机制</p>
<p>典型的例子是:网卡从网络收到报文,把报文放到接收环,然后发送中断请求通知处理器,接着处理器响应中断请求,执行中断处理程序,从网卡的接收环取走报文;<br>网卡驱动程序发送报文的时候,把报文放到网卡的发送环,当网卡从发送环取出报文发送的时候,发送中断请求通知处理器发送完成。</p>
<h2 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h2><p>外围设备不是把中断请求直接发给处理器,而是发给中断控制器,由中断控制器转发给处理器。ARM公司提供了一种标准的中断控制器,称为通用中断控制器(Generic Interrupt Controller, GIC)。目前GIC架构规范有4个版本:v1～v4。GIC v2最多支持8个处理器,GIC v3最多支持128个处理器,GIC v3和GIC v4只支持ARM64处理器。</p>
<p>GIC硬件的实现形态有两种。</p>
<ul>
<li>厂商研发自己的ARM处理器,向ARM公司购买GIC的授权,ARM公司提供的GIC型号有:GIC-400、GIC-500和GIC-600。GIC-400遵循GIC v2规范,GIC-500和GIC-600遵循GIC v3规范。</li>
<li>厂商直接向ARM公司购买处理器的授权,这些处理器包含了GIC。</li>
</ul>
<p>从软件的角度看,GIC v2控制器有两个主要的功能块。</p>
<ul>
<li>分发器(Distributor):系统中所有的中断源连接到分发器,分发器的寄存器用来控制单个中断的属性:优先级、状态、安全、转发信息(可以被发送到哪些处理器)和使能状态。分发器决定哪个中断应该通过处理器接口转发到哪个处理器。</li>
<li>处理器接口(CPU Interface):处理器通过处理器接口接收中断。处理器接口提供的寄存器用来屏蔽和识别中断,控制中断的状态。每个处理器有一个单独的处理器接口。</li>
</ul>
<blockquote>
<p>软件通过中断号识别中断,每个中断号唯一对应一个中断源。中断有以下4种类型。</p>
</blockquote>
<ul>
<li>软件生成的中断(Software Generated Interrupt, SGI):中断号0～15,通常用来实现处理器间中断(Inter-Processor Interrupt, IPI)。<br>  这种中断是由软件写分发器的软件生成中断寄存器(GICD_SGIR)生成的。</li>
<li>私有外设中断(Private Peripheral Interrupt, PPI):中断号16～31。<br>  处理器私有的中断源,不同处理器的相同中断源没有关系,比如每个处理器的定时器。</li>
<li>共享外设中断(Shared Peripheral Interrupt, SPI):中断号32～1020。<br>  这种中断可以被中断控制器转发到多个处理器。</li>
<li>局部特定外设中断(Locality-specific Peripheral Interrupt, LPI):基于消息的中断。<br>  GIC v1和GIC v2不支持LPI。</li>
</ul>
<blockquote>
<p>中断可以是边沿触发(edge-triggered),也可以是电平触发(level-triggered)。</p>
</blockquote>
<p>边沿触发是在电压变化的一瞬间触发,电压由高到低变化触发的中断称为下降沿触发,电压由低到高变化触发的中断称为上升沿触发。<br>电平触发是在高电压或低电压保持的时间内触发,低电压触发的中断称为低电平触发,高电压触发的中断称为高电平触发。</p>
<blockquote>
<p>中断有以下4种状态。</p>
</blockquote>
<ul>
<li>Inactive:中断源没有发送中断。</li>
<li>Pending:中断源已经发送中断,等待处理器处理。</li>
<li>Active:处理器已经确认中断,正在处理。</li>
<li>Active and pending:处理器正在处理中断,相同的中断源又发送了一个中断。</li>
</ul>
<blockquote>
<p>中断的状态转换过程如下。</p>
</blockquote>
<ul>
<li>Inactive -&gt; Pending:外围设备发送了中断。</li>
<li>Pending -&gt; Active:处理器确认了中断。</li>
<li>Active -&gt; Inactive:处理器处理完中断。</li>
</ul>
<p>处理器可以通过中断控制器的寄存器访问中断控制器。<br>中断控制器的寄存器和物理内存使用统一的物理地址空间,把寄存器的物理地址映射到内核的虚拟地址空间,可以像访问内存一样访问寄存器。<br>所有处理器可以访问公共的分发器,但是每个处理器使用相同的地址只能访问自己私有的处理器接口</p>
<p>外围设备把中断发送给分发器,如果中断的状态是inactive,那么切换到pending;如果中断的状态已经是active,那么切换到active and pending。<br>分发器取出优先级最高的状态为pending的中断,转发到目标处理器的处理器接口,然后处理器接口把中断发送到处理器。</p>
<p>处理器取出中断,执行中断处理程序,中断处理程序读取处理器接口的中断确认寄存器(Interrupt Acknowledge Register),得到中断号,读取操作导致分发器里面的中断状态切换到active。<br>中断处理程序根据中断号可以知道中断是由哪个设备发出的,从而调用该设备的处理程序。</p>
<p>中断处理程序执行完的时候,把中断号写到处理器接口的中断结束寄存器(End of Interrupt Register)中, 指示中断处理完成,分发器里面的中断状态从active切换到inactive,或者从active and pending切换到pending。</p>
<p>不同种类的中断控制器的访问方法存在差异,为了屏蔽差异,内核定义了中断控制器描述符irq_chip,每种中断控制器自定义各种操作函数。</p>
<blockquote>
<p>GIC v2控制器的描述符如下:</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-01.png" width="500px"></p>
<h2 id="中断域"><a href="#中断域" class="headerlink" title="中断域"></a>中断域</h2><p>一个大型系统可能有多个中断控制器，这些中断控制器可以级联，一个中断控制器作为中断源连接到另一个中断控制器，但只有一个中断控制器作为根控制器直接连接到处理器。<br>为了把每个中断控制器本地的硬件中断号映射到全局唯一的Linux中断号（也称为虚拟中断号），内核定义了中断域irq_domain，每个中断控制器有自己的中断域。</p>
<h3 id="创建中断域"><a href="#创建中断域" class="headerlink" title="创建中断域"></a>创建中断域</h3><p>一个大型系统可能有多个中断控制器，这些中断控制器可以级联，一个中断控制器作为中断源连接到另一个中断控制器，但只有一个中断控制器作为根控制器直接连接到处理器。<br>为了把每个中断控制器本地的硬件中断号映射到全局唯一的Linux中断号（也称为虚拟中断号），内核定义了中断域irq_domain，每个中断控制器有自己的中断域。</p>
<p>中断控制器的驱动程序使用分配函数irq_domain_add_*()创建和注册中断域。每种映射方法提供不同的分配函数，调用者必须给分配函数提供irq_domain_ops结构体，分配函数在执行成功的时候返回irq_domain的指针。</p>
<p>中断域支持以下映射方法。</p>
<ul>
<li>线性映射（linear map）<br>  线性映射维护一个固定大小的表，索引是硬件中断号。<br>  如果硬件中断号的最大数量是固定的，并且比较小（小于256），那么线性映射是好的选择。<br>  对于线性映射，分配中断域的函数如下<br>  <img src="/2021/10/13/linux-interrupt/image-02.png" width="500px"></li>
<li>树映射（tree map）。<br>  树映射使用基数树（radix tree）保存硬件中断号到Linux中断号的映射。<br>  如果硬件中断号可能非常大，那么树映射是好的选择，因为不需要根据最大硬件中断号分配一个很大的表。<br>  对于树映射，分配中断域的函数如下<br>  <img src="/2021/10/13/linux-interrupt/image-03.png" width="500px"></li>
<li>不映射（no map）<br>  有些中断控制器很强，硬件中断号是可以配置的，例如PowerPC架构使用的MPIC （Multi-Processor Interrupt Controller）。<br>  我们直接把Linux中断号写到硬件，硬件中断号就是Linux中断号，不需要映射。<br>  对于不映射，分配中断域的函数如下<br>  <img src="/2021/10/13/linux-interrupt/image-04.png" width="500px"><br>  分配函数把主要工作委托给函数<strong>irq_domain_add()。<br>  函数</strong>irq_domain_add()的执行过程是：分配一个irq_domain结构体，初始化成员，然后把中断域添加到全局链表irq_domain_list中。</li>
</ul>
<h3 id="创建映射"><a href="#创建映射" class="headerlink" title="创建映射"></a>创建映射</h3><p>创建中断域以后，需要向中断域添加硬件中断号到Linux中断号的映射，内核提供了函数irq_create_mapping</p>
<p><img src="/2021/10/13/linux-interrupt/image-05.png" width="500px"></p>
<p>输入参数是中断域和硬件中断号，返回Linux中断号。<br>该函数首先分配Linux中断号，然后把硬件中断号到Linux中断号的映射添加到中断域。</p>
<h3 id="查找映射"><a href="#查找映射" class="headerlink" title="查找映射"></a>查找映射</h3><p>中断处理程序需要根据硬件中断号查找Linux中断号，内核提供了函数irq_find_mapping</p>
<p><img src="/2021/10/13/linux-interrupt/image-06.png" width="500px"></p>
<p>输入参数是中断域和硬件中断号，返回Linux中断号。</p>
<h2 id="Linux中断处理"><a href="#Linux中断处理" class="headerlink" title="Linux中断处理"></a>Linux中断处理</h2><p>对于中断控制器的每个中断源，向中断域添加硬件中断号到Linux中断号的映射时，内核分配一个Linux中断号和一个中断描述符irq_desc，如图所示，中断描述符有两个层次的中断处理函数。</p>
<p><img src="/2021/10/13/linux-interrupt/image-07.png" width="500px"></p>
<ul>
<li>第一层处理函数是中断描述符的成员handle_irq()。</li>
<li>第二层处理函数是设备驱动程序注册的处理函数。中断描述符有一个中断处理链表（irq_desc.action），每个中断处理描述符（irq_action）保存设备驱动程序注册的处理函数。因为多个设备可以共享同一个硬件中断号，所以中断处理链表可能挂载多个中断处理描述符。</li>
</ul>
<blockquote>
<p>怎么存储Linux中断号到中断描述符的映射关系？有两种实现方式。</p>
</blockquote>
<ul>
<li>如果中断编号是稀疏的（即不连续），那么使用基数树（radix tree）存储。需要开启配置宏CONFIG_SPARSE_IRQ。</li>
<li>如果中断编号是连续的，那么使用数组存储。</li>
</ul>
<p><img src="/2021/10/13/linux-interrupt/image-08.png" width="500px"></p>
<blockquote>
<p>ARM64架构默认开启配置宏CONFIG_SPARSE_IRQ，使用基数树存储。</p>
</blockquote>
<p>把硬件中断号映射到Linux中断号的时候，根据硬件中断的类型设置中断描述符的成员handle_irq()，以GIC v2控制器为例，函数gic_irq_domain_map所做的处理如下所示。</p>
<ul>
<li>如果硬件中断号小于32，说明是软件生成的中断或私有外设中断，那么把中断描述符的成员handle_irq()设置为函数handle_percpu_devid_irq。</li>
<li>如果硬件中断号大于或等于32，说明是共享外设中断，那么把中断描述符的成员handle_irq()设置为函数handle_fasteoi_irq。</li>
</ul>
<p><img src="/2021/10/13/linux-interrupt/image-09.png" width="700px"></p>
<blockquote>
<p>设备驱动程序可以使用函数request_irq()注册中断处理函数：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *dev)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数irq是Linux中断号。</li>
<li>参数handler是处理函数。</li>
<li>参数fags是标志位，可以是0或者以下标志位的组合。<ul>
<li>IRQF_SHARED：允许多个设备共享同一个中断号。</li>
<li><code>__IRQF_TIMER</code>：定时器中断。</li>
<li>IRQF_PERCPU：中断是每个处理器私有的。</li>
<li>IRQF_NOBALANCING：不允许该中断在处理器之间负载均衡。</li>
<li>IRQF_NO_THREAD：中断不能线程化。</li>
</ul>
</li>
<li>参数name是设备名称。</li>
<li>参数dev是传给处理函数（由参数handler指定）的参数。</li>
</ul>
<blockquote>
<p>在ARM64架构下，在异常级别1的异常向量表中，中断的入口有3个。</p>
</blockquote>
<ul>
<li>如果处理器处在内核模式（异常级别1），中断的入口是el1_irq。</li>
<li>如果处理器正在用户模式（异常级别0）下执行64位应用程序，中断的入口是el0_irq。</li>
<li>如果处理器正在用户模式（异常级别0）下执行32位应用程序，中断的入口是el0_irq_compat。</li>
</ul>
<p>假设处理器正在用户模式（异常级别0）下执行64位应用程序，中断控制器是GIC v2控制器，Linux中断处理流程如图所示</p>
<p><img src="/2021/10/13/linux-interrupt/image-10.png" width="600px"></p>
<ul>
<li>读取处理器接口的中断确认寄存器得到中断号，分发器里面的中断状态切换到active。</li>
<li>如果硬件中断号大于15且小于1020，即中断是由外围设备发送的，处理如下。<ul>
<li>把中断号写到处理器接口的中断结束寄存器中，指示中断处理完成，分发器里面的中断状态从active切换到inactive，或者从active and pending切换到pending。</li>
<li>调用函数irq_enter()，进入中断上下文。</li>
<li>调用函数irq_find_mapping()，根据硬件中断号查找Linux中断号。</li>
<li>调用中断描述符的成员handle_irq()。</li>
<li>调用函数irq_exit()，退出中断上下文。</li>
</ul>
</li>
<li>如果硬件中断号小于16，即中断是由软件生成的，处理如下。<ul>
<li>把中断号写到处理器接口的中断结束寄存器中，指示中断处理完成。</li>
<li>调用函数handle_IPI()进行处理。</li>
</ul>
</li>
</ul>
<blockquote>
<p>函数el0_irq的代码如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-11.png" width="500px"></p>
<ul>
<li>把进程的寄存器值保存到内核栈。</li>
<li>开启调试异常。</li>
<li><p>irq_handler是一个宏，执行过程如下。</p>
<ul>
<li>从进程的内核栈切换到中断栈。每个处理器有一个专用的中断栈：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arch/arm64/kerne1/ irq. c</span><br><span class="line">DEFINE_PER_CPU(<span class="keyword">unsigned</span> <span class="number">1</span>ong [IRQ_STACK_SIZE/<span class="keyword">sizeof</span> (<span class="number">1</span>ong)]，irg_stack)__aligned(<span class="number">16</span>) ;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>调用函数指针handle_arch_irq指向的函数。中断控制器在内核初始化的时候设置函数指针handle_arch_irq, GIC v2控制器把该函数指针设置为函数gic_handle_irq。</p>
</li>
<li>从中断栈切换到进程的内核栈。</li>
<li>使用内核栈保存的寄存器值恢复进程的寄存器，返回用户模式。</li>
</ul>
<blockquote>
<p>GIC v2控制器的函数gic_handle_irq的代码如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-12.png" width="500px"></p>
<p>如果是私有外设中断，那么中断描述符的成员handle_irq()是函数handle_percpu_devid_irq，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-13.png" width="500px"></p>
<p>如果是共享外设中断，那么中断描述符的成员handle_irq()是函数handle_fasteoi_irq，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-14.png" width="500px"></p>
<p>调用函数handle_irq_event，执行设备驱动程序注册的处理函数。<br>函数handle_irq_event把主要工作委托给函数<code>__handle_irq_event_percpu</code>。<br>函数<code>__handle_irq_event_percpu</code>遍历中断描述符的中断处理链表，执行每个中断处理描述符的处理函数，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-15.png" width="500px"></p>
<h2 id="中断线程化"><a href="#中断线程化" class="headerlink" title="中断线程化"></a>中断线程化</h2><p>中断线程化就是使用内核线程处理中断，目的是减少系统关中断的时间，增强系统的实时性。<br>内核提供的函数request_threaded_irq()用来注册线程化的中断</p>
<p><img src="/2021/10/13/linux-interrupt/image-16.png" width="600px"></p>
<p>参数thread_fn是线程处理函数。<br>少数中断不能线程化，典型的例子是时钟中断，有些流氓进程不主动让出处理器，内核只能依靠周期性的时钟中断夺回处理器的控制权，时钟中断是调度器的脉搏。<br>对于不能线程化的中断，注册处理函数的时候必须设置标志<code>IRQF_NO_THREAD</code>。<br>如果开启了强制中断线程化的配置宏<code>CONFIG_IRQ_FORCED_THREADING</code>，并且在引导内核的时候指定内核参数<code>“threadirqs”</code>，那么强制除了标记<code>IRQF_NO_THREAD</code>以外的所有中断线程化。<br>ARM64架构默认开启配置宏<code>CONFIG_IRQ_FORCED_THREADING</code>。</p>
<p>每个中断处理描述符（irqaction）对应一个内核线程，成员thread指向内核线程的进程描述符，成员thread_fn指向线程处理函数，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-17.png" width="400px"></p>
<p>可以看到，中断处理线程是优先级为50、调度策略是SCHED_FIFO的实时内核线程，名称是“irq/”后面跟着Linux中断号，线程处理函数是irq_thread()。</p>
<p><img src="/2021/10/13/linux-interrupt/image-18.png" width="600px"></p>
<p>在中断处理程序中，函数__handle_irq_event_percpu遍历中断描述符的中断处理链表，执行每个中断处理描述符的处理函数。<br>如果处理函数返回IRQ_WAKE_THREAD，说明是线程化的中断，那么唤醒中断处理线程。</p>
<p><img src="/2021/10/13/linux-interrupt/image-19.png" width="600px"></p>
<p>中断处理线程的处理函数是irq_thread()，调用函数irq_thread_fn()，然后函数irq_thread_fn()调用注册的线程处理函数。</p>
<p><img src="/2021/10/13/linux-interrupt/image-20.png" width="600px"></p>
<h2 id="禁止-开启中断"><a href="#禁止-开启中断" class="headerlink" title="禁止/开启中断"></a>禁止/开启中断</h2><p>软件可以禁止中断，使处理器不响应所有中断请求，但是不可屏蔽中断（Non Maskable Interrupt,NMI）是个例外。</p>
<blockquote>
<p>禁止中断的接口如下</p>
</blockquote>
<ul>
<li>local_irq_disable()。</li>
<li>local_irq_save(fags)：首先把中断状态保存在参数fags中，然后禁止中断。</li>
</ul>
<p>这两个接口只能禁止本处理器的中断，不能禁止其他处理器的中断。禁止中断以后，处理器不会响应中断请求。</p>
<blockquote>
<p>开启中断的接口如下</p>
</blockquote>
<ul>
<li>local_irq_enable()。</li>
<li>local_irq_restore(fags)：恢复本处理器的中断状态。local_irq_disable()和local_irq_enable()不能嵌套使用，local_irq_save(fags)和local_irq_restore(fags)可以嵌套使用。</li>
</ul>
<blockquote>
<p>ARM64架构禁止中断的函数local_irq_disable()如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-21.png" width="600px"></p>
<p>把处理器状态的中断掩码位设置成1，从此以后处理器不会响应中断请求。<br>ARM64架构开启中断的函数local_irq_enable()如下：</p>
<p><img src="/2021/10/13/linux-interrupt/image-22.png" width="600px"></p>
<p>把处理器状态的中断掩码位设置成0</p>
<h2 id="禁止-开启单个中断"><a href="#禁止-开启单个中断" class="headerlink" title="禁止/开启单个中断"></a>禁止/开启单个中断</h2><p>软件可以禁止某个外围设备的中断，中断控制器不会把该设备发送的中断转发给处理器。</p>
<blockquote>
<p>禁止单个中断的函数是</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disable_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数irq是Linux中断号。</p>
<blockquote>
<p>开启单个中断的函数是</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数irq是Linux中断号。</p>
<p>对于ARM64架构的GIC控制器，如果需要开启硬件中断n，那么设置分发器的寄存器GICD_ISENABLERn（Interrupt Set-Enable Register）；<br>如果需要禁止硬件中断n，那么设置分发器的寄存器GICD_ICENABLERn（Interrupt Clear-Enable Register）。</p>
<p>假设某个外围设备的硬件中断号是n，当这个外围设备发送中断给分发器的时候，只有在分发器上开启了硬件中断n，分发器才会把硬件中断n转发给处理器。</p>
<h2 id="中断亲和性"><a href="#中断亲和性" class="headerlink" title="中断亲和性"></a>中断亲和性</h2><p>在多处理器系统中，管理员可以设置中断亲和性，允许中断控制器把某个中断转发给哪些处理器，有两种配置方法。</p>
<ul>
<li>写文件“/proc/irq/IRQ#/smp_affinity”，参数是位掩码。</li>
<li>写文件“/proc/irq/IRQ#/smp_affinity_list”，参数是处理器列表。</li>
</ul>
<p>例如，管理员想要配置允许中断控制器把Linux中断号为32的中断转发给处理器0～3，配置方法有两种。</p>
<ul>
<li><code>echo 0f &gt; /proc/irq/32/smp_affinity</code></li>
<li><code>echo 0-3 &gt; /proc/irq/32/smp_affinity_list</code></li>
</ul>
<p>配置完以后，可以连续执行命令<code>“cat /proc/interrupts | grep &#39;CPU\|32:&#39;”</code>，观察是否只有处理器0～3收到了Linux中断号为32的中断。</p>
<p>内核提供了设置中断亲和性的函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">irq_set_affinity</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">const</span> struct cpumask *cpumask)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>参数irq是Linux中断号，参数cpumask是处理器位掩码。</p>
<p>对于ARM64架构的GIC控制器，可以设置分发器的寄存器GICD_ITARGETSRn（中断目标寄存器，Interrupt Targets Register）允许把硬件中断n转发到哪些处理器，硬件中断n必须是共享外设中断。</p>
<h2 id="处理器间中断"><a href="#处理器间中断" class="headerlink" title="处理器间中断"></a>处理器间中断</h2><p>处理器间中断（Inter-Processor Interrupt, IPI）是一种特殊的中断，在多处理器系统中，一个处理器可以向其他处理器发送中断，要求目标处理器执行某件事情。常见的使用处理器间中断的函数如下。</p>
<ul>
<li>在所有其他处理器上执行一个函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smp_call_function</span><span class="params">(<span class="keyword">smp_call_func_t</span> func, <span class="keyword">void</span> *info, <span class="keyword">int</span> wait)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数func是要执行的函数，目标处理器在中断处理程序中执行该函数；<br>参数info是传给函数func的参数；参数wait表示是否需要等待目标处理器执行完函数。</p>
<ul>
<li>在指定的处理器上执行一个函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smp_call_function_single</span><span class="params">(<span class="keyword">int</span> cpu, <span class="keyword">smp_call_func_t</span> func, <span class="keyword">void</span> *info, <span class="keyword">int</span> wait)</span></span>;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- 要求指定的处理器重新调度进程</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">smp_send_reschedule</span><span class="params">(<span class="keyword">int</span> cpu)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于ARM64架构的GIC控制器，把处理器间中断称为软件生成的中断，可以写分发器的寄存器GICD_SGIR（软件生成中断寄存器，Software Generated Interrupt Register）以生成处理器间中断。</p>
<p>假设处理器正在用户模式（异常级别0）下执行64位应用程序，中断控制器是GIC v2控制器，处理处理器间中断的执行流程如图所示。</p>
<p><img src="/2021/10/13/linux-interrupt/image-23.png" width="400px"></p>
<p>函数handle_IPI负责处理处理器间中断，参数ipinr是硬件中断号，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-24.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-25.png" width="600px"></p>
<p>目前支持7种处理器间中断。</p>
<ul>
<li>IPI_RESCHEDULE：硬件中断号是0，重新调度进程，函数smp_send_reschedule()生成的中断。</li>
<li>IPI_CALL_FUNC：硬件中断号是1，执行函数，函数smp_call_function()生成的中断。</li>
<li>IPI_CPU_STOP：硬件中断号是2，使处理器停止，函数smp_send_stop()生成的中断。</li>
<li>IPI_CPU_CRASH_STOP：硬件中断号是3，使处理器停止，函数smp_send_crash_stop()生成的中断。</li>
<li>IPI_TIMER：硬件中断号是4，广播的时钟事件，函数tick_broadcast()生成的中断。</li>
<li>IPI_IRQ_WORK：硬件中断号是5，在硬中断上下文中执行回调函数，函数irq_work_queue()生成的中断。</li>
<li>IPI_WAKEUP：硬件中断号是6，唤醒处理器，函数acpi_parking_protocol_cpu_boot()生成的中断。</li>
</ul>
<p><br><br><br></p>
<hr>

<h1 id="中断下半部"><a href="#中断下半部" class="headerlink" title="中断下半部"></a>中断下半部</h1><p>为了避免处理复杂的中断嵌套，中断处理程序是在关闭中断的情况下执行的。可是，如果关闭中断的时间太长，可能导致中断请求丢失。例如周期时钟每隔10毫秒发送一个中断请求，如果执行某个中断处理程序花费的时间超过10毫秒，在这段时间里时钟发送了两个中断请求，但是处理器只认为收到一个时钟中断请求。</p>
<p>最激进的解决办法是中断线程化，但是常用的解决办法是：把中断处理程序分为两部分，上半部（top half, th）在关闭中断的情况下执行，只做对时间非常敏感、与硬件相关或者不能被其他中断打断的工作；下半部（bottom half, bh）在开启中断的情况下执行，可以被其他中断打断。</p>
<blockquote>
<p>上半部称为硬中断（hardirq），下半部有3种：软中断（softirq）、小任务（tasklet）和工作队列（workqueue）。3种下半部的区别如下。</p>
</blockquote>
<ul>
<li>软中断和小任务不允许睡眠；工作队列是使用内核线程实现的，处理函数可以睡眠。</li>
<li>软中断的种类是编译时静态定义的，在运行时不能添加或删除；小任务可以在运行时添加或删除。</li>
<li>同一种软中断的处理函数可以在多个处理器上同时执行，处理函数必须是可以重入的，需要使用锁保护临界区；一个小任务同一时刻只能在一个处理器上执行，不要求处理函数是可以重入的。</li>
</ul>
<h2 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h2><p>软中断（softirq）是中断处理程序在开启中断的情况下执行的部分，可以被硬中断抢占。<br>内核定义了一张软中断向量表，每种软中断有一个唯一的编号，对应一个softirq_action实例，softirq_action实例的成员action是处理函数。</p>
<p><img src="/2021/10/13/linux-interrupt/image-26.png" width="600px"></p>
<h3 id="软中断的种类"><a href="#软中断的种类" class="headerlink" title="软中断的种类"></a>软中断的种类</h3><p>目前内核定义了10种软中断，各种软中断的编号如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-27.png" width="600px"></p>
<ul>
<li>HI_SOFTIRQ：高优先级的小任务。</li>
<li>TIMER_SOFTIRQ：定时器软中断。</li>
<li>NET_TX_SOFTIRQ：网络栈发送报文的软中断。</li>
<li>NET_RX_SOFTIRQ：网络栈接收报文的软中断。</li>
<li>BLOCK_SOFTIRQ：块设备软中断。</li>
<li>IRQ_POLL_SOFTIRQ：支持I/O轮询的块设备软中断。</li>
<li>TASKLET_SOFTIRQ：低优先级的小任务。</li>
<li>SCHED_SOFTIRQ：调度软中断，用于在处理器之间负载均衡。</li>
<li>HRTIMER_SOFTIRQ：高精度定时器，这种软中断已经被废弃，目前在中断处理程序的上半部处理高精度定时器。</li>
<li>RCU_SOFTIRQ:RCU软中断。</li>
</ul>
<p>软中断的编号形成了优先级顺序，编号小的软中断优先级高。</p>
<h3 id="注册软中断的处理函数"><a href="#注册软中断的处理函数" class="headerlink" title="注册软中断的处理函数"></a>注册软中断的处理函数</h3><p>函数open_softirq()用来注册软中断的处理函数，在软中断向量表中为指定的软中断编号设置处理函数。</p>
<p><img src="/2021/10/13/linux-interrupt/image-28.png" width="600px"></p>
<p>同一种软中断的处理函数可以在多个处理器上同时执行，处理函数必须是可以重入的，需要使用锁保护临界区。</p>
<h3 id="触发软中断"><a href="#触发软中断" class="headerlink" title="触发软中断"></a>触发软中断</h3><p>函数raise_softirq用来触发软中断，参数是软中断编号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_softirq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在已经禁止中断的情况下可以调用函数raise_softirq_irqoff来触发软中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_softirq_irqoff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数raise_softirq在当前处理器的待处理软中断位图中为指定的软中断编号设置对应的位，如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">raise_softirq()-&gt;raise_softirq_irqoff()-&gt;__raise_softirq_irqoff()</span><br><span class="line">kernel/softirq.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __raise_softirq_irqoff(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span><br><span class="line">&#123;</span><br><span class="line">	or_softirq_pending(<span class="number">1U</span>L &lt;&lt; nr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把宏or_softirq_pending展开以后是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irq_stat[smp_processor_id()].__softirq_pending |= (<span class="number">1U</span>L &lt;&lt; nr);</span><br></pre></td></tr></table></figure>
<h3 id="执行软中断"><a href="#执行软中断" class="headerlink" title="执行软中断"></a>执行软中断</h3><p>内核执行软中断的地方如下。</p>
<ul>
<li>在中断处理程序的后半部分执行软中断，对执行时间有限制：不能超过2毫秒，并且最多执行10次。</li>
<li>每个处理器有一个软中断线程，调度策略是SCHED_NORMAL，优先级是120。</li>
<li>开启软中断的函数local_bh_enable()。</li>
</ul>
<p>如果开启了强制中断线程化的配置宏CONFIG_IRQ_FORCED_THREADING，并且在引导内核的时候指定内核参数“threadirqs”，那么所有软中断由软中断线程执行。</p>
<blockquote>
<p>中断处理程序执行软中断</p>
</blockquote>
<p>在中断处理程序的后半部分，调用函数irq_exit()以退出中断上下文，处理软中断，其代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kernel/softirq.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">irq_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	preempt_count_sub(HARDIRQ_OFFSET);</span><br><span class="line">	<span class="keyword">if</span>(!in_interrupt() &amp;&amp; local_softirq_pending())&#123;</span><br><span class="line">		invoke_softirq();</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果in_interrupt()为真，表示在不可屏蔽中断、硬中断或软中断上下文，或者禁止软中断。<br>如果正在处理的硬中断没有抢占正在执行的软中断，没有禁止软中断，并且当前处理器的待处理软中断位图不是空的，那么调用函数invoke_softirq()来处理软中断。</p>
<p>函数invoke_softirq的代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kernel/softirq.c</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">invoke_softirq</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ksoftirqd_running())&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!force_irqthreads)&#123;</span><br><span class="line">		__do_softirq();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		wakeup_softirqd();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果软中断线程处于就绪状态或运行状态，那么让软中断线程执行软中断。</li>
<li>如果没有强制中断线程化，那么调用函数__do_softirq()执行软中断。</li>
<li>如果强制中断线程化，那么唤醒软中断线程执行软中断。</li>
</ul>
<p>函数__do_softirq是执行软中断的核心函数，其主要代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-29.png" width="600px"></p>
<p><img src="/2021/10/13/linux-interrupt/image-30.png" width="600px"></p>
<ul>
<li>把抢占计数器的软中断计数加1。第20行代码，把当前处理器的待处理软中断位图重新设置为0。</li>
<li>开启硬中断。</li>
<li>从低位向高位扫描待处理软中断位图，针对每个设置了对应位的软中断编号，执行软中断的处理函数。</li>
<li>禁止硬中断。</li>
<li>如果软中断的处理函数又触发软中断，处理如下。<ul>
<li>如果软中断的执行时间小于2毫秒，不需要重新调度进程，并且软中断的执行次数没超过10，那么跳转到第19行代码继续执行软中断。</li>
<li>唤醒软中断线程执行软中断。</li>
</ul>
</li>
<li>把抢占计数器的软中断计数减1。</li>
</ul>
<blockquote>
<p>软中断线程</p>
</blockquote>
<p>每个处理器有一个软中断线程，名称是<code>“ksoftirqd/”</code>后面跟着处理器编号，调度策略是SCHED_NORMAL，优先级是120。<br>软中断线程的核心函数是run_ksoftirqd()，其代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kernel/softirq.c</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run_ksoftirqd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	local_irq_disabled();</span><br><span class="line">	<span class="keyword">if</span>(local_softirq_pending())&#123;</span><br><span class="line">		__do_softirq();</span><br><span class="line">		local_irq_enable();</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	local_irq_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>开启软中断时执行软中断</p>
</blockquote>
<p>当进程调用函数local_bh_enable()开启软中断的时候，如果是开启最外层的软中断，并且当前处理器的待处理软中断位图不是空的，那么执行软中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">local_bh_enable() -&gt; __local_bh_enable_ip()</span><br><span class="line">kernel/softirq.c</span><br><span class="line"><span class="keyword">void</span> __local_bh_enable_ip(<span class="keyword">unsigned</span> <span class="keyword">long</span> ip, <span class="keyword">unsigned</span> <span class="keyword">int</span> cnt)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	preempt_count_sub(cnt - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(unlikely(!in_interrupt() &amp;&amp; local_softirq_pending()))&#123;</span><br><span class="line">		do_softirq();</span><br><span class="line">	&#125;</span><br><span class="line">	preempt_count_dec();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抢占计数器"><a href="#抢占计数器" class="headerlink" title="抢占计数器"></a>抢占计数器</h3><p>在介绍“禁止/开启软中断”之前，首先了解一下抢占计数器这个背景知识。每个进程的thread_info结构体有一个抢占计数器：int preempt_count，它用来表示当前进程能不能被抢占。<br>抢占是指当进程在内核模式下运行的时候可以被其他进程抢占，如果优先级更高的进程处于就绪状态，强行剥夺当前进程的处理器使用权。<br>但是有时候进程可能在执行一些关键操作，不能被抢占，所以内核设计了抢占计数器。如果抢占计数器为0，表示可以被抢占；如果抢占计数器不为0，表示不能被抢占。<br>当中断处理程序返回的时候，如果进程在被打断的时候正在内核模式下执行，就会检查抢占计数器是否为0。如果抢占计数器是0，可以让优先级更高的进程抢占当前进程。</p>
<p>虽然抢占计数器不为0意味着禁止抢占，但是内核进一步按照各种场景对抢占计数器的位进行了划分，如图所示。</p>
<p><img src="/2021/10/13/linux-interrupt/image-31.png" width="600px"></p>
<p>其中第0～7位是抢占计数，第8～15位是软中断计数，第16～19位是硬中断计数，第20位是不可屏蔽中断（Non Maskable Interrupt, NMI）计数</p>
<p><img src="/2021/10/13/linux-interrupt/image-32.png" width="600px"></p>
<p>各种场景分别利用各自的位禁止或开启抢占。</p>
<ul>
<li>普通场景（PREEMPT_MASK）：对应函数<code>preempt_disable()</code>和<code>preempt_enable()</code>。</li>
<li>软中断场景（SOFTIRQ_MASK）：对应函数<code>local_bh_disable()</code>和<code>local_bh_enable()</code>。</li>
<li>硬中断场景（HARDIRQ_MASK）：对应函数 <code>__irq_enter()</code>和<code>__irq_exit()</code>。</li>
<li>不可屏蔽中断场景（NMI_MASK）：对应函数<code>nmi_enter()</code>和<code>nmi_exit()</code>。</li>
</ul>
<p>反过来，我们可以通过抢占计数器的值判断当前处在什么场景</p>
<p><img src="/2021/10/13/linux-interrupt/image-33.png" width="600px"></p>
<p>in_irq()表示硬中断场景，也就是正在执行硬中断。<br>in_softirq()表示软中断场景，包括禁止软中断和正在执行软中断。<br>in_interrupt()表示正在执行不可屏蔽中断、硬中断或软中断，或者禁止软中断。<br>in_serving_softirq()表示正在执行软中断。<br>in_nmi()表示不可屏蔽中断场景。<br>in_task()表示普通场景，也就是进程上下文。</p>
<h3 id="禁止-开启软中断"><a href="#禁止-开启软中断" class="headerlink" title="禁止/开启软中断"></a>禁止/开启软中断</h3><p>如果进程和软中断可能访问同一个对象，那么进程和软中断需要互斥，进程需要禁止软中断。<br>禁止软中断的函数是local_bh_disable()，注意：这个函数只能禁止本处理器的软中断，不能禁止其他处理器的软中断。</p>
<p>该函数把抢占计数器的软中断计数加2，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-34.png" width="600px"></p>
<p>开启软中断的函数是local_bh_enable()，该函数把抢占计数器的软中断计数减2。</p>
<blockquote>
<p>为什么禁止软中断的函数local_bh_disable()把抢占计数器的软中断计数加2，而不是加1呢？</p>
</blockquote>
<p>目的是区分禁止软中断和正在执行软中断这两种情况。<br>执行软中断的函数__do_softirq()把抢占计数器的软中断计数加1。<br>如果软中断计数是奇数，可以确定正在执行软中断。</p>
<h2 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h2><p>tasklet是基于软中断实现的。</p>
<blockquote>
<p>为什么要提供小任务(tasklet)？</p>
</blockquote>
<p>因为小任务相对软中断有以下优势。</p>
<ul>
<li>软中断的种类是编译时静态定义的，在运行时不能添加或删除；小任务可以在运行时添加或删除。</li>
<li>同一种软中断的处理函数可以在多个处理器上同时执行，处理函数必须是可以重入的，需要使用锁保护临界区；<br>  一个小任务同一时刻只能在一个处理器上执行，不要求处理函数是可以重入的。<br>  小任务根据优先级分为两种：低优先级小任务和高优先级小任务。</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><blockquote>
<p>小任务的数据结构如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-35.png" width="600px"></p>
<p>成员next用来把小任务添加到单向链表中。成员state是小任务的状态，取值如下。</p>
<ul>
<li>0：小任务没有被调度。</li>
<li>(1 &lt;&lt; TASKLET_STATE_SCHED)：小任务被调度，即将被执行。</li>
<li>(1 &lt;&lt; TASKLET_STATE_RUN)：只在多处理器系统中使用，表示小任务正在执行。</li>
</ul>
<p>成员count是计数，0表示允许小任务被执行，非零值表示禁止小任务被执行。<br>成员func是处理函数，成员data是传给处理函数的参数。</p>
<blockquote>
<p>每个处理器有两条单向链表：低优先级小任务链表和高优先级小任务链表。</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-36.png" width="600px"></p>
<h3 id="编程接口"><a href="#编程接口" class="headerlink" title="编程接口"></a>编程接口</h3><p>定义一个静态的小任务，并且允许小任务被执行，方法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_TASKLET(name, func, data);</span><br></pre></td></tr></table></figure>
<p>定义一个静态的小任务，并且禁止小任务被执行，方法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_TASKLET_DISABLED(name, func, data);</span><br></pre></td></tr></table></figure>
<p>在运行时动态初始化小任务，并且允许小任务被执行，方法如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void tasklet_init(struct tasklet_struct *t, void(*func)(unsigned long), unsigned long data);</span><br></pre></td></tr></table></figure>
<p>函数tasklet_disable()用来禁止小任务被执行，如果小任务正在被执行，该函数等待小任务执行完。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_disable</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数tasklet_disable_nosync()用来禁止小任务被执行，如果小任务正在被执行，该函数不会等待小任务执行完。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_disable_nosync</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数tasklet_enable()用来允许小任务被执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_enable</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数tasklet_schedule()用来调度低优先级小任务：把小任务添加到当前处理器的低优先级小任务链表中，并且触发低优先级小任务软中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_schedule</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数tasklet_hi_schedule()用来调度高优先级小任务：把小任务添加到当前处理器的高优先级小任务链表的尾部，并且触发高优先级小任务软中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_hi_schedule</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数tasklet_hi_schedule_first()用来调度高优先级小任务：把小任务添加到当前处理器的高优先级小任务链表的首部，并且触发高优先级小任务软中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_hi_schedule_first</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数tasklet_kill()用来杀死小任务，确保小任务不会被调度和执行。如果小任务正在被执行，该函数等待小任务执行完。通常在卸载内核模块的时候调用该函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_kill</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h3><p>小任务是基于软中断实现的，根据优先级分为两种：低优先级小任务和高优先级小任务。软中断HI_SOFTIRQ执行高优先级小任务，软中断TASKLET_SOFTIRQ执行低优先级小任务。</p>
<h4 id="调度小任务"><a href="#调度小任务" class="headerlink" title="调度小任务"></a>调度小任务</h4><p>函数tasklet_schedule()用来调度低优先级小任务，函数tasklet_hi_schedule()用来调度高优先级小任务。<br>以函数tasklet_schedule()为例说明，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-37.png" width="600px"></p>
<p>如果小任务没有被调度过，那么首先设置调度标志位，然后把小任务添加到当前处理器的低优先级小任务链表的尾部，最后触发软中断TASKLET_SOFTIRQ。</p>
<h4 id="执行小任务"><a href="#执行小任务" class="headerlink" title="执行小任务"></a>执行小任务</h4><p>初始化的时候，把软中断TASKLET_SOFTIRQ的处理函数注册为函数tasklet_action，把软中断HI_SOFTIRQ的处理函数注册为函数tasklet_hi_action</p>
<p><img src="/2021/10/13/linux-interrupt/image-38.png" width="500px"></p>
<p>以函数tasklet_action()为例说明，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-39.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-40.png" width="600px"></p>
<ul>
<li>把当前处理器的低优先级小任务链表中的所有小任务移到临时链表list中。</li>
<li>遍历临时链表list，依次处理每个小任务，如下。<ul>
<li>尝试锁住小任务，确保一个小任务同一时刻只在一个处理器上执行。</li>
<li>如果小任务的计数为0，表示允许小任务被执行。</li>
<li>清除小任务的调度标志位，其他处理器可以调度这个小任务，但是不能执行这个小任务。</li>
<li>执行小任务的处理函数。</li>
<li>释放小任务的锁，其他处理器就可以执行这个小任务了。</li>
<li>如果尝试锁住小任务失败（表示小任务正在其他处理器上执行），或者禁止小任务被执行，那么把小任务重新添加到当前处理器的低优先级小任务链表的尾部，然后触发软中断TASKLET_SOFTIRQ。</li>
</ul>
</li>
</ul>
<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p>工作队列（work queue）是使用内核线程异步执行函数的通用机制。</p>
<p>工作队列是中断处理程序的一种下半部机制，中断处理程序可以把耗时比较长并且可能睡眠的函数交给工作队列执行。<br>工作队列不完全是中断处理程序的下半部。内核的很多模块需要异步执行函数，这些模块可以创建一个内核线程来异步执行函数。<br>但是如果每个模块都创建自己的内核线程，会造成内核线程的数量过多，内存消耗比较大，影响系统性能。<br>所以最好的方法是提供一种通用机制，让这些模块把需要异步执行的函数交给工作队列执行，共享内核线程，节省资源。</p>
<h3 id="编程接口-1"><a href="#编程接口-1" class="headerlink" title="编程接口"></a>编程接口</h3><p>内核使用工作项保存需要异步执行的函数，工作项的数据类型是work_struct，需要异步执行的函数的原型如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">work_func_t</span>)</span><span class="params">(struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>有一类工作项称为延迟工作项，数据类型是delayed_work。把延迟工作项添加到工作队列中的时候，延迟一段时间才会真正地把工作项添加到工作队列中。延迟工作项是工作项和定时器的结合，可以避免使用者自己创建定时器。</p>
<p>我们可以使用内核定义的工作队列，也可以自己创建专用的工作队列。内核定义了以下工作队列</p>
<p><img src="/2021/10/13/linux-interrupt/image-41.png" width="600px"></p>
<ul>
<li>system_wq：如果工作项的执行时间比较短，应该使用这个工作队列。早期的内核版本只提供了这个工作队列，称为全局工作队列，函数schedule_work()和schedule_delayed_work()使用这个工作队列。</li>
<li>system_highpri_wq：高优先级的工作队列。</li>
<li>system_long_wq：如果工作项的执行时间比较长，应该使用这个工作队列。</li>
<li>system_unbound_wq：这个工作队列使用的内核线程不绑定到某个特定的处理器。</li>
<li>system_freezable_wq：这个工作队列可以冻结。</li>
<li>system_power_efficient_wq：如果开启了工作队列模块的参数“wq_power_efficient”，那么这个工作队列倾向于省电；否则和system_wq相同。</li>
<li>system_freezable_power_efficient_wq：这个工作队列和system_power_efficient_wq的区别是可以冻结。</li>
</ul>
<h4 id="定义工作项"><a href="#定义工作项" class="headerlink" title="定义工作项"></a>定义工作项</h4><p>定义一个静态的工作项，参数n是变量名称，参数f是工作项的处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WORK(n, f);</span><br></pre></td></tr></table></figure>
<p>定义一个静态的延迟工作项，参数n是变量名称，参数f是工作项的处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_DELAYED_WORK(n, f);</span><br></pre></td></tr></table></figure>
<p>使用DECLARE_DEFERRABLE_WORK(n, f)也可以定义一个静态的延迟工作项，和DECLARE_DELAYED_WORK()的区别是它使用可推迟的定时器（deferrable timer）。<br>可推迟的定时器在系统忙的时候工作正常，但是在处理器空闲的时候不会处理可推迟的定时器。当一个不可推迟的定时器唤醒处理器的时候，才会处理可推迟的定时器。</p>
<blockquote>
<p>在运行时动态初始化工作项，方法如下</p>
</blockquote>
<ul>
<li><code>INIT_WORK(_work, _func)</code>：初始化一个工作项，参数_work是工作项的地址，参数_func是需要异步执行的函数。</li>
<li><code>INIT_WORK_ONSTACK(_work, _func)</code>：初始化一个工作项，工作项是栈里面的局部变量，参数_work是工作项的地址，参数_func是需要异步执行的函数。</li>
<li><code>INIT_DELAYED_WORK(_work, _func)</code>：初始化一个延迟工作项，参数_work是延迟工作项的地址，参数_func是需要异步执行的函数。</li>
<li><code>INIT_DELAYED_WORK_ONSTACK(_work, _func)</code>：初始化一个延迟工作项，延迟工作项是栈里面的局部变量，参数_work是延迟工作项的地址，参数_func是需要异步执行的函数。</li>
<li><code>INIT_DEFERRABLE_WORK(_work, _func)</code>：初始化一个延迟工作项，和INIT_DELAYED_WORK()的区别是它使用可推迟的定时器。</li>
</ul>
<h4 id="全局工作队列"><a href="#全局工作队列" class="headerlink" title="全局工作队列"></a>全局工作队列</h4><p>在全局工作队列中添加一个工作项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">schedule_work</span><span class="params">(struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在全局工作队列中添加一个工作项，并且指定执行工作项的处理器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">schedule_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct work_struct* work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在全局工作队列中添加一个延迟工作项，参数delay是把工作项添加到工作队列中之前等待的时间，单位是嘀嗒（tick）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">schedule_delayed_work</span><span class="params">(struct delayed_work *dwork, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在全局工作队列中添加一个延迟工作项，并且指定执行工作项的处理器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">schedule_delayed_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct delayed_work *dwork, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span>;</span><br></pre></td></tr></table></figure>
<p>冲刷全局工作队列，确保全局工作队列中的所有工作项执行完。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_scheduled_work</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="专用工作队列"><a href="#专用工作队列" class="headerlink" title="专用工作队列"></a>专用工作队列</h4><p>分配工作队列的函数是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc_workqueue(fmt, flags, max_active, args...)</span><br></pre></td></tr></table></figure>
<ul>
<li>参数fmt是工作队列名称的格式。</li>
<li>参数fags是标志位，可以是0，也可以是下面这些标志位的组合。<ul>
<li>WQ_UNBOUND：处理工作项的内核线程不绑定到任何特定的处理器。</li>
<li>WQ_FREEZABLE：在系统挂起的时候冻结。</li>
<li>WQ_MEM_RECLAIM：在内存回收的时候可能使用这个工作队列。</li>
<li>WQ_HIGHPRI：高优先级。❑ WQ_CPU_INTENSIVE：处理器密集型。</li>
<li>WQ_POWER_EFFICIENT：省电。</li>
</ul>
</li>
<li>参数max_active是每个处理器可以同时执行的工作项的最大数量，0表示使用默认值。</li>
<li>参数args是传给参数fmt的参数。</li>
</ul>
<p>下面的函数用来分配一个有序的工作队列。有序的工作队列在任何时刻，按照入队的顺序只执行一个工作项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc_ordered_workqueue(fmt, flags, args...)</span><br></pre></td></tr></table></figure>
<p>旧版本的创建工作队列的函数<code>create_workqueue()</code>、<code>create_freezable_workqueue()</code>和<code>create_singlethread_workqueue()</code>已经被废弃。<br>在指定的工作队列中添加一个工作项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">queue_work</span><span class="params">(struct workqueue_struct *wq, struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在指定的工作队列中添加一个工作项，并且指定执行工作项的处理器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">queue_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct workqueue_struct *wq, struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在指定的工作队列中添加一个延迟工作项，参数delay是把工作项添加到工作队列中之前等待的时间，单位是嘀嗒（tick）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">queue_delayed_work</span><span class="params">(struct workqueue_struct *wq, struct delayed_work *dwork, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在指定的工作队列中添加一个延迟工作项，并且指定执行工作项的处理器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">queue_delayed_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct workqueue_struct *wq, struct delayed_work *work, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span>;</span><br></pre></td></tr></table></figure>
<p>冲刷工作队列，确保工作队列中的所有工作项执行完。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_workqueue</span><span class="params">(struct workqueue_struct *wq)</span></span>;</span><br></pre></td></tr></table></figure>
<p>销毁工作队列的函数是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_workqueue</span><span class="params">(struct workqueue_struct *wq)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="其他编程接口"><a href="#其他编程接口" class="headerlink" title="其他编程接口"></a>其他编程接口</h4><p>取消一个工作项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cancel_work</span><span class="params">(struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>取消一个工作项，并且等待取消操作执行完</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cancel_work_sync</span><span class="params">(struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>取消一个延迟工作项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cancel_delayed_work</span><span class="params">(struct delayed_work *dwork)</span></span>;</span><br></pre></td></tr></table></figure>
<p>取消一个延迟工作项，并且等待取消操作执行完</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cancel_delayed_work_sync</span><span class="params">(struct delayed_work *dwork)</span></span>;</span><br></pre></td></tr></table></figure>
<p>等待一个工作项执行完</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">flush_work</span><span class="params">(struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>等待一个延迟工作项执行完</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">flush_delayed_work</span><span class="params">(struct delayed_work *dwork)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="技术原理-1"><a href="#技术原理-1" class="headerlink" title="技术原理"></a>技术原理</h3><p>首先介绍一下工作队列使用的术语。</p>
<ul>
<li>work：工作，也称为工作项。</li>
<li>work queue：工作队列，就是工作的集合，work queue和work是一对多的关系。</li>
<li>worker：工人，一个工人对应一个内核线程，我们把工人对应的内核线程称为工人线程。</li>
<li>worker_pool：工人池，就是工人的集合，工人池和工人是一对多的关系。</li>
<li>pool_workqueue：中介，负责建立工作队列和工人池之间的关系。工作队列和pool_workqueue是一对多的关系，pool_workqueue和工人池是一对一的关系。</li>
</ul>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p>工作队列分为两种。</p>
<ul>
<li>绑定处理器的工作队列：默认创建绑定处理器的工作队列，每个工人线程绑定到一个处理器。</li>
<li>不绑定处理器的工作队列：创建工作队列的时候需要指定标志位WQ_UNBOUND，工人线程不绑定到某个处理器，可以在处理器之间迁移。</li>
</ul>
<p>绑定处理器的工作队列的数据结构如图所示，工作队列在每个处理器上有一个pool_workqueue实例，一个pool_workqueue实例对应一个工人池，一个工人池有一条工人链表，每个工人对应一个内核线程。<br>向工作队列中添加工作项的时候，选择当前处理器的pool_workqueue实例、工人池和工人线程。</p>
<p><img src="/2021/10/13/linux-interrupt/image-42.png" width="800px"></p>
<p>不绑定处理器的工作队列的数据结构如图所示，工作队列在每个内存节点上有一个pool_workqueue实例，一个pool_workqueue实例对应一个工人池，一个工人池有一条工人链表，每个工人对应一个内核线程。向工作队列中添加工作项的时候，选择当前处理器所属的内存节点的pool_workqueue实例、工人池和工人线程。</p>
<p><img src="/2021/10/13/linux-interrupt/image-43.png" width="800px"></p>
<p>不绑定处理器的工作队列还有一个默认的pool_workqueue实例（workqueue_struct.df_pwq），当某个处理器下线的时候，使用默认的pool_workqueue实例。</p>
<p>工作项负责保存需要异步执行的函数，数据类型是work_struct</p>
<p><img src="/2021/10/13/linux-interrupt/image-44.png" width="700px"></p>
<p>成员func是需要异步执行的函数，成员data是传给函数func的参数。<br>成员entry用来把工作项添加到链表中。<br>延迟工作项是工作项和定时器的结合，数据类型是delayed_work。<br>把延迟工作项添加到工作队列中的时候，延迟一段时间才会真正地把工作项添加到工作队列中。</p>
<p><img src="/2021/10/13/linux-interrupt/image-45.png" width="600px"></p>
<h4 id="添加工作项"><a href="#添加工作项" class="headerlink" title="添加工作项"></a>添加工作项</h4><p>函数queue_work()用来向工作队列中添加一个工作项，把主要工作委托给函数queue_work_on()，把第一个参数<code>“int cpu”</code>设置为WORK_CPU_UNBOUND，意思是不绑定到任何处理器，优先选择当前处理器。</p>
<p><img src="/2021/10/13/linux-interrupt/image-46.png" width="600px"></p>
<p>函数queue_work_on的代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-47.png" width="600px"></p>
<p>如果工作项没有添加过，那么给工作项设置标志位WORK_STRUCT_PENDING_BIT，然后把主要工作委托给函数<strong>queue_work()。<br>函数</strong>queue_work的代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-48.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-49.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-50.png" width="600px"></p>
<ul>
<li>从工作队列中选择pool_workqueue实例。如果是绑定处理器的工作队列，那么选择当前处理器的pool_workqueue实例；如果是不绑定处理器的工作队列，那么选择当前处理器所属的内存节点的pool_workqueue实例。</li>
<li>如果工作正在被其他pool_workqueue实例的工人执行，那么还是把工作添加到那个pool_workqueue实例。</li>
<li>如果pool_workqueue实例的未处理工作数量小于限制，那么把工作添加到pool_workqueue实例对应的工人池的链表worklist中；如果pool_workqueue实例的未处理工作数量达到限制，那么给工作设置标志位WORK_STRUCT_DELAYED，并且把工作添加到pool_workqueue实例的链表delayed_works中。</li>
<li>把工作添加到选择的链表中。</li>
</ul>
<h4 id="工人处理工作"><a href="#工人处理工作" class="headerlink" title="工人处理工作"></a>工人处理工作</h4><p>每个工人对应一个内核线程，一个工人池对应一个或多个工人。<br>多个工人从工人池的未处理工作链表（worker_pool.worklist）中取工作并处理。<br>工人线程的处理函数是worker_thread()，调用函数process_one_work()处理一个工作项。</p>
<blockquote>
<p>函数worker_thread()的代码如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-51.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-52.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-53.png" width="600px"></p>
<ul>
<li>如果工人太多，想要减少工人的数量，那么当前工人线程退出。</li>
<li>工人退出空闲状态。</li>
<li>如果不需要本工人执行工作，那么本工人进入空闲状态。</li>
<li>如果工人池中没有空闲的工人，那么创建一些工人备用。</li>
<li>从工人池的链表worklist中取一个工作。</li>
<li>如果是正常工作，那么调用函数process_one_work()执行正常工作，然后执行工人的链表scheduled中的特殊工作。</li>
<li>如果是特殊工作，那么首先把工作添加到工人的链表scheduled的尾部，然后执行工人的链表scheduled中的特殊工作。</li>
<li>如果有工作需要处理，并且处于运行状态的工人数量不超过1，那么本工人继续执行工作。</li>
<li>工人进入空闲状态，睡眠。</li>
</ul>
<blockquote>
<p>下面解释一下正常工作和特殊工作。</p>
</blockquote>
<p>向工作队列中添加正常工作，是直接添加到工人池的链表worklist中。<br>调用函数fush_work(t)等待工作t执行完，实现方法是添加一个特殊工作：屏障工作，执行这个屏障工作的时候就可以确定工作t执行完。如果工作t正在被工人p执行，那么把屏障工作直接添加到工人p的链表scheduled中；如果工作t没有执行，那么把屏障工作添加到工人池的链表worklist中，并且给屏障工作设置标志位WORK_STRUCT_LINKED。</p>
<p>函数process_one_work()负责处理一个工作，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-54.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-55.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-56.png" width="600px"></p>
<ul>
<li>一个工作不应该被多个工人并发执行。如果一个工作正在被工人池的其他工人执行，那么把这个工作添加到这个工人的链表scheduled中延后执行。</li>
<li>把工人添加到工人池的散列表busy_hash中。</li>
<li>工人的成员current_work指向当前工作，成员current_func指向当前工作的处理函数，成员current_pwq指向当前pool_workqueue实例。</li>
<li>如果工作队列是处理器密集型的，那么给工人设置标志位WORKER_CPU_INTENSIVE，工人不再被工人池动态调度。</li>
<li>对于不绑定处理器或处理器密集型的工作队列，唤醒更多空闲的工人处理工作。</li>
<li>执行工作的处理函数。</li>
</ul>
<h4 id="工人池动态管理工人"><a href="#工人池动态管理工人" class="headerlink" title="工人池动态管理工人"></a>工人池动态管理工人</h4><blockquote>
<p>工人池可以动态增加和删除工人，算法如下</p>
</blockquote>
<ul>
<li>工人有3种状态：空闲（idle）、运行（running）和挂起（suspend）。空闲是指没有执行工作，运行是指正在执行工作，挂起是指在执行工作的过程中睡眠。</li>
<li>如果工人池中有工作需要处理，至少保持一个处在运行状态的工人来处理。</li>
<li>如果处在运行状态的工人在执行工作的过程中进入挂起状态，为了保证其他工作的执行，需要唤醒空闲的工人处理工作。</li>
<li>如果有工作需要执行，并且处在运行状态的工人数量大于1，会让多余的工人进入空闲状态。</li>
<li>如果没有工作需要执行，会让所有工人进入空闲状态。</li>
<li>如果创建的工人过多，工人池把空闲时间超过300秒（IDLE_WORKER_TIMEOUT）的工人删除。</li>
</ul>
<p>为了跟踪工人的运行和挂起状态、动态调整工人的数量，工作队列使用在进程调度中加钩子函数的技巧。</p>
<ul>
<li>跟踪工人从挂起进入运行状态。唤醒工人线程的时候，如果工人线程正在执行工作的过程中，那么把工人池中处在运行状态的工人计数（nr_running）加1。<br>  相关代码如下<br>  <img src="/2021/10/13/linux-interrupt/image-57.png" width="600px"></li>
<li>跟踪工人从运行进入挂起状态。当一个工人睡眠的时候，如果工人池没有工人处于运行状态，并且工人池有工作需要执行，那么唤醒一个空闲的工人。<br>  相关代码如下<br>  <img src="/2021/10/13/linux-interrupt/image-58.png" width="600px"></li>
</ul>
<p>工人池的调度思想是如果有工作需要处理，保持一个处在运行状态的工人来处理，不多也不少。<br>这种做法有个问题：如果工作是处理器密集型的，虽然工人没有进入挂起状态，但是会长时间占用处理器，让后续的工作阻塞太长时间。<br>为了解决这个问题，可以在创建工作队列的时候设置标志位WQ_CPU_INTENSIVE，声明工作队列是处理器密集的。当一个工人执行工作的时候，让这个工人不受工人池动态调度，像是进入了挂起状态，工人池创建新的工人来执行后续的工作。</p>
<p>工人线程对处理器密集的特殊处理如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-59.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-60.png" width="600px"></p>
<p>可以看到，给工人设置标志位WORKER_CPU_INTENSIVE的时候，把工人池的计数nr_running减1，相当于工人进入挂起状态。</p>
<p><br><br><br></p>
<hr>


<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>系统调用是内核给用户程序提供的编程接口。用户程序调用系统调用，通常使用glibc库针对单个系统调用封装的函数。<br>如果glibc库没有针对某个系统调用封装函数，用户程序可以使用通用的封装函数syscall()：</p>
<p><img src="/2021/10/13/linux-interrupt/image-61.png" width="600px"></p>
<p>参数number是系统调用号，后面是传递给系统调用的参数。返回值0表示成功，返回值−1表示错误，错误号存储在变量errno中。</p>
<blockquote>
<p>例如应用程序使用系统调用fork()创建子进程，有两种调用方法。</p>
</blockquote>
<ul>
<li>ret = fork();</li>
<li>ret = syscall(SYS_fork);</li>
</ul>
<p>ARM64处理器提供的系统调用指令是svc，调用约定如下。</p>
<ul>
<li>64位应用程序使用寄存器x8传递系统调用号，32位应用程序使用寄存器x7传递系统调用号。</li>
<li>使用寄存器x0～x6最多可以传递7个参数。</li>
<li>当系统调用执行完的时候，使用寄存器x0存放返回值。</li>
</ul>
<h2 id="定义系统调用"><a href="#定义系统调用" class="headerlink" title="定义系统调用"></a>定义系统调用</h2><p>Linux内核使用宏SYSCALL_DEFINE定义系统调用，以创建子进程的系统调用fork为例：</p>
<p><img src="/2021/10/13/linux-interrupt/image-62.png" width="600px"></p>
<blockquote>
<p>把宏“SYSCALL_DEFINE0(fork)”展开以后是：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_fork</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>“SYSCALL_DEFINE”后面的数字表示系统调用的参数个数，“SYSCALL_DEFINE0”表示系统调用没有参数，“SYSCALL_DEFINE6”表示系统调用有6个参数，如果参数超过6个，使用宏“SYSCALL_DEFINEx”。头文件“include/linux/syscalls.h”定义了这些宏。</p>
<p>“asmlinkage”表示这个C语言函数可以被汇编代码调用。如果使用C++编译器，“asmlinkage”被定义为extern “C”；如果使用C编译器，“asmlinkage”是空的宏。</p>
<p>系统调用的函数名称以“sys_”开头。<br>需要在系统调用表中保存系统调用号和处理函数的映射关系，ARM64架构定义的系统调用表sys_call_table如下：</p>
<blockquote>
<p>arch/arm64/kernel/sys.c</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-63.png" width="600px"></p>
<blockquote>
<p>对于ARM64架构，头文件“asm/unistd.h”是“arch/arm64/include/asm/unistd.h”。</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-64.png" width="600px"></p>
<h2 id="执行系统调用"><a href="#执行系统调用" class="headerlink" title="执行系统调用"></a>执行系统调用</h2><p>ARM64处理器把系统调用划分到同步异常，在异常级别1的异常向量表中，系统调用的入口有两个：</p>
<ul>
<li>如果64位应用程序执行系统调用指令svc，系统调用的入口是el0_sync。</li>
<li>如果32位应用程序执行系统调用指令svc，系统调用的入口是el0_sync_compat。</li>
</ul>
<blockquote>
<p>el0_sync的代码如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-65.png" width="600px"></p>
<ul>
<li>把当前进程的寄存器值保存在内核栈中。</li>
<li>读取异常症状寄存器esr_el1。</li>
<li>解析出异常症状寄存器的异常类别字段。</li>
<li>如果异常类别是系统调用，跳转到el0_svc。</li>
</ul>
<blockquote>
<p>el0_svc负责执行系统调用，其代码如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-66.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-67.png" width="600px"></p>
<ul>
<li>把寄存器x27设置为系统调用表sys_call_table的起始地址。</li>
<li>把寄存器x26设置为系统调用号。64位进程使用寄存器x8传递系统调用号，w8是寄存器x8的32位形式。</li>
<li>把寄存器x25设置为系统调用的数量，也就是（最大的系统调用号+1）。</li>
<li>把寄存器x0和x8的值保存到内核栈中，x0存放系统调用的第一个参数，x8存放系统调用号。</li>
<li>开启调试异常和中断。</li>
<li>如果使用ptrace跟踪系统调用，跳转到__sys_trace处理。</li>
<li>如果进程传递的系统调用号等于或大于系统调用的数量，即大于最大的系统调用号，那么是非法值，跳转到ni_sys处理错误。</li>
<li>计算出系统调用号对应的表项地址（sys_call_table + 系统调用号 * 8），然后取出处理函数的地址。</li>
<li>调用系统调用号对应的处理函数。</li>
<li>从系统调用返回用户空间。</li>
</ul>
<blockquote>
<p>ret_fast_syscall从系统调用返回用户空间，其代码如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-68.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-69.png" width="600px"></p>
<ul>
<li>禁止中断。</li>
<li>寄存器x0已经存放了处理函数的返回值，把保存在内核栈中的寄存器x0的值更新为返回值。</li>
<li>如果使用ptrace跟踪系统调用，跳转到ret_fast_syscall_trace处理。</li>
<li>如果进程的thread_info.fags设置了需要重新调度（_TIF_NEED_RESCHED）或者有信号需要处理（_TIF_SIGPENDING）等标志位，跳转到work_pending处理。</li>
<li>如果使用系统调用ptrace设置了软件单步执行，那么开启单步执行。</li>
<li>使用保存在内核栈中的寄存器值恢复寄存器，从内核模式返回用户模式。</li>
</ul>
<blockquote>
<p>work_pending调用函数do_notify_resume，函数do_notify_resume的代码如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-70.png" width="600px"></p>
<ul>
<li>如果当前进程的thread_info.fags设置了标志位_TIF_NEED_RESCHED，那么调度进程。</li>
<li>如果设置了标志位_TIF_UPROBE，调用函数uprobe_notify_resume()处理。uprobes（user-space probes，用户空间探测器）可以在进程的任何指令地址插入探测器，收集调试和性能信息，发现性能问题。需要内核支持，编译内核时开启配置宏CONFIG_UPROBE_EVENTS。</li>
<li>如果设置了标志位_TIF_SIGPENDING，调用函数do_signal()处理信号。</li>
<li>如果设置了标志位_TIF_NOTIFY_RESUME，那么调用函数tracehook_notify_resume()，执行返回用户模式之前的回调函数。</li>
<li>如果设置了标志位_TIF_FOREIGN_FPSTATE，那么恢复浮点寄存器。</li>
</ul>
<p><br><br><br></p>
<h1 id="中断细节"><a href="#中断细节" class="headerlink" title="中断细节"></a>中断细节</h1><p>外部设备与中央处理器交互一般有两种手段：轮询和中断。<br>对于轮询要求处理器不停地查询外设的状态，在此期间处理器不能做别的事情。<br>而中断不要求处理器不停地查询自己的状态，而是在自己的状态满足处理器的要求时主动发送一个硬件信号给处理器，后者在接收到这一信号时，会挂起当前正在执行的任务转而去处理外设的中断信号。</p>
<p>现代设备绝大多数采用中断的方式与处理器进行沟通，因此设备驱动程序必须能够支持设备的中断特性。<br>处理器在中断到达时会根据不同的中断号找到对应的处理函数对该信号进行处理，这些处理函数称为中断处理例程ISR（Interrupt Service Routine），设备驱动程序负责为管理的设备提供中断处理例程并向系统注册。<br>从设备发出中断信号到处理器最终调用中断处理例程进行处理，期间会经过很多步骤，这个过程构成了中断处理框架。</p>
<p>不同的操作系统对中断处理框架的设计不尽相同，但是要达到的目的是一样的，那就是最终调用设备的中断处理例程。<br>将先描述Linux系统下的中断处理框架设计，然后在此基础上讨论设备驱动程序如何利用内核提供的接口函数向系统挂载中断处理例程，最后讨论中断上下文的相关内容，包括软中断等。</p>
<h2 id="中断的硬件框架"><a href="#中断的硬件框架" class="headerlink" title="中断的硬件框架"></a>中断的硬件框架</h2><p>处理器一般只有两根左右的中断引脚，而管理的外设却很多。<br>为了解决这个问题，现代设备的中断信号线并不是与处理器直接相连，而是与一个称为中断控制器的设备相连接，后者才跟处理器的中断引脚直接连接。<br>中断控制器一般可以通过处理器进行编程配置，所以常称为可编程中断控制器PIC</p>
<p><img src="/2021/10/13/linux-interrupt/image-71.png" width="500px"></p>
<p>PIC的输出中断信号线连接到处理器的INT引脚上，这是处理器专门用来接收中断信号的pin脚。<br>外部设备的中断线连接到PIC的pin引脚上，这是PIC用来接收外设中断的pin脚，比如外部设备1的中断线通过P0连到PIC上。</p>
<p>在实际的硬件平台上，PIC有的在CPU外部，比如x86平台上的8259控制器；有的被封装到了CPU的内部，这广泛见于嵌入式领域，一颗SoC芯片内部集成了处理器和各种外部设备的控制器，其中包括PIC。<br>中断方面的内容常常涉及硬件平台的差别，但是这里不会纠结于某个具体的硬件设计，而是希望相关的内容可以很快被读者吸纳到自己手边的平台上。</p>
<h2 id="PIC与软件中断号"><a href="#PIC与软件中断号" class="headerlink" title="PIC与软件中断号"></a>PIC与软件中断号</h2><p>实际使用中在处理器能处理外部设备的中断前，常常需要对PIC进行配置，配置工作常常作为操作系统初始化任务的一部分。<br>当然中断处理框架也需要提供适当的PIC配置接口函数供设备驱动程序调用，因为设备驱动所管理的设备也许并不是一开始就连接到PIC的某一中断引脚上的。<br>如果在系统运行起来之后，某一外设才被用户接入系统，那么它的驱动程序应该负责配置PIC的对应引脚，使该外设能正常中断处理器。</p>
<blockquote>
<p>对PIC的配置工作主要包括：</p>
</blockquote>
<ul>
<li>设定外部设备中断触发电信号的类型，常见的触发类型有水平触发和边沿触发。</li>
<li>将外设的中断引脚编号映射到处理器可见的软件中断号irq。</li>
<li>屏蔽掉某些外部设备的中断触发。</li>
</ul>
<p>为了让处理器可以配置自己，PIC常常需要提供一系列的控制寄存器。这些控制寄存器可以完成上述所有配置工作，并且配置粒度可以细分到PIC的每一个中断输入引脚P。<br>此处一个需要明确定义的概念是软件中断号irq，它是发生设备中断时处理器从PIC中读到的中断号码，在操作系统建立的中断处理框架内，会使用这个irq号来标识一个外设的中断并调用对应的中断处理例程。<br>作为描述的示例,外部设备0触发的一个中断电信号被处理的大体流程。</p>
<p>PIC将首先接收到该信号，如果它没有被屏蔽，那么PIC应该在INT引脚上产生一个中断信号告诉处理器。<br>后者在接收到该信号后会从PIC那里得到一个特定的标识号码，该号码告诉中断处理框架，是设备0发生了中断。<br>于是中断处理框架会调用设备0的中断处理例程，此处的这个特定的标识设备0的中断号码就称为软件中断号irq或者中断号irq。</p>
<p>此处还有一个概念需要提一下，那就是中断向量表（vector table）。<br>这其实是处理器内部的一个概念，因为处理器除了会被外部设备中断，其内部也可能会产生异常等事件。<br>当这些事发生时，CPU必须暂停当前的工作，转而去处理中断或者异常，因此处理器需要知道到哪里去获得这些中断或异常的处理函数的目标地址。<br>中断向量表就用来解决这个问题，其每一项都是一个中断或异常处理函数的入口地址。<br>外部设备的中断常常对应向量表中的某一项，这是个通用的外部中断处理函数的入口，因此在进入通用的中断处理函数之后，系统必须要知道正在处理的中断是哪一个设备产生的，而这正是由前面提到的软件中断号irq决定的。<br>中断向量表中的内容由操作系统在初始化阶段来填写，对于外部中断，操作系统负责实现一个通用的外部中断处理函数，然后把这个函数的入口地址放到中断向量表中的对应位置。</p>
<h2 id="通用的中断处理函数"><a href="#通用的中断处理函数" class="headerlink" title="通用的中断处理函数"></a>通用的中断处理函数</h2><p>当有外部中断发生时，预先设计好的处理器硬件逻辑往往会做一些特定的动作，为从软件层面发起的中断处理做准备工作。<br>不同的处理器有不同的逻辑设计，但这些动作常常包括把当前任务的上下文寄存器保存在一个特定的中断栈中，屏蔽掉处理器响应外部中断的能力等。<br>在这些动作的结束部分，硬件逻辑根据中断向量表中的外部中断对应的入口地址，开始调用由操作系统提供的通用中断处理函数。</p>
<p>不同的架构平台上通用中断处理函数的实现也不尽相同，但在开始部分都会设法从PIC中得到导致本次中断发生的外部设备对应的软件中断号irq，这部分代码通常都是用汇编语言实现，在Linux源码树中散落在各个特定架构对应的目录中。<br>然后通用处理函数开始调用一个C函数，大部分平台上这个C函数的名字是do_IRQ，但也有例外比如ARM平台上是asm_do_IRQ，本书采用do_IRQ来指代该C函数的名称。</p>
<p>中断处理的绝大部分流程都浓缩在了这个C函数当中，当这个函数返回时，通用中断处理函数余下部分的代码将完成中断现场恢复的工作，这也标志着整个中断处理流程的结束:被中断的任务开始继续执行，仿佛中断根本没有发生过一样。<br>通常处理器在接收到外部的中断信号时，硬件逻辑会自动屏蔽处理器响应外部中断的能力，因此如果操作系统实现的中断处理框架不主动打开中断的话，整个中断处理的流程是在中断关闭的情况下进行的。<br>因为各个设备的中断处理函数一般是由驱动程序实现的，内核无法保证这些中断处理函数执行时间的长短，如果某一中断处理函数执行时间过长，则将会导致系统可能很长时间无法接收中断，这可能会使某些外部设备丢失数据或者操作系统响应时间变长等。<br>为了解决这一问题，Linux内核为驱动程序提供的中断处理机制分成了两个部分：HARDIRQ和SOFTIRQ。<br>前者是在中断关闭的情况下执行，用来完成中断发生后最关键的操作，它的执行时间应该尽可能短。<br>后者是在中断开启的情况下进行，此时外部设备仍可以继续中断处理器，驱动程序因此可以将一些比较耗时的工作延迟到这部分执行。<br>在do_IRQ函数中，对irq_enter的调用可以认为是HARDIRQ部分的开始，而SOFTIRQ则在irq_exit中完成。</p>
<h2 id="do-IRQ函数"><a href="#do-IRQ函数" class="headerlink" title="do_IRQ函数"></a>do_IRQ函数</h2><p>do_IRQ函数从通用中断处理函数中发起，负责整个中断处理流程中实质性的中断处理任务。<br>虽然该函数在各个平台上的实现代码不尽相同，但是原理基本上大同小异，一个典型的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">void__irq_entry  <span class="title">do_IRQ</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq,struct pt_regs*regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">old_regs</span> = <span class="title">set_irq_regs</span>(<span class="title">regs</span>);</span></span><br><span class="line">    irq_enter();</span><br><span class="line">    check_stack_overflow();</span><br><span class="line">    generic_handle_irq(irq);</span><br><span class="line">    irq_exit();</span><br><span class="line">    set_irq_regs(old_regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看该函数的两个参数，irq是该函数的调用者——通用中断处理函数从PIC中得到的软件中断号，regs是保存下来的被中断任务的执行现场，不同的处理器有不同的执行现场，也就是有不同的寄存器。<br>函数首先调用set_irq_regs将一个per-CPU型的指针变量<code>__irq_regs</code>保存到<code>old_regs</code>中，然后将<code>__irq_regs</code>赋予了一个新值regs，这样中断处理过程中，系统中的每一个CPU都可以通过<code>__irq_regs</code>来访问系统保存的中断现场。<br>在函数的结束，调用set_irq_regs(old_regs)来恢复<code>__irq_regs</code>。<code>__irq_regs</code>一般用来在调试或者诊断时打印当前栈的信息，也可以通过这些保存的中断现场寄存器判断出被中断的进程当时运行在用户态还是内核态。</p>
<p>接下来irq_enter会更新系统中的一些统计量，同时会把当前栈中的preempt_count变量加上HARDIRQ_OFFSET来标识一个HARDIRQ中断上下文：<code>preempt_count() +=HARDIRQ_OFFSET</code><br>HARDIRQ是Linux下对中断处理上半部分的称谓，与之对应的是中断处理的下半部分SOFTIRQ，此处irq_enter告诉系统现在进入了中断处理的上半部分。<br>与irq_enter行为配对的是irq_exit，在当前中断处理完成准备退出时调用，除了更新一些系统统计量和清除中断上下文的标识外，它还有一个重要的功能是处理软中断，也就是中断处理的下半部分</p>
<p>check_stack_overflow()函数用来检查当前中断是否会导致栈的溢出，因为每次中断发生时系统都会做保护现场的动作，从代码的层面，就是将系统的寄存器压入中断栈中。<br>理想情况下一个中断处理结束时将恢复现场，也就是将之前在栈中保存的寄存器弹出堆栈，因此不会发生栈溢出的情况。<br>但是如果中断处理函数中打开了处理器响应外部中断的能力，那就有可能在当前中断正在被处理时，处理器又接收到了新的中断，也就是所谓的中断嵌套，这将导致系统重复地进行中断现场保护的动作，甚至发生大量的中断嵌套行为，使得栈不断增长，从而出现堆栈的溢出，影响到系统的稳定性。<br>为此系统使用check_stack_overflow函数来对栈是否溢出进行检查，如果发现本次中断有可能导致栈的溢出，通常会打印出当前栈的信息（dump_stack），对于某些启用了watchdog的系统，也可能会强制系统进行reset动作。</p>
<p>do_IRQ的核心是调用generic_handle_irq函数，后者在其函数调度链中负责对当前发生的中断进行实际的处理：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/irq.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">generic_handle_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> = &amp;<span class="title">irq_desc</span>[<span class="title">irq</span>];</span></span><br><span class="line">    desc-&gt;handle_irq(irq, desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数通过软件中断号irq来索引数组irq_desc,得到一个struct irq_desc类型的指针变量desc，然后调用其成员函数handle_irq对当前中断进行实际的处理。<br>irq_desc是个struct irq_desc类型的数组,在Linux的整个中断处理框架中非常重要，起着沟通从通用的中断处理函数到设备特定的中断处理例程之间的桥梁作用，图展示了该数组的组成结构：</p>
<p><img src="/2021/10/13/linux-interrupt/image-72.png" width="600px"></p>
<blockquote>
<p>通常其定义和默认值如下</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/irq/irqdesc.c&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> <span class="title">irq_desc</span>[<span class="title">NR_IRQS</span>] __<span class="title">cacheline_aligned_in_smp</span> = &#123;</span></span><br><span class="line">    [<span class="number">0</span> ... NR_IRQS<span class="number">-1</span>] = &#123;</span><br><span class="line">        .handle_irq =handle_bad_irq,</span><br><span class="line">        .depth         =<span class="number">1</span>,</span><br><span class="line">        .lock     =__RAW_SPIN_LOCK_UNLOCKED(irq_desc-&gt;lock),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>NR_IRQS是个平台相关的常量，用来表示特定的平台上可以处理的外部中断的数量。<br>Linux操作系统初始化期间通过调用early_irq_init函数来对这个数组初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/irq/irqdesc.c&gt;</span><br><span class="line">nt __<span class="function">init <span class="title">early_irq_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count, i, node = first_online_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">    init_irq_default_affinity();</span><br><span class="line">    printk(KERN_INFO <span class="string">"NR_IRQS:%d\n"</span>, NR_IRQS);</span><br><span class="line">    desc = irq_desc;</span><br><span class="line">    count = ARRAY_SIZE(irq_desc);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        desc[i].irq_data.irq = i;</span><br><span class="line">        desc[i].irq_data.chip = &amp;no_irq_chip;</span><br><span class="line">        desc[i].kstat_irqs = alloc_percpu(<span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">        irq_settings_clr_and_set(desc, ~<span class="number">0</span>, _IRQ_DEFAULT_INIT_FLAGS);</span><br><span class="line">        alloc_masks(desc + i, GFP_KERNEL, node);</span><br><span class="line">        desc_smp_init(desc + i, node);</span><br><span class="line">        lockdep_set_class(&amp;desc[i].lock, &amp;irq_desc_lock_class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arch_early_irq_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="irq-desc"><a href="#irq-desc" class="headerlink" title="irq_desc"></a>irq_desc</h3><p>数组的类型struct irq_desc是个非常重要的数据结构, 定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/irqdesc.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>         <span class="title">irq_data</span>;</span>  <span class="class"><span class="keyword">struct</span> <span class="title">timer_rand_state</span>*<span class="title">timer_rand_state</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> int__percpu    *kstat_irqs;<span class="keyword">irq_flow_handler_t</span>     handle_irq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IRQ_PREFLOW_FASTEOI</span></span><br><span class="line">    <span class="keyword">irq_preflow_handler_t</span>  preflow_handler;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>  *<span class="title">action</span>;</span>   <span class="comment">/*IRQ action list*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>      status_use_accessors;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>      istate;<span class="keyword">unsigned</span> <span class="keyword">int</span>     depth;         <span class="comment">/*nested irq disables*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>      wake_depth;      <span class="comment">/*nested wake enables*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>      irq_count; <span class="comment">/*For detecting broken IRQs*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>           last_unhandled;  <span class="comment">/*Aging timer for unhandled count*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>      irqs_unhandled;</span><br><span class="line">    <span class="keyword">raw_spinlock_t</span>         lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>     *<span class="title">affinity_hint</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_affinity_notify</span> *<span class="title">affinity_notify</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_PENDING_IRQ</span></span><br><span class="line">    <span class="keyword">cpumask_var_t</span>          pending_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>           threads_oneshot;</span><br><span class="line">    <span class="keyword">atomic_t</span>         threads_active;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span>      wait_for_threads;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>   *<span class="title">dir</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *name;</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>
<p>主要用来保存软件中断号irq和chip相关的数据</p>
<h3 id="irq-data"><a href="#irq-data" class="headerlink" title="irq_data"></a>irq_data</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/irqdesc.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    irq;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    node;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    state_use_accessors;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span>       *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="keyword">void</span>          *handler_data;</span><br><span class="line">    <span class="keyword">void</span>          *chip_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msi_desc</span>      *<span class="title">msi_desc</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="keyword">cpumask_var_t</span>       affinity;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>成员irq代表软件中断号。<br>chip成员则代表着当前中断来自的PIC，chip所在的数据结构是在软件层面对PIC的一个抽象。<br>Linux通过封装在struct irq_data中的chip来屏蔽各种不同硬件平台上PIC的差异，给上层的软件提供统一的对PIC操作的接口。<br>利用PIC中封装的函数，可以屏蔽或启用当前中断，设定外部设备中断触发电信号的类型等。</p>
<h3 id="kstat-irqs"><a href="#kstat-irqs" class="headerlink" title="kstat_irqs"></a>kstat_irqs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __percpu *kstat_irqs</span><br></pre></td></tr></table></figure>
<p>一个per-CPU型成员，用于系统的中断统计计数。</p>
<h3 id="handle-irq"><a href="#handle-irq" class="headerlink" title="handle_irq"></a>handle_irq</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">irq_flow_handler_t</span> handle_irq</span><br></pre></td></tr></table></figure>
<p>这是个函数指针，一般用来指向一个跟当前设备中断触发电信号类型相关的函数。<br>比如如果外部设备的中断电信号是边沿触发，那么此处handle_irq将指向一个边沿触发类的处理函数;<br>如果是水平触发那么将指向一个水平触发类的处理函数。</p>
<p>如果在某一平台上边沿触发的中断和水平触发的中断处理起来完全相同，那么就没有必要如此细分，提供一个常规的处理函数就可以了。<br>在handle_irq指向的函数内部，才会调用设备特定的中断服务例程。<br>特定平台的Linux系统在初始化阶段会提供handle_irq的具体实现，这是内核设计者或者嵌入式平台BSP模块所承担的任务，设备驱动程序员在这一层面通常没有什么工作要做。</p>
<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span></span></span><br></pre></td></tr></table></figure>
<p>action是针对某一具体设备的中断处理的抽象。设备驱动程序会通过request_irq来向其中挂载设备特定的中断处理函数，相对于前面提到的通用中断处理函数，本称action中的handler为设备中断服务例程ISR<br>通过前面讨论的handle_irq和action，可以看到从通用中断处理函数发起的对某一中断处理，实际上又被划分成了两个层次，第一层是handle_irq函数，它与软件中断号irq一一对应，代表了对IRQ line上的处理动作，而action则代表着与具体设备相关的中断处理，也是设备驱动程序员要直接与之打交道的对象，通过action成员，可以在一条IRQ line上挂载多个设备，换句话说多个设备可以通过同一条IRQ line来共享同一个软件中断号irq，形成所谓的中断链，所以可以推想到action中必然有构成链表的成员</p>
<blockquote>
<p>图展示了hangle_irq与action的层次关系</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-73.jpg" width="600px"></p>
<blockquote>
<p>通过上面的讨论，为使读者对Linux下的中断处理流程有个全局性的直观印象</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-74.jpg" width="600px"></p>
<p>从图中可以看到，Linux内核将中断的处理分成了两大部分，分别是HARDIRQ和SOFTIRQ，前者一般是在处理器屏蔽外部中断的情况下工作，而后者在工作前会启用处理器响应外部中断的能力。<br>通用中断处理函数是外部设备的中断到达处理器后，处理器首先进入的函数，在完成必要的工作后，调用do_IRQ来对中断进行实际的处理。后者通过引发本次中断的软件中断号来索引irq_desc数组，找到对应的处理函数并调用，而设备驱动程序等内核模块则通过修改irq_desc数组中对应项的action成员来达到安装或卸载设备中断处理服务例程ISR的目的。<br>设备的中断处理函数调用结束后，中断流程进入SOFTIRQ部分，在这里如果有等待的softirq需要处理，则处理之，否则返回到通用中断处理函数。</p>
<h2 id="struct-irq-chip"><a href="#struct-irq-chip" class="headerlink" title="struct irq_chip"></a>struct irq_chip</h2><p>数据结构struct irq_data中的<code>struct irq_chip *chip</code>成员用来表示一个PIC的对象，如果系统中只有一个PIC，那么irq_desc数组的每一项中的chip都应该指向该PIC的对象。<br>平台的初始化函数负责实现该平台使用的PIC的对象并将其安装到irq_desc数组中。<br>PIC对象用来实现对PIC的配置，配置工作主要包括设定外部设备的中断触发信号的类型，屏蔽或者启用某一设备的中断信号，向发出中断请求的设备发送中断响应信号等。</p>
<blockquote>
<p>struct irq_chip定义如下</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/irq.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*irq_startup)</span><span class="params">(struct irq_data *data)</span></span>;</span><br><span class="line">    <span class="keyword">void</span>      (*irq_shutdown)(struct irq_data*data);</span><br><span class="line">    <span class="keyword">void</span>      (*irq_enable)(struct irq_data*data);</span><br><span class="line">    <span class="keyword">void</span>      (*irq_disable)(struct irq_data*data);</span><br><span class="line">    <span class="keyword">void</span>      (*irq_ack)(struct irq_data*data);</span><br><span class="line">    <span class="keyword">void</span>      (*irq_mask)(struct irq_data*data);</span><br><span class="line">    <span class="keyword">void</span>      (*irq_mask_ack)(struct irq_data*data);</span><br><span class="line">    <span class="keyword">void</span>      (*irq_unmask)(struct irq_data*data);</span><br><span class="line">    <span class="keyword">void</span>      (*irq_eoi)(struct irq_data*data);</span><br><span class="line">    <span class="keyword">int</span>       (*irq_set_affinity)(struct irq_data*data,<span class="keyword">const</span> struct cpumask*dest,<span class="keyword">bool</span> force);</span><br><span class="line">    <span class="keyword">int</span>       (*irq_retrigger)(struct irq_data*data);</span><br><span class="line">    <span class="keyword">int</span>       (*irq_set_type)(struct irq_data*data,<span class="keyword">unsigned</span> <span class="keyword">int</span> flow_type);</span><br><span class="line">    <span class="keyword">int</span>       (*irq_set_wake)(struct irq_data*data,<span class="keyword">unsigned</span> <span class="keyword">int</span> on);</span><br><span class="line">    <span class="keyword">void</span>      (*irq_bus_lock)(struct irq_data*data);</span><br><span class="line">    <span class="keyword">void</span>      (*irq_bus_sync_unlock)(struct irq_data*data);</span><br><span class="line">    <span class="keyword">void</span>      (*irq_cpu_online)(struct irq_data*data);</span><br><span class="line">    <span class="keyword">void</span>      (*irq_cpu_offline)(struct irq_data*data);</span><br><span class="line">    <span class="keyword">void</span>      (*irq_print_chip)(struct irq_data*data,struct seq_file*p);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   flags;</span><br><span class="line">    <span class="comment">/* Currently used only by UML, might disappear one day.*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IRQ_RELEASE_METHOD</span></span><br><span class="line">    <span class="keyword">void</span>      (*release)(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq,<span class="keyword">void</span>*dev_id);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其成员绝大多数是函数指针，用来指向具体平台实现的PIC控制函数。</p>
<h2 id="struct-irqaction"><a href="#struct-irqaction" class="headerlink" title="struct irqaction"></a>struct irqaction</h2><p>在继续下面的讨论前，有必要了解struct irqaction这个重要的数据结构。<br>在struct irq_desc结构中，成员变量action是一指向struct irqaction类型的指针，设备驱动程序通过这个结构将其中断处理函数挂载在action上。</p>
<blockquote>
<p>以下是该数据结构的定义</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">irq_handler_t</span> handler;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">void</span> *dev_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> irq;</span><br><span class="line">    <span class="keyword">irq_handler_t</span> thread_fn;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> thread_flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> thread_mask;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">dir</span>;</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>
<p>其中irq_handler_t handler指向设备特定的中断服务例程函数的指针，irq_handler_t的声明如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">irqreturn_t</span> <span class="params">(*<span class="keyword">irq_handler_t</span>)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<p>设备驱动程序负责实现该函数，然后调用request_irq函数，后者会把驱动程序实现的中断服务例程赋值给handler。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *dev_id</span><br></pre></td></tr></table></figure>
<p>调用handler时传给它的参数，在多个设备共享一个irq的情况下特别重要，这种链式的action中，设备驱动程序通过dev_id来标识自己。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">next</span></span></span><br></pre></td></tr></table></figure>
<p>指向下一个action对象，用于多个设备共享同一个irq的情形，此时action通过next构成一个链表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">dir</span></span></span><br></pre></td></tr></table></figure></p>
<p>中断处理函数中用来创建在proc文件系统中的目录项。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">irq_handler_t</span> thread_fn、<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span>和<span class="title">unsigned</span> <span class="title">long</span> <span class="title">thread_flags</span></span></span><br></pre></td></tr></table></figure></p>
<p>当驱动程序调用request_threaded_irq函数来安装中断处理例程时，用来实现irq_thread机制。</p>
<h2 id="irq-set-handler"><a href="#irq-set-handler" class="headerlink" title="irq_set_handler"></a>irq_set_handler</h2><p>现在把讨论的焦点集中到irq_desc数组中被软件中断号irq索引的某一项irq_desc[irq]，对于一个特定的irq_desc[irq]，其上的中断处理分为两级，第一级是调用irq_desc[irq].handle_irq，第二级是设备特定的中断处理例程ISR，在handle_irq的内部通过irq_desc[irq].action-&gt;handler调用。</p>
<p>第一级函数在平台初始化期间被安装到irq_desc数组中，第二级函数的注册发生在设备驱动程序调用request_irq安装对应设备的中断处理例程时。<br>第一级函数主要面向PIC的某一中断线IRQ line，第二级函数则面向该中断线上连接的具体设备，正如我们在前面图中看到的那样。<br>内核通过这种两级操作的方式除了可以增加设计的灵活性外，也可以获得某些额外的好处，比如后面将看到的设备软件中断号的探测机制等。</p>
<p>从上节的讨论可知，irq_desc[irq].handle_irq会被do_IRQ调用到，在Linux源码中handle_irq的类型声明如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/irq.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span>   <span class="title">void</span><span class="params">(*<span class="keyword">irq_flow_handler_t</span>)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq,struct irq_desc*desc)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>为了让平台的初始化代码能够通过handle_irq注册第一级中断处理函数，内核提供了两个接口函数：irq_set_handler和irq_set_chained_handler。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/irq.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span>  <span class="title">irq_set_handler</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq,<span class="keyword">irq_flow_handler_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __irq_set_handler(irq, handle, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span>  <span class="title">irq_set_chained_handler</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq,<span class="keyword">irq_flow_handler_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __irq_set_handler(irq, handle, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数handle就是要安装在irq_desc[irq].handle_irq上的第一级处理函数，最终的安装任务通过__irq_set_handler来完成。其原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/irq/chip.c&gt;</span><br><span class="line"><span class="keyword">void</span> __irq_set_handler(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_flow_handler_t</span> handle, <span class="keyword">int</span> is_chained,</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br></pre></td></tr></table></figure>
<p><code>__irq_set_handler</code>在对传递进来的参数作一些必要的检查后，将handle安装到irq_desc[irq]上：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">irq_desc[irq].handle_irq = handle;</span><br><span class="line">irq_desc[irq].name = name;</span><br></pre></td></tr></table></figure>
<p>参数is_chained用来表示irq_desc[irq]对应的项是否支持中断共享，如果是则将irq_desc[irq].status_use_accessors作如下设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc-&gt;status_use_accessors |= _IRQ_NOPROBE | _IRQ_NOREQUEST;</span><br></pre></td></tr></table></figure>
<p><code>_IRQ_NOREQUEST</code>意味着对于irq_desc[irq]而言，无法通过request_irq来安装中断处理例程。<code>_IRQ_NOPROBE</code>意味着无法对irq_desc[irq]执行中断号的探测机制。因此若irq_desc[irq]对应的项支持中断的共享，那么它将不能支持自动探测中断号，这是由自动探测机制的设计原理所决定的，后面会看到这一点。<br>作为handle_irq的一个具体实现例子，下面来看一个用来处理边沿中断触发信号的函数handle_edge_irq的主要实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/irq/chip.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_edge_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq,struct irq_desc*desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  raw_spin_lock(&amp;desc-&gt;lock);</span><br><span class="line">  desc-&gt;istate&amp;=~(IRQS_REPLAY|IRQS_WAITING);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">* If we're currently running this IRQ, or its disabled,</span></span><br><span class="line"><span class="comment">* we shouldn't process the IRQ. Mark it pending, handle</span></span><br><span class="line"><span class="comment">* the necessary masking and go out</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">if</span> (unlikely(irqd_irq_disabled(&amp;desc-&gt;irq_data) ||</span><br><span class="line">          irqd_irq_inprogress(&amp;desc-&gt;irq_data) || !desc-&gt;action)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!irq_check_poll(desc)) &#123;</span><br><span class="line">          desc-&gt;istate |= IRQS_PENDING;</span><br><span class="line">          mask_ack_irq(desc);</span><br><span class="line">          <span class="keyword">goto</span> out_unlock;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kstat_incr_irqs_this_cpu(irq,desc);</span><br><span class="line">  <span class="comment">/*Start handling the irq*/</span></span><br><span class="line">  desc-&gt;irq_data.chip-&gt;irq_ack(&amp;desc-&gt;irq_data);</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(unlikely(!desc-&gt;action))&#123;</span><br><span class="line">          mask_irq(desc);</span><br><span class="line">          <span class="keyword">goto</span> out_unlock;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * When another irq arrived while we were handling</span></span><br><span class="line"><span class="comment">    * one, we could have masked the irq.</span></span><br><span class="line"><span class="comment">    * Renable it, if it was not disabled in meantime.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">      <span class="keyword">if</span>(unlikely(desc-&gt;istate&amp;IRQS_PENDING))&#123;</span><br><span class="line">          <span class="keyword">if</span> (!irqd_irq_disabled(&amp;desc-&gt;irq_data) &amp;&amp;</span><br><span class="line">              irqd_irq_masked(&amp;desc-&gt;irq_data))</span><br><span class="line">                unmask_irq(desc);</span><br><span class="line">      &#125;</span><br><span class="line">      handle_irq_event(desc);</span><br><span class="line">  &#125;<span class="keyword">while</span>((desc-&gt;istate&amp;IRQS_PENDING)&amp;&amp;</span><br><span class="line">    !irqd_irq_disabled(&amp;desc-&gt;irq_data));</span><br><span class="line">out_unlock:</span><br><span class="line">  raw_spin_unlock(&amp;desc-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>desc-&gt;istate &amp;= ~( IRQS_REPLAY IRQS_WAITING)清除掉IRQ_REPLAY和IRQ_WAITING位，用来实现设备软件中断号的自动探测机制，稍后有专门的小节讨论如何自动探测中断号。<br>函数首先检查desc-&gt;irq_data中的state_use_accessors成员，确定其IRQD_IRQ_DISABLED或IRQD_IRQ_INPROGRESS位有没有被置1，这两位中的任一位被置1或者desc-&gt;action为空，handle_edge_irq函数都需要做进一步的特殊处理。<br>IRQD_IRQ_DISABLED表示当前的desc指向一个被禁止的中断线IRQ line，IRQD_IRQ_INPROGRESS表示当前的中断线正在处理中，同一中断irq的嵌套或者共享会出现该情况。<br>desc-&gt;action为空表示当前中断线上尚没有被安装特定的设备的中断ISR。<br>从设备驱动程序员的角度来看，这三种情况出现的概率较小，if条件中的unlikely也可说明这一点。这里的特殊处理是：</p>
<p>如果当前的中断线不处在正被轮询的阶段（IRQS_POLL_INPROGRESS），handle_edge_irq需要将desc-&gt;istate的IRQS_PENDING位置1，同时调用mask_ack_irq(desc)利用PIC对象的irq_mask例程将该条中断线在PIC中屏蔽掉，然后将IRQD_IRQ_MASKED位置1。<br>这样的处理其实很好理解：对一个正在被处理（因此没有必要作进一步处理），或者被disabled （当前的触发信号是非预期的，很可能是一种人为或者硬件线路的故障导致的“假”中断信号），或者压根儿没有安装设备中断处理例程ISR（没有设备在使用这根中断线），对于这样的中断线来说，这条正在触发中断信号的IRQ line都应该被屏蔽掉，当然为了后续的跟踪处理，IRQS_PENDING和IRQD_IRQ_MASKED位需要置1。<br>如果当前中断线正在被轮询，那么需要根据轮询的结果决定下一步的处理。<br>kstat_incr_irqs_this_cpu用来更新与中断相关的一些统计量，比如统计某一CPU上中断发生的次数。</p>
<p>经过上述这些步骤之后，可以正式进入下一阶段对该中断信号进行处理。handle_edge_irq首先调用desc-&gt;irq_data.chip-&gt;irq_ack(&amp;desc-&gt;irq_data)函数，利用PIC对象的irq_ack例程向设备发出一个中断响应信号，从硬件逻辑角度，这一步通常使得当前发出中断信号的设备中产生一个信号电平的转换，防止设备在它的中断已经在设备驱动程序中处理时依然不停地发出同一中断信号。</p>
<p>do while循环是handle_edge_irq函数的核心部分，通过调用handle_irq_event来对本次中断进行实际的处理操作。<br>do while中首先对当前irq对应的desc-&gt;action指针进行判断，如果action是个空指针表明到目前为止还没有设备驱动程序在这条中断线上安装中断处理例程ISR，对于这种情况的处理是调用mask_irq函数通过PIC对象的irq_mask例程来屏蔽掉当前中断线在PIC中对应的中断位，同时将desc-&gt;irq_data.state_use_accessors的IRQD_IRQ_MASKED位置1，这样做是合理的，对于一个没有安装中断处理函数的外部中断，应该屏蔽掉它直到它的处理函数被安装上，否则该设备将不停地中断处理器。<br>之后再次对desc-&gt;istate进行检查，如果发现有等待的中断信号出现而且是被屏蔽掉的，同时其所对应的中断线又没有被disable掉，则通过PIC的unmask函数取消对应设备的屏蔽位，这主要是针对中断处理例程在执行过程中又产生了新的中断这种情况，对于第二次出现的中断信号，handle_edge_irq做的处理是将desc-&gt;istate上的IRQS_PENDING位和desc-&gt;irq_data.state_use_accessors上的IRQD_IRQ_MASKED位置1，同时在PIC中将对应的中断线屏蔽掉。<br>这样当前的中断处理例程结束后while循环条件满足，重新执行do while，在接下来的新循环中，这个处于IRQS_PENDING状态的中断线在PIC中的屏蔽将被解除， IRQD_IRQ_MASKED位也被清除掉。</p>
<h2 id="handle-irq-event"><a href="#handle-irq-event" class="headerlink" title="handle_irq_event"></a>handle_irq_event</h2><p>函数handle_irq_event的工作比较简单，它为调用设备驱动程序安装的中断处理例程做最后的准备工作，比较容易急躁的读者此时也许还要耐心一点，不过我们很快就会看到与具体的设备中断处理例程相关的调用。<br>实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/irq/handle.c&gt;</span><br><span class="line"><span class="keyword">irqreturn_t</span> handle_irq_event(struct irq_desc *desc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span> = <span class="title">desc</span>-&gt;<span class="title">action</span>;</span></span><br><span class="line">    <span class="keyword">irqreturn_t</span> ret;</span><br><span class="line">    desc-&gt;istate &amp;= ~IRQS_PENDING;</span><br><span class="line">    irqd_set(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);</span><br><span class="line">    raw_spin_unlock(&amp;desc-&gt;lock);</span><br><span class="line">    ret = handle_irq_event_percpu(desc, action);</span><br><span class="line">    raw_spin_lock(&amp;desc-&gt;lock);</span><br><span class="line">    irqd_clear(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进入正式的设备中断处理例程之前，通过<code>desc-&gt;istate &amp;= ~IRQS_PENDING</code>语句清除掉IRQS_PENDING位，因为紧接下来就会调用设备的中断处理例程ISR，所以IRQS_PENDING不应再置1，同时需要将当前的中断线设置IRQD_IRQ_INPROGRESS状态，表明该中断线上一个中断正在被处理。<br>真正的设备驱动程序实现的中断处理函数例程的调用发生在handle_irq_event_percpu函数中，后者在源码中的实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/irq/handle.c&gt;</span><br><span class="line"><span class="keyword">irqreturn_t</span></span><br><span class="line">handle_irq_event_percpu(struct irq_desc *desc, struct irqaction *action)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">irqreturn_t</span> retval = IRQ_NONE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> random = <span class="number">0</span>, irq = desc-&gt;irq_data.irq;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">irqreturn_t</span> res;</span><br><span class="line">        trace_irq_handler_entry(irq, action);</span><br><span class="line">        res = action-&gt;handler(irq, action-&gt;dev_id);</span><br><span class="line">        trace_irq_handler_exit(irq, action, res);</span><br><span class="line">        <span class="keyword">if</span> (WARN_ONCE(!irqs_disabled(),<span class="string">"irq %u handler %pF enabled interrupts\n"</span>,</span><br><span class="line">                  irq, action-&gt;handler))</span><br><span class="line">              local_irq_disable();</span><br><span class="line">        <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">        <span class="keyword">case</span> IRQ_WAKE_THREAD:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">              * Set result to handled so the spurious check</span></span><br><span class="line"><span class="comment">              * does not trigger.</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">            res = IRQ_HANDLED;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">              * Catch drivers which return WAKE_THREAD but</span></span><br><span class="line"><span class="comment">              * did not set up a thread function</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">              <span class="keyword">if</span> (unlikely(!action-&gt;thread_fn)) &#123;</span><br><span class="line">                  warn_no_thread(irq, action);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            irq_wake_thread(desc, action);</span><br><span class="line">            <span class="comment">/* Fall through to add to randomness */</span></span><br><span class="line">        <span class="keyword">case</span> IRQ_HANDLED:</span><br><span class="line">            random |= action-&gt;flags;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        retval |= res;</span><br><span class="line">        action = action-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (action);</span><br><span class="line">    <span class="keyword">if</span> (random &amp; IRQF_SAMPLE_RANDOM)</span><br><span class="line">        add_interrupt_randomness(irq);</span><br><span class="line">    <span class="keyword">if</span> (!noirqdebug)</span><br><span class="line">        note_interrupt(irq, desc, retval);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的主体是一do while循环，用于遍历action可能形成的链表结构，当然大部分情况下，一个中断线只安装了一个设备中断处理例程，此时action对象并不构成链表，但是从代码中可以清楚地看到内核对同一中断线上多个设备共享中断的支持。<br>循环的一开始就通过action-&gt;handler来调用具体设备的中断处理例程（action对象中的handler由设备驱动程序通过request_irq函数进行安装，Linux下的设备驱动程序员对此应该不会陌生）。<br>函数接下来对action-&gt;handler调用的返回值进行处理，驱动程序中实现的中断处理例程函数绝大部分返回值IRQ_HANDLED，返回IRQ_WAKE_THREAD的情形相对比较少，如果返回的是IRQ_WAKE_THREAD，那么函数将调用irq_wake_thread来唤醒action-&gt;thread表示的一个内核线程，关于这种情形将在后续的中断安装部分予以讨论。<br>在结束一个具体设备的中断处理例程之后，函数通过action = action-&gt;next来获得action的下一个节点（如果节点存在的话）。</p>
<p>do while的循环条件是action-&gt;next不为空，这种情况表明正在处理一个共享的中断。对共享中断形成的链式结构的处理是遍历action链表，对每一个节点调用其上的handler函数。</p>
<h2 id="request-irq"><a href="#request-irq" class="headerlink" title="request_irq"></a>request_irq</h2><p>前面讲了Linux下处理一个外部中断的整个流程，其中大部分的工作都是由内核来完成，这里之所以用一定量的篇幅对其进行讨论，目的是希望读者对设备驱动程序提供的中断处理例程被调用时的上下文背景有个清晰的认识，这样我们才能知道如何去实现一个无安全隐患的中断处理例程。<br>现在开始讨论驱动程序如何与Linux的中断处理框架进行交互，向irq_desc数组中安装设备的中断处理例程。驱动程序中安装一个设备中断服务例程是通过调用request_irq函数完成的，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __must_check</span><br><span class="line">request_irq(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *dev)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的第一个参数irq是当前要安装的中断处理例程所对应的软中断号；handler就是已经多次提及的中断处理例程ISR，由设备驱动程序负责实现；flags是标志变量，可影响内核在安装ISR时的一些行为模式；name是当前安装中断ISR的设备名称，内核会在proc文件系统中生成name的一个入口点；dev是个传递到中断处理例程的指针，在中断共享的情形下，将在free_irq时被用到，以区分当前的free_irq要释放的是哪一个struct irqaction对象，因此必须确保dev参数在内核整个中断处理框架中的唯一性，由于内核在用request_irq安装一个中断处理例程时并不对dev的唯一性进行检查，因此设备驱动程序应该努力做到这一点，通常的做法是将设备驱动程序所管理的与设备相关的某一数据结构对象的指针作为dev的实参。<br>另外由于内核中断处理框架在调用设备驱动程序的ISR时，会将该dev参数一并传入，因此也可以借助它在被中断的进程与中断处理例程中传递数据之用。</p>
<p>request_irq函数的核心是通过调用request_threaded_irq完成中断处理函数的实际安装工作，可以看到request_irq在调用request_threaded_irq函数时传入的第三个参数是NULL，这个参数跟内核中一个用于中断处理的线程irq_thread有关，如果设备驱动程序通过request_irq来安装一个中断处理例程，因为对thread_fn传入的实参是NULL，所以不会涉及irq_thread部分，但是设备驱动程序也可以直接通过调用request_threaded_irq来安装中断，此时就有机会使用到irq_thread机制。request_threaded_irq函数的实现源码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/irq/manage.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_threaded_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">irq_handler_t</span> thread_fn, <span class="keyword">unsigned</span> <span class="keyword">long</span> irqflags,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">if</span> ((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    desc = irq_to_desc(irq);</span><br><span class="line">    <span class="keyword">if</span> (!desc)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!irq_settings_can_request(desc))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!thread_fn)</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    handler = irq_default_primary_handler;</span><br><span class="line">    &#125;</span><br><span class="line">    action = kzalloc(<span class="keyword">sizeof</span>(struct irqaction), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!action)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    action-&gt;handler = handler;</span><br><span class="line">    action-&gt;thread_fn = thread_fn;</span><br><span class="line">    action-&gt;flags = irqflags;</span><br><span class="line">    action-&gt;name = devname;</span><br><span class="line">    action-&gt;dev_id = dev_id;</span><br><span class="line">    chip_bus_lock(irq, desc);</span><br><span class="line">    retval = __setup_irq(irq, desc, action);</span><br><span class="line">    chip_bus_sync_unlock(irq, desc);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        kfree(action);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数一开始进行了一系列的检查。<br>比如如果irqflags中的IRQF_SHARED位被置1，表明正在安装一个共享的中断，这种情况下驱动程序必须提供dev_id，如果dev_id为空则是非法情况，因为在free_irq中将无法确定到底卸载哪一个action。<br>如果desc-&gt;status_use_accessors上的_IRQ_NOREQUEST位被置1，表明irq_desc数组中的这一项禁止通过request_threaded_irq来安装中断处理函数，也是非法情况。这些检查通过之后，函数调用kzalloc分配一块类型为struct irqaction的地址空间action，然后根据函数传入的参数初始化action，并调用<code>__setup_irq</code>来安装中断处理函数。<code>__setup_irq</code>的声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">__setup_irq(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, struct irq_desc *desc, struct irqaction *<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<p>因为中断安装时有诸多的细节需要内核仔细处理，所以__setup_irq函数的源码实现看起来比较冗长，但其实质性的工作其实就是将desc中的action成员指针指向要安装的中断处理例程。下面按照request_irq调用时desc-&gt;action是否为空分别进行讨论（先暂不考虑irq_thread机制）。</p>
<h3 id="desc-gt-action为空"><a href="#desc-gt-action为空" class="headerlink" title="desc-&gt;action为空"></a>desc-&gt;action为空</h3><p>这种情况比较简单，因为此时desc-&gt;action为空，意味着当前尚无设备驱动程序正在使用这条中断线，所以只需先获得指向desc-&gt;action的指针old_ptr：<code>struct irqaction **old_ptr =&amp;desc-&gt;action</code>，然后将<code>request_threaded_irq</code>中新分配的action指针赋值给old_ptr即可：<code>*old_ptr =new</code>;。<br>从设备驱动程序的角度而言，有几个需要注意的地方，如果设备驱动调用request_irq时，参数flags中设定了IRQF_TRIGGER_MASK标志位，表明驱动程序需要利用request_irq对irq的触发类型进行配置，因为<code>desc-&gt;irq_data</code>中的chip是PIC的抽象，所以此时只需调用chip中的irq_set_type成员函数就可配置PIC。系统定义的中断信号触发类型标志有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="comment">//上升沿触发</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_TRIGGER_RISING     0x00000001</span></span><br><span class="line"><span class="comment">//下降沿触发</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_TRIGGER_FALLING    0x00000002</span></span><br><span class="line"><span class="comment">//高电平触发</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_TRIGGER_HIGH       0x00000004</span></span><br><span class="line"><span class="comment">//低电平触发</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_TRIGGER_LOW        0x00000008</span></span><br><span class="line"><span class="comment">//中断触发信号掩码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_TRIGGER_MASK  (IRQF_TRIGGER_HIGH|IRQF_TRIGGER_LOW|\</span></span><br><span class="line">                        IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)</span><br></pre></td></tr></table></figure>
<p>设定中断触发信号类型的函数为__irq_set_trigger，其主要功能是通过PIC对象的irq_set_type成员函数设定当前中断线上有效的中断触发信号类型，同时将设定的类型记录到desc-&gt;irq_data.state_use_accessors中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/irq/manage.c&gt;</span><br><span class="line"><span class="keyword">int</span> __irq_set_trigger(struct irq_desc *desc, <span class="keyword">unsigned</span> <span class="keyword">int</span> irq,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> *<span class="title">chip</span> = <span class="title">desc</span>-&gt;<span class="title">irq_data</span>.<span class="title">chip</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret, unmask = <span class="number">0</span>;</span><br><span class="line">    …</span><br><span class="line">    ret = chip-&gt;irq_set_type(&amp;desc-&gt;irq_data, flags);</span><br><span class="line">    …</span><br><span class="line">    desc-&gt;irq_data. state_use_accessors &amp;= IRQD_TRIGGER_MASK;</span><br><span class="line">    desc-&gt;irq_data. state_use_accessors |= flags;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为不是共享中断的情形，所以当前的request_irq调用将独占irq所对应的中断线的所有权，可以根据设备自身需要随意设置其中断触发信号类型，这在存在中断共享的情形下是不可能的。<br>所以如果驱动程序需要将irq的触发信号配置成下降沿触发，可以作如下调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request_irq(irq, demo_handler, IRQF_TRIGGER_FALLING, NULL, NULL);</span><br></pre></td></tr></table></figure>
<h3 id="desc-gt-action不为空"><a href="#desc-gt-action不为空" class="headerlink" title="desc-&gt;action不为空"></a>desc-&gt;action不为空</h3><p>这种情形表明当前irq所对应的中断线此前已经被安装了中断处理函数，换言之，这意味着正在安装一个共享该irq的中断处理例程。在中断共享的情况下，事情变得有些复杂，因为在此之前至少有一个设备驱动程序在当前的中断线上安装了中断处理例程，此时内核再安装一个新的中断处理例程就有了相当的限制，一个大体的原则是，新的安装不能破坏之前已有的中断工作模式。<br>从代码的角度，新的irqaction对象的flags成员必须与action链上已有的节点的flags成员作检查比较，如果有不一致的情形出现，安装将不会成功，函数返回一个错误码-EBUSY。<br>被检查的flags标志有IRQF_SHARED、IRQF_TRIGGER_MASK、IRQF_ONESHOT及IRQF_PERCPU，这些都是设备驱动程序在调用request_irq时通过参数flags传入的标志位。</p>
<p>在共享中断的情形下，如果新的request_irq调用去设定当前的触发信号的类型，<code>__setup_irq</code>函数并不会去真正调用PIC对象的irq_set_type函数，而只是检查当前要设定的中断触发信号类型是否与这条线上已经设定的类型相符，如果不符合，<code>__setup_irq</code>会给出一个警告信息，当前的安装虽然可以成功，但是未必能如预期的那样正常工作。<br>如果这些检查都成功通过，那么request_irq此时要做的是，将新分配的action加到action链的末尾。</p>
<p>在<code>__setup_irq</code>函数的结束部分，如果desc-&gt;dir还是空，那么调用register_irq_proc在/proc/irq目录下创建类似/proc/irq/125这样的新目录项。最后调用的register_handler_proc在action-&gt;name不为空的情况下，会为此新action在proc文件系统中创建类似/proc/irq/125/action_name这样的目录。<br>内核通过这些proc文件系统的操作，可以方便开发者在用户空间查看系统中设备驱动程序的中断安装情况，例如x86平台上对应irq=45的proc文件系统节点的下列输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@AMDLinuxFGL:/proc/irq/<span class="number">45</span><span class="meta"># ll</span></span><br><span class="line">total <span class="number">0</span></span><br><span class="line">dr-xr-xr-x <span class="number">3</span>    root root <span class="number">0</span>   Aug <span class="number">6</span>   <span class="number">17</span>:<span class="number">48.</span></span><br><span class="line">dr-xr-xr-x <span class="number">27</span>   root root <span class="number">0</span>   Aug <span class="number">6</span>   <span class="number">17</span>:<span class="number">44.</span>.</span><br><span class="line">-r--------  <span class="number">1</span>   root root <span class="number">0</span>   Aug <span class="number">6</span>   <span class="number">17</span>:<span class="number">48</span>affinity_hint</span><br><span class="line">dr-xr-xr-x <span class="number">2</span>    root root <span class="number">0</span>   Aug <span class="number">6</span>   <span class="number">17</span>:<span class="number">48</span>hda_intel</span><br><span class="line">-r--r--r--  <span class="number">1</span>   root root <span class="number">0</span>   Aug <span class="number">6</span>   <span class="number">17</span>:<span class="number">48</span>node</span><br><span class="line">-rw------- <span class="number">1</span>    root root <span class="number">0</span>   Aug <span class="number">6</span>   <span class="number">17</span>:<span class="number">48</span>smp_affinity</span><br><span class="line">-r--r--r--  <span class="number">1</span>   root root <span class="number">0</span>   Aug <span class="number">6</span>   <span class="number">17</span>:<span class="number">48</span>spurious</span><br></pre></td></tr></table></figure>
<h2 id="中断处理的irq-thread机制"><a href="#中断处理的irq-thread机制" class="headerlink" title="中断处理的irq_thread机制"></a>中断处理的irq_thread机制</h2><p>下面再简单讨论一下内核为中断处理提供的另一种机制，这种机制在设备驱动程序通过调用request_threaded_irq函数来安装一个中断时，需要在struct irqaction对象中实现它的thread_fn成员。<br>request_threaded_irq函数内部会生成一个名为irq_thread的独立线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/irq/manage.c&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">__setup_irq(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, struct irq_desc *desc, struct irqaction *<span class="keyword">new</span>)</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>-&gt;thread_fn &amp;&amp; !nested) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span>;</span></span><br><span class="line">        t = kthread_create(irq_thread, <span class="keyword">new</span>, <span class="string">"irq/%d-%s"</span>, irq,</span><br><span class="line">                  <span class="keyword">new</span>-&gt;name);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(t))</span><br><span class="line">            <span class="keyword">return</span> PTR_ERR(t);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * We keep the reference to the task struct even if</span></span><br><span class="line"><span class="comment">        * the thread dies to avoid that the interrupt code</span></span><br><span class="line"><span class="comment">        * references an already freed task_struct.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        get_task_struct(t);</span><br><span class="line">        <span class="keyword">new</span>-&gt;thread = t;</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>irq_thread线程被创建出来时将以TASK_INTERRUPTIBLE的状态睡眠等待中断的发生，当中断发生时action-&gt;handler只负责唤醒睡眠的irq_thread，后者将调用action-&gt;thread_fn进行实际的中断处理工作。<br>因为irq_thread本质上是系统中的一个独立进程，所以采用这种机制将使实质的中断处理工作发生在进程空间，而不是中断的上下文中。</p>
<h2 id="free-irq"><a href="#free-irq" class="headerlink" title="free_irq"></a>free_irq</h2><p>通过request_irq安装的中断处理函数，如果不再需要的话应该调用free_irq予以释放。<br>free_irq完成的任务和request_irq正好相反，其声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">free_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> * dev_id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>根据第一个参数irq，函数在irq_desc数组中查找对应的action，遍历该action所在的链表，如果有action-&gt;dev_id == dev_id，那么就找到了要释放的action。<br>找到后调用kfree释放action所占的空间。如果释放的action是irq_desc[irq]中唯一的一个action节点，那么释放后还需要把desc-&gt;irq_data.state_use_accessors的IRQD_DISABLED位置1，同时调用irq_desc[irq].chip的irq_shutdown或者irq_disable/irq_mask函数在PIC中屏蔽掉irq所对应的外部设备中断线。<br>request_irq中建立的proc文件系统节点也将被删除。</p>
<h2 id="SOFTIRQ"><a href="#SOFTIRQ" class="headerlink" title="SOFTIRQ"></a>SOFTIRQ</h2><p>前面讨论了HARDIRQ的执行流程，下面再来看看Linux内核如何实现SOFTIRQ。SOFTIRQ的处理是在do_IRQ函数的irq_exit中实现的，irq_exit函数中实现SOFTIRQ调用的代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">irq_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    sub_preempt_count(IRQ_EXIT_OFFSET);</span><br><span class="line">    <span class="keyword">if</span> (!in_interrupt() &amp;&amp; local_softirq_pending())</span><br><span class="line">        invoke_softirq();</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数首先把当前栈中的preempt_count变量减去IRQ_EXIT_OFFSET来标识一个HARDIRQ中断上下文的结束：preempt_count() -= IRQ_EXIT_OFFSET，这步动作对应do_IRQ中的irq_enter。<br>在没有配置内核可抢占的系统中，IRQ_EXIT_OFFSET=HARDIRQ_OFFSET；如果配置了可抢占，那么IRQ_EXIT_OFFSET=(HARDIRQ_OFFSET-1)，意味着在HARDIRQ部分结束之后，内核已经启动可抢占性。</p>
<p>invoke_softirq是真正处理SOFTIRQ部分的函数，不过这个函数的调用有个前提，就是if中的两个条件：in_interrupt和local_softirq_pending。in_interrupt是个宏，展开为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/hardirq.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_interrupt()  (preempt_count()&amp;(HARDIRQ_MASK|SOFTIRQ_MASK|NMI_MASK))</span></span><br></pre></td></tr></table></figure></p>
<p>其主要用意是根据当前栈中的preempt_count变量，来判断当前是否在一个中断上下文中执行。<br>根据in_interrupt的定义来看，Linux内核认为HARDIRQ、SOFTIRQ和NMI都属于interrupt范畴。<br>对于HARDIRQ，前面讨论do_IRQ时可以看到在irq_enter和irq_exit之间，内核在preempt_count()上标示了HARDIRQ_OFFSET，表示这是个HARDIRQ的上下文。</p>
<p>Linux内核对preempt_count的使用如图所示：</p>
<p><img src="/2021/10/13/linux-interrupt/image-75.jpg" width="500px"></p>
<p>由图可见，preempt_count的低8位与PREEMPT相关，8~15位留给SOFTIRQ使用，16~25位给HARDIRQ使用，NMI占据1位。local_softirq_pending也是一个宏，展开为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/irq_cpustat.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> local_softirq_pending()   (irq_stat[smp_processor_id()].__softirq_pending)</span></span><br></pre></td></tr></table></figure>
<p>irq_stat是个数组，其具体定义取决于__ARCH_IRQ_STAT宏，在大部分体系架构中这是个per-CPU变量，比如对于x86平台：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/x86/include/<span class="keyword">asm</span>/hardirq.h&gt;</span><br><span class="line">DECLARE_PER_CPU_SHARED_ALIGNED(<span class="keyword">irq_cpustat_t</span>, irq_stat);</span><br></pre></td></tr></table></figure>
<p>如果没有定义__ARCH_IRQ_STAT，那么irq_stat定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ARCH_IRQ_STAT</span></span><br><span class="line"><span class="keyword">irq_cpustat_t</span> irq_stat[NR_CPUS] ____cacheline_aligned;</span><br><span class="line">EXPORT_SYMBOL(irq_stat);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>基本上可以认为这是个per-CPU变量，系统中的每个CPU都拥有各自的副本。其类型irq_cpustat_t定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/<span class="keyword">asm</span>-generic/hardirq.h&gt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __softirq_pending;</span><br><span class="line">&#125; ____cacheline_aligned <span class="keyword">irq_cpustat_t</span>;</span><br></pre></td></tr></table></figure>
<p>内核用一个无符号整型<code>__softirq_pending</code>来表示当前正在等待被处理的softirq，每一种softirq在<code>__softirq_pending</code>中占据一位，每个CPU都拥有自己的<code>__softirq_pending</code>变量。<br>回到irq_exit，现在知道invoke_softirq被调用的前提是：当前不在interrupt上下文中而且<code>__softirq_pending</code>中有等待的softirq。当前不在interrupt上下文中保证了如果代码正在SOFTIRQ部分执行时（此时处理器可以处理外部中断），如果发生了一个外部中断，那么在中断处理函数结束HARDIRQ部分时，将不会处理softirq，而是直接返回，这样此前被中断的SOFTIRQ部分将继续执行。</p>
<p>现在开始讨论softirq的处理部分，invoke_softirq是一个宏，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ARCH_IRQ_EXIT_IRQS_DISABLED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> invoke_softirq()    __do_softirq()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> invoke_softirq()     do_softirq()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>__ARCH_IRQ_EXIT_IRQS_DISABLED</code>是个体系架构相关的宏，用来决定在HARDIRQ部分结束时，有没有关闭处理器响应外部中断的能力。<br>如果定义了<code>__ARCH_IRQ_EXIT_IRQS_DISABLED</code>，就意味着在处理SOFTIRQ部分时，可以保证外部中断已经关闭，此时可以直接调用<code>__do_softirq</code>，否则调用do_softirq，后者最终会调用到<code>__do_softirq</code>，不过之前要做一些中断屏蔽的事情，保证<code>__do_softirq</code>开始执行时中断是关闭的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> <span class="title">do_softirq</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __u32 pending;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">if</span> (in_interrupt())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    local_irq_save(flags);</span><br><span class="line">    pending = local_softirq_pending();</span><br><span class="line">    <span class="keyword">if</span> (pending)</span><br><span class="line">        __do_softirq();</span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__do_softirq</code>的核心代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SOFTIRQ_RESTART 10</span></span><br><span class="line">asmlinkage <span class="keyword">void</span> __do_softirq(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> *<span class="title">h</span>;</span></span><br><span class="line">    __u32 pending;</span><br><span class="line">    <span class="keyword">int</span> max_restart = MAX_SOFTIRQ_RESTART;</span><br><span class="line">    <span class="keyword">int</span> cpu;</span><br><span class="line">    pending = local_softirq_pending();</span><br><span class="line">    __local_bh_disable((<span class="keyword">unsigned</span> <span class="keyword">long</span>)__builtin_return_address(<span class="number">0</span>));</span><br><span class="line">    cpu = smp_processor_id();</span><br><span class="line">restart:</span><br><span class="line">    set_softirq_pending(<span class="number">0</span>);</span><br><span class="line">    local_irq_enable();</span><br><span class="line">    h = softirq_vec;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pending &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            h-&gt;action(h);</span><br><span class="line">        &#125;</span><br><span class="line">        h++;</span><br><span class="line">        pending &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pending);</span><br><span class="line">    local_irq_disable();</span><br><span class="line">    pending = local_softirq_pending();</span><br><span class="line">    <span class="keyword">if</span> (pending &amp;&amp; --max_restart)</span><br><span class="line">        <span class="keyword">goto</span> restart;</span><br><span class="line">    <span class="keyword">if</span> (pending)</span><br><span class="line">        wakeup_softirqd();</span><br><span class="line">    _local_bh_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在具体讨论这个函数之前，先看看系统定义的几个softirq的类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">    TIMER_SOFTIRQ,</span><br><span class="line">    NET_TX_SOFTIRQ,</span><br><span class="line">    NET_RX_SOFTIRQ,</span><br><span class="line">    BLOCK_SOFTIRQ,</span><br><span class="line">    BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">    TASKLET_SOFTIRQ,</span><br><span class="line">    SCHED_SOFTIRQ,</span><br><span class="line">    HRTIMER_SOFTIRQ,</span><br><span class="line">    RCU_SOFTIRQ,</span><br><span class="line">    NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个softirq对应<code>__softirq_pending</code>中的一个位。其中，HI_SOFTIRQ和TASKLET_SOFTIRQ用来实现tasklet，TIMER_SOFTIRQ和HRTIMER_SOFTIRQ用于定时器,NET_TX_SOFTIRQ和NET_RX_SOFTIRQ用于网络设备的发送和接收操作，BLOCK_SOFTIRQ和BLOCK_IOPOLL_SOFTIRQ用于块设备的操作，SCHED_SOFTIRQ用于调度器。内核在此基础上定义了一个struct softirq_action类型的数值softirq_vec，用来放置softirq对应的处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*action)(struct softirq_action*);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span>  <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>]__<span class="title">cacheline_aligned_in_smp</span>;</span></span><br></pre></td></tr></table></figure>
<p>所以<code>__do_softirq</code>的核心思想是：从CPU本地的<strong>softirq_pending的最低位开始，依次往高位扫描，如果发现某位为1，说明对应该位有个等待中的softirq需要处理，那么就调用softirq_vec数组中对应项的action函数。这个过程会一直持续下去，直到`</strong>softirq_pending`为0。具体的函数实现上，有以下几点需要注意：</p>
<ul>
<li><code>__local_bh_disable</code>和<code>_local_bh_enable</code>用来在preempt_count()上标示SOFTIRQ的上下文，考虑到SOFTIRQ执行过程可能会被外部中断的情况，这可以防止SOFTIRQ部分的重入，因为只有在非interrupt的上下文中才可以进入到SOFTIRQ部分。</li>
<li>在执行softirq的前后分别调用了local_irq_enable和local_irq_disable，这说明SOFTIRQ部分在执行时处理器可以响应并处理外部的中断。</li>
<li>softirq执行的先后顺序由__softirq_pending中的位决定，低位的softirq要先于高位的softirq执行。</li>
<li>在do while循环之后，会再次检测__softirq_pending是否为0，这主要是因为SOFTIRQ在执行过程中可能被外部设备中断，其设备驱动程序在实现该中断处理函数时可能使用了一个softirq，因此在do while循环之后，需要检测有没有新加入的softirq需要处理。</li>
<li>如果上面第3步的动作执行超过一定的次数，则需要唤醒ksoftirqd来处理。因为如果在SOFTIRQ部分耗费太多的时间，会导致一个中断处理流程迟迟无法结束，这意味着此前被中断的任务无法继续运行。为了避免这种情况，Linux系统在初始化期间生成了一个新的进程ksoftirqd，该进程运行时要完成的主要任务就是调用do_softirq来执行等待中的softirq，如果没有softirq需要处理，该进程将进入睡眠状态。</li>
</ul>
<p>因此为了避免在一个中断的SOFTIRQ部分耗费太多时间处理softirq导致该中断流程迟迟无法结束，<code>__do_softirq</code>通过wakeup_softirqd唤醒ksoftirqd，让调度器来平衡当前中断在SOFTIRQ部分的工作负荷。</p>
<h2 id="irq的自动探测"><a href="#irq的自动探测" class="headerlink" title="irq的自动探测"></a>irq的自动探测</h2><p>如果一个设备的驱动程序无法确定它所管理的设备的软件中断号irq，此时设备驱动程序可以使用irq的自动探测机制来获得其正在使用的irq。<br>内核为此提供了几个接口函数供驱动程序使用，需要注意的是，中断探测机制的实现需要内核和驱动程序共同努力才能完成，并且这种探测只限于非共享中断的情况，因此只有当一个设备能确定其irq不会与别的设备共享时，才可以使用这里的探测。<br>探测前的情形是，该设备关联到了某个irq，但是因为设备驱动程序还不清楚是哪个irq，因此不可能调用request_irq来向该irq安装中断处理例程，所以对应该irq的action为空。探测要完成的任务是找到该设备所关联的irq。</p>
<p>探测的原理是，调用probe_irq_on函数遍历整个irq_desc数组，对于每个action为空的元素且在该项允许自动探测的情形下，将其istate上的IRQS_WAITING位置1，然后让设备产生一次中断，irq_desc数组中与该设备irq关联的那一项的第一级中断函数handle_irq会被调用，后者将会清除IRQS_WAITING位，然后调用probe_irq_off再遍历一遍irq_desc数组，对于每个action为空的元素，查看其istate上的IRQS_WAITING位是否被清0，如果是那么该元素对应的irq就是正与目前设备关联的。</p>
<p>以下是一个设备驱动程序用来实现自动探测的代码序列的示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> irqs;</span><br><span class="line"><span class="comment">//清除设备内部的中断</span></span><br><span class="line">…</span><br><span class="line">irqs=probe_irq_on();</span><br><span class="line"><span class="comment">/*等待5ms*/</span></span><br><span class="line">msleep(<span class="number">5</span>);</span><br><span class="line"><span class="comment">/*让设备产生一次中断 */</span></span><br><span class="line">…</span><br><span class="line"><span class="comment">/*等待5ms*/</span></span><br><span class="line">msleep(<span class="number">5</span>);</span><br><span class="line"><span class="comment">/* 得到探测到的中断号 */</span></span><br><span class="line">irq=probe_irq_off(irqs);</span><br></pre></td></tr></table></figure>
<p>这段代码中用到了probe_irq_on和probe_irq_off两个函数，它们都是内核为驱动程序实现的自动探测接口函数，下面将看到这两个函数的实现原理。<br>probe_irq_on函数的核心代码是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/irq/autoprobe.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">probe_irq_on</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * quiesce the kernel, or at least the asynchronous portion</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    async_synchronize_full();</span><br><span class="line">    mutex_lock(&amp;probing_active);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * something may have generated an irq long ago and we want to</span></span><br><span class="line"><span class="comment">    * flush such a longstanding irq before considering it as spurious.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">for_each_irq_desc_reverse(i, desc) &#123;</span><br><span class="line">        raw_spin_lock_irq(&amp;desc-&gt;lock);</span><br><span class="line">        <span class="keyword">if</span> (!desc-&gt;action &amp;&amp; irq_settings_can_probe(desc)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">              * Some chips need to know about probing in</span></span><br><span class="line"><span class="comment">              * progress:</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">            <span class="keyword">if</span> (desc-&gt;irq_data.chip-&gt;irq_set_type)</span><br><span class="line">                  desc-&gt;irq_data.chip-&gt;irq_set_type(&amp;desc-&gt;irq_data,</span><br><span class="line">                          IRQ_TYPE_PROBE);</span><br><span class="line">            irq_startup(desc);</span><br><span class="line">        &#125;</span><br><span class="line">        raw_spin_unlock_irq(&amp;desc-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Wait for longstanding interrupts to trigger. */</span></span><br><span class="line">        &#125;</span><br><span class="line">        raw_spin_unlock_irq(&amp;desc-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    msleep(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * enable any unassigned irqs</span></span><br><span class="line"><span class="comment">    * (we must startup again here because if a longstanding irq</span></span><br><span class="line"><span class="comment">    * happened in the previous stage, it may have masked itself)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  for_each_irq_desc_reverse(i, desc) &#123;</span><br><span class="line">        raw_spin_lock_irq(&amp;desc-&gt;lock);</span><br><span class="line">        <span class="keyword">if</span> (!desc-&gt;action &amp;&amp; irq_settings_can_probe(desc)) &#123;</span><br><span class="line">            desc-&gt;istate |= IRQS_AUTODETECT | IRQS_WAITING;</span><br><span class="line">            <span class="keyword">if</span> (irq_startup(desc))</span><br><span class="line">                desc-&gt;istate |= IRQS_PENDING;</span><br><span class="line">        &#125;</span><br><span class="line">        raw_spin_unlock_irq(&amp;desc-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        raw_spin_unlock_irq(&amp;desc-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * Wait for spurious interrupts to trigger</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    msleep(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * Now filter out any obviously spurious interrupts</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">  for_each_irq_desc(i, desc) &#123;</span><br><span class="line">        raw_spin_lock_irq(&amp;desc-&gt;lock);</span><br><span class="line">        <span class="keyword">if</span> (desc-&gt;istate &amp; IRQS_AUTODETECT) &#123;</span><br><span class="line">            <span class="comment">/* It triggered already - consider it spurious. */</span></span><br><span class="line">            <span class="keyword">if</span> (!(desc-&gt;istate &amp; IRQS_WAITING)) &#123;</span><br><span class="line">                  desc-&gt;istate &amp;= ~IRQS_AUTODETECT;</span><br><span class="line">                  irq_shutdown(desc);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                  <span class="keyword">if</span> (i &lt; <span class="number">32</span>)</span><br><span class="line">                        mask |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        raw_spin_unlock_irq(&amp;desc-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的主体是三个for_each_irq_desc所引导的循环。</p>
<ul>
<li>第一个for_each_irq_desc循环从后向前遍历irq_desc数组，遍历过程中对于每一个desc，只要能满足desc-&gt;action为空并且desc-&gt;status_use_accessors没有设置_IRQ_NOPROBE位，那么就通过PIC中的irq_startup函数把对应的中断启用起来。desc-&gt;action为空说明该irq上还没有安装中断处理例程， desc-&gt;status_use_accessors没有设置_IRQ_NOPROBE位说明该desc允许被探测，设备所关联的irq只可能存在满足这两个条件的desc中。</li>
<li><p>第二个for_each_irq_desc循环依旧从后向前遍历irq_desc数组，对于满足desc-&gt;action为空并且desc-&gt;status_use_accessors没有设置_IRQ_NOPROBE位的desc，将其istate重新设置为：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc-&gt;istate |= IRQS_AUTODETECT | IRQS_WAITING;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三个for_each_irq_desc循环从前向后遍历irq_desc数组，对于满足(desc-&gt;istate &amp;IRQS_AUTODETECT) != 0的每一个desc，说明它正是我们在探测的元素，此时检查desc-&gt;istate上的IRQS_WAITING位有没有被置1。因为根据探测的流程，在调用probe_irq_on时，驱动程序还没有让设备产生中断，因此IRQS_WAITING位不可能被清0，如果它被清0，说明该desc上的第一级函数被调用了，这意味着这个irq所对应的中断线上正在产生无意义的触发信号（不可能是由安装了ISR的正常设备所产生，因为request_irq在安装ISR时会清除掉IRQS_AUTODETECT位），对此的处理是通过PIC屏蔽该中断，然后继续查找下一个irq_desc元素。</p>
</li>
</ul>
<p>这个函数的返回值如同probe_irq_off中的参数一样并无实际的用途。<br>当probe_irq_off被调用时，驱动程序已经让设备产生了一次中断，所以probe_irq_off需要使用for_each_irq_desc循环从前向后遍历irq_desc数组，试图找到这样一个desc：(desc-&gt;istate &amp;IRQS_AUTODETECT) != 0并且desc-&gt;istate的IRQS_WAITING位被清除，这正是probe_irq_off的主要流程。<br>如果找到了设备所关联的irq就返回之，否则函数返回0。</p>
<h2 id="中断处理例程"><a href="#中断处理例程" class="headerlink" title="中断处理例程"></a>中断处理例程</h2><p>如果设备需要通过中断这种方式与处理器进行沟通，那么它的驱动程序就有必要实现一个中断处理例程并负责把它安装到系统中，这样当设备的中断信号来临时，处理器才可能调用到它的处理例程。<br>虽然中断处理例程不过是种普通的函数，但是内核作为这种游戏规则的制定者，为了确保一切尽在它的掌握之中，对于中断处理例程的实现有着特定的要求。<br>首先从中断处理例程的原型看，它必须与struct irqaction中handler函数指针的原型保持一致。<br>这很正常，因为中断处理例程的安装，本质上是让这个指针指向中断处理例程。</p>
<p>handler的原型前面提过，这里再重复一遍：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">irqreturn_t</span> <span class="params">(*<span class="keyword">irq_handler_t</span>)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span> *)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>因此一个实际的中断处理例程应该这样声明自己：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">irqreturn_t</span> demo_isr(<span class="keyword">int</span> irq, <span class="keyword">void</span> * dev_id);</span><br></pre></td></tr></table></figure>
<p>函数的返回值是个irqreturn_t类型，该类型在内核源码中的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/irqreturn.h&gt;</span><br><span class="line"><span class="keyword">enum</span> irqreturn &#123;</span><br><span class="line">    IRQ_NONE,</span><br><span class="line">    IRQ_HANDLED,</span><br><span class="line">    IRQ_WAKE_THREAD,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> irqreturn <span class="keyword">irqreturn_t</span>;</span><br></pre></td></tr></table></figure>
<p>因此，中断处理例程只能有三种返回值，分别是</p>
<ul>
<li>IRQ_NONE中断例程发现正在处理一个不是自己的设备触发的中断，此时它唯一要做的就是返回该值。</li>
<li>IRQ_HANDLED中断处理例程成功地处理了自己设备的中断，返回该值。</li>
<li>IRQ_WAKE_THREAD中断处理例程被用来作唤醒一个等待在它的irq上的一个进程使用，此时它返回该值。</li>
</ul>
<p>其次，中断处理例程是在中断上下文中执行，这对它的实现提出了某些限制。因为中断上下文不隶属于某个进程，在这里current指针不再有意义，它们游离在Linux进程世界的边缘，因此在这种环境下绝对禁止任何形式的进程切换。实际的代码实现中，确保中断处理上下文中不出现进程的切换并不是件容易的事，需要仔细审查中断处理例程中的每行代码，包括调用的每一个函数，确保它们不会进入睡眠状态而使调度器介入其中。<br>一个典型的例子是在中断处理例程中使用内存分配函数kmalloc，如果在调用这个函数时使用了GFP_KERNEL标志而不是GFP_ATOMIC，那么很小的概率下会因为内存难以满足需求而进入睡眠，虽然大部分时间都不会遇到麻烦，但是偶尔出现的睡眠将会带来真正的大麻烦。</p>
<p>最后，中断处理例程作为系统中的一种并发源头，可能会去访问一些共享的资源，如果不幸恰好有别的进程（最典型的是被它中断的进程）也在使用同样的共享资源，竞态将不可避免，因此需要考虑互斥的机制来保护。<br>内核所提供的用于互斥的各种机制，在中断处理例程中使用这些机制需要格外小心，防止出现睡眠的可能性，因此信号量和互斥锁首先就会被排除掉，绝大多数的情况你需要使用自旋锁spin lock及其变体。</p>
<h2 id="中断共享"><a href="#中断共享" class="headerlink" title="中断共享"></a>中断共享</h2><p>即便PIC已经提供足够多的中断引脚供外部设备使用，但也有不够用的时候，此时中断共享机制可能就会派上用场。所谓中断共享是指多个设备共享一根中断线，使用同一个irq。<br>对驱动程序来说，需要注意的地方在调用request_irq和中断处理例程的实现上。对于一个共享的中断，驱动程序在调用request_irq时应该使用IRQF_SHARED标志，同时提供dev_id，提供的dev_id在中断处理例程中并没有什么特别的用处，之所以要求在中断共享时提供这个参数，主要是为了在free_irq时能在action链中找到它，因此这个dev_id在中断共享的action链中应该具有唯一性，实际使用中可以像下面这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pDev是一个指向设备相关的结构体的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">demo_dev</span>*<span class="title">pDev</span>=…</span></span><br><span class="line"><span class="class">//<span class="title">request_irq</span></span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">retval</span>=<span class="title">request_irq</span>(<span class="title">irq</span>,<span class="title">demo_isr</span>,<span class="title">IRQF_SHARED</span>,"<span class="title">demo</span> <span class="title">device</span>",<span class="title">pDev</span>);</span></span><br></pre></td></tr></table></figure>
<p>接下来是中断共享时的中断处理例程的实现，因为当irq上的中断发生时，内核会调用irq上的每个action中的handler，因此即便不是你的设备产生的中断，你的中断处理例程ISR也会被调用到，因此共享中断时的ISR需要能判断是否是自己的设备产生的中断，这主要靠读取自己设备的中断状态寄存器来完成。如果发现你的设备没有产生中断，那么ISR只需要返回一个IRQ_NONE就好了，下面是一个共享中断下的ISR的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">irqreturn_t</span>  demo_isr(<span class="keyword">int</span> irq,<span class="keyword">void</span>*dev_id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//读取设备中断状态寄存器</span></span><br><span class="line">    status=read_intr_reg(…);</span><br><span class="line">    <span class="comment">//判断自己的设备有没有产生中断，没有的话直接返回IRQ_NONE</span></span><br><span class="line">    <span class="keyword">if</span>(status&amp;…)&#123;</span><br><span class="line">        <span class="keyword">return</span> IRQ_NONE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//中断处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>讨论了Linux下一个外部中断发生后的整个处理流程。通过内核精心设计的中断处理框架，如果一个设备驱动程序为其所管理的设备通过request_irq注册了中断处理例程，那么该设备产生的中断在中断处理框架中经过多层的调用，最终会进入到该中断处理例程中来。<br>可以看到这其中大部分的任务来自于内核的代码（嵌入式系统还需要BSP代码）。</p>
<p>驱动程序对中断的支持相对简单，只需要实现中断处理例程函数并调用request_irq向系统注册即可，在某些特定的情形下，设备驱动程序也可以使用request_threaded_irq函数来向系统注册中断处理例程，比如需要使用irq_thread机制。<br>了解整个中断处理流程，有助于了解中断处理例程的执行环境，避免因为不安全的中断例程实现给系统造成负面影响。<br>Linux内核将中断处理分成了HARDIRQ和SOFTIRQ两部分。HARDIRQ在执行时中断是关闭的，因此这部分的代码应该完成中断处理中最关键的任务，执行时间也应尽可能短。如果需要执行时间很长的操作，可以将其延迟到SOFTIRQ部分执行，因为SOFTIRQ部分在执行时处理器的中断是打开的。</p>
<p><br><br><br></p>
<h1 id="中断下半部细节"><a href="#中断下半部细节" class="headerlink" title="中断下半部细节"></a>中断下半部细节</h1><p>inux内核将对一个外部设备中断的处理分成两大部分HARDIRQ和SOFTIRQ，因为HARDIRQ部分在执行时处理器的中断是关闭的，所以驱动程序的中断处理例程在这部分只应该完成一些关键的中断操作，而将耗时的工作延迟到SOFTIRQ部分执行。<br>内核为此给驱动程序提供了一个基于SOFTIRQ的任务延迟的实现机制tasklet。因为tasklet需要在中断上下文中执行，所以有些延迟的操作无法用tasklet来完成，为此内核又提供了一个基于进程的延迟操作实现机制——工作队列work queue。</p>
<p>本节将先描述tasklet和工作队列的内核实现机制，然后再分别讨论设备驱动程序如何使用它们来实现延迟的操作。<br>当然驱动程序中可以使用的延迟操作机制并非只有softirq/tasklet和工作队列workqueue这两种，比如定时器timer也可以用来实现延迟的操作。</p>
<h2 id="tasklet-1"><a href="#tasklet-1" class="headerlink" title="tasklet"></a>tasklet</h2><p>tasklet是内核定义的几种softirq之一，设备驱动程序的中断处理例程常常利用tasklet来完成一些延后的处理。<br>根据优先级的不同，内核将tasklet分成两种，在softirq中对应TASKLET_SOFTIRQ和HI_SOFTIRQ，后者的执行顺序优于前者。</p>
<blockquote>
<p>Linux内核定义的softirq有：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">    TIMER_SOFTIRQ,</span><br><span class="line">    NET_TX_SOFTIRQ,</span><br><span class="line">    NET_RX_SOFTIRQ,</span><br><span class="line">    BLOCK_SOFTIRQ,</span><br><span class="line">    BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">    TASKLET_SOFTIRQ,</span><br><span class="line">    SCHED_SOFTIRQ,</span><br><span class="line">    HRTIMER_SOFTIRQ,</span><br><span class="line">    RCU_SOFTIRQ, <span class="comment">/*Preferable RCU should always be the last softirq*/</span></span><br><span class="line">    NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中HI_SOFTIRQ和TASKLET_SOFTIRQ就是本章要讨论的主题tasklet。</p>
<h3 id="tasklet机制初始化"><a href="#tasklet机制初始化" class="headerlink" title="tasklet机制初始化"></a>tasklet机制初始化</h3><p>Linux系统初始化期间通过调用softirq_init为TASKLET_SOFTIRQ和HI_SOFTIRQ安装了执行函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">softirq_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cpu;</span><br><span class="line">    for_each_possible_cpu(cpu) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        per_cpu(tasklet_vec, cpu).tail =</span><br><span class="line">            &amp;per_cpu(tasklet_vec, cpu).head;</span><br><span class="line">        per_cpu(tasklet_hi_vec, cpu).tail =</span><br><span class="line">            &amp;per_cpu(tasklet_hi_vec, cpu).head;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_SOFTIRQS; i++)</span><br><span class="line">            INIT_LIST_HEAD(&amp;per_cpu(softirq_work_list[i], cpu));</span><br><span class="line">    &#125;</span><br><span class="line">    register_hotcpu_notifier(&amp;remote_softirq_cpu_notifier);</span><br><span class="line">    open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line">    open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数中的for_each_possible_cpu循环用来初始化管理tasklet链表的变量tasklet_vec和tasklet_hi_vec，稍后会谈到这两个变量的具体用途。<br>open_softirq用来给TASKLET_SOFTIRQ和HI_SOFTIRQ安装对应的执行函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">softirq_vec[TASKLET_SOFTIRQ].action = tasklet_action;</span><br><span class="line">softirq_vec[HI_SOFTIRQ].action = tasklet_hi_action;</span><br></pre></td></tr></table></figure>
<p>上述代码中，softirq_vec是一个struct softirq_action类型的数组，数组中的每一项都对应一个软中断处理函数指针。该数组在源码中的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>] __<span class="title">cacheline_aligned_in_smp</span>;</span></span><br></pre></td></tr></table></figure>
<p>软中断处理函数原型则由struct softirq_action来定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*action)(struct softirq_action*);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如此，在中断处理的SOFTIRQ部分，如果发现本地CPU的<strong>softirq_pending上TASKLET_SOFTIRQ或者HI_SOFTIRQ位被置1，就将调用tasklet_action或者tasklet_hi_action。<br>后面会看到</strong>softirq_pending与softirq_vec数组间的对应关系。</p>
<h3 id="提交一个tasklet"><a href="#提交一个tasklet" class="headerlink" title="提交一个tasklet"></a>提交一个tasklet</h3><p>本节将讨论设备驱动程序如何利用内核提供的tasklet机制来实现一个延迟的操作。内核为此定义了一个表示tasklet对象的数据结构struct tasklet_struct：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> state;</span><br><span class="line">    <span class="keyword">atomic_t</span> count;</span><br><span class="line">    <span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span></span></span><br></pre></td></tr></table></figure>
<p>用来将系统中的tasklet对象构建成链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> state</span><br></pre></td></tr></table></figure>
<p>记录每个tasklet在系统中的状态，其值是枚举型变量TASKLET_STATE_SCHED和TASKLET_STATE_RUN两者之一。<br>TASKLET_STATE_SCHED表示当前tasklet已经被提交；TASKLET_STATE_RUN只用在对称多处理器系统SMP中，表示当前tasklet正在执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">atomic_t</span> count</span><br></pre></td></tr></table></figure>
<p>用来实现tasklet的disable和enable操作，count.counter=0表示当前的tasklet是enabled的，可以被调度执行，否则便是个disabled的tasklet，不可以被执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span><br></pre></td></tr></table></figure>
<p>该tasklet上的执行函数或者延迟函数，当该tasklet在SOFTIRQ部分被调度执行时，该函数指针指向的函数被调用，用来完成驱动程序中实际的延迟操作任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> data</span><br></pre></td></tr></table></figure>
<p>func所指向的函数被调用时，data将作为参数传给func函数。驱动程序可以利用data向tasklet上的执行函数传递特定的参数。<br>驱动程序为了实现基于tasklet机制的延迟操作，首先需要声明一个tasklet对象。驱动程序可以用DECLARE_TASKLET宏声明并初始化一个静态的tasklet对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_TASKLET(name, func, data) \</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">name</span> = &#123;</span> <span class="literal">NULL</span>, <span class="number">0</span>, ATOMIC_INIT(<span class="number">0</span>), func, data &#125;</span><br></pre></td></tr></table></figure>
<p>相对于DECLARE_TASKLET宏，另一个相似的宏DECLARE_TASKLET_DISABLED则用来声明一个处于disabled状态的tasklet对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_TASKLET_DISABLED(name, func, data) \</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">name</span> = &#123;</span> <span class="literal">NULL</span>, <span class="number">0</span>, ATOMIC_INIT(<span class="number">1</span>), func, data &#125;</span><br></pre></td></tr></table></figure>
<p>以上宏定义中，name是声明的tasklet对象的名称，func是驱动程序中用来实现延迟操作的函数，data是传递给func函数的参数。如果驱动程序在运行过程中构建了一个tasklet对象，这种情况下对tasklet对象的初始化可以通过调用函数tasklet_init来完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_init</span><span class="params">(struct tasklet_struct *t,</span></span></span><br><span class="line">          void (*func)(unsigned long), unsigned long data)</span><br><span class="line">&#123;</span><br><span class="line">    t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;state = <span class="number">0</span>;</span><br><span class="line">    atomic_set(&amp;t-&gt;count, <span class="number">0</span>);</span><br><span class="line">    t-&gt;func = func;</span><br><span class="line">    t-&gt;data = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明了tasklet对象之后，驱动程序需要调用tasklet_schedule来向系统提交这个tasklet。这里所谓的提交，实际上就是将一个tasklet对象加入到tasklet_vec管理的链表中。对于HI_SOFTIRQ，提交tasklet对象的函数为tasklet_hi_schedule，除了用来管理tasklet对象链表的变量为tasklet_hi_vec外，其他方面完全一样。<br>鉴于这种代码层面的一致性，所以接下来把讨论的主角设定为tasklet_schedule。为了方便这里的讨论，这里对tasklet_schedule函数进行了轻微的改动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tasklet_schedule</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">if</span> (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))&#123;</span><br><span class="line">        local_irq_save(flags);</span><br><span class="line">        t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        *__get_cpu_var(tasklet_vec).tail = t;</span><br><span class="line">        __get_cpu_var(tasklet_vec).tail = &amp;(t-&gt;next);</span><br><span class="line">        raise_softirq_irqoff(TASKLET_SOFTIRQ);</span><br><span class="line">        local_irq_restore(flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数中用到的tasklet_vec是个per-CPU型的变量，用来将系统中所有通过tasklet_schedule函数提交的tasklet对象构建成链表，如果是多处理器系统，那么每个处理器都将用各自的tasklet_vec链表管理提交到其上的tasklet。<br>tasklet_vec在Linux源码中具体的声明和类型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> **<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct tasklet_head, tasklet_vec)</span></span>;</span><br></pre></td></tr></table></figure>
<p>tasklet_vec变量的初始化最早发生在Linux系统初始化阶段调用的softirq_init函数中。<br>上一小节提到了该函数，在那里将tasklet_vec的成员head的地址赋给了tail，在tasklet_schedule函数中正是通过操作tail的方式将tasklet对象依次加入到了链表中。</p>
<p>函数首先检查要提交的tasklet的state上的TASKLET_STATE_SCHED位有没有置1，对一个尚未提交过的tasklet对象来说，其值应该是0，所以test_and_set_bit函数会返回0，同时把tasklet的state上的TASKLET_STATE_SCHED位置1表明这个tasklet已被提交。此后该tasklet对象的TASKLET_STATE_SCHED位一直为1直到被调度运行，因此一个tasklet对象在被成功提交进系统但尚未被调度执行时，处于TASKLET_STATE_SCHED状态。<br>此时即便是在多处理器系统中，运行在其他处理器上的tasklet_schedule函数也无法再次提交一个处于TASKLET_STATE_SCHED状态的tasklet对象，因此一个tasklet对象在同一时间只可能在一个处理器上运行，而不会同时有多个实例在不同的CPU上运行。</p>
<p>如果tasklet可以被提交，那么接下来的工作就是把它加入到当前处理器tasklet_vec管理的链表中，然后再通过raise_softirq_irqoff(TASKLET_SOFTIRQ)调用告诉SOFTIRQ部分当前处理器有个TASKLET_SOFTIRQ正等待处理。raise_softirq_irqoff用一个整型变量的位来表示该位上是否有待决的softirq等待处理，1表示有，0则是没有。</p>
<p>关于tasklet_vec建立链表的操作，因为接下来的讨论中还会经常见到，读者不妨通过图来建立个初步的印象：</p>
<p><img src="/2021/10/13/linux-interrupt/image-76.jpg" width="800px"></p>
<p>图中，tasklet_vec的head成员总是指向所管理链表的第一个节点，tail总是保存链表最后一个节点next成员的地址。作为示例，图中的0xE2042608表示next所在的内存地址，这里笔者简单地用一根带箭头的线指向链表的最后一个节点。</p>
<p>这样如果要把一个新的节点t加入到链表尾部，只需如下操作即可：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">*__get_cpu_var(tasklet_vec).tail = t;</span><br><span class="line">__get_cpu_var(tasklet_vec).tail = &amp;(t-&gt;next);</span><br></pre></td></tr></table></figure></p>
<p>其实像这种单向链表的操作很简单，似乎用不着通过tasklet_vec这种很绕的方式来实现，但是Linux内核这样做有它的道理，后面在讨论tasklet_action的时候会看到这点。<br>下面是一个设备驱动程序在其中断处理例程demo_isr中通过tasklet_schedule实现的一个延迟操作示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设备相关的指针</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">demo_dev</span> * <span class="title">p</span> = …;</span></span><br><span class="line"><span class="comment">//延迟操作函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo_delay_action</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过data获得设备相关指针</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">demo_dev</span> * <span class="title">pdev</span> = (<span class="title">static</span> <span class="title">struct</span> <span class="title">demo_dev</span> *)<span class="title">data</span>;</span></span><br><span class="line">    <span class="comment">//延迟操作</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用DECLARE_TASKLET(name, func, data)定义一个tasklet对象demo_tasklet</span></span><br><span class="line">DECLARE_TASKLET(demo_tasklet, demo_delay_action, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)p);</span><br><span class="line"><span class="comment">//中断处理例程</span></span><br><span class="line"><span class="keyword">irqreturn_t</span>  demo_isr(<span class="keyword">int</span> irq,<span class="keyword">void</span>*dev_id)</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//通过tasklet_schedule实现延迟操作</span></span><br><span class="line">    tasklet_schedule(&amp;demo_tasklet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例中的demo_delay_action函数将延迟到中断处理的SOFTIRQ部分才会被执行到。</p>
<h3 id="tasklet-action"><a href="#tasklet-action" class="headerlink" title="tasklet_action"></a>tasklet_action</h3><p>上一小节讨论了设备驱动程序通过tasklet_schedule向系统提交一个tasklet对象执行延迟操作的实现机制，本节将会看到中断处理的SOFTIRQ部分如何去调用这些延迟的操作函数。<br>在“tasklet机制初始化”小节，内核为TASKLET_SOFTIRQ和HI_SOFTIRQ分别安装了执行函数tasklet_action和tasklet_hi_action，鉴于这两个执行函数的实现机制完全一样，在此只对tasklet_action的实现机制进行分析。下面是这个函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tasklet_action</span><span class="params">(struct softirq_action *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">list</span>;</span></span><br><span class="line">    local_irq_disable();</span><br><span class="line">    <span class="built_in">list</span> = __get_cpu_var(tasklet_vec).head;</span><br><span class="line">    __get_cpu_var(tasklet_vec).head = <span class="literal">NULL</span>;</span><br><span class="line">    __get_cpu_var(tasklet_vec).tail = &amp;__get_cpu_var(tasklet_vec).head;</span><br><span class="line">    local_irq_enable();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">t</span> = <span class="title">list</span>;</span></span><br><span class="line">        <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (tasklet_trylock(t)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!atomic_read(&amp;t-&gt;count)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!test_and_clear_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">                    BUG();</span><br><span class="line">                t-&gt;func(t-&gt;data);</span><br><span class="line">                tasklet_unlock(t);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tasklet_unlock(t);</span><br><span class="line">        &#125;</span><br><span class="line">        local_irq_disable();</span><br><span class="line">        t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        *__get_cpu_var(tasklet_vec).tail = t;</span><br><span class="line">        __get_cpu_var(tasklet_vec).tail = &amp;(t-&gt;next);</span><br><span class="line">        __raise_softirq_irqoff(TASKLET_SOFTIRQ);</span><br><span class="line">        local_irq_enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的主体是个while循环，在进入while循环之前，需要得到tasklet链表的头指针，这需要访问per-CPU变量tasklet_vec，因为该变量用来管理tasklet链表，tasklet_vec.head指向tasklet链表的第一个节点。注意在访问tasklet_vec之前，函数用local_irq_disable关闭了处理器的中断，这是因为虽然tasklet_vec在系统的每个处理器中都有个副本，但是在单一CPU的范围里，依然存在SOFTIRQ在执行时被外部设备中断，在它的中断处理例程中使用到了tasklet的功能比如调用tasklet_schedule来提交一个tasklet对象，这样会导致两个执行路径都有操作tasklet_vec的可能性。所以此处用local_irq_disable和local_irq_enable来保护tasklet_vec不会在可能的并发访问中遭到破坏，其间的代码将tasklet_vec管理的链表的第一个节点存放在本地变量list中，然后将tasklet_vec设置成其最初的状态（空链表）。</p>
<blockquote>
<p>在继续对while循环中代码的讨论之前，有两点需要注意。</p>
</blockquote>
<p>首先，tasklet_action作为一个softirq执行函数，在多处理器系统中可能同时在不同的CPU上运行。<br>虽然一个处于TASKLET_STATE_SCHED状态的tasklet对象不能被多次提交，但是当一个tasklet对象被调度运行时，TASKLET_STATE_SCHED状态位会被清除，这样就可能导致该tasklet对象在别的处理器上被重新提交。<br>考虑一下如下的情形：在一个有A和B两个处理器的系统中，某设备对处理器A产生了一次中断，在它的中断处理例程中会调用tasklet_schedule函数向系统提交一个tasklet对象，假设处理器A已经进入本次中断处理的SOFTIRQ部分并且正在运行该tasklet，注意此时它的TASKLET_STATE_SCHED状态位已经被清除，此时该设备又产生了一次中断，这次的中断发送给了处理器B，处理器B在它的中断处理例程中同样会调用tasklet_schedule把同一个tasklet对象向处理器B上的tasklet_vec链表提交，因为该tasklet的TASKLET_STATE_SCHED状态位已经被清除，所以提交是可能成功的。<br>如此就可能出现同一tasklet对象的执行函数在不同的处理器上同时运行的情形，因此while循环需要某种机制来确保这种情况不会发生。我们不妨把这个问题称为SMP中tasklet运行冲突的问题，等下会在while循环具体的代码实现中看到内核对此给出的解决方案。</p>
<p>其次，在while循环中tasklet_action通过一个本地变量list来实现对tasklet链表的遍历。对于遍历过程中的每一个tasklet节点，如果不满足执行的条件，将通过操作tasklet_vec.tail指针将其重新加入tasklet_vec链表；如果它被成功执行了，那么该tasklet对象将不会再出现于tasklet_vec链表中。通过启用一个本地变量list，使得我们在调用tasklet上的执行函数时，无须再考虑list链表的互斥访问问题，因此读者可以看到tasklet上的执行函数在运行期间，中断是打开的，这也是SOFTIRQ当初的设计初衷。</p>
<p>如果考虑到在某个tasklet运行期间发生了中断，那么可能会有新的tasklet要被提交到当前处理器的tasklet_vec链表上，不过这不会影响到list所在链表，新的tasklet对象将会加入到tasklet_vec链表中。如此，在tasklet_action执行前后，tasklet_vec链表发生的变化是：一些新的tasklet对象可能被提交进来，只是因为还没有被运行过，所以新节点将处于TASKLET_STATE_SCHED状态，而被运行过的老节点其TASKLET_STATE_SCHED状态位将被清除，而且也不会再出现在当前处理器的tasklet_vec链表中。</p>
<p>现在来看看while循环实际的代码，tasklet_trylock在单处理器系统中直接返回1，在多处理器中，其定义是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tasklet_trylock</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !test_and_set_bit(TASKLET_STATE_RUN, &amp;(t)-&gt;state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数将tasklet中state的TASKLET_STATE_RUN位置1，同时返回TASKLET_STATE_RUN位原来的值。因此，while循环中的if (tasklet_trylock(t))实际上就是用来解决前面提到的SMP中tasklet运行冲突的问题的。在SMP系统中一个运行中的tasklet（其TASKLET_STATE_RUN位被置1，TASKLET_STATE_SCHED位被清0）有可能被重新提交到另一个处理器的tasklet_vec链表中，为了防止该tasklet同时在不同的处理器上运行，内核在SMP系统中为tasklet对象增加了一个额外的状态位TASKLET_STATE_RUN，这个状态位只对SMP系统有效，单处理器系统不需要这个状态。</p>
<p>内核用tasklet对象的TASKLET_STATE_RUN位来标记对应的tasklet当前是否正在运行，如果没有，那么tasklet_trylock(t)将返回真，同时tasklet_trylock也会将state中的TASKLET_STATE_RUN位置1，这样别的CPU再运行tasklet_action时，将不会处理该tasklet直到其运行完毕清除掉TASKLET_STATE_RUN。</p>
<p>内核通过这种方式实现了tasklet的串行化：任一时刻tasklet只可能在一个CPU上运行。对于单处理器，不存在tasklet运行冲突的问题，所以tasklet_trylock直接返回1。</p>
<p>接下来通过atomic_read对tasklet的count成员进行测试，这个成员主要用来实现enable或者disable一个tasklet，如果某个tasklet对象的count为0，说明它处在enabled的状态。对于一个enabled的tasklet，需要再测试其state的TASKLET_STATE_SCHED位有没有被置1，提交tasklet的函数会设置该位，如果该位没有被设置，说明tasklet_action函数正试图调度一个没有被提交的tasklet，这是非正常状况。</p>
<p>如果一切顺利，当前tasklet上的函数被调用，意味着延迟的操作开始进行。<br>从代码中可以看到，如果一个tasklet被调度执行完之后，其state的TASKLET_STATE_SCHED位被清0，这意味着除非被再次提交，否则下次的SOFTIRQ部分将不会再调度到它，这是一种one-shot特性：提交一次，调度运行一次，运行完后就从CPU的tasklet_vec链表中消失，除非有代码再次提交该tasklet对象。</p>
<p>通过上面对tasklet_action的分析可以看出，一个提交的tasklet在被SOFTIRQ调度执行完后，将从当前处理器的tasklet_vec链表中消失，因此除非再次提交，否则该tasklet对象将不会有机会被再次运行。<br>同时内核对tasklet的实现机制确保了同一个tasklet对象不会同时在不同的处理器上运行，因此驱动程序在实现tasklet的延迟函数时，无须考虑多处理器间的并发问题。<br>另外tasklet运行在中断上下文环境中，因此在中断上下文中的种种限制同样适用于tasklet的延迟函数。这些都是tasklet这种机制最典型的特质。</p>
<h3 id="tasklet的其他操作"><a href="#tasklet的其他操作" class="headerlink" title="tasklet的其他操作"></a>tasklet的其他操作</h3><p>前面已经讨论了tasklet的整个实现机制，下面在此基础上讲述tasklet一些其他的操作，包括如何disable和enable一个tasklet等。<br><code>tasklet_disable</code>和<code>tasklet_disable_nosync</code>这两个函数可以用来disable一个tasklet，使之无法被SOFTIRQ调度运行。</p>
<p>函数定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tasklet_disable_nosync</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    atomic_inc(&amp;t-&gt;count);</span><br><span class="line">    smp_mb__after_atomic_inc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tasklet_disable</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tasklet_disable_nosync(t);</span><br><span class="line">    tasklet_unlock_wait(t);</span><br><span class="line">    smp_mb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>disable本身的行为很简单，将要操作的tasklet对象t上的count加1就可以了。相对于tasklet_disable_nosync，tasklet_disable是个“同步”版本，它在调用tasklet_disable_nosync函数之后，会再调用tasklet_unlock_wait函数实现所谓“同步”功能，这里的术语“同步”只限于SMP系统，单处理器系统中，tasklet_unlock_wait什么也不做。<br>多处理器系统中，如果要disable的tasklet正在运行，那么tasklet_unlock_wait要一直忙等待到t的TASKLET_STATE_RUN状态位被清除，就是说tasklet_disable要等到t运行完毕才会返回，这意味着tasklet_disable返回之后，可以确保该tasklet不会在系统的任何地方运行。<br>一个处于disabled状态的tasklet可以被提交到tasklet_vec中，但是不会被调度执行。</p>
<h4 id="tasklet-enable"><a href="#tasklet-enable" class="headerlink" title="tasklet_enable"></a>tasklet_enable</h4><p>tasklet_enable函数用来enable一个tasklet，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tasklet_enable</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    smp_mb__before_atomic_dec();</span><br><span class="line">    atomic_dec(&amp;t-&gt;count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将指定的tasklet对象t上的count减1。一个tasklet对象要能被执行，count应该为0。<br>所以如果想enable一个先前被disable的tasklet，使之能被调度执行，tasklet_enable和tasklet_disable的调用次数要匹配。</p>
<h4 id="tasklet-kill"><a href="#tasklet-kill" class="headerlink" title="tasklet_kill"></a>tasklet_kill</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_kill</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数通过清除一个tasklet对象的TASKLET_STATE_SCHED状态位，使SOFTIRQ不再能够调度运行它。如果当前tasklet对象正在运行，那么tasklet_kill将忙等待直到tasklet运行结束，这样可以确保tasklet_kill返回后系统中不再有运行中的该tasklet对象。<br>如果一个tasklet对象被提交到了系统但还没有被调度执行，那么针对该tasklet对象调用tasklet_kill，后者将会睡眠直到该tasklet被执行完从tasklet_vec链表中移除，所以tasklet_kill是个可能会被阻塞的函数。</p>
<p>一般在设备驱动程序所在的内核模块要被移除或者是设备要被关闭时，才调用该函数，因为这种情况下虽然你可以删除tasklet对象所在的空间，但这不会影响到tasklet_vec已有的链表元素构成，所以一个可能的情况是，在你的驱动模块已经移出系统，SOFTIRQ还是调度运行了你的驱动程序提交的tasklet对象，这是一种危险情况，因为当你的模块已经从系统中移除之后，被调度运行的tasklet函数也许会使用到模块中的资源，但是现在它们已经不存在了。内核模块调用tasklet_kill可以确保不会发生这种情况。</p>
<p><br><br><br></p>
<h2 id="工作队列work-queue"><a href="#工作队列work-queue" class="headerlink" title="工作队列work queue"></a>工作队列work queue</h2><p>工作队列是设备驱动程序可以使用的另一种延迟执行的方法。<br>为了实现这种延迟执行的机制，内核或者驱动程序需要建立一套完整的基础设施，这里的设计思想与现实中的工厂加工非常相像：基础设施就是一条加工厂的成产流水线和在流水线上工作的工人，平时没事的时候，流水线上的工人就休息。<br>如果某一客户想要加工一件工件，只需要把要加工的工件打个包（包里放有记载该工件应该如何加工的文档），扔到流水线上，然后客户可以继续做自己的事情。流水线上的工人发现有活要做，就结束休息，帮助客户加工工件。<br>这个我们所熟悉的场景对应到Linux内核代码的世界，流水线变成了worklist，工人变成了worker_thread，打成包的工件就是struct work_struct对象，把包扔到流水线的工作变成了queue_work函数的调用等等，所有这些我们都将在接下来的内容中看清它们的内部运作流程。</p>
<p>为了叙述上的方便，我们不妨就把这整个所谓的基础设施统称为工作队列。</p>
<p>内核本身提供了一套默认的工作队列，但是驱动程序自身也可以另起炉灶创建属于自己的基工作队列。<br>本节将先从驱动程序创建自己的工作队列谈起，讨论整个延迟处理的工作流程，然后再把讨论的范围延伸到内核自己创建的基础设施上去，最后对比工作队列与tasklet机制的区别以及各自的适用场景。</p>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p>在具体讨论创建工作队列的内核机制之前，先交代几个核心的数据结构，它们在后面的讨论中会频频出现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/workqueue.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">work_func_t</span> func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>驱动程序要通过工作队列实现延迟操作时，需要生成一个struct work_struct对象，本书称之为工作节点，然后通过queue_work函数将其提交给工作队列。</li>
<li>atomic_long_t data驱动程序可以利用data来将设备驱动程序使用的某些指针传递给延迟函数。</li>
<li>struct list_head entry双向链表对象，用来将提交的等待处理的工作节点形成链表。</li>
<li><p>work_func_t func工作节点的延迟函数，用来完成实际的延迟操作。其原型定义如下：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">work_func_t</span>)</span><span class="params">(struct work_struct *work)</span></span>;</span><br><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">worklist</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> more_work;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">current_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span>;</span></span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure>
<p>  实际的代码中，struct cpu_workqueue_struct对象是个per-CPU型的变量，通过alloc_percpu函数动态创建，系统中的每个CPU都有一份，本书称struct cpu_workqueue_struct为CPU工作队列管理结构。</p>
</li>
<li>spinlock_t lock对象的自旋锁，用于对可能的并发访问该对象时提供互斥保护机制。</li>
<li>struct list_head worklist双向链表对象，用来将驱动程序提交的工作节点形成链表。驱动程序中的延迟操作以工作节点的形式存在。</li>
<li>wait_queue_head_t more_work等待队列头节点，工作队列的工人线程（worker_thread）没有工作节点需要处理时将进入睡眠状态，此时它需要进入该等待队列。</li>
<li><code>struct work_struct *current_work</code>用于记录当前工人线程正在处理的工作节点。</li>
<li><code>struct workqueue_struct *wq</code>指向系统工作队列管理结构，接下来有它的具体定义。</li>
<li><p><code>struct task_struct *thread</code>指向工人线程所在的进程空间结构workqueue_struct。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> *<span class="title">cpu_wq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> singlethread;</span><br><span class="line">    <span class="keyword">int</span> freezeable;</span><br><span class="line">    <span class="keyword">int</span> rt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  相对于上面的CPU工作队列管理结构，本书称struct workqueue_struct为工作队列管理结构，内核会为创建的每个工作队列生成一个工作队列管理结构对象。</p>
</li>
<li><code>struct cpu_workqueue_struct *cpu_wq</code>指向CPU工作队列管理结构的per-CPU类型的指针。根据该指针，系统中的每个CPU都可以通过per_cpu_ptr来获得属于自己的CPU工作队列管理结构的对象。</li>
<li>struct list_head list双向链表对象，用于将工作队列管理结构加入到一个全局变量workqueues中，只对非singlethread工作队列有效。</li>
<li><code>const char *name</code>工作队列的名称。</li>
<li>int singlethread标识创建的工作队列中工人线程的数量。</li>
<li>int freezeable表示进程可否处于冻结状态。</li>
<li>int rt用来调整worker_thread线程所在进程的调度策略。</li>
</ul>
<h3 id="create-singlethread-workqueue和create-workqueue"><a href="#create-singlethread-workqueue和create-workqueue" class="headerlink" title="create_singlethread_workqueue和create_workqueue"></a>create_singlethread_workqueue和create_workqueue</h3><p>设备驱动程序通过这两个函数创建属于自己的基础设施，严格地说，其实它们是宏，不过这种文字上的小区别对理解整个流程的内核实现并没有什么特别的意义，所以不妨先展开来看看它们各自的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/workqueue.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> create_workqueue(name) __create_workqueue_key ((name), 0, 0, 0,NULL, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> create_singlethread_workqueue(name) \</span></span><br><span class="line">__create_workqueue_key ((name), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure></p>
<p>所以最终调用的函数是<strong>create_workqueue_key，这才是真正的核心函数，create_workqueue和create_singlethread_workqueue的区别在于调用`</strong>create_workqueue_key<code>时的第二个参数，接下来讨论__create_workqueue_key函数的实现时再来看这个参数对驱动程序而言意味着什么。
内核源码中</code>__create_workqueue_key`的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *__<span class="title">create_workqueue_key</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">int</span> <span class="title">singlethread</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">int</span> <span class="title">freezeable</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">int</span> <span class="title">rt</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">const</span> <span class="title">char</span> *<span class="title">lock_name</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> *<span class="title">cwq</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>, cpu;</span><br><span class="line">    wq = kzalloc(<span class="keyword">sizeof</span>(*wq), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!wq)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    wq-&gt;cpu_wq = alloc_percpu(struct cpu_workqueue_struct);</span><br><span class="line">    <span class="keyword">if</span> (!wq-&gt;cpu_wq) &#123;</span><br><span class="line">        kfree(wq);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wq-&gt;name = name;</span><br><span class="line">    wq-&gt;singlethread = singlethread;</span><br><span class="line">    wq-&gt;freezeable = freezeable;</span><br><span class="line">    wq-&gt;rt = rt;</span><br><span class="line">    INIT_LIST_HEAD(&amp;wq-&gt;<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">if</span> (singlethread) &#123;</span><br><span class="line">        cwq = init_cpu_workqueue(wq, singlethread_cpu);</span><br><span class="line">        err = create_workqueue_thread(cwq, singlethread_cpu);</span><br><span class="line">        start_workqueue_thread(cwq, <span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cpu_maps_update_begin();</span><br><span class="line">        spin_lock(&amp;workqueue_lock);</span><br><span class="line">        list_add(&amp;wq-&gt;<span class="built_in">list</span>, &amp;workqueues);</span><br><span class="line">        spin_unlock(&amp;workqueue_lock);</span><br><span class="line">        for_each_possible_cpu(cpu) &#123;</span><br><span class="line">            cwq = init_cpu_workqueue(wq, cpu);</span><br><span class="line">            <span class="keyword">if</span> (err || !cpu_online(cpu))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            err = create_workqueue_thread(cwq, cpu);</span><br><span class="line">            start_workqueue_thread(cwq, cpu);</span><br><span class="line">        &#125;</span><br><span class="line">        cpu_maps_update_done();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        destroy_workqueue(wq);</span><br><span class="line">        wq = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wq;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>函数一开始便调用kzalloc生成了一个工作队列管理结构的对象wq并初始化，同时利用alloc_percpu函数生成了per-CPU类型的CPU工作队列管理结构对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wq-&gt;cpu_wq = alloc_percpu(struct cpu_workqueue_struct);</span><br></pre></td></tr></table></figure>
<p>接下来函数根据参数singlethread的值对单线程队列和多线程队列分别进行处理。create_singlethread_workqueue函数生成的工作队列是单线程的，singlethread=1，对这种情况，函数需要做的是：</p>
<ul>
<li>调用init_cpu_workqueue函数，在该函数中获得系统中第一个CPU（代码中的称谓是singlethread_cpu）对应的CPU工作队列管理结构的指针cwq，同时初始化cwq中的等待队列和双向链表等成员变量。</li>
<li>调用create_workqueue_thread函数生成工人线程（worker_thread）。Linux内核中所谓的内核线程其实是一个进程，拥有独立的task_struct结构，这里的工人线程也不例外。create_workqueue_thread函数实际的操作是生成一个新的进程，将该进程task_struct中保存有进程执行现场寄存器的pc值指向worker_thread函数（本书称worker_thread函数为工人线程的线程函数），这样当该进程被调度运行时将执行worker_thread函数，传给函数的参数是系统中第一个CPU上的cwq指针。新进程的task_struct结构体指针p将保存在CPU工作队列管理结构的thread成员中：cwq-&gt;thread = p。</li>
<li>调用start_workqueue_thread函数，后者再通过wake_up_process函数将新进程投入到系统的运行队列中：wake_up_process(p)，如此之后新进程就具备了被调度器调度运行的条件。</li>
</ul>
<p>如果singlethread不为1，那么__create_workqueue_key将对系统中的每个CPU调用singlethread中的三大步骤，这样每个CPU都将拥有自己的CPU工作队列管理结构和工作在其上的工人线程。<br>这种情况下工作队列管理结构对象wq还将把自己加入到workqueues管理的链表中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_add(&amp;wq-&gt;<span class="built_in">list</span>, &amp;workqueues);</span><br></pre></td></tr></table></figure>
<p>workqueues是一个全局型的双向链表对象，用来链接系统中所有非singlethread的工作队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(workqueues)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/10/13/linux-interrupt/image-77.jpg" width="800px"></p>
<p>图中内核部分描述了通过create_singlethread_workqueue或者create_workqueue创建的工作队列及其上的工人线程worker_thread，后者的任务是操作worklist链表上的工作节点，如果worklist上面没有工作节点，那么worker_thread所在的进程将进入睡眠状态并驻留在more_work维护的等待队列中。</p>
<p>驱动程序部分将要延迟的操作打包进struct work_struct类型的工作节点中，然后通过queue_work向worklist上提交该工作节点，最后唤醒worker_thread线程。<br>图描述的是singlethread工作队列，对于非singlethread工作队列，上面的工作原理依然适用，只是此时系统中的每个CPU都拥有自己的工作队列和工人线程worker_thread。至于驱动程序提交节点时向哪个工作队列提交，在queue_work部分再讨论。</p>
<h3 id="工人线程worker-thread"><a href="#工人线程worker-thread" class="headerlink" title="工人线程worker_thread"></a>工人线程worker_thread</h3><p>工人线程worker_thread用来处理驱动程序提交到工作队列中的工作节点，如果工作队列中没有节点需要处理，那么它将睡眠在cwq-&gt;more_work表示的等待队列中。<br>worker_thread运行在一个独立的新进程空间中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">worker_thread</span><span class="params">(<span class="keyword">void</span> *__cwq)</span></span>&#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> *<span class="title">cwq</span> = __<span class="title">cwq</span>;</span></span><br><span class="line">       DEFINE_WAIT(wait);</span><br><span class="line">       <span class="keyword">if</span> (cwq-&gt;wq-&gt;freezeable)</span><br><span class="line">              set_freezable();</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              prepare_to_wait(&amp;cwq-&gt;more_work, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line">              <span class="keyword">if</span> (!freezing(current) &amp;&amp;</span><br><span class="line">                   !kthread_should_stop() &amp;&amp;</span><br><span class="line">                   list_empty(&amp;cwq-&gt;worklist))</span><br><span class="line">                     schedule();</span><br><span class="line">              finish_wait(&amp;cwq-&gt;more_work, &amp;wait);</span><br><span class="line">              try_to_freeze();</span><br><span class="line">              <span class="keyword">if</span> (kthread_should_stop())</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">              run_workqueue(cwq);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>worker_thread的主体是一for(;;)循环，它首先用kthread_should_stop检测有没有别的函数对它调用了kthread_stop，如果有的话代表该线程的kthread对象的should_stop成员将被置1，此时worker_thread将通过break跳出循环，线程函数所在的进程将会终结。<br>如果worker_thread不需要stop而且cwq-&gt;worklist上也没有工作节点等待处理，工人线程将调用schedule以TASK_INTERRUPTIBLE状态睡眠在等待队列cwq-&gt;more_work中，直到驱动程序向cwq-&gt;worklist上提交了一个新的节点并唤醒worker_thread，它醒来之后将调用run_workqueue来处理cwq-&gt;worklist上的工作节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run_workqueue</span><span class="params">(struct cpu_workqueue_struct *cwq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    spin_lock_irq(&amp;cwq-&gt;lock);</span><br><span class="line">    <span class="keyword">while</span> (!list_empty(&amp;cwq-&gt;worklist)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> = <span class="title">list_entry</span>(<span class="title">cwq</span>-&gt;<span class="title">worklist</span>.<span class="title">next</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">struct</span> <span class="title">work_struct</span>, <span class="title">entry</span>);</span></span><br><span class="line">        <span class="keyword">work_func_t</span> f = work-&gt;func;</span><br><span class="line">        cwq-&gt;current_work = work;</span><br><span class="line">        list_del_init(cwq-&gt;worklist.next);</span><br><span class="line">        spin_unlock_irq(&amp;cwq-&gt;lock);</span><br><span class="line">        work_clear_pending(work);</span><br><span class="line">        f(work);</span><br><span class="line">        spin_lock_irq(&amp;cwq-&gt;lock);</span><br><span class="line">        cwq-&gt;current_work = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irq(&amp;cwq-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数在while循环中遍历cwq-&gt;worklist链表，对于其中的每个工作节点work，先将其从cwq-&gt;worklist链表删除，然后调用工作节点上的延迟函数f(work)，传递给函数的参数是延迟函数所在工作节点的指针work。从run_workqueue的代码可以看出，一个工作节点被处理完之后，将不会再出现在工作队列的cwq-&gt;worklist链表中，除非被再次提交。<br>函数中的work_clear_pending用来清除work-&gt;data的WORK_STRUCT_PENDING位（位0），这里内核把work-&gt;data的低2位用于记录work的状态信息，当驱动程序调用queue_work向工作队列提交节点work时，queue_work会把work-&gt;data的WORK_STRUCT_PENDING位置1，这是为了防止驱动程序将一个尚未被处理的工作节点再次向cwq-&gt;worklist上提交。</p>
<h3 id="destroy-workqueue"><a href="#destroy-workqueue" class="headerlink" title="destroy_workqueue"></a>destroy_workqueue</h3><p>destroy_workqueue执行与create_singlethread_workqueue/create_workqueue相反的任务，当驱动程序不再需要使用后者创建的工作队列时（比如驱动程序所在的模块要从系统中移走或者关闭设备等），需要调用destroy_workqueue来做工作队列的清理善后工作，比如释放create_workqueue分配使用的一些系统资源如内存等，还有worker_thread线程也应该被安全地终结。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_workqueue</span><span class="params">(struct workqueue_struct *wq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> *<span class="title">cpu_map</span> = <span class="title">wq_cpu_map</span>(<span class="title">wq</span>);</span></span><br><span class="line">    <span class="keyword">int</span> cpu;</span><br><span class="line">    cpu_maps_update_begin();</span><br><span class="line">    spin_lock(&amp;workqueue_lock);</span><br><span class="line">    list_del(&amp;wq-&gt;<span class="built_in">list</span>);</span><br><span class="line">    spin_unlock(&amp;workqueue_lock);</span><br><span class="line">    for_each_cpu(cpu, cpu_map)</span><br><span class="line">        cleanup_workqueue_thread(per_cpu_ptr(wq-&gt;cpu_wq, cpu));</span><br><span class="line">    cpu_maps_update_done();</span><br><span class="line">    free_percpu(wq-&gt;cpu_wq);</span><br><span class="line">    kfree(wq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了将wq从workqueues中移走及释放工作队列管理结构等对象所占用的内存外，主要的工作是调用cleanup_workqueue_thread来完全地终结worker_thread，因为destroy_workqueue被调用的时候，worker_thread很有可能正在处理worklist中余下的工作节点，因此函数要小心处理，避免发生不必要的麻烦。<br>这里将cleanup_workqueue_thread稍作改写以突出其主线：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanup_workqueue_thread</span><span class="params">(struct cpu_workqueue_struct *cwq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cwq-&gt;thread == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    flush_cpu_workqueue(cwq);</span><br><span class="line">    kthread_stop(cwq-&gt;thread);</span><br><span class="line">    cwq-&gt;thread = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的主要作用是通过调用kthread_stop函数来让worker_thread所在的进程终止，因为一旦进程的执行函数worker_thread结束，进程就将调用do_exit而终结，所以kthread_stop让worker_thread结束的原理就是设置should_stop=1，前面在讨论worker_thread时已看到过should_stop的这一用法。<br>但是终止worker_thread所在进程的一个前提条件是要确保所有提交到cwq-&gt;worklist中的工作节点都已处理完毕，这是由flush_cpu_workqueue函数完成的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">flush_cpu_workqueue</span><span class="params">(struct cpu_workqueue_struct *cwq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> active = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wq_barrier</span> <span class="title">barr</span>;</span></span><br><span class="line">    WARN_ON(cwq-&gt;thread == current);</span><br><span class="line">    spin_lock_irq(&amp;cwq-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;cwq-&gt;worklist) || cwq-&gt;current_work != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        insert_wq_barrier(cwq, &amp;barr, &amp;cwq-&gt;worklist);</span><br><span class="line">        active = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irq(&amp;cwq-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> (active) &#123;</span><br><span class="line">        wait_for_completion(&amp;barr.done);</span><br><span class="line">        destroy_work_on_stack(&amp;barr.work);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> active;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flush_cpu_workqueue确保cwq-&gt;worklist上所有工作节点都已处理完毕的设计思想是利用完成接口completion：如果cwq-&gt;worklist不为空或者cwq-&gt;current_work不为空，说明cwq_worklist上还有工作节点或者worker_thread正在处理一个工作节点，则向cwq-&gt;worklist上提交一个新的工作节点，这里不妨称之为中止节点。<br>当中止节点上的延迟函数被执行时，它将调用complete函数通知flush_cpu_workqueue，而后者在提交完中止节点之后将睡眠等待在wait_for_completion函数上，直到之前提交的中止节点上的延迟函数执行结束，如此可确保所有中止节点前的工作节点都会被处理完毕。</p>
<p>从函数的实现代码可以看到，虽然在insert_wq_barrier函数提交了中止节点之后，其他部分的代码依然可以向cwq-&gt;worklist提交新的工作节点，但是内核无法保证这些工作节点上的延迟函数有机会执行。函数中的WARN_ON(cwq-&gt;thread == current)意味着驱动程序不应该在提交的工作节点延迟函数中调用flush_cpu_workqueue。</p>
<p>flush_cpu_workqueue的操作范围只限于单个CPU。对于非singlethread工作队列，因为每个CPU上都有一个工作队列和worker_thread，要确保系统中所有CPU上的工作队列中的工作节点都被处理完，应该使用flush_workqueue函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_workqueue</span><span class="params">(struct workqueue_struct *wq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    for_each_cpu(cpu, cpu_map)</span><br><span class="line">        flush_cpu_workqueue(per_cpu_ptr(wq-&gt;cpu_wq, cpu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不管是flush_cpu_workqueue还是flush_workqueue，都是对工作队列worklist上所有的工作节点进行操作：函数返回后，可以确保函数调用前提交的所有工作节点都已处理完毕。<br>与之类似的还有另外一个函数flush_work，如果驱动程序想等待在某单个提交的工作节点上直到该节点处理完毕函数才返回，就可以使用flush_work函数，其原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flush_work</span><span class="params">(struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>参数work就是调用者要等待在其上的工作节点，如果该函数调用时work已处理完毕，那么函数返回0。</p>
<h3 id="提交工作节点queue-work"><a href="#提交工作节点queue-work" class="headerlink" title="提交工作节点queue_work"></a>提交工作节点queue_work</h3><p>前面几节描述了工作队列在内核内部的实现机制，本节开始讨论驱动程序如何通过向工作队列提交节点的方式来执行延迟操作。<br>设备驱动程序将要延迟的操作打包进一个struct work_struct对象，也就是所谓的工作节点，然后通过queue_work函数来向工作队列提交该节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_work</span><span class="params">(struct workqueue_struct *wq, struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = queue_work_on(get_cpu(), wq, work);</span><br><span class="line">    put_cpu();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前的讨论中，驱动程序可以调用create_singlethread_workqueue和create_workqueue函数来让内核生成属于自己的工作队列，两者的区别是：create_singlethread_workqueue只在系统中的第一个CPU（singlethread_cpu）上创建工作队列和工人线程，而create_workqueue函数会在系统中的每个CPU上都创建工作队列和工人线程。<br>在用queue_work向工作队列提交工作节点时，如果工作队列是singlethread类型的，因为此时只有一个worklist，所以queue_work没得选择，工作节点只能提交到这唯一的一个worklist上。<br>反之如果队列不是singlethread类型的，那么工作节点将会提交到当前运行queue_work的CPU所在的worklist中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct workqueue_struct *wq, struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!test_and_set_bit(WORK_STRUCT_PENDING, work_data_bits(work))) &#123;</span><br><span class="line">        BUG_ON(!list_empty(&amp;work-&gt;entry));</span><br><span class="line">        __queue_work(wq_per_cpu(wq, cpu), work);</span><br><span class="line">        ret = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数首先检测work-&gt;data的WORK_STRUCT_PENDING位有没有被置1，置1的话意味着此前该work已被提交还没有处理，内核禁止驱动程序在一个工作节点还没处理完就再次提交该节点。<br>此处的检测也告诉驱动程序，在构造工作节点对象work时，应该确保work-&gt;data低2位为0。如果work-&gt;data的WORK_STRUCT_PENDING位是0，那么就把该位置1表明工作节点处于等待处理的状态，然后调用<code>__queue_work</code>来提交节点。</p>
<p><code>__queue_work</code>的原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __queue_work(struct cpu_workqueue_struct *cwq, struct work_struct *work);</span><br></pre></td></tr></table></figure>
<p>第一个参数是CPU工作队列管理结构，第二个参数是待提交的节点指针。queue_work_on在调用__queue_work时传递的第一个参数是wq_per_cpu(wq, cpu)，为了搞清向哪个cwq提交节点，不妨看看wq_per_cpu的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct cpu_workqueue_struct *<span class="title">wq_per_cpu</span><span class="params">(struct workqueue_struct *wq, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(is_wq_single_threaded(wq)))</span><br><span class="line">        cpu = singlethread_cpu;</span><br><span class="line">    <span class="keyword">return</span> per_cpu_ptr(wq-&gt;cpu_wq, cpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的实现很简单，如果是singlethread类型的工作队列，那么工作节点就提交到第一个CPU的cwq上，否则哪个CPU调用queue_work，工作节点就提交到哪个CPU的cwq上。</p>
<p>下面继续看__queue_work，其内部通过调用insert_work(cwq, work, &amp;cwq-&gt;worklist)来完成节点的提交。insert_work的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_work</span><span class="params">(struct cpu_workqueue_struct *cwq,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct work_struct *work, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_wq_data(work, cwq);</span><br><span class="line">    smp_wmb();</span><br><span class="line">    list_add_tail(&amp;work-&gt;entry, head);</span><br><span class="line">    wake_up(&amp;cwq-&gt;more_work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的主体和我们的预期完全一样：将工作节点加到cwq-&gt;worklist链表的尾部，然后调用wake_up唤醒在等待队列cwq-&gt;more_work上睡眠的worker_thread，如果worker_thread正在运行，那么wake_up就什么也不做。<br>在把驱动程序向工作队列提交节点的queue_work函数搞清楚之后，再回过头来看看实际的驱动程序代码中如何动态初始化一个工作队列节点work_struct的对象。内核为此提供了两个宏PREPARE_WORK和INIT_WORK，展开后如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/workqueue.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREPARE_WORK(_work,_func)             \</span></span><br><span class="line">    <span class="keyword">do</span>&#123;                           \</span><br><span class="line">        (_work)-&gt;func=(_func);            \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_WORK(_work,_func)                 \</span></span><br><span class="line">    <span class="keyword">do</span>&#123;                           \</span><br><span class="line">        (_work)-&gt;data = (<span class="keyword">atomic_long_t</span>) ATOMIC_LONG_INIT(<span class="number">0</span>); \</span><br><span class="line">        INIT_LIST_HEAD(&amp;(_work)-&gt;entry);           \</span><br><span class="line">        PREPARE_WORK((_work),(_func));   \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>INIT_WORK初始化struct work_struct中的每个成员，而PREPARE_WORK只是重新设置struct work_struct中的func指针。在实际的驱动程序中，使用INIT_WORK的机会要比PREPARE_WORK大得多。</p>
<p>除了这种动态初始化，内核还提供了另外一个宏DECLARE_WORK，可以让驱动程序静态定义一个struct work_struct对象同时初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/workqueue.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_WORK(n,f)  struct work_struct n=&#123;              \</span></span><br><span class="line">    .data=WORK_DATA_STATIC_INIT(),          \</span><br><span class="line">    .entry=&#123;&amp;(n).entry,&amp;(n).entry&#125;,          \</span><br><span class="line">    .func=(f),                      \</span><br><span class="line">    __WORK_INIT_LOCKDEP_MAP(#n,&amp;(n))           \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>除queue_work之外，内核还提供了另外一个提交节点的函数queue_delayed_work：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_delayed_work</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct delayed_work *dwork, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delay == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> queue_work(wq, &amp;dwork-&gt;work);</span><br><span class="line">    <span class="keyword">return</span> queue_delayed_work_on(<span class="number">-1</span>, wq, dwork, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相对于queue_work，queue_delayed_work多了个参数delay，不过在delay=0的情况下，对queue_delayed_work就蜕变成了queue_work，上面的代码很明显地展示了这一点。<br>如果delay不等于0，那么它代表一个延迟的时间，换句话说调用queue_delayed_work之后，工作节点work需要等到delay指定的时间过后才会被真正提交到队列wq上。这种延迟提交的工作在queue_delayed_work_on函数中完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_delayed_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct delayed_work *dwork, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> *<span class="title">timer</span> = &amp;<span class="title">dwork</span>-&gt;<span class="title">timer</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> = &amp;<span class="title">dwork</span>-&gt;<span class="title">work</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!test_and_set_bit(WORK_STRUCT_PENDING, work_data_bits(work))) &#123;</span><br><span class="line">        timer_stats_timer_set_start_info(&amp;dwork-&gt;timer);</span><br><span class="line">        set_wq_data(work, wq_per_cpu(wq, raw_smp_processor_id()));</span><br><span class="line">        timer-&gt;expires = jiffies + delay;</span><br><span class="line">        timer-&gt;data = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)dwork;</span><br><span class="line">        timer-&gt;function = delayed_work_timer_fn;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(cpu &gt;= <span class="number">0</span>))</span><br><span class="line">            add_timer_on(timer, cpu);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            add_timer(timer);</span><br><span class="line">        ret = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的设计思想比较直白，利用定时器timer来实现延迟提交的工作，timer-&gt;expires = jiffies+delay，这样当delay时间到期后，timer-&gt;function = delayed_work_timer_fn将被调用，delayed_work_timer_fn会把queue_delayed_work_on要提交的节点提交到工作队列中。<br>所以驱动程序如果要使用queue_delayed_work，要先生成一个struct delayed_work对象。struct delayed_work定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/workqueue.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>延迟函数所在的工作节点在struct delayed_work结构体的work成员中，其另一个成员是个timer对象，用来实现时间上的延迟操作，queue_delayed_work中的dalay参数将用来给timer中的延时成员赋值。<br>至此我们已经完整地讨论了工作队列整个框架的实现机制，包括内核部分如何建立队列和工人线程，以及驱动程序部分如何利用内核提供的接口向工作队列中提交工作节点实现延迟的操作。<br>为了加深读者对这部分内容的理解，下面用一个使用了工作队列执行延迟操作的代码片段作为具体的范例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义全局性的struct workqueue_struct指针demo_dev_wq</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span>*<span class="title">demo_dev_wq</span>;</span></span><br><span class="line"><span class="comment">//设备特定的数据结构，实际使用中大部分struct work_struct结构都内嵌在这个数据结构中struct demo_device&#123;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">demo_device</span> *<span class="title">demo_dev</span>;</span></span><br><span class="line"><span class="comment">//定义延迟的操作函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo_work_func</span><span class="params">(struct work_struct*work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//驱动程序模块初始化代码调用create_singlethread_workqueue创建工作队列</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> int__init <span class="title">demo_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    demo_dev = kzalloc(<span class="keyword">sizeof</span> * demo_dev, GFP_KERNEL);</span><br><span class="line">    demo_dev_wq = create_singlethread_workqueue(<span class="string">"demo_dev_workqueue"</span>);</span><br><span class="line">    INIT_WORK(&amp;demo_dev-&gt;work, demo_work_func);</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模块退出函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo_dev_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    flush_workqueue(demo_dev_wq);</span><br><span class="line">    destroy_workqueue(demo_dev_wq );</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中断处理函数</span></span><br><span class="line"><span class="keyword">irqreturn_t</span>  demo_isr(<span class="keyword">int</span> irq,<span class="keyword">void</span>*dev_id)</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    queue_work(demo_dev_wq, &amp;demo_dev-&gt; work);</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内核创建的工作队列"><a href="#内核创建的工作队列" class="headerlink" title="内核创建的工作队列"></a>内核创建的工作队列</h3><p>Linux系统在初始化阶段的init_workqueues函数中通过调用create_workqueue创建了一个名为events的工作队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">keventd_wq</span> __<span class="title">read_mostly</span>;</span></span><br><span class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">init_workqueues</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    keventd_wq = create_workqueue(<span class="string">"events"</span>);</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面已经仔细讨论了create_workqueue函数，内核在初始化阶段创建的工作队列与驱动程序自己调用create_workqueue函数创建的在本质上没有任何不同。<br>设备驱动程序就算不创建自己的工作队列，也可以利用内核创建的工作队列来实现延迟操作，在提交工作节点时只需要调用queue_work(keventd_wq, work)即可。<br>不过内核已经用另一个函数schedule_work包装了queue_work(keventd_wq, work)调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">schedule_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue_work(keventd_wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，驱动程序如果使用内核创建的工作队列，在提交工作节点时只需调用schedule_work函数就可以了。对应queue_delayed_work，对于内核创建的工作队列而言，延迟提交函数就变成了schedule_delayed_work。</p>
<p>使用内核提供的工作队列的好处是，驱动程序无须创建自己的工作队列就可以提交节点来实现延迟操作。但是不好的地方也很明显：我们正在与系统中其他模块共享一个工作队列以及该队列上的worker_thread，所以队列上的工作节点的多少我们无法预期，意味着我们无法确定在提交一个工作节点之后，需要多长时间才有机会被调度执行。同时，我们也应该注意避免在提交的延迟函数中执行很耗时的任务影响到他人。所以对使用内核创建的工作队列总结起来就是：虽然少了创建队列销毁队列这些麻烦事，但是使用起来的灵活性就下降了。这里没有一成不变的规则，设备驱动程序需要根据实际情况做出适合自己的选择。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>深入讨论了设备驱动程序中经常使用的两种延迟操作的实现机制，分别是tasklet和workqueue。<br>tasklet的实现基于softirq机制，内核在初始化期间就初始化了HI_SOFTIRQ和TASKLET_SOFTIRQ两个softirq所对应的action函数：tasklet_hi_action和tasklet_action。</p>
<p>驱动程序在可以使用tasklet机制实现延迟操作前，需要定义一个tasklet对象，将要延迟的函数封装到该对象中，之后需要调用tasklet_schedule函数向系统提交该对象。<br>中断处理的SOFTIRQ部分发现有等待的softirq需要处理时，就去处理被驱动程序提交的tasklet对象，在那里被打包进tasklet对象的驱动程序中的实际延迟函数将被调用。</p>
<p>当一个tasklet对象在SOFTIRQ部分处理完之后，除非再次提交，否则将不再会被执行。<br>由此可见，通过tasklet实现的延迟操作，是运行在中断处理的上下文环境中，因此它不应该引入睡眠。tasklet是严格串行化的：在任一时刻，同一tasklet只能有一个实例在运行，即使是多处理器系统也是如此。<br>tasklet的另一个特性是：哪个处理器调用tasklet_schedule提交的tasklet，只能在该处理器上运行。</p>
<p>相对于tasklet，工作队列的延迟函数是在一个独立的进程环境下运行的。<br>系统中可能有两种形式的工作队列：singlethread的和非singlethread的。对于多处理器系统而言，前者只在系统中的第一个CPU上产生工作队列和工人线程，而后者则为系统中的每个处理器都产生一个工作队列和工人线程。<br>内核在初始化阶段创建了一个非singlethread的工作队列，驱动程序可以使用该队列，也可以调用create_workqueue或者create_singlethread_workqueue创建属于自己的工作队列。</p>
<p>为了实现延迟操作，驱动程序需要生成一个类型为struct work_struct的工作队列对象，将要延迟执行的函数打包到该对象中，然后通过queue_work函数向工作队列提交该节点。<br>同tasklet对象一样，当work对象被处理完毕后除非被再次提交，否则将不再有执行的机会。与tasklet不同的是，基于工作队列的延迟操作是运行在进程的上下文中，所以允许睡眠。</p>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2021/10/13/linux-interrupt/';
        this.page.title = 'Linux-中断笔记';
        this.page.identifier = '2021/10/13/linux-interrupt/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
