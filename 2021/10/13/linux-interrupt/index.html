<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Linux-中断笔记 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="Linux-Interrupt笔记知识详解笔记
中断中断是外围设备通知处理器的一种机制
典型的例子是:网卡从网络收到报文,把报文放到接收环,然后发送中断请求通知处理器,接着处理器响应中断请求,执行中断处理程序,从网卡的接收环取走报文;网卡驱动程序发送报文的时候,把报文放到网卡的发送环,当网卡从发送环取出报文发送的时候,发送中断请求通知处理器发送完成。
中断控制器外围设备不是把中断请求直接发给处理器,而是发给中断控制器,由中断控制器转发给处理器。ARM公司提供了一种标准的中断控制器,称为通用中断控">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Go/Rust</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">系统内核</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">威胁追踪</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">数据库</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#中断"><span class="toc-number">1.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#中断控制器"><span class="toc-number">1.1.</span> <span class="toc-text">中断控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断域"><span class="toc-number">1.2.</span> <span class="toc-text">中断域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建中断域"><span class="toc-number">1.2.1.</span> <span class="toc-text">创建中断域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建映射"><span class="toc-number">1.2.2.</span> <span class="toc-text">创建映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找映射"><span class="toc-number">1.2.3.</span> <span class="toc-text">查找映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux中断处理"><span class="toc-number">1.3.</span> <span class="toc-text">Linux中断处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断线程化"><span class="toc-number">1.4.</span> <span class="toc-text">中断线程化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#禁止-开启中断"><span class="toc-number">1.5.</span> <span class="toc-text">禁止/开启中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#禁止-开启单个中断"><span class="toc-number">1.6.</span> <span class="toc-text">禁止/开启单个中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断亲和性"><span class="toc-number">1.7.</span> <span class="toc-text">中断亲和性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理器间中断"><span class="toc-number">1.8.</span> <span class="toc-text">处理器间中断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#中断下半部"><span class="toc-number">2.</span> <span class="toc-text">中断下半部</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#软中断"><span class="toc-number">2.1.</span> <span class="toc-text">软中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#软中断的种类"><span class="toc-number">2.1.1.</span> <span class="toc-text">软中断的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册软中断的处理函数"><span class="toc-number">2.1.2.</span> <span class="toc-text">注册软中断的处理函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#触发软中断"><span class="toc-number">2.1.3.</span> <span class="toc-text">触发软中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行软中断"><span class="toc-number">2.1.4.</span> <span class="toc-text">执行软中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抢占计数器"><span class="toc-number">2.1.5.</span> <span class="toc-text">抢占计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#禁止-开启软中断"><span class="toc-number">2.1.6.</span> <span class="toc-text">禁止/开启软中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tasklet"><span class="toc-number">2.2.</span> <span class="toc-text">tasklet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构"><span class="toc-number">2.2.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编程接口"><span class="toc-number">2.2.2.</span> <span class="toc-text">编程接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#技术原理"><span class="toc-number">2.2.3.</span> <span class="toc-text">技术原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#调度小任务"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">调度小任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行小任务"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">执行小任务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作队列"><span class="toc-number">2.3.</span> <span class="toc-text">工作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编程接口-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">编程接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义工作项"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">定义工作项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全局工作队列"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">全局工作队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#专用工作队列"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">专用工作队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他编程接口"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">其他编程接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#技术原理-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">技术原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据结构-1"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#添加工作项"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">添加工作项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工人处理工作"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">工人处理工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工人池动态管理工人"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">工人池动态管理工人</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#系统调用"><span class="toc-number">3.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义系统调用"><span class="toc-number">3.1.</span> <span class="toc-text">定义系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行系统调用"><span class="toc-number">3.2.</span> <span class="toc-text">执行系统调用</span></a></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            Linux-中断笔记
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2021/10/13/linux-interrupt/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-10-13T03:46:11.000Z" itemprop="datePublished">2021-10-13</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Linux/">Linux</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>Linux-Interrupt笔记知识详解笔记<br><a id="more"></a></p>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>中断是外围设备通知处理器的一种机制</p>
<p>典型的例子是:网卡从网络收到报文,把报文放到接收环,然后发送中断请求通知处理器,接着处理器响应中断请求,执行中断处理程序,从网卡的接收环取走报文;<br>网卡驱动程序发送报文的时候,把报文放到网卡的发送环,当网卡从发送环取出报文发送的时候,发送中断请求通知处理器发送完成。</p>
<h2 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h2><p>外围设备不是把中断请求直接发给处理器,而是发给中断控制器,由中断控制器转发给处理器。ARM公司提供了一种标准的中断控制器,称为通用中断控制器(Generic Interrupt Controller, GIC)。目前GIC架构规范有4个版本:v1～v4。GIC v2最多支持8个处理器,GIC v3最多支持128个处理器,GIC v3和GIC v4只支持ARM64处理器。</p>
<p>GIC硬件的实现形态有两种。</p>
<ul>
<li>厂商研发自己的ARM处理器,向ARM公司购买GIC的授权,ARM公司提供的GIC型号有:GIC-400、GIC-500和GIC-600。GIC-400遵循GIC v2规范,GIC-500和GIC-600遵循GIC v3规范。</li>
<li>厂商直接向ARM公司购买处理器的授权,这些处理器包含了GIC。</li>
</ul>
<p>从软件的角度看,GIC v2控制器有两个主要的功能块。</p>
<ul>
<li>分发器(Distributor):系统中所有的中断源连接到分发器,分发器的寄存器用来控制单个中断的属性:优先级、状态、安全、转发信息(可以被发送到哪些处理器)和使能状态。分发器决定哪个中断应该通过处理器接口转发到哪个处理器。</li>
<li>处理器接口(CPU Interface):处理器通过处理器接口接收中断。处理器接口提供的寄存器用来屏蔽和识别中断,控制中断的状态。每个处理器有一个单独的处理器接口。</li>
</ul>
<blockquote>
<p>软件通过中断号识别中断,每个中断号唯一对应一个中断源。中断有以下4种类型。</p>
</blockquote>
<ul>
<li>软件生成的中断(Software Generated Interrupt, SGI):中断号0～15,通常用来实现处理器间中断(Inter-Processor Interrupt, IPI)。<br>  这种中断是由软件写分发器的软件生成中断寄存器(GICD_SGIR)生成的。</li>
<li>私有外设中断(Private Peripheral Interrupt, PPI):中断号16～31。<br>  处理器私有的中断源,不同处理器的相同中断源没有关系,比如每个处理器的定时器。</li>
<li>共享外设中断(Shared Peripheral Interrupt, SPI):中断号32～1020。<br>  这种中断可以被中断控制器转发到多个处理器。</li>
<li>局部特定外设中断(Locality-specific Peripheral Interrupt, LPI):基于消息的中断。<br>  GIC v1和GIC v2不支持LPI。</li>
</ul>
<blockquote>
<p>中断可以是边沿触发(edge-triggered),也可以是电平触发(level-triggered)。</p>
</blockquote>
<p>边沿触发是在电压变化的一瞬间触发,电压由高到低变化触发的中断称为下降沿触发,电压由低到高变化触发的中断称为上升沿触发。<br>电平触发是在高电压或低电压保持的时间内触发,低电压触发的中断称为低电平触发,高电压触发的中断称为高电平触发。</p>
<blockquote>
<p>中断有以下4种状态。</p>
</blockquote>
<ul>
<li>Inactive:中断源没有发送中断。</li>
<li>Pending:中断源已经发送中断,等待处理器处理。</li>
<li>Active:处理器已经确认中断,正在处理。</li>
<li>Active and pending:处理器正在处理中断,相同的中断源又发送了一个中断。</li>
</ul>
<blockquote>
<p>中断的状态转换过程如下。</p>
</blockquote>
<ul>
<li>Inactive -&gt; Pending:外围设备发送了中断。</li>
<li>Pending -&gt; Active:处理器确认了中断。</li>
<li>Active -&gt; Inactive:处理器处理完中断。</li>
</ul>
<p>处理器可以通过中断控制器的寄存器访问中断控制器。<br>中断控制器的寄存器和物理内存使用统一的物理地址空间,把寄存器的物理地址映射到内核的虚拟地址空间,可以像访问内存一样访问寄存器。<br>所有处理器可以访问公共的分发器,但是每个处理器使用相同的地址只能访问自己私有的处理器接口</p>
<p>外围设备把中断发送给分发器,如果中断的状态是inactive,那么切换到pending;如果中断的状态已经是active,那么切换到active and pending。<br>分发器取出优先级最高的状态为pending的中断,转发到目标处理器的处理器接口,然后处理器接口把中断发送到处理器。</p>
<p>处理器取出中断,执行中断处理程序,中断处理程序读取处理器接口的中断确认寄存器(Interrupt Acknowledge Register),得到中断号,读取操作导致分发器里面的中断状态切换到active。<br>中断处理程序根据中断号可以知道中断是由哪个设备发出的,从而调用该设备的处理程序。</p>
<p>中断处理程序执行完的时候,把中断号写到处理器接口的中断结束寄存器(End of Interrupt Register)中, 指示中断处理完成,分发器里面的中断状态从active切换到inactive,或者从active and pending切换到pending。</p>
<p>不同种类的中断控制器的访问方法存在差异,为了屏蔽差异,内核定义了中断控制器描述符irq_chip,每种中断控制器自定义各种操作函数。</p>
<blockquote>
<p>GIC v2控制器的描述符如下:</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-01.png" width="500px"></p>
<h2 id="中断域"><a href="#中断域" class="headerlink" title="中断域"></a>中断域</h2><p>一个大型系统可能有多个中断控制器，这些中断控制器可以级联，一个中断控制器作为中断源连接到另一个中断控制器，但只有一个中断控制器作为根控制器直接连接到处理器。<br>为了把每个中断控制器本地的硬件中断号映射到全局唯一的Linux中断号（也称为虚拟中断号），内核定义了中断域irq_domain，每个中断控制器有自己的中断域。</p>
<h3 id="创建中断域"><a href="#创建中断域" class="headerlink" title="创建中断域"></a>创建中断域</h3><p>一个大型系统可能有多个中断控制器，这些中断控制器可以级联，一个中断控制器作为中断源连接到另一个中断控制器，但只有一个中断控制器作为根控制器直接连接到处理器。<br>为了把每个中断控制器本地的硬件中断号映射到全局唯一的Linux中断号（也称为虚拟中断号），内核定义了中断域irq_domain，每个中断控制器有自己的中断域。</p>
<p>中断控制器的驱动程序使用分配函数irq_domain_add_*()创建和注册中断域。每种映射方法提供不同的分配函数，调用者必须给分配函数提供irq_domain_ops结构体，分配函数在执行成功的时候返回irq_domain的指针。</p>
<p>中断域支持以下映射方法。</p>
<ul>
<li>线性映射（linear map）<br>  线性映射维护一个固定大小的表，索引是硬件中断号。<br>  如果硬件中断号的最大数量是固定的，并且比较小（小于256），那么线性映射是好的选择。<br>  对于线性映射，分配中断域的函数如下<br>  <img src="/2021/10/13/linux-interrupt/image-02.png" width="500px"></li>
<li>树映射（tree map）。<br>  树映射使用基数树（radix tree）保存硬件中断号到Linux中断号的映射。<br>  如果硬件中断号可能非常大，那么树映射是好的选择，因为不需要根据最大硬件中断号分配一个很大的表。<br>  对于树映射，分配中断域的函数如下<br>  <img src="/2021/10/13/linux-interrupt/image-03.png" width="500px"></li>
<li>不映射（no map）<br>  有些中断控制器很强，硬件中断号是可以配置的，例如PowerPC架构使用的MPIC （Multi-Processor Interrupt Controller）。<br>  我们直接把Linux中断号写到硬件，硬件中断号就是Linux中断号，不需要映射。<br>  对于不映射，分配中断域的函数如下<br>  <img src="/2021/10/13/linux-interrupt/image-04.png" width="500px"><br>  分配函数把主要工作委托给函数<strong>irq_domain_add()。<br>  函数</strong>irq_domain_add()的执行过程是：分配一个irq_domain结构体，初始化成员，然后把中断域添加到全局链表irq_domain_list中。</li>
</ul>
<h3 id="创建映射"><a href="#创建映射" class="headerlink" title="创建映射"></a>创建映射</h3><p>创建中断域以后，需要向中断域添加硬件中断号到Linux中断号的映射，内核提供了函数irq_create_mapping</p>
<p><img src="/2021/10/13/linux-interrupt/image-05.png" width="500px"></p>
<p>输入参数是中断域和硬件中断号，返回Linux中断号。<br>该函数首先分配Linux中断号，然后把硬件中断号到Linux中断号的映射添加到中断域。</p>
<h3 id="查找映射"><a href="#查找映射" class="headerlink" title="查找映射"></a>查找映射</h3><p>中断处理程序需要根据硬件中断号查找Linux中断号，内核提供了函数irq_find_mapping</p>
<p><img src="/2021/10/13/linux-interrupt/image-06.png" width="500px"></p>
<p>输入参数是中断域和硬件中断号，返回Linux中断号。</p>
<h2 id="Linux中断处理"><a href="#Linux中断处理" class="headerlink" title="Linux中断处理"></a>Linux中断处理</h2><p>对于中断控制器的每个中断源，向中断域添加硬件中断号到Linux中断号的映射时，内核分配一个Linux中断号和一个中断描述符irq_desc，如图所示，中断描述符有两个层次的中断处理函数。</p>
<p><img src="/2021/10/13/linux-interrupt/image-07.png" width="500px"></p>
<ul>
<li>第一层处理函数是中断描述符的成员handle_irq()。</li>
<li>第二层处理函数是设备驱动程序注册的处理函数。中断描述符有一个中断处理链表（irq_desc.action），每个中断处理描述符（irq_action）保存设备驱动程序注册的处理函数。因为多个设备可以共享同一个硬件中断号，所以中断处理链表可能挂载多个中断处理描述符。</li>
</ul>
<blockquote>
<p>怎么存储Linux中断号到中断描述符的映射关系？有两种实现方式。</p>
</blockquote>
<ul>
<li>如果中断编号是稀疏的（即不连续），那么使用基数树（radix tree）存储。需要开启配置宏CONFIG_SPARSE_IRQ。</li>
<li>如果中断编号是连续的，那么使用数组存储。</li>
</ul>
<p><img src="/2021/10/13/linux-interrupt/image-08.png" width="500px"></p>
<blockquote>
<p>ARM64架构默认开启配置宏CONFIG_SPARSE_IRQ，使用基数树存储。</p>
</blockquote>
<p>把硬件中断号映射到Linux中断号的时候，根据硬件中断的类型设置中断描述符的成员handle_irq()，以GIC v2控制器为例，函数gic_irq_domain_map所做的处理如下所示。</p>
<ul>
<li>如果硬件中断号小于32，说明是软件生成的中断或私有外设中断，那么把中断描述符的成员handle_irq()设置为函数handle_percpu_devid_irq。</li>
<li>如果硬件中断号大于或等于32，说明是共享外设中断，那么把中断描述符的成员handle_irq()设置为函数handle_fasteoi_irq。</li>
</ul>
<p><img src="/2021/10/13/linux-interrupt/image-09.png" width="700px"></p>
<blockquote>
<p>设备驱动程序可以使用函数request_irq()注册中断处理函数：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *dev)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数irq是Linux中断号。</li>
<li>参数handler是处理函数。</li>
<li>参数fags是标志位，可以是0或者以下标志位的组合。<ul>
<li>IRQF_SHARED：允许多个设备共享同一个中断号。</li>
<li><code>__IRQF_TIMER</code>：定时器中断。</li>
<li>IRQF_PERCPU：中断是每个处理器私有的。</li>
<li>IRQF_NOBALANCING：不允许该中断在处理器之间负载均衡。</li>
<li>IRQF_NO_THREAD：中断不能线程化。</li>
</ul>
</li>
<li>参数name是设备名称。</li>
<li>参数dev是传给处理函数（由参数handler指定）的参数。</li>
</ul>
<blockquote>
<p>在ARM64架构下，在异常级别1的异常向量表中，中断的入口有3个。</p>
</blockquote>
<ul>
<li>如果处理器处在内核模式（异常级别1），中断的入口是el1_irq。</li>
<li>如果处理器正在用户模式（异常级别0）下执行64位应用程序，中断的入口是el0_irq。</li>
<li>如果处理器正在用户模式（异常级别0）下执行32位应用程序，中断的入口是el0_irq_compat。</li>
</ul>
<p>假设处理器正在用户模式（异常级别0）下执行64位应用程序，中断控制器是GIC v2控制器，Linux中断处理流程如图所示</p>
<p><img src="/2021/10/13/linux-interrupt/image-10.png" width="600px"></p>
<ul>
<li>读取处理器接口的中断确认寄存器得到中断号，分发器里面的中断状态切换到active。</li>
<li>如果硬件中断号大于15且小于1020，即中断是由外围设备发送的，处理如下。<ul>
<li>把中断号写到处理器接口的中断结束寄存器中，指示中断处理完成，分发器里面的中断状态从active切换到inactive，或者从active and pending切换到pending。</li>
<li>调用函数irq_enter()，进入中断上下文。</li>
<li>调用函数irq_find_mapping()，根据硬件中断号查找Linux中断号。</li>
<li>调用中断描述符的成员handle_irq()。</li>
<li>调用函数irq_exit()，退出中断上下文。</li>
</ul>
</li>
<li>如果硬件中断号小于16，即中断是由软件生成的，处理如下。<ul>
<li>把中断号写到处理器接口的中断结束寄存器中，指示中断处理完成。</li>
<li>调用函数handle_IPI()进行处理。</li>
</ul>
</li>
</ul>
<blockquote>
<p>函数el0_irq的代码如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-11.png" width="500px"></p>
<ul>
<li>把进程的寄存器值保存到内核栈。</li>
<li>开启调试异常。</li>
<li><p>irq_handler是一个宏，执行过程如下。</p>
<ul>
<li>从进程的内核栈切换到中断栈。每个处理器有一个专用的中断栈：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arch/arm64/kerne1/ irq. c</span><br><span class="line">DEFINE_PER_CPU(<span class="keyword">unsigned</span> <span class="number">1</span>ong [IRQ_STACK_SIZE/<span class="keyword">sizeof</span> (<span class="number">1</span>ong)]，irg_stack)__aligned(<span class="number">16</span>) ;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>调用函数指针handle_arch_irq指向的函数。中断控制器在内核初始化的时候设置函数指针handle_arch_irq, GIC v2控制器把该函数指针设置为函数gic_handle_irq。</p>
</li>
<li>从中断栈切换到进程的内核栈。</li>
<li>使用内核栈保存的寄存器值恢复进程的寄存器，返回用户模式。</li>
</ul>
<blockquote>
<p>GIC v2控制器的函数gic_handle_irq的代码如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-12.png" width="500px"></p>
<p>如果是私有外设中断，那么中断描述符的成员handle_irq()是函数handle_percpu_devid_irq，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-13.png" width="500px"></p>
<p>如果是共享外设中断，那么中断描述符的成员handle_irq()是函数handle_fasteoi_irq，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-14.png" width="500px"></p>
<p>调用函数handle_irq_event，执行设备驱动程序注册的处理函数。<br>函数handle_irq_event把主要工作委托给函数<code>__handle_irq_event_percpu</code>。<br>函数<code>__handle_irq_event_percpu</code>遍历中断描述符的中断处理链表，执行每个中断处理描述符的处理函数，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-15.png" width="500px"></p>
<h2 id="中断线程化"><a href="#中断线程化" class="headerlink" title="中断线程化"></a>中断线程化</h2><p>中断线程化就是使用内核线程处理中断，目的是减少系统关中断的时间，增强系统的实时性。<br>内核提供的函数request_threaded_irq()用来注册线程化的中断</p>
<p><img src="/2021/10/13/linux-interrupt/image-16.png" width="600px"></p>
<p>参数thread_fn是线程处理函数。<br>少数中断不能线程化，典型的例子是时钟中断，有些流氓进程不主动让出处理器，内核只能依靠周期性的时钟中断夺回处理器的控制权，时钟中断是调度器的脉搏。<br>对于不能线程化的中断，注册处理函数的时候必须设置标志<code>IRQF_NO_THREAD</code>。<br>如果开启了强制中断线程化的配置宏<code>CONFIG_IRQ_FORCED_THREADING</code>，并且在引导内核的时候指定内核参数<code>“threadirqs”</code>，那么强制除了标记<code>IRQF_NO_THREAD</code>以外的所有中断线程化。<br>ARM64架构默认开启配置宏<code>CONFIG_IRQ_FORCED_THREADING</code>。</p>
<p>每个中断处理描述符（irqaction）对应一个内核线程，成员thread指向内核线程的进程描述符，成员thread_fn指向线程处理函数，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-17.png" width="400px"></p>
<p>可以看到，中断处理线程是优先级为50、调度策略是SCHED_FIFO的实时内核线程，名称是“irq/”后面跟着Linux中断号，线程处理函数是irq_thread()。</p>
<p><img src="/2021/10/13/linux-interrupt/image-18.png" width="600px"></p>
<p>在中断处理程序中，函数__handle_irq_event_percpu遍历中断描述符的中断处理链表，执行每个中断处理描述符的处理函数。<br>如果处理函数返回IRQ_WAKE_THREAD，说明是线程化的中断，那么唤醒中断处理线程。</p>
<p><img src="/2021/10/13/linux-interrupt/image-19.png" width="600px"></p>
<p>中断处理线程的处理函数是irq_thread()，调用函数irq_thread_fn()，然后函数irq_thread_fn()调用注册的线程处理函数。</p>
<p><img src="/2021/10/13/linux-interrupt/image-20.png" width="600px"></p>
<h2 id="禁止-开启中断"><a href="#禁止-开启中断" class="headerlink" title="禁止/开启中断"></a>禁止/开启中断</h2><p>软件可以禁止中断，使处理器不响应所有中断请求，但是不可屏蔽中断（Non Maskable Interrupt,NMI）是个例外。</p>
<blockquote>
<p>禁止中断的接口如下</p>
</blockquote>
<ul>
<li>local_irq_disable()。</li>
<li>local_irq_save(fags)：首先把中断状态保存在参数fags中，然后禁止中断。</li>
</ul>
<p>这两个接口只能禁止本处理器的中断，不能禁止其他处理器的中断。禁止中断以后，处理器不会响应中断请求。</p>
<blockquote>
<p>开启中断的接口如下</p>
</blockquote>
<ul>
<li>local_irq_enable()。</li>
<li>local_irq_restore(fags)：恢复本处理器的中断状态。local_irq_disable()和local_irq_enable()不能嵌套使用，local_irq_save(fags)和local_irq_restore(fags)可以嵌套使用。</li>
</ul>
<blockquote>
<p>ARM64架构禁止中断的函数local_irq_disable()如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-21.png" width="600px"></p>
<p>把处理器状态的中断掩码位设置成1，从此以后处理器不会响应中断请求。<br>ARM64架构开启中断的函数local_irq_enable()如下：</p>
<p><img src="/2021/10/13/linux-interrupt/image-22.png" width="600px"></p>
<p>把处理器状态的中断掩码位设置成0</p>
<h2 id="禁止-开启单个中断"><a href="#禁止-开启单个中断" class="headerlink" title="禁止/开启单个中断"></a>禁止/开启单个中断</h2><p>软件可以禁止某个外围设备的中断，中断控制器不会把该设备发送的中断转发给处理器。</p>
<blockquote>
<p>禁止单个中断的函数是</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disable_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数irq是Linux中断号。</p>
<blockquote>
<p>开启单个中断的函数是</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数irq是Linux中断号。</p>
<p>对于ARM64架构的GIC控制器，如果需要开启硬件中断n，那么设置分发器的寄存器GICD_ISENABLERn（Interrupt Set-Enable Register）；<br>如果需要禁止硬件中断n，那么设置分发器的寄存器GICD_ICENABLERn（Interrupt Clear-Enable Register）。</p>
<p>假设某个外围设备的硬件中断号是n，当这个外围设备发送中断给分发器的时候，只有在分发器上开启了硬件中断n，分发器才会把硬件中断n转发给处理器。</p>
<h2 id="中断亲和性"><a href="#中断亲和性" class="headerlink" title="中断亲和性"></a>中断亲和性</h2><p>在多处理器系统中，管理员可以设置中断亲和性，允许中断控制器把某个中断转发给哪些处理器，有两种配置方法。</p>
<ul>
<li>写文件“/proc/irq/IRQ#/smp_affinity”，参数是位掩码。</li>
<li>写文件“/proc/irq/IRQ#/smp_affinity_list”，参数是处理器列表。</li>
</ul>
<p>例如，管理员想要配置允许中断控制器把Linux中断号为32的中断转发给处理器0～3，配置方法有两种。</p>
<ul>
<li><code>echo 0f &gt; /proc/irq/32/smp_affinity</code></li>
<li><code>echo 0-3 &gt; /proc/irq/32/smp_affinity_list</code></li>
</ul>
<p>配置完以后，可以连续执行命令<code>“cat /proc/interrupts | grep &#39;CPU\|32:&#39;”</code>，观察是否只有处理器0～3收到了Linux中断号为32的中断。</p>
<p>内核提供了设置中断亲和性的函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">irq_set_affinity</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">const</span> struct cpumask *cpumask)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>参数irq是Linux中断号，参数cpumask是处理器位掩码。</p>
<p>对于ARM64架构的GIC控制器，可以设置分发器的寄存器GICD_ITARGETSRn（中断目标寄存器，Interrupt Targets Register）允许把硬件中断n转发到哪些处理器，硬件中断n必须是共享外设中断。</p>
<h2 id="处理器间中断"><a href="#处理器间中断" class="headerlink" title="处理器间中断"></a>处理器间中断</h2><p>处理器间中断（Inter-Processor Interrupt, IPI）是一种特殊的中断，在多处理器系统中，一个处理器可以向其他处理器发送中断，要求目标处理器执行某件事情。常见的使用处理器间中断的函数如下。</p>
<ul>
<li>在所有其他处理器上执行一个函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smp_call_function</span><span class="params">(<span class="keyword">smp_call_func_t</span> func, <span class="keyword">void</span> *info, <span class="keyword">int</span> wait)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数func是要执行的函数，目标处理器在中断处理程序中执行该函数；<br>参数info是传给函数func的参数；参数wait表示是否需要等待目标处理器执行完函数。</p>
<ul>
<li>在指定的处理器上执行一个函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smp_call_function_single</span><span class="params">(<span class="keyword">int</span> cpu, <span class="keyword">smp_call_func_t</span> func, <span class="keyword">void</span> *info, <span class="keyword">int</span> wait)</span></span>;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- 要求指定的处理器重新调度进程</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">smp_send_reschedule</span><span class="params">(<span class="keyword">int</span> cpu)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于ARM64架构的GIC控制器，把处理器间中断称为软件生成的中断，可以写分发器的寄存器GICD_SGIR（软件生成中断寄存器，Software Generated Interrupt Register）以生成处理器间中断。</p>
<p>假设处理器正在用户模式（异常级别0）下执行64位应用程序，中断控制器是GIC v2控制器，处理处理器间中断的执行流程如图所示。</p>
<p><img src="/2021/10/13/linux-interrupt/image-23.png" width="400px"></p>
<p>函数handle_IPI负责处理处理器间中断，参数ipinr是硬件中断号，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-24.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-25.png" width="600px"></p>
<p>目前支持7种处理器间中断。</p>
<ul>
<li>IPI_RESCHEDULE：硬件中断号是0，重新调度进程，函数smp_send_reschedule()生成的中断。</li>
<li>IPI_CALL_FUNC：硬件中断号是1，执行函数，函数smp_call_function()生成的中断。</li>
<li>IPI_CPU_STOP：硬件中断号是2，使处理器停止，函数smp_send_stop()生成的中断。</li>
<li>IPI_CPU_CRASH_STOP：硬件中断号是3，使处理器停止，函数smp_send_crash_stop()生成的中断。</li>
<li>IPI_TIMER：硬件中断号是4，广播的时钟事件，函数tick_broadcast()生成的中断。</li>
<li>IPI_IRQ_WORK：硬件中断号是5，在硬中断上下文中执行回调函数，函数irq_work_queue()生成的中断。</li>
<li>IPI_WAKEUP：硬件中断号是6，唤醒处理器，函数acpi_parking_protocol_cpu_boot()生成的中断。</li>
</ul>
<p><br><br><br></p>
<hr>

<h1 id="中断下半部"><a href="#中断下半部" class="headerlink" title="中断下半部"></a>中断下半部</h1><p>为了避免处理复杂的中断嵌套，中断处理程序是在关闭中断的情况下执行的。可是，如果关闭中断的时间太长，可能导致中断请求丢失。例如周期时钟每隔10毫秒发送一个中断请求，如果执行某个中断处理程序花费的时间超过10毫秒，在这段时间里时钟发送了两个中断请求，但是处理器只认为收到一个时钟中断请求。</p>
<p>最激进的解决办法是中断线程化，但是常用的解决办法是：把中断处理程序分为两部分，上半部（top half, th）在关闭中断的情况下执行，只做对时间非常敏感、与硬件相关或者不能被其他中断打断的工作；下半部（bottom half, bh）在开启中断的情况下执行，可以被其他中断打断。</p>
<blockquote>
<p>上半部称为硬中断（hardirq），下半部有3种：软中断（softirq）、小任务（tasklet）和工作队列（workqueue）。3种下半部的区别如下。</p>
</blockquote>
<ul>
<li>软中断和小任务不允许睡眠；工作队列是使用内核线程实现的，处理函数可以睡眠。</li>
<li>软中断的种类是编译时静态定义的，在运行时不能添加或删除；小任务可以在运行时添加或删除。</li>
<li>同一种软中断的处理函数可以在多个处理器上同时执行，处理函数必须是可以重入的，需要使用锁保护临界区；一个小任务同一时刻只能在一个处理器上执行，不要求处理函数是可以重入的。</li>
</ul>
<h2 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h2><p>软中断（softirq）是中断处理程序在开启中断的情况下执行的部分，可以被硬中断抢占。<br>内核定义了一张软中断向量表，每种软中断有一个唯一的编号，对应一个softirq_action实例，softirq_action实例的成员action是处理函数。</p>
<p><img src="/2021/10/13/linux-interrupt/image-26.png" width="600px"></p>
<h3 id="软中断的种类"><a href="#软中断的种类" class="headerlink" title="软中断的种类"></a>软中断的种类</h3><p>目前内核定义了10种软中断，各种软中断的编号如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-27.png" width="600px"></p>
<ul>
<li>HI_SOFTIRQ：高优先级的小任务。</li>
<li>TIMER_SOFTIRQ：定时器软中断。</li>
<li>NET_TX_SOFTIRQ：网络栈发送报文的软中断。</li>
<li>NET_RX_SOFTIRQ：网络栈接收报文的软中断。</li>
<li>BLOCK_SOFTIRQ：块设备软中断。</li>
<li>IRQ_POLL_SOFTIRQ：支持I/O轮询的块设备软中断。</li>
<li>TASKLET_SOFTIRQ：低优先级的小任务。</li>
<li>SCHED_SOFTIRQ：调度软中断，用于在处理器之间负载均衡。</li>
<li>HRTIMER_SOFTIRQ：高精度定时器，这种软中断已经被废弃，目前在中断处理程序的上半部处理高精度定时器。</li>
<li>RCU_SOFTIRQ:RCU软中断。</li>
</ul>
<p>软中断的编号形成了优先级顺序，编号小的软中断优先级高。</p>
<h3 id="注册软中断的处理函数"><a href="#注册软中断的处理函数" class="headerlink" title="注册软中断的处理函数"></a>注册软中断的处理函数</h3><p>函数open_softirq()用来注册软中断的处理函数，在软中断向量表中为指定的软中断编号设置处理函数。</p>
<p><img src="/2021/10/13/linux-interrupt/image-28.png" width="600px"></p>
<p>同一种软中断的处理函数可以在多个处理器上同时执行，处理函数必须是可以重入的，需要使用锁保护临界区。</p>
<h3 id="触发软中断"><a href="#触发软中断" class="headerlink" title="触发软中断"></a>触发软中断</h3><p>函数raise_softirq用来触发软中断，参数是软中断编号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_softirq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在已经禁止中断的情况下可以调用函数raise_softirq_irqoff来触发软中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_softirq_irqoff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数raise_softirq在当前处理器的待处理软中断位图中为指定的软中断编号设置对应的位，如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">raise_softirq()-&gt;raise_softirq_irqoff()-&gt;__raise_softirq_irqoff()</span><br><span class="line">kernel/softirq.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __raise_softirq_irqoff(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span><br><span class="line">&#123;</span><br><span class="line">	or_softirq_pending(<span class="number">1U</span>L &lt;&lt; nr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把宏or_softirq_pending展开以后是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irq_stat[smp_processor_id()].__softirq_pending |= (<span class="number">1U</span>L &lt;&lt; nr);</span><br></pre></td></tr></table></figure>
<h3 id="执行软中断"><a href="#执行软中断" class="headerlink" title="执行软中断"></a>执行软中断</h3><p>内核执行软中断的地方如下。</p>
<ul>
<li>在中断处理程序的后半部分执行软中断，对执行时间有限制：不能超过2毫秒，并且最多执行10次。</li>
<li>每个处理器有一个软中断线程，调度策略是SCHED_NORMAL，优先级是120。</li>
<li>开启软中断的函数local_bh_enable()。</li>
</ul>
<p>如果开启了强制中断线程化的配置宏CONFIG_IRQ_FORCED_THREADING，并且在引导内核的时候指定内核参数“threadirqs”，那么所有软中断由软中断线程执行。</p>
<blockquote>
<p>中断处理程序执行软中断</p>
</blockquote>
<p>在中断处理程序的后半部分，调用函数irq_exit()以退出中断上下文，处理软中断，其代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kernel/softirq.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">irq_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	preempt_count_sub(HARDIRQ_OFFSET);</span><br><span class="line">	<span class="keyword">if</span>(!in_interrupt() &amp;&amp; local_softirq_pending())&#123;</span><br><span class="line">		invoke_softirq();</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果in_interrupt()为真，表示在不可屏蔽中断、硬中断或软中断上下文，或者禁止软中断。<br>如果正在处理的硬中断没有抢占正在执行的软中断，没有禁止软中断，并且当前处理器的待处理软中断位图不是空的，那么调用函数invoke_softirq()来处理软中断。</p>
<p>函数invoke_softirq的代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kernel/softirq.c</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">invoke_softirq</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ksoftirqd_running())&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!force_irqthreads)&#123;</span><br><span class="line">		__do_softirq();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		wakeup_softirqd();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果软中断线程处于就绪状态或运行状态，那么让软中断线程执行软中断。</li>
<li>如果没有强制中断线程化，那么调用函数__do_softirq()执行软中断。</li>
<li>如果强制中断线程化，那么唤醒软中断线程执行软中断。</li>
</ul>
<p>函数__do_softirq是执行软中断的核心函数，其主要代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-29.png" width="600px"></p>
<p><img src="/2021/10/13/linux-interrupt/image-30.png" width="600px"></p>
<ul>
<li>把抢占计数器的软中断计数加1。第20行代码，把当前处理器的待处理软中断位图重新设置为0。</li>
<li>开启硬中断。</li>
<li>从低位向高位扫描待处理软中断位图，针对每个设置了对应位的软中断编号，执行软中断的处理函数。</li>
<li>禁止硬中断。</li>
<li>如果软中断的处理函数又触发软中断，处理如下。<ul>
<li>如果软中断的执行时间小于2毫秒，不需要重新调度进程，并且软中断的执行次数没超过10，那么跳转到第19行代码继续执行软中断。</li>
<li>唤醒软中断线程执行软中断。</li>
</ul>
</li>
<li>把抢占计数器的软中断计数减1。</li>
</ul>
<blockquote>
<p>软中断线程</p>
</blockquote>
<p>每个处理器有一个软中断线程，名称是<code>“ksoftirqd/”</code>后面跟着处理器编号，调度策略是SCHED_NORMAL，优先级是120。<br>软中断线程的核心函数是run_ksoftirqd()，其代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kernel/softirq.c</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run_ksoftirqd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	local_irq_disabled();</span><br><span class="line">	<span class="keyword">if</span>(local_softirq_pending())&#123;</span><br><span class="line">		__do_softirq();</span><br><span class="line">		local_irq_enable();</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	local_irq_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>开启软中断时执行软中断</p>
</blockquote>
<p>当进程调用函数local_bh_enable()开启软中断的时候，如果是开启最外层的软中断，并且当前处理器的待处理软中断位图不是空的，那么执行软中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">local_bh_enable() -&gt; __local_bh_enable_ip()</span><br><span class="line">kernel/softirq.c</span><br><span class="line"><span class="keyword">void</span> __local_bh_enable_ip(<span class="keyword">unsigned</span> <span class="keyword">long</span> ip, <span class="keyword">unsigned</span> <span class="keyword">int</span> cnt)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	preempt_count_sub(cnt - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(unlikely(!in_interrupt() &amp;&amp; local_softirq_pending()))&#123;</span><br><span class="line">		do_softirq();</span><br><span class="line">	&#125;</span><br><span class="line">	preempt_count_dec();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抢占计数器"><a href="#抢占计数器" class="headerlink" title="抢占计数器"></a>抢占计数器</h3><p>在介绍“禁止/开启软中断”之前，首先了解一下抢占计数器这个背景知识。每个进程的thread_info结构体有一个抢占计数器：int preempt_count，它用来表示当前进程能不能被抢占。<br>抢占是指当进程在内核模式下运行的时候可以被其他进程抢占，如果优先级更高的进程处于就绪状态，强行剥夺当前进程的处理器使用权。<br>但是有时候进程可能在执行一些关键操作，不能被抢占，所以内核设计了抢占计数器。如果抢占计数器为0，表示可以被抢占；如果抢占计数器不为0，表示不能被抢占。<br>当中断处理程序返回的时候，如果进程在被打断的时候正在内核模式下执行，就会检查抢占计数器是否为0。如果抢占计数器是0，可以让优先级更高的进程抢占当前进程。</p>
<p>虽然抢占计数器不为0意味着禁止抢占，但是内核进一步按照各种场景对抢占计数器的位进行了划分，如图所示。</p>
<p><img src="/2021/10/13/linux-interrupt/image-31.png" width="600px"></p>
<p>其中第0～7位是抢占计数，第8～15位是软中断计数，第16～19位是硬中断计数，第20位是不可屏蔽中断（Non Maskable Interrupt, NMI）计数</p>
<p><img src="/2021/10/13/linux-interrupt/image-32.png" width="600px"></p>
<p>各种场景分别利用各自的位禁止或开启抢占。</p>
<ul>
<li>普通场景（PREEMPT_MASK）：对应函数<code>preempt_disable()</code>和<code>preempt_enable()</code>。</li>
<li>软中断场景（SOFTIRQ_MASK）：对应函数<code>local_bh_disable()</code>和<code>local_bh_enable()</code>。</li>
<li>硬中断场景（HARDIRQ_MASK）：对应函数 <code>__irq_enter()</code>和<code>__irq_exit()</code>。</li>
<li>不可屏蔽中断场景（NMI_MASK）：对应函数<code>nmi_enter()</code>和<code>nmi_exit()</code>。</li>
</ul>
<p>反过来，我们可以通过抢占计数器的值判断当前处在什么场景</p>
<p><img src="/2021/10/13/linux-interrupt/image-33.png" width="600px"></p>
<p>in_irq()表示硬中断场景，也就是正在执行硬中断。<br>in_softirq()表示软中断场景，包括禁止软中断和正在执行软中断。<br>in_interrupt()表示正在执行不可屏蔽中断、硬中断或软中断，或者禁止软中断。<br>in_serving_softirq()表示正在执行软中断。<br>in_nmi()表示不可屏蔽中断场景。<br>in_task()表示普通场景，也就是进程上下文。</p>
<h3 id="禁止-开启软中断"><a href="#禁止-开启软中断" class="headerlink" title="禁止/开启软中断"></a>禁止/开启软中断</h3><p>如果进程和软中断可能访问同一个对象，那么进程和软中断需要互斥，进程需要禁止软中断。<br>禁止软中断的函数是local_bh_disable()，注意：这个函数只能禁止本处理器的软中断，不能禁止其他处理器的软中断。</p>
<p>该函数把抢占计数器的软中断计数加2，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-34.png" width="600px"></p>
<p>开启软中断的函数是local_bh_enable()，该函数把抢占计数器的软中断计数减2。</p>
<blockquote>
<p>为什么禁止软中断的函数local_bh_disable()把抢占计数器的软中断计数加2，而不是加1呢？</p>
</blockquote>
<p>目的是区分禁止软中断和正在执行软中断这两种情况。<br>执行软中断的函数__do_softirq()把抢占计数器的软中断计数加1。<br>如果软中断计数是奇数，可以确定正在执行软中断。</p>
<h2 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h2><p>tasklet是基于软中断实现的。</p>
<blockquote>
<p>为什么要提供小任务(tasklet)？</p>
</blockquote>
<p>因为小任务相对软中断有以下优势。</p>
<ul>
<li>软中断的种类是编译时静态定义的，在运行时不能添加或删除；小任务可以在运行时添加或删除。</li>
<li>同一种软中断的处理函数可以在多个处理器上同时执行，处理函数必须是可以重入的，需要使用锁保护临界区；<br>  一个小任务同一时刻只能在一个处理器上执行，不要求处理函数是可以重入的。<br>  小任务根据优先级分为两种：低优先级小任务和高优先级小任务。</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><blockquote>
<p>小任务的数据结构如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-35.png" width="600px"></p>
<p>成员next用来把小任务添加到单向链表中。成员state是小任务的状态，取值如下。</p>
<ul>
<li>0：小任务没有被调度。</li>
<li>(1 &lt;&lt; TASKLET_STATE_SCHED)：小任务被调度，即将被执行。</li>
<li>(1 &lt;&lt; TASKLET_STATE_RUN)：只在多处理器系统中使用，表示小任务正在执行。</li>
</ul>
<p>成员count是计数，0表示允许小任务被执行，非零值表示禁止小任务被执行。<br>成员func是处理函数，成员data是传给处理函数的参数。</p>
<blockquote>
<p>每个处理器有两条单向链表：低优先级小任务链表和高优先级小任务链表。</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-36.png" width="600px"></p>
<h3 id="编程接口"><a href="#编程接口" class="headerlink" title="编程接口"></a>编程接口</h3><p>定义一个静态的小任务，并且允许小任务被执行，方法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_TASKLET(name, func, data);</span><br></pre></td></tr></table></figure>
<p>定义一个静态的小任务，并且禁止小任务被执行，方法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_TASKLET_DISABLED(name, func, data);</span><br></pre></td></tr></table></figure>
<p>在运行时动态初始化小任务，并且允许小任务被执行，方法如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void tasklet_init(struct tasklet_struct *t, void(*func)(unsigned long), unsigned long data);</span><br></pre></td></tr></table></figure>
<p>函数tasklet_disable()用来禁止小任务被执行，如果小任务正在被执行，该函数等待小任务执行完。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_disable</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数tasklet_disable_nosync()用来禁止小任务被执行，如果小任务正在被执行，该函数不会等待小任务执行完。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_disable_nosync</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数tasklet_enable()用来允许小任务被执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_enable</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数tasklet_schedule()用来调度低优先级小任务：把小任务添加到当前处理器的低优先级小任务链表中，并且触发低优先级小任务软中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_schedule</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数tasklet_hi_schedule()用来调度高优先级小任务：把小任务添加到当前处理器的高优先级小任务链表的尾部，并且触发高优先级小任务软中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_hi_schedule</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数tasklet_hi_schedule_first()用来调度高优先级小任务：把小任务添加到当前处理器的高优先级小任务链表的首部，并且触发高优先级小任务软中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_hi_schedule_first</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数tasklet_kill()用来杀死小任务，确保小任务不会被调度和执行。如果小任务正在被执行，该函数等待小任务执行完。通常在卸载内核模块的时候调用该函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_kill</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h3><p>小任务是基于软中断实现的，根据优先级分为两种：低优先级小任务和高优先级小任务。软中断HI_SOFTIRQ执行高优先级小任务，软中断TASKLET_SOFTIRQ执行低优先级小任务。</p>
<h4 id="调度小任务"><a href="#调度小任务" class="headerlink" title="调度小任务"></a>调度小任务</h4><p>函数tasklet_schedule()用来调度低优先级小任务，函数tasklet_hi_schedule()用来调度高优先级小任务。<br>以函数tasklet_schedule()为例说明，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-37.png" width="600px"></p>
<p>如果小任务没有被调度过，那么首先设置调度标志位，然后把小任务添加到当前处理器的低优先级小任务链表的尾部，最后触发软中断TASKLET_SOFTIRQ。</p>
<h4 id="执行小任务"><a href="#执行小任务" class="headerlink" title="执行小任务"></a>执行小任务</h4><p>初始化的时候，把软中断TASKLET_SOFTIRQ的处理函数注册为函数tasklet_action，把软中断HI_SOFTIRQ的处理函数注册为函数tasklet_hi_action</p>
<p><img src="/2021/10/13/linux-interrupt/image-38.png" width="500px"></p>
<p>以函数tasklet_action()为例说明，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-39.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-40.png" width="600px"></p>
<ul>
<li>把当前处理器的低优先级小任务链表中的所有小任务移到临时链表list中。</li>
<li>遍历临时链表list，依次处理每个小任务，如下。<ul>
<li>尝试锁住小任务，确保一个小任务同一时刻只在一个处理器上执行。</li>
<li>如果小任务的计数为0，表示允许小任务被执行。</li>
<li>清除小任务的调度标志位，其他处理器可以调度这个小任务，但是不能执行这个小任务。</li>
<li>执行小任务的处理函数。</li>
<li>释放小任务的锁，其他处理器就可以执行这个小任务了。</li>
<li>如果尝试锁住小任务失败（表示小任务正在其他处理器上执行），或者禁止小任务被执行，那么把小任务重新添加到当前处理器的低优先级小任务链表的尾部，然后触发软中断TASKLET_SOFTIRQ。</li>
</ul>
</li>
</ul>
<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p>工作队列（work queue）是使用内核线程异步执行函数的通用机制。</p>
<p>工作队列是中断处理程序的一种下半部机制，中断处理程序可以把耗时比较长并且可能睡眠的函数交给工作队列执行。<br>工作队列不完全是中断处理程序的下半部。内核的很多模块需要异步执行函数，这些模块可以创建一个内核线程来异步执行函数。<br>但是如果每个模块都创建自己的内核线程，会造成内核线程的数量过多，内存消耗比较大，影响系统性能。<br>所以最好的方法是提供一种通用机制，让这些模块把需要异步执行的函数交给工作队列执行，共享内核线程，节省资源。</p>
<h3 id="编程接口-1"><a href="#编程接口-1" class="headerlink" title="编程接口"></a>编程接口</h3><p>内核使用工作项保存需要异步执行的函数，工作项的数据类型是work_struct，需要异步执行的函数的原型如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">work_func_t</span>)</span><span class="params">(struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>有一类工作项称为延迟工作项，数据类型是delayed_work。把延迟工作项添加到工作队列中的时候，延迟一段时间才会真正地把工作项添加到工作队列中。延迟工作项是工作项和定时器的结合，可以避免使用者自己创建定时器。</p>
<p>我们可以使用内核定义的工作队列，也可以自己创建专用的工作队列。内核定义了以下工作队列</p>
<p><img src="/2021/10/13/linux-interrupt/image-41.png" width="600px"></p>
<ul>
<li>system_wq：如果工作项的执行时间比较短，应该使用这个工作队列。早期的内核版本只提供了这个工作队列，称为全局工作队列，函数schedule_work()和schedule_delayed_work()使用这个工作队列。</li>
<li>system_highpri_wq：高优先级的工作队列。</li>
<li>system_long_wq：如果工作项的执行时间比较长，应该使用这个工作队列。</li>
<li>system_unbound_wq：这个工作队列使用的内核线程不绑定到某个特定的处理器。</li>
<li>system_freezable_wq：这个工作队列可以冻结。</li>
<li>system_power_efficient_wq：如果开启了工作队列模块的参数“wq_power_efficient”，那么这个工作队列倾向于省电；否则和system_wq相同。</li>
<li>system_freezable_power_efficient_wq：这个工作队列和system_power_efficient_wq的区别是可以冻结。</li>
</ul>
<h4 id="定义工作项"><a href="#定义工作项" class="headerlink" title="定义工作项"></a>定义工作项</h4><p>定义一个静态的工作项，参数n是变量名称，参数f是工作项的处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WORK(n, f);</span><br></pre></td></tr></table></figure>
<p>定义一个静态的延迟工作项，参数n是变量名称，参数f是工作项的处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_DELAYED_WORK(n, f);</span><br></pre></td></tr></table></figure>
<p>使用DECLARE_DEFERRABLE_WORK(n, f)也可以定义一个静态的延迟工作项，和DECLARE_DELAYED_WORK()的区别是它使用可推迟的定时器（deferrable timer）。<br>可推迟的定时器在系统忙的时候工作正常，但是在处理器空闲的时候不会处理可推迟的定时器。当一个不可推迟的定时器唤醒处理器的时候，才会处理可推迟的定时器。</p>
<blockquote>
<p>在运行时动态初始化工作项，方法如下</p>
</blockquote>
<ul>
<li><code>INIT_WORK(_work, _func)</code>：初始化一个工作项，参数_work是工作项的地址，参数_func是需要异步执行的函数。</li>
<li><code>INIT_WORK_ONSTACK(_work, _func)</code>：初始化一个工作项，工作项是栈里面的局部变量，参数_work是工作项的地址，参数_func是需要异步执行的函数。</li>
<li><code>INIT_DELAYED_WORK(_work, _func)</code>：初始化一个延迟工作项，参数_work是延迟工作项的地址，参数_func是需要异步执行的函数。</li>
<li><code>INIT_DELAYED_WORK_ONSTACK(_work, _func)</code>：初始化一个延迟工作项，延迟工作项是栈里面的局部变量，参数_work是延迟工作项的地址，参数_func是需要异步执行的函数。</li>
<li><code>INIT_DEFERRABLE_WORK(_work, _func)</code>：初始化一个延迟工作项，和INIT_DELAYED_WORK()的区别是它使用可推迟的定时器。</li>
</ul>
<h4 id="全局工作队列"><a href="#全局工作队列" class="headerlink" title="全局工作队列"></a>全局工作队列</h4><p>在全局工作队列中添加一个工作项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">schedule_work</span><span class="params">(struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在全局工作队列中添加一个工作项，并且指定执行工作项的处理器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">schedule_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct work_struct* work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在全局工作队列中添加一个延迟工作项，参数delay是把工作项添加到工作队列中之前等待的时间，单位是嘀嗒（tick）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">schedule_delayed_work</span><span class="params">(struct delayed_work *dwork, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在全局工作队列中添加一个延迟工作项，并且指定执行工作项的处理器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">schedule_delayed_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct delayed_work *dwork, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span>;</span><br></pre></td></tr></table></figure>
<p>冲刷全局工作队列，确保全局工作队列中的所有工作项执行完。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_scheduled_work</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="专用工作队列"><a href="#专用工作队列" class="headerlink" title="专用工作队列"></a>专用工作队列</h4><p>分配工作队列的函数是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc_workqueue(fmt, flags, max_active, args...)</span><br></pre></td></tr></table></figure>
<ul>
<li>参数fmt是工作队列名称的格式。</li>
<li>参数fags是标志位，可以是0，也可以是下面这些标志位的组合。<ul>
<li>WQ_UNBOUND：处理工作项的内核线程不绑定到任何特定的处理器。</li>
<li>WQ_FREEZABLE：在系统挂起的时候冻结。</li>
<li>WQ_MEM_RECLAIM：在内存回收的时候可能使用这个工作队列。</li>
<li>WQ_HIGHPRI：高优先级。❑ WQ_CPU_INTENSIVE：处理器密集型。</li>
<li>WQ_POWER_EFFICIENT：省电。</li>
</ul>
</li>
<li>参数max_active是每个处理器可以同时执行的工作项的最大数量，0表示使用默认值。</li>
<li>参数args是传给参数fmt的参数。</li>
</ul>
<p>下面的函数用来分配一个有序的工作队列。有序的工作队列在任何时刻，按照入队的顺序只执行一个工作项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc_ordered_workqueue(fmt, flags, args...)</span><br></pre></td></tr></table></figure>
<p>旧版本的创建工作队列的函数<code>create_workqueue()</code>、<code>create_freezable_workqueue()</code>和<code>create_singlethread_workqueue()</code>已经被废弃。<br>在指定的工作队列中添加一个工作项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">queue_work</span><span class="params">(struct workqueue_struct *wq, struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在指定的工作队列中添加一个工作项，并且指定执行工作项的处理器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">queue_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct workqueue_struct *wq, struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在指定的工作队列中添加一个延迟工作项，参数delay是把工作项添加到工作队列中之前等待的时间，单位是嘀嗒（tick）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">queue_delayed_work</span><span class="params">(struct workqueue_struct *wq, struct delayed_work *dwork, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在指定的工作队列中添加一个延迟工作项，并且指定执行工作项的处理器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">queue_delayed_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct workqueue_struct *wq, struct delayed_work *work, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span>;</span><br></pre></td></tr></table></figure>
<p>冲刷工作队列，确保工作队列中的所有工作项执行完。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_workqueue</span><span class="params">(struct workqueue_struct *wq)</span></span>;</span><br></pre></td></tr></table></figure>
<p>销毁工作队列的函数是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_workqueue</span><span class="params">(struct workqueue_struct *wq)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="其他编程接口"><a href="#其他编程接口" class="headerlink" title="其他编程接口"></a>其他编程接口</h4><p>取消一个工作项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cancel_work</span><span class="params">(struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>取消一个工作项，并且等待取消操作执行完</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cancel_work_sync</span><span class="params">(struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>取消一个延迟工作项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cancel_delayed_work</span><span class="params">(struct delayed_work *dwork)</span></span>;</span><br></pre></td></tr></table></figure>
<p>取消一个延迟工作项，并且等待取消操作执行完</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cancel_delayed_work_sync</span><span class="params">(struct delayed_work *dwork)</span></span>;</span><br></pre></td></tr></table></figure>
<p>等待一个工作项执行完</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">flush_work</span><span class="params">(struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>等待一个延迟工作项执行完</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">flush_delayed_work</span><span class="params">(struct delayed_work *dwork)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="技术原理-1"><a href="#技术原理-1" class="headerlink" title="技术原理"></a>技术原理</h3><p>首先介绍一下工作队列使用的术语。</p>
<ul>
<li>work：工作，也称为工作项。</li>
<li>work queue：工作队列，就是工作的集合，work queue和work是一对多的关系。</li>
<li>worker：工人，一个工人对应一个内核线程，我们把工人对应的内核线程称为工人线程。</li>
<li>worker_pool：工人池，就是工人的集合，工人池和工人是一对多的关系。</li>
<li>pool_workqueue：中介，负责建立工作队列和工人池之间的关系。工作队列和pool_workqueue是一对多的关系，pool_workqueue和工人池是一对一的关系。</li>
</ul>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p>工作队列分为两种。</p>
<ul>
<li>绑定处理器的工作队列：默认创建绑定处理器的工作队列，每个工人线程绑定到一个处理器。</li>
<li>不绑定处理器的工作队列：创建工作队列的时候需要指定标志位WQ_UNBOUND，工人线程不绑定到某个处理器，可以在处理器之间迁移。</li>
</ul>
<p>绑定处理器的工作队列的数据结构如图所示，工作队列在每个处理器上有一个pool_workqueue实例，一个pool_workqueue实例对应一个工人池，一个工人池有一条工人链表，每个工人对应一个内核线程。<br>向工作队列中添加工作项的时候，选择当前处理器的pool_workqueue实例、工人池和工人线程。</p>
<p><img src="/2021/10/13/linux-interrupt/image-42.png" width="800px"></p>
<p>不绑定处理器的工作队列的数据结构如图所示，工作队列在每个内存节点上有一个pool_workqueue实例，一个pool_workqueue实例对应一个工人池，一个工人池有一条工人链表，每个工人对应一个内核线程。向工作队列中添加工作项的时候，选择当前处理器所属的内存节点的pool_workqueue实例、工人池和工人线程。</p>
<p><img src="/2021/10/13/linux-interrupt/image-43.png" width="800px"></p>
<p>不绑定处理器的工作队列还有一个默认的pool_workqueue实例（workqueue_struct.df_pwq），当某个处理器下线的时候，使用默认的pool_workqueue实例。</p>
<p>工作项负责保存需要异步执行的函数，数据类型是work_struct</p>
<p><img src="/2021/10/13/linux-interrupt/image-44.png" width="700px"></p>
<p>成员func是需要异步执行的函数，成员data是传给函数func的参数。<br>成员entry用来把工作项添加到链表中。<br>延迟工作项是工作项和定时器的结合，数据类型是delayed_work。<br>把延迟工作项添加到工作队列中的时候，延迟一段时间才会真正地把工作项添加到工作队列中。</p>
<p><img src="/2021/10/13/linux-interrupt/image-45.png" width="600px"></p>
<h4 id="添加工作项"><a href="#添加工作项" class="headerlink" title="添加工作项"></a>添加工作项</h4><p>函数queue_work()用来向工作队列中添加一个工作项，把主要工作委托给函数queue_work_on()，把第一个参数<code>“int cpu”</code>设置为WORK_CPU_UNBOUND，意思是不绑定到任何处理器，优先选择当前处理器。</p>
<p><img src="/2021/10/13/linux-interrupt/image-46.png" width="600px"></p>
<p>函数queue_work_on的代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-47.png" width="600px"></p>
<p>如果工作项没有添加过，那么给工作项设置标志位WORK_STRUCT_PENDING_BIT，然后把主要工作委托给函数<strong>queue_work()。<br>函数</strong>queue_work的代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-48.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-49.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-50.png" width="600px"></p>
<ul>
<li>从工作队列中选择pool_workqueue实例。如果是绑定处理器的工作队列，那么选择当前处理器的pool_workqueue实例；如果是不绑定处理器的工作队列，那么选择当前处理器所属的内存节点的pool_workqueue实例。</li>
<li>如果工作正在被其他pool_workqueue实例的工人执行，那么还是把工作添加到那个pool_workqueue实例。</li>
<li>如果pool_workqueue实例的未处理工作数量小于限制，那么把工作添加到pool_workqueue实例对应的工人池的链表worklist中；如果pool_workqueue实例的未处理工作数量达到限制，那么给工作设置标志位WORK_STRUCT_DELAYED，并且把工作添加到pool_workqueue实例的链表delayed_works中。</li>
<li>把工作添加到选择的链表中。</li>
</ul>
<h4 id="工人处理工作"><a href="#工人处理工作" class="headerlink" title="工人处理工作"></a>工人处理工作</h4><p>每个工人对应一个内核线程，一个工人池对应一个或多个工人。<br>多个工人从工人池的未处理工作链表（worker_pool.worklist）中取工作并处理。<br>工人线程的处理函数是worker_thread()，调用函数process_one_work()处理一个工作项。</p>
<blockquote>
<p>函数worker_thread()的代码如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-51.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-52.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-53.png" width="600px"></p>
<ul>
<li>如果工人太多，想要减少工人的数量，那么当前工人线程退出。</li>
<li>工人退出空闲状态。</li>
<li>如果不需要本工人执行工作，那么本工人进入空闲状态。</li>
<li>如果工人池中没有空闲的工人，那么创建一些工人备用。</li>
<li>从工人池的链表worklist中取一个工作。</li>
<li>如果是正常工作，那么调用函数process_one_work()执行正常工作，然后执行工人的链表scheduled中的特殊工作。</li>
<li>如果是特殊工作，那么首先把工作添加到工人的链表scheduled的尾部，然后执行工人的链表scheduled中的特殊工作。</li>
<li>如果有工作需要处理，并且处于运行状态的工人数量不超过1，那么本工人继续执行工作。</li>
<li>工人进入空闲状态，睡眠。</li>
</ul>
<blockquote>
<p>下面解释一下正常工作和特殊工作。</p>
</blockquote>
<p>向工作队列中添加正常工作，是直接添加到工人池的链表worklist中。<br>调用函数fush_work(t)等待工作t执行完，实现方法是添加一个特殊工作：屏障工作，执行这个屏障工作的时候就可以确定工作t执行完。如果工作t正在被工人p执行，那么把屏障工作直接添加到工人p的链表scheduled中；如果工作t没有执行，那么把屏障工作添加到工人池的链表worklist中，并且给屏障工作设置标志位WORK_STRUCT_LINKED。</p>
<p>函数process_one_work()负责处理一个工作，其代码如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-54.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-55.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-56.png" width="600px"></p>
<ul>
<li>一个工作不应该被多个工人并发执行。如果一个工作正在被工人池的其他工人执行，那么把这个工作添加到这个工人的链表scheduled中延后执行。</li>
<li>把工人添加到工人池的散列表busy_hash中。</li>
<li>工人的成员current_work指向当前工作，成员current_func指向当前工作的处理函数，成员current_pwq指向当前pool_workqueue实例。</li>
<li>如果工作队列是处理器密集型的，那么给工人设置标志位WORKER_CPU_INTENSIVE，工人不再被工人池动态调度。</li>
<li>对于不绑定处理器或处理器密集型的工作队列，唤醒更多空闲的工人处理工作。</li>
<li>执行工作的处理函数。</li>
</ul>
<h4 id="工人池动态管理工人"><a href="#工人池动态管理工人" class="headerlink" title="工人池动态管理工人"></a>工人池动态管理工人</h4><blockquote>
<p>工人池可以动态增加和删除工人，算法如下</p>
</blockquote>
<ul>
<li>工人有3种状态：空闲（idle）、运行（running）和挂起（suspend）。空闲是指没有执行工作，运行是指正在执行工作，挂起是指在执行工作的过程中睡眠。</li>
<li>如果工人池中有工作需要处理，至少保持一个处在运行状态的工人来处理。</li>
<li>如果处在运行状态的工人在执行工作的过程中进入挂起状态，为了保证其他工作的执行，需要唤醒空闲的工人处理工作。</li>
<li>如果有工作需要执行，并且处在运行状态的工人数量大于1，会让多余的工人进入空闲状态。</li>
<li>如果没有工作需要执行，会让所有工人进入空闲状态。</li>
<li>如果创建的工人过多，工人池把空闲时间超过300秒（IDLE_WORKER_TIMEOUT）的工人删除。</li>
</ul>
<p>为了跟踪工人的运行和挂起状态、动态调整工人的数量，工作队列使用在进程调度中加钩子函数的技巧。</p>
<ul>
<li>跟踪工人从挂起进入运行状态。唤醒工人线程的时候，如果工人线程正在执行工作的过程中，那么把工人池中处在运行状态的工人计数（nr_running）加1。<br>  相关代码如下<br>  <img src="/2021/10/13/linux-interrupt/image-57.png" width="600px"></li>
<li>跟踪工人从运行进入挂起状态。当一个工人睡眠的时候，如果工人池没有工人处于运行状态，并且工人池有工作需要执行，那么唤醒一个空闲的工人。<br>  相关代码如下<br>  <img src="/2021/10/13/linux-interrupt/image-58.png" width="600px"></li>
</ul>
<p>工人池的调度思想是如果有工作需要处理，保持一个处在运行状态的工人来处理，不多也不少。<br>这种做法有个问题：如果工作是处理器密集型的，虽然工人没有进入挂起状态，但是会长时间占用处理器，让后续的工作阻塞太长时间。<br>为了解决这个问题，可以在创建工作队列的时候设置标志位WQ_CPU_INTENSIVE，声明工作队列是处理器密集的。当一个工人执行工作的时候，让这个工人不受工人池动态调度，像是进入了挂起状态，工人池创建新的工人来执行后续的工作。</p>
<p>工人线程对处理器密集的特殊处理如下</p>
<p><img src="/2021/10/13/linux-interrupt/image-59.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-60.png" width="600px"></p>
<p>可以看到，给工人设置标志位WORKER_CPU_INTENSIVE的时候，把工人池的计数nr_running减1，相当于工人进入挂起状态。</p>
<p><br><br><br></p>
<hr>


<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>系统调用是内核给用户程序提供的编程接口。用户程序调用系统调用，通常使用glibc库针对单个系统调用封装的函数。<br>如果glibc库没有针对某个系统调用封装函数，用户程序可以使用通用的封装函数syscall()：</p>
<p><img src="/2021/10/13/linux-interrupt/image-61.png" width="600px"></p>
<p>参数number是系统调用号，后面是传递给系统调用的参数。返回值0表示成功，返回值−1表示错误，错误号存储在变量errno中。</p>
<blockquote>
<p>例如应用程序使用系统调用fork()创建子进程，有两种调用方法。</p>
</blockquote>
<ul>
<li>ret = fork();</li>
<li>ret = syscall(SYS_fork);</li>
</ul>
<p>ARM64处理器提供的系统调用指令是svc，调用约定如下。</p>
<ul>
<li>64位应用程序使用寄存器x8传递系统调用号，32位应用程序使用寄存器x7传递系统调用号。</li>
<li>使用寄存器x0～x6最多可以传递7个参数。</li>
<li>当系统调用执行完的时候，使用寄存器x0存放返回值。</li>
</ul>
<h2 id="定义系统调用"><a href="#定义系统调用" class="headerlink" title="定义系统调用"></a>定义系统调用</h2><p>Linux内核使用宏SYSCALL_DEFINE定义系统调用，以创建子进程的系统调用fork为例：</p>
<p><img src="/2021/10/13/linux-interrupt/image-62.png" width="600px"></p>
<blockquote>
<p>把宏“SYSCALL_DEFINE0(fork)”展开以后是：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_fork</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>“SYSCALL_DEFINE”后面的数字表示系统调用的参数个数，“SYSCALL_DEFINE0”表示系统调用没有参数，“SYSCALL_DEFINE6”表示系统调用有6个参数，如果参数超过6个，使用宏“SYSCALL_DEFINEx”。头文件“include/linux/syscalls.h”定义了这些宏。</p>
<p>“asmlinkage”表示这个C语言函数可以被汇编代码调用。如果使用C++编译器，“asmlinkage”被定义为extern “C”；如果使用C编译器，“asmlinkage”是空的宏。</p>
<p>系统调用的函数名称以“sys_”开头。<br>需要在系统调用表中保存系统调用号和处理函数的映射关系，ARM64架构定义的系统调用表sys_call_table如下：</p>
<blockquote>
<p>arch/arm64/kernel/sys.c</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-63.png" width="600px"></p>
<blockquote>
<p>对于ARM64架构，头文件“asm/unistd.h”是“arch/arm64/include/asm/unistd.h”。</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-64.png" width="600px"></p>
<h2 id="执行系统调用"><a href="#执行系统调用" class="headerlink" title="执行系统调用"></a>执行系统调用</h2><p>ARM64处理器把系统调用划分到同步异常，在异常级别1的异常向量表中，系统调用的入口有两个：</p>
<ul>
<li>如果64位应用程序执行系统调用指令svc，系统调用的入口是el0_sync。</li>
<li>如果32位应用程序执行系统调用指令svc，系统调用的入口是el0_sync_compat。</li>
</ul>
<blockquote>
<p>el0_sync的代码如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-65.png" width="600px"></p>
<ul>
<li>把当前进程的寄存器值保存在内核栈中。</li>
<li>读取异常症状寄存器esr_el1。</li>
<li>解析出异常症状寄存器的异常类别字段。</li>
<li>如果异常类别是系统调用，跳转到el0_svc。</li>
</ul>
<blockquote>
<p>el0_svc负责执行系统调用，其代码如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-66.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-67.png" width="600px"></p>
<ul>
<li>把寄存器x27设置为系统调用表sys_call_table的起始地址。</li>
<li>把寄存器x26设置为系统调用号。64位进程使用寄存器x8传递系统调用号，w8是寄存器x8的32位形式。</li>
<li>把寄存器x25设置为系统调用的数量，也就是（最大的系统调用号+1）。</li>
<li>把寄存器x0和x8的值保存到内核栈中，x0存放系统调用的第一个参数，x8存放系统调用号。</li>
<li>开启调试异常和中断。</li>
<li>如果使用ptrace跟踪系统调用，跳转到__sys_trace处理。</li>
<li>如果进程传递的系统调用号等于或大于系统调用的数量，即大于最大的系统调用号，那么是非法值，跳转到ni_sys处理错误。</li>
<li>计算出系统调用号对应的表项地址（sys_call_table + 系统调用号 * 8），然后取出处理函数的地址。</li>
<li>调用系统调用号对应的处理函数。</li>
<li>从系统调用返回用户空间。</li>
</ul>
<blockquote>
<p>ret_fast_syscall从系统调用返回用户空间，其代码如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-68.png" width="600px"><br><img src="/2021/10/13/linux-interrupt/image-69.png" width="600px"></p>
<ul>
<li>禁止中断。</li>
<li>寄存器x0已经存放了处理函数的返回值，把保存在内核栈中的寄存器x0的值更新为返回值。</li>
<li>如果使用ptrace跟踪系统调用，跳转到ret_fast_syscall_trace处理。</li>
<li>如果进程的thread_info.fags设置了需要重新调度（_TIF_NEED_RESCHED）或者有信号需要处理（_TIF_SIGPENDING）等标志位，跳转到work_pending处理。</li>
<li>如果使用系统调用ptrace设置了软件单步执行，那么开启单步执行。</li>
<li>使用保存在内核栈中的寄存器值恢复寄存器，从内核模式返回用户模式。</li>
</ul>
<blockquote>
<p>work_pending调用函数do_notify_resume，函数do_notify_resume的代码如下</p>
</blockquote>
<p><img src="/2021/10/13/linux-interrupt/image-70.png" width="600px"></p>
<ul>
<li>如果当前进程的thread_info.fags设置了标志位_TIF_NEED_RESCHED，那么调度进程。</li>
<li>如果设置了标志位_TIF_UPROBE，调用函数uprobe_notify_resume()处理。uprobes（user-space probes，用户空间探测器）可以在进程的任何指令地址插入探测器，收集调试和性能信息，发现性能问题。需要内核支持，编译内核时开启配置宏CONFIG_UPROBE_EVENTS。</li>
<li>如果设置了标志位_TIF_SIGPENDING，调用函数do_signal()处理信号。</li>
<li>如果设置了标志位_TIF_NOTIFY_RESUME，那么调用函数tracehook_notify_resume()，执行返回用户模式之前的回调函数。</li>
<li>如果设置了标志位_TIF_FOREIGN_FPSTATE，那么恢复浮点寄存器。</li>
</ul>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2021/10/13/linux-interrupt/';
        this.page.title = 'Linux-中断笔记';
        this.page.identifier = '2021/10/13/linux-interrupt/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
