<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Rust知识集锦 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="Rust 知识体系

Box是“指针”，指向一个在堆上分配的对象;
Vec是“指针”，指向一组同类型的顺序排列的堆上分配的对象，且携带有当前缓存空间总大小和元素个数大小的元数据；
Rc和Arc也是某种形式的、携带了额外元数据的“指针”，它们提供的是一种“共享”的所有权，当所有的引用计数指针都销毁之后，它们所指向的内存空间才会被释放。

Trait静态方法12345678910111213141516// 静态方法struct T(i32);impl T&amp;#123;	fn func(this:&amp;a">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java前后端</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">Cpp嵌入式</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Go云原生</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">Linux安全</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">Win安全</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">数据与算法</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/work">工作相关</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">文章标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Net/">Net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nosql/">Nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rust/">Rust</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/嵌入式/">嵌入式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">历史归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Trait"><span class="toc-number">1.</span> <span class="toc-text">Trait</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#静态方法"><span class="toc-number">1.1.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展方法"><span class="toc-number">1.2.</span> <span class="toc-text">扩展方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完整函数调用语法"><span class="toc-number">1.3.</span> <span class="toc-text">完整函数调用语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trait约束和继承"><span class="toc-number">1.4.</span> <span class="toc-text">trait约束和继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Derive"><span class="toc-number">1.5.</span> <span class="toc-text">Derive</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trait别名"><span class="toc-number">1.6.</span> <span class="toc-text">trait别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组和字符串"><span class="toc-number">2.</span> <span class="toc-text">数组和字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">2.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内置方法"><span class="toc-number">2.1.1.</span> <span class="toc-text">内置方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多维数组"><span class="toc-number">2.1.2.</span> <span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组切片"><span class="toc-number">2.1.3.</span> <span class="toc-text">数组切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DST和胖指针"><span class="toc-number">2.1.4.</span> <span class="toc-text">DST和胖指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Range"><span class="toc-number">2.1.5.</span> <span class="toc-text">Range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#边界检查"><span class="toc-number">2.1.6.</span> <span class="toc-text">边界检查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">2.2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#amp-str"><span class="toc-number">2.2.1.</span> <span class="toc-text">&amp;str</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">2.2.2.</span> <span class="toc-text">String</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#容器与迭代器"><span class="toc-number">3.</span> <span class="toc-text">容器与迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#容器"><span class="toc-number">3.1.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vec"><span class="toc-number">3.1.1.</span> <span class="toc-text">Vec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VecDeque"><span class="toc-number">3.1.2.</span> <span class="toc-text">VecDeque</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">3.1.3.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTreeMap"><span class="toc-number">3.1.4.</span> <span class="toc-text">BTreeMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器"><span class="toc-number">3.2.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现迭代器"><span class="toc-number">3.2.1.</span> <span class="toc-text">实现迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器的组合"><span class="toc-number">3.2.2.</span> <span class="toc-text">迭代器的组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for循环"><span class="toc-number">3.2.3.</span> <span class="toc-text">for循环</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#生成器"><span class="toc-number">4.</span> <span class="toc-text">生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">4.1.</span> <span class="toc-text">简介</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#项目和模块"><span class="toc-number">5.</span> <span class="toc-text">项目和模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cargo"><span class="toc-number">5.1.</span> <span class="toc-text">cargo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#项目依赖"><span class="toc-number">5.2.</span> <span class="toc-text">项目依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#配置"><span class="toc-number">5.2.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#workspace"><span class="toc-number">5.2.2.</span> <span class="toc-text">workspace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#build-rs"><span class="toc-number">5.2.3.</span> <span class="toc-text">build.rs</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关键字"><span class="toc-number">6.</span> <span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型"><span class="toc-number">7.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#特征"><span class="toc-number">8.</span> <span class="toc-text">特征</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本概念"><span class="toc-number">8.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特征的分发"><span class="toc-number">8.2.</span> <span class="toc-text">特征的分发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Self-与-self"><span class="toc-number">8.3.</span> <span class="toc-text">Self 与 self</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包"><span class="toc-number">9.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#三种-Fn-特征"><span class="toc-number">9.1.</span> <span class="toc-text">三种 Fn 特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#move-和-Fn"><span class="toc-number">9.2.</span> <span class="toc-text">move 和 Fn</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生命周期"><span class="toc-number">9.3.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#三条消除规则"><span class="toc-number">9.3.1.</span> <span class="toc-text">三条消除规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#智能指针"><span class="toc-number">10.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Box"><span class="toc-number">10.1.</span> <span class="toc-text">Box</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Deref解引用"><span class="toc-number">10.2.</span> <span class="toc-text">Deref解引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Drop-释放资源"><span class="toc-number">10.3.</span> <span class="toc-text">Drop 释放资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rc-与-Arc"><span class="toc-number">10.4.</span> <span class="toc-text">Rc 与 Arc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Rc"><span class="toc-number">10.4.1.</span> <span class="toc-text">Rc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不可变引用"><span class="toc-number">10.4.2.</span> <span class="toc-text">不可变引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rc-简单总结"><span class="toc-number">10.4.3.</span> <span class="toc-text">Rc 简单总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arc"><span class="toc-number">10.4.4.</span> <span class="toc-text">Arc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arc-的性能损耗"><span class="toc-number">10.4.5.</span> <span class="toc-text">Arc 的性能损耗</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cell与RefCell内部可变性"><span class="toc-number">10.5.</span> <span class="toc-text">Cell与RefCell内部可变性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#循环引用与自引用"><span class="toc-number">11.</span> <span class="toc-text">循环引用与自引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Weak与循环引用"><span class="toc-number">11.1.</span> <span class="toc-text">Weak与循环引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#宏"><span class="toc-number">12.</span> <span class="toc-text">宏</span></a></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
           Rust知识集锦
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2022/07/09/rust/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2022-07-09T04:15:20.000Z" itemprop="datePublished">2022-07-09</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Rust/">Rust</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>Rust 知识体系<br><a id="more"></a></p>
<ul>
<li>Box<t>是“指针”，指向一个在堆上分配的对象;</t></li>
<li>Vec<t>是“指针”，指向一组同类型的顺序排列的堆上分配的对象，且携带有当前缓存空间总大小和元素个数大小的元数据；</t></li>
<li>Rc<t>和Arc<t>也是某种形式的、携带了额外元数据的“指针”，它们提供的是一种“共享”的所有权，当所有的引用计数指针都销毁之后，它们所指向的内存空间才会被释放。</t></t></li>
</ul>
<h1 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h1><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span></span>(<span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> T&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">func</span></span>(this:&amp;<span class="keyword">Self</span>)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"value:&#123;&#125;"</span>, this.<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> x = T(<span class="number">66</span>);</span><br><span class="line">	T::func(&amp;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>trait中也可以定义静态函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Default</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">default</span></span>() -&gt; <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>trait包含default函数,无参数的函数,返回的类型是实现该trait的具体类型<br>Rust中没有构造函数的概念, Default trait实际上可以看作一个针对无参数构造函数的统一抽象</p>
<p>与C+相比, Rust定义静态函数无需使用Static关键字,因为它把self参数显式在参数列表中列出来了</p>
<p><br></p>
<h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><p>trait给其他类型添加成员方法, 哪怕这个类型不是自己写的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Double</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">double</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Double <span class="keyword">for</span> <span class="built_in">i32</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">double</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span>&#123;</span><br><span class="line">		*<span class="keyword">self</span> * <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> x:<span class="built_in">i32</span> = <span class="number">10</span>.double();</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="完整函数调用语法"><a href="#完整函数调用语法" class="headerlink" title="完整函数调用语法"></a>完整函数调用语法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chef</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Cook <span class="keyword">for</span> Chef&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">start</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"Cook::start"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Wash <span class="keyword">for</span> Chef&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">start</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"Wash::start"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> me = Chef;</span><br><span class="line">	<span class="comment">// me.start();</span></span><br><span class="line">	<span class="comment">// 定义两个trait start()函数有同样方法签名</span></span><br><span class="line">	<span class="comment">// 会出现编译错误 multiple applicable items in scope</span></span><br><span class="line">	<span class="comment">// 这个时候有必要使用完整的函数调用语法进行方法调用</span></span><br><span class="line">	<span class="comment">// 只有这样才能清晰明白无歧义表达清楚期望调用哪个函数</span></span><br><span class="line">	&lt;Cook&gt;::start(&amp;me);</span><br><span class="line">	&lt;Chef <span class="keyword">as</span> Wash&gt;::start(&amp;me);</span><br><span class="line">	<span class="comment">// 或者</span></span><br><span class="line">	<span class="comment">//&lt;Wash&gt;::start(&amp;me);</span></span><br><span class="line">	<span class="comment">//&lt;Cook&gt;::start(&amp;me);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>成员方法和普通函数没本质区别</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span></span>(<span class="built_in">usize</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> T&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">get1</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;<span class="keyword">self</span>.<span class="number">0</span>&#125;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">get2</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;<span class="keyword">self</span>.<span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get3</span></span>(t: &amp;T) -&gt; <span class="built_in">usize</span> &#123;t.<span class="number">0</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_type</span></span>(_:<span class="function"><span class="keyword">fn</span></span>(&amp;T)-&gt;<span class="built_in">usize</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	check_type(T::get1);</span><br><span class="line">	check_type(T::get2);</span><br><span class="line">	check_type(get3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="trait约束和继承"><a href="#trait约束和继承" class="headerlink" title="trait约束和继承"></a>trait约束和继承</h2><p>Rust的trait另一个用处是作为泛型约束使用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">my_print</span></span>&lt;T:<span class="built_in">Debug</span>&gt;(x:T)&#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"The value is &#123;:?&#125;"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">	my_print(<span class="string">"China"</span>);</span><br><span class="line">	my_print(<span class="number">41_i32</span>);</span><br><span class="line">	my_print(<span class="literal">true</span>);</span><br><span class="line">	my_print([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>my_print函数引入一个泛型T, 所以参数不是具体的类型, 而是一组类型<br>冒号后面加trait名字,就是泛型参数约束条件, 要求T类型实现Debug这个trait</p>
<p>泛型约束另一种写法是where子句<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"><span class="comment">// fn my_print&lt;T:Debug&gt;(x:T)&#123;</span></span><br><span class="line"><span class="comment">// 	println!("The value is &#123;:?&#125;", x);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">my_print</span></span>&lt;T&gt;(x:T) <span class="keyword">where</span> T:<span class="built_in">Debug</span>&#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">	my_print(<span class="string">"China"</span>);</span><br><span class="line">	my_print(<span class="number">41_i32</span>);</span><br><span class="line">	my_print(<span class="literal">true</span>);</span><br><span class="line">	my_print([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>trait允许继承,类似这样</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Base</span></span> &#123;</span><br><span class="line">	<span class="comment">// add code here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Derived</span></span>:Base &#123;</span><br><span class="line">	<span class="comment">// add code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后impl满足的时候两个都需要</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Base</span></span> &#123;</span><br><span class="line">	<span class="comment">// add code here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Derived</span></span>:Base &#123;</span><br><span class="line">	<span class="comment">// add code here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Derived <span class="keyword">for</span> T&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Base <span class="keyword">for</span> T&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实trait Derived:Base{}等同于trait Derived where Slef:Base{}</p>
<p><br></p>
<h2 id="Derive"><a href="#Derive" class="headerlink" title="Derive"></a>Derive</h2><p>Rust里面为类型impl某些trait的时候,逻辑是非常机械化的<br>许多类型重复而单调地impl某些trait是非常鼓噪地<br>为此Rust提供了特殊的attribute,自动impl某些trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy,Clone,Default, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">	data: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> v1 = Foo&#123;data:<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">let</span> v2 = v1;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的语法是在你希望impl trait类型前面写#[derive(…)], 括号里面是你希望impl地trait地名字<br>这样写了之后,编译器就帮你自动加上impl块,类似如下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="built_in">Copy</span> <span class="keyword">for</span> Foo&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Clone</span> <span class="keyword">for</span> Foo&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Debug</span> <span class="keyword">for</span> Foo&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Default</span> <span class="keyword">for</span> Foo&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> Hash <span class="keyword">for</span> Foo&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">PartialEq</span> <span class="keyword">for</span> Foo&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这些都是特殊地trait,帮我们自动实现默认的逻辑</p>
<p><br></p>
<h2 id="trait别名"><a href="#trait别名" class="headerlink" title="trait别名"></a>trait别名</h2><p>跟type alias类似,trait也可以起别名 trait alias</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Service</span></span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Request</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Response</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Error</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Future</span></span>:Future&lt;Item=Slef::Response, Error=Self::Error&gt;;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>, req:Self::Request) -&gt; Self::Future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HttpService</span></span> = Service&lt;Request=http::Request,</span><br><span class="line">	Response=http::Response,</span><br><span class="line">	Error=http::Error&gt;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>trait本身可以携带泛型参数；</li>
<li>trait可以用在泛型参数的约束中；</li>
<li>trait可以为一组类型impl，也可以单独为某一个具体类型impl，而且它们可以同时存在；</li>
<li>trait可以为某个trait impl，而不是为某个具体类型impl；</li>
<li>trait可以包含关联类型，而且还可以包含类型构造器，实现高阶类型的某些功能；</li>
<li>trait可以实现泛型代码的静态分派，也可以通过trait object实现动态分派；</li>
<li>trait可以不包含任何方法，用于给类型做标签（marker），以此来描述类型的一些重要特性；</li>
<li>trait可以包含常量。</li>
</ul>
<p><br><br><br></p>
<h1 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一个容器，它在一块连续空间内存中，存储了一系列的同样类型的数据。<br>数组中元素的占用空间大小必须是编译期确定的。数组本身所容纳的元素个数也必须是编译期确定的，执行阶段不可变。<br>如果需要使用变长的容器，可以使用标准库中的Vec/LinkedList等</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定长数组</span></span><br><span class="line"><span class="keyword">let</span> xs:[<span class="built_in">i32</span>, <span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 所有元素,如果初始化为同样数据,可以使用如下语法</span></span><br><span class="line"><span class="keyword">let</span> ys:[<span class="built_in">i32</span>, <span class="number">500</span>] = [<span class="number">0</span>;<span class="number">500</span>];</span><br></pre></td></tr></table></figure>
<p>在Rust中，对于两个数组类型，只有元素类型和元素个数都完全相同，这两个数组才是同类型的。<br>数组与指针之间不能隐式转换。同类型的数组之间可以互相赋值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> xs:[<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> ys:[<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line">xs = ys;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"arry &#123;:?&#125;"</span>, xs);</span><br></pre></td></tr></table></figure>
<p>把数组xs作为参数传给一个函数，这个数组并不会退化成一个指针。<br>而是会将这个数组完整复制进这个函数。<br>函数体内对数组的改动不会影响到外面的数组。</p>
<p>对数组内部元素的访问，可以使用中括号索引的方式</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> xs:[<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> ys:[<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line">xs = ys;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"arry &#123;:?&#125;"</span>, xs);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"index item:&#123;:?&#125;"</span>, xs[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h3><blockquote>
<p>比较</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">let</span> v2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>];</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, v1 &lt; v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以对数组执行遍历操作</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v1 = [<span class="number">0_i32</span>; <span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> &amp;v1&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>既然[T; n]是一个合法的类型，那么它的元素T当然也可以是数组类型，因此[[T; m]; n]类型自然也是合法类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v :[[<span class="built_in">i32</span>; <span class="number">2</span>]; <span class="number">3</span>] = [[<span class="number">0</span>,<span class="number">1</span>], [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>]];</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h3><p>对数组取借用borrow操作，可以生成一个“数组切片”（Slice）。<br>数组切片对数组没有“所有权”，我们可以把数组切片看作专门用于指向数组的指针，是对数组的另外一个“视图”。<br>比如我们有一个数组[T; n]，它的借用指针的类型就是&amp;[T; n]。<br>它可以通过编译器内部魔法转换为数组切片类型&amp;[T]。<br>数组切片实质上还是指针，它不过是在类型系统中丢弃了编译阶段定长数组类型的长度信息，而将此长度信息存储为运行期的值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">mut_array</span></span>(a: &amp;<span class="keyword">mut</span>[<span class="built_in">i32</span>])&#123;</span><br><span class="line">		a[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"size of &#123;:?&#125;"</span>, std::mem::size_of::&lt;&amp;[<span class="built_in">i32</span>;<span class="number">3</span>]&gt;());</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"size of &#123;:?&#125;"</span>, std::mem::size_of::&lt;&amp;[<span class="built_in">i32</span>]&gt;());</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> v:[<span class="built_in">i32</span>;<span class="number">3</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">let</span> s:&amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>;<span class="number">3</span>] = &amp;<span class="keyword">mut</span> v;</span><br><span class="line">		mut_array(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, v);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量v是[i32; 3]类型；变量s是&amp;mut [i32; 3]类型，占用的空间大小与指针相同。它可以自动转换为&amp;mut [i32]数组切片类型传入函数mut_array，占用的空间大小等于两个指针的空间大小。<br>通过这个指针，在函数内部，修改了外部的数组v的值。</p>
<h3 id="DST和胖指针"><a href="#DST和胖指针" class="headerlink" title="DST和胖指针"></a>DST和胖指针</h3><p>Slice与普通的指针是不同的，它有一个非常形象的名字：胖指针（fat pointer）。<br>与这个概念相对应的概念是“动态大小类型”（Dynamic Sized Type, DST）。<br>所谓的DST指的是编译阶段无法确定占用空间大小的类型。为了安全性，指向DST的指针一般是胖指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于不定长数组类型[T]，有对应的胖指针&amp;[T]类型；</span><br><span class="line">对于不定长字符串str类型，有对应的胖指针&amp;str类型；以及在后文中会出现的Trait Object;等等。</span><br></pre></td></tr></table></figure>
<p>由于不定长数组类型[T]在编译阶段是无法判断该类型占用空间的大小的，目前我们不能在栈上声明一个不定长大小数组的变量实例，也不能用它作为函数的参数、返回值。<br>但是指向不定长数组的胖指针的大小是确定的，&amp;[T]类型可以用做变量实例、函数参数、返回值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">raw_slice</span></span>(arr:&amp;[<span class="built_in">i32</span>])&#123;</span><br><span class="line">	<span class="keyword">unsafe</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> (val1, val2): (<span class="built_in">usize</span>, <span class="built_in">usize</span>) = std::mem::transmute(arr);</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"val1:&#123;:x&#125;"</span>, val1);</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"val2:&#123;:x&#125;"</span>, val2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> arr:[<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">let</span> address :&amp;[<span class="built_in">i32</span>;<span class="number">5</span>] = &amp;arr;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"arr:&#123;:p&#125;"</span>, address);</span><br><span class="line">	raw_slice(address <span class="keyword">as</span> &amp;[<span class="built_in">i32</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们arr是长度为5的i32类型的数组。address是一个普通的指向arr的借用指针。<br>我们可以用as关键字把address转换为一个胖指针&amp;[i32]，并传递给raw_slice函数。<br>在raw_slice函数内部，我们利用了unsafe的transmute函数。<br>我们可以把它看作一个强制类型转换，类似reinterpret_cast，通过这个函数，我们把胖指针的内部数据转换成了两个usize大小的整数来看待</p>
<p>对于DST类型，Rust有如下限制：</p>
<ul>
<li>只能通过指针来间接创建和操作DST类型，&amp;[T] Box&lt;[T]&gt;可以，[T]不可以；</li>
<li>局部变量和函数参数的类型不能是DST类型，因为局部变量和函数参数必须在编译阶段知道它的大小因为目前unsized rvalue功能还没有实现；</li>
<li>enum中不能包含DST类型，struct中只有最后一个元素可以是DST，其他地方不行，如果包含有DST类型，那么这个结构体也就成了DST类型。</li>
</ul>
<p>Rust设计出DST类型，使得类型暂时系统更完善，也有助于消除一些C/C++中容易出现的bug。这一设计的好处有：</p>
<ul>
<li>首先，DST类型虽然有一些限制条件，但我们依然可以把它当成合法的类型看待，比如，可以为这样的类型实现trait、添加方法、用在泛型参数中等；</li>
<li>胖指针的设计，避免了数组类型作为参数传递时自动退化为裸指针类型，丢失了长度信息的问题，保证了类型安全；</li>
<li>这一设计依然保持了与“所有权”“生命周期”等概念相容的特点。</li>
</ul>
<p>数组切片不只是提供了“数组到指针”的安全转换，配合上Range功能，它还能提供数组的局部切片功能。</p>
<p><br></p>
<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>Rust中的Range代表一个“区间”，一个“范围”，它有内置的语法支持，就是两个小数点..</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> r = <span class="number">1</span>..<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> r &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;\t"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是在begin..end这个语法中，前面是闭区间，后面是开区间。<br>这个语法实际上生成的是一个<code>std::ops::Range&lt;_&gt;</code>类型的变量</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Range;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> r = Range&#123;start:<span class="number">1</span>, end:<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> r &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类型本身实现了Iterator trait，因此它可以直接应用到循环语句中。<br>Range具有迭代器的全部功能，因此它能调用迭代器的成员方法。<br>比如我们要实现从100递减到10，中间间隔为10的序列，可以这么做</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">use</span> std::iter::<span class="built_in">Iterator</span>;</span><br><span class="line">	<span class="keyword">let</span> r = (<span class="number">1i32</span>..<span class="number">11</span>).rev().map(|i|i * <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> r&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;\t"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Rust中，还有其他的几种Range，包括</p>
<ul>
<li>std::ops::RangeFrom代表只有起始没有结束的范围，语法为start..，含义是[start, +∞)；</li>
<li>std::ops::RangeTo代表没有起始只有结束的范围，语法为．.end，对有符号数的含义是(-∞,end)，对无符号数的含义是[0, end)；</li>
<li>std::ops::RangeFull代表没有上下限制的范围，语法为．.，对有符号数的含义是(-∞, +∞)，对无符号数的含义是[0, +∞)。</li>
</ul>
<p>数组和Range之间最常用的配合就是使用Range进行索引操作</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_slice</span></span>(arr:&amp;[<span class="built_in">i32</span>])&#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"Length:&#123;&#125;"</span>, arr.len());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> item <span class="keyword">in</span> arr &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;&#125;\t"</span>, item);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> arr:[<span class="built_in">i32</span>;<span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">	print_slice(&amp;arr[..]);	<span class="comment">//Full Range</span></span><br><span class="line">	<span class="keyword">let</span> slice = &amp;arr[<span class="number">2</span>..];	<span class="comment">//RangeFrom</span></span><br><span class="line">	print_slice(slice);</span><br><span class="line">	<span class="keyword">let</span> slice2 = &amp;slice[..<span class="number">2</span>];<span class="comment">//RangeTo</span></span><br><span class="line">	print_slice(slice2);</span><br><span class="line">	print_slice(&amp;arr[<span class="number">2</span>..<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="边界检查"><a href="#边界检查" class="headerlink" title="边界检查"></a>边界检查</h3><p>我们的“索引”都是一个合法的值，没有超过数组的长度。<br>如果我们给“索引”一个非法的值会怎样呢?</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v= [<span class="number">10i32</span>, <span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">let</span> index:<span class="built_in">usize</span> = std::env::args().nth(<span class="number">1</span>).map(|x|x.parse().unwrap_or(<span class="number">0</span>)).unwrap_or(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, v[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行thread ‘main’ panicked at ‘index out of bounds : the len is 5 but the index is 10’。<br>可以看出如果用/test 10，则会出现数组越界，Rust目前还无法任意索引执行编译阶段边界检查，但是在运行阶段执行了边界检查。</p>
<p>在Rust中，“索引”操作也是一个通用的运算符，是可以自行扩展的。<br>如果希望某个类型可以执行“索引”读操作，就需要该类型实现std::ops::Index trait<br>如果希望某个类型可以执行“索引”写操作，就需要该类型实现std::ops::IndexMut trait。</p>
<p>为了防止索引操作导致程序崩溃，如果我们不确定使用的“索引”是否合法，应该使用get()方法调用来获取数组中的元素，这个方法不会引起panic!，它的返回类型是Option<t></t></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v= [<span class="number">10i32</span>, <span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">let</span> first = v.get(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">let</span> tenth = v.get(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125; &#123;:?&#125;"</span>, first, tenth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：“Some（10）None”</p>
<p>对于明显的数组越界行为，在Rust中可以通过lint检查来发现。大家可以参考“clippy”这个项目，它可以检查出这种明显的常量索引越界的现象。<br>总体来说，在Rust里面，靠编译阶段静态检查是无法消除数组越界的行为的。</p>
<p><br><br><br></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Rust的字符串涉及两种类型，一种是&amp;str，另外一种是String。</p>
<h3 id="amp-str"><a href="#amp-str" class="headerlink" title="&amp;str"></a>&amp;str</h3><p>str是Rust的内置类型。<br>&amp;str是对str的借用。Rust的字符串内部默认是使用utf-8编码格式的。<br>而内置的char类型是4字节长度的，存储的内容是Unicode Scalar Value。<br>所以Rust里面的字符串不能视为char类型的数组，而更接近u8类型的数组。<br>实际上str类型有一种方法：<code>fn as_ptr(&amp;self) -&gt; ＊const u8</code>。它内部无须做任何计算，只需做一个强制类型转换即可</p>
<p>这样设计有一个缺点，就是不能支持O(1)时间复杂度的索引操作。如果我们要找一个字符串s内部的第n个字符，不能直接通过s[n]得到，这一点跟其他许多语言不一样。<br>在Rust中，这样的需求可以通过下面的语句实现：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.chars().nth(n)</span><br></pre></td></tr></table></figure></p>
<p>它的时间复杂度是O(n)，因为utf-8是变长编码，如果我们不从头开始过一遍，根本不知道第n个字符的地址在什么地方。<br>但是综合来看，选择utf-8作为内部默认编码格式是缺陷最少的一种方式了。</p>
<p>相比其他的编码格式，它有相当多的优点。比如：它是大小端无关的，它跟ASCII码兼容，它是互联网上的首选编码等等。</p>
<blockquote>
<p>[T]是DST类型，对应的str是DST类型。<br>&amp;[T]是数组切片类型，对应的&amp;str是字符串切片类型。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> greeting : &amp;<span class="built_in">str</span> = <span class="string">"hello"</span>;</span><br><span class="line">	<span class="keyword">let</span> substr : &amp;<span class="built_in">str</span> = &amp;greeting[<span class="number">2</span>..];</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, substr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&amp;str类型也是一个胖指针</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, std::mem::size_of::&lt;*<span class="keyword">const</span>()&gt;());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, std::mem::size_of::&lt;&amp;<span class="built_in">str</span>&gt;());</span><br></pre></td></tr></table></figure>
<p>它内部实际上包含了一个指向字符串片段头部的指针和一个长度。<br>所以它跟C/C++的字符串不同：C/C++里面的字符串以’\0’结尾，而Rust的字符串是可以中间包含’\0’字符的。</p>
<p><br></p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>它跟&amp;str类型的主要区别是，它有管理内存空间的权力。关于“所有权”和“借用”的关系<br>&amp;str类型是对一块字符串区间的借用，它对所指向的内存空间没有所有权，哪怕&amp;mut str也一样</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"Hello"</span>);</span><br><span class="line">	s.push(<span class="string">' '</span>);</span><br><span class="line">	s.push_str(<span class="string">"world."</span>);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String可以后面追加内容,这是因为String类型在堆上动态申请了一块内存空间，它有权对这块内存空间进行扩容，内部实现类似于std::Vec<u8>类型。<br>所以我们可以把这个类型作为容纳字符串的容器使用。</u8></p>
<p><br><br><br></p>
<h1 id="容器与迭代器"><a href="#容器与迭代器" class="headerlink" title="容器与迭代器"></a>容器与迭代器</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p><img src="/2022/07/09/rust/image-01.png" width="700px"></p>
<h3 id="Vec"><a href="#Vec" class="headerlink" title="Vec"></a>Vec</h3><p>Vec是最常用的一个容器，对应C++里面的vector。<br>它就是一个可以自动扩展容量的动态数组。<br>它重载了Index运算符，可以通过中括号取下标的形式访问内部成员。<br>它还重载了Deref / DerefMut运算符，因此可以自动被解引用为数组切片</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v1 = <span class="built_in">Vec</span>::&lt;<span class="built_in">i32</span>&gt;::new();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> v2:<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::with_capacity(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> v3 = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> v4 = <span class="built_in">Vec</span>::new();</span><br><span class="line">	v4.push(<span class="number">1</span>);</span><br><span class="line">	v4.extend_from_slice(&amp;[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>]);</span><br><span class="line">	v4.insert(<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"capacity:&#123;&#125;, length:&#123;&#125;"</span>, v4.capacity(), v4.len());</span><br><span class="line"></span><br><span class="line">	v4[<span class="number">5</span>] = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">let</span> i = v4[<span class="number">5</span>];</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">	<span class="comment">// index运算符直接访问,如果越界会造成panic,而get方法不会,因为它返回一个Optional&lt;T&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(i) = v4.get(<span class="number">6</span>)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// index运算符支持使用各种Range作为索引</span></span><br><span class="line">	<span class="keyword">let</span> slice = &amp;v4[<span class="number">4</span>..];</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, slice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个Vec中能存储的元素个数最多为std::usize::MAX个，超过了会发生panic。<br>因为它记录元素个数，用的就是usize类型。<br>如果我们指定元素的类型是0大小的类型，那么这个Vec根本不需要在堆上分配任何空间。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">Vec</span>::&lt;ZeroSized&gt;::new();</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"capacity:&#123;&#125; length:&#123;&#125;"</span>, v.capacity(), v.len());</span><br><span class="line"></span><br><span class="line">	v.push(ZeroSized&#123;&#125;);</span><br><span class="line">	v.push(ZeroSized&#123;&#125;);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"capacity:&#123;&#125; length:&#123;&#125;"</span>, v.capacity(), v.len());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// p永远指向align_of::&lt;ZeroSized&gt;(),不需要调用allocator</span></span><br><span class="line">	<span class="keyword">let</span> p = v.as_ptr();</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"ptr:&#123;:p&#125;"</span>, p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> size1 = std::mem::size_of::&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt;();</span><br><span class="line">	<span class="keyword">let</span> size2 = std::mem::size_of::&lt;<span class="built_in">Option</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt;&gt;();</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"size of Vec:&#123;&#125;, size of option vec:&#123;&#125;"</span>, size1, size2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">λ .\hello_world.exe</span><br><span class="line">capacity:<span class="number">18446744073709551615</span> length:<span class="number">0</span></span><br><span class="line">capacity:<span class="number">18446744073709551615</span> length:<span class="number">2</span></span><br><span class="line">ptr:<span class="number">0x1</span></span><br><span class="line">size of <span class="built_in">Vec</span>:<span class="number">24</span>, size of option vec:<span class="number">24</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="VecDeque"><a href="#VecDeque" class="headerlink" title="VecDeque"></a>VecDeque</h3><p>VecDeque是一个双向队列。在它的头部或者尾部执行添加或者删除操作，都是效率很高的。<br>它的用法和Vec非常相似，主要是多了pop_front() push_front()等方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> queue = VecDeque::with_capacity(<span class="number">64</span>);</span><br><span class="line">	<span class="comment">// 向尾部按顺序插入一堆数据</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>&#123;</span><br><span class="line">		queue.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从头部按顺序一个个取出来</span></span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(i) = queue.pop_front() &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">λ .\hello_world.exe</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap&lt;K, V, S&gt;是基于hash算法的存储一组键值对（key-value-pair）的容器。<br>其中泛型参数K是键的类型，V是值的类型，S是哈希算法的类型。</p>
<p>hash算法的关键是，将记录的存储地址和key之间建立一个确定的对应关系。<br>这样当想查找某条记录时，我们根据记录的key，通过一次函数计算，就可以得到它的存储地址，进而快速判断这条记录是否存在、存储在哪里。</p>
<p>因此Rust的HashMap要求，key要满足Eq + Hash的约束。<br>Eq trait代表这个类型可以作相等比较，并且一定满足下列三个性质：</p>
<ul>
<li>自反性——对任意a，满足a == a；</li>
<li>对称性——如果a == b成立，则b == a成立；</li>
<li>传递性——如果a == b且b == c成立，则a == c成立。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Hash</span></span>&#123;</span><br><span class="line">	fh hash&lt;H:Haser&gt;(&amp;<span class="keyword">self</span>, state:&amp;<span class="keyword">mut</span> H);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Haser</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">finish</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u64</span>;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, bytes:&amp;[<span class="built_in">u8</span>]);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器提供derive帮助实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Hash)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	first_name: <span class="built_in">String</span>,</span><br><span class="line">	last_name: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>完整使用hashMap示例</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> book = HashMap::new();</span><br><span class="line">	book.insert(Person::new(<span class="string">"John"</span>, <span class="string">"Smith"</span>), <span class="string">"521-8976"</span>);</span><br><span class="line">	book.insert(Person::new(<span class="string">"Sandra"</span>, <span class="string">"Dee"</span>), <span class="string">"521-8976"</span>);</span><br><span class="line">	book.insert(Person::new(<span class="string">"Ted"</span>, <span class="string">"Baker"</span>), <span class="string">"521-8976"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> p = Person::new(<span class="string">"John"</span>, <span class="string">"Smith"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找键对应的值</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(phone) = book.get(&amp;p)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"Phone number found:&#123;&#125;"</span>, phone);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除</span></span><br><span class="line">	book.remove(&amp;p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查询是否存在</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"Find key:&#123;&#125;"</span>, book.contains_key(&amp;p));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找并插入</span></span><br><span class="line">	<span class="keyword">if</span> map.contains_key(key)&#123;</span><br><span class="line">		map.insert(key, value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更方便的查找并插入</span></span><br><span class="line">	map.entry(key).or_insert(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">λ .\hello_world.exe</span><br><span class="line">Phone number found:<span class="number">521</span>-<span class="number">8976</span></span><br><span class="line">Find key:<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="BTreeMap"><a href="#BTreeMap" class="headerlink" title="BTreeMap"></a>BTreeMap</h3><p>BTreeMap&lt;K, V&gt;是基于B树数据结构的存储一组键值对（key-value-pair）的容器。<br>它跟HashMap的用途相似，但是内部存储的机制不同。<br>B树的每个节点包含多个连续存储的元素，以及多个子节点。</p>
<p><img src="/2022/07/09/rust/image-02.png" width="500px"></p>
<p>BTreeMap对key的要求是满足Ord约束，即具备“全序”特征。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BTreeMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Ord,PartialOrd, Eq, PartialEq, Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	first_name:<span class="built_in">String</span>,</span><br><span class="line">	last_name:<span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Person&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(first:&amp;<span class="built_in">str</span>, last:&amp;<span class="built_in">str</span>) -&gt;<span class="keyword">Self</span>&#123;</span><br><span class="line">		Person&#123;</span><br><span class="line">			first_name: first.to_string(),</span><br><span class="line">			last_name: last.to_string(),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> book = BTreeMap::new();</span><br><span class="line">	book.insert(Person::new(<span class="string">"John"</span>, <span class="string">"Smith"</span>), <span class="string">"521-8976"</span>);</span><br><span class="line">	book.insert(Person::new(<span class="string">"Sandra"</span>, <span class="string">"Dee"</span>), <span class="string">"521-8976"</span>);</span><br><span class="line">	book.insert(Person::new(<span class="string">"Ted"</span>, <span class="string">"Baker"</span>), <span class="string">"521-8976"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> p = Person::new(<span class="string">"John"</span>, <span class="string">"Smith"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找键对应的值</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(phone) = book.get(&amp;p)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"Phone number found:&#123;&#125;"</span>, phone);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除</span></span><br><span class="line">	book.remove(&amp;p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查询是否存在</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"Find key:&#123;&#125;"</span>, book.contains_key(&amp;p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">λ .\hello_world.exe</span><br><span class="line">Phone number found:<span class="number">521</span>-<span class="number">8976</span></span><br><span class="line">Find key:<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>BTreeMap比HashMap多的一项功能是，它不仅可以查询单个key的结果，还可以查询一个区间的结果</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BTreeMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> map = BTreeMap::new();</span><br><span class="line">	map.insert(<span class="number">3</span>, <span class="string">"a"</span>);</span><br><span class="line">	map.insert(<span class="number">5</span>, <span class="string">"b"</span>);</span><br><span class="line">	map.insert(<span class="number">8</span>, <span class="string">"c"</span>);</span><br><span class="line">	<span class="keyword">for</span> (k,v) <span class="keyword">in</span> map.range(<span class="number">2</span>..<span class="number">6</span>)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;&#125; : &#123;&#125;"</span>, k, v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Itertor</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它最主要的一个方法就是next()，返回一个Option<item>。<br>一般情况返回Some(Item)；如果迭代完成，就返回None。</item></p>
<h3 id="实现迭代器"><a href="#实现迭代器" class="headerlink" title="实现迭代器"></a>实现迭代器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::iter::<span class="built_in">Iterator</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seq</span></span> &#123;</span><br><span class="line">	current: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Seq&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span>&#123;</span><br><span class="line">		Seq &#123; current:<span class="number">0</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Iterator</span> <span class="keyword">for</span> Seq&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = <span class="built_in">i32</span>;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;&#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">self</span>.current &lt; <span class="number">100</span>&#123;</span><br><span class="line">			<span class="keyword">self</span>.current += <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">Some</span>(<span class="keyword">self</span>.current);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> seq = Seq::new();</span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(i) = seq.next() &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="迭代器的组合"><a href="#迭代器的组合" class="headerlink" title="迭代器的组合"></a>迭代器的组合</h3><p>Rust标准库有一个命名规范，从容器创造出迭代器一般有三种方法</p>
<ul>
<li>iter()创造一个Item是&amp;T类型的迭代器;</li>
<li>iter_mut()创造一个Item是&amp;mut T类型的迭代器;</li>
<li>into_iter()创造一个Item是T类型的迭代器。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> iter = v.iter();</span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(i) = iter.next() &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust的迭代器有一个重要特点，那它就是可组合的(composability)</p>
<p>Iterator trait里面还有一大堆的方法，比如nth、map、filter、skip_while、take等等，这些方法都有默认实现，它们可以统称为adapters(适配器)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> iter = v.iter()</span><br><span class="line">		.take(<span class="number">5</span>)</span><br><span class="line">		.filter(|&amp;x| x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		.map(|&amp;x| x*x)</span><br><span class="line">		.enumerate();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>((i,v)) = iter.next() &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>, i, v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">λ .\hello_world.exe</span><br><span class="line"><span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>之前都是手工直接调用迭代器的next()方法，然后使用while let语法来做循环。<br>实际上Rust里面更简洁、更自然地使用迭代器的方式是使用for循环</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> v &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> map:HashMap&lt;<span class="built_in">i32</span>, <span class="built_in">char</span>&gt; = [(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>)].iter().cloned().collect();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">λ .\hello_world.exe</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>Rust的<code>for &lt;item&gt; in &lt;container&gt; { &lt;body&gt; }</code>语法结构就是一个语法糖。<br>这个语法的原理其实就是调用<code>&lt;container&gt;.into_iter()</code>方法来获得迭代器，然后不断循环调用迭代器的next()方法，将返回值解包，赋值给<item>，然后调用<body>语句块。</body></item></p>
<p>只要某个类型实现了IntoIterator，那么调用into_iter()方法就可以得到对应的迭代器。<br>这个into_iter()方法的receiver是self，而不是&amp;self，执行的是move语义。<br>这么做可以同时支持Item类型为T、&amp;T或者&amp;mut T，用户有选择的权力。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">IntoIterator</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">IntoIter</span></span>:<span class="built_in">Iterator</span>&lt;Item=Self::Item&gt;;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">into_iter</span></span>(<span class="keyword">self</span>) -&gt; Self::IntoIter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个容器类型，标准库里面对它impl了三次IntoIterator。</p>
<ul>
<li>当Self类型为BTreeMap的时候，Item类型为(K, V)，这意味着，每次next()方法都是把内部的元素move出来了;</li>
<li>当Self类型为&amp;BTreeMap的时候，Item类型为(&amp;K, &amp;V)，每次next()方法返回的是借用;</li>
<li>当Self类型为&amp;mut BTreeMap的时候，Item类型为(&amp;K,&amp;mut V)，每次next()方法返回的key是只读的，value是可读写的。</li>
</ul>
<p>所以如果有个变量m，其类型为BTreeMap，那么用户可以选择使用m.into_iter()或者(&amp;m).into_iter()或者(&amp;mut m).into_iter()，分别达到不同的目的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// container在循环之后生命周期就结束了，循环过程中的每个item是从container中move出来的</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> container &#123;&#125;</span><br><span class="line"><span class="comment">//迭代器中只包含container的&amp;型引用，循环过程中的每个item都是container中元素的借用</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> &amp;container &#123;&#125;</span><br><span class="line"><span class="comment">//迭代器中包含container的&amp;mut型引用，循环过程中的每个item都是指向container中元素的可变借用</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> &amp;<span class="keyword">mut</span> container &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>在Rust里面，协程（Coroutine）是编写高性能异步程序的关键设施，生成器（Generator）是协程的基础。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>生成器的语法很像前面讲过的闭包，但它与闭包有一个区别，即yield关键字。<br>当闭包中有yield关键字的时候，它就不是一个闭包，而是一个生成器。</p>
<p><br><br><br></p>
<h1 id="项目和模块"><a href="#项目和模块" class="headerlink" title="项目和模块"></a>项目和模块</h1><p>Rust用了两个概念来管理项目:一个是crate，一个是mod</p>
<ul>
<li>crate简单理解就是一个项目。crate是Rust中的独立编译单元。每个crate对应生成一个库或者可执行文件（如lib .dll .so .exe等）。<br>  官方有一个crate仓库<a href="https://crates.io/，可以供用户发布各种各样的库，用户也可以直接使用这里面的开源库。" target="_blank" rel="noopener">https://crates.io/，可以供用户发布各种各样的库，用户也可以直接使用这里面的开源库。</a></li>
<li>mod简单理解就是命名空间。mod可以嵌套，还可以控制内部元素的可见性。</li>
</ul>
<p>crate和mod有一个重要区别是：crate之间不能出现循环引用；而mod是无所谓的，mod1要使用mod2的内容，同时mod2要使用mod1的内容，是完全没问题的。</p>
<p>在Rust里面，crate才是一个完整的编译单元（compile unit）。<br>也就是说rustc编译器必须把整个crate的内容全部读进去才能执行编译，rustc不是基于单个的．rs文件或者mod来执行编译的。<br>作为对比C/C++里面的编译单元是单独的．c/.cpp文件以及它们所有的include文件。<br>每个．c/. cpp文件都是单独编译，生成．o文件，再把这些．o文件链接起来。</p>
<h2 id="cargo"><a href="#cargo" class="headerlink" title="cargo"></a>cargo</h2><p>Cargo是Rust的包管理工具，是随着编译器一起发布的。<br>在使用rustup安装了官方发布的Rust开发套装之后，Cargo工具就已经安装好了，无须单独安装。<br>我们可以使用cargo命令来查看它的基本用法。<br>Cargo的官方使用文档在这个地址：<a href="https://doc.rust-lang.org/cargo/。" target="_blank" rel="noopener">https://doc.rust-lang.org/cargo/。</a></p>
<p>Cargo可以用于创建和管理项目、编译、执行、测试、管理外部下载的包和可执行文件等。<br>我们创建一个新的工程，这个工程会生成一个可执行程序。</p>
<blockquote>
<p>步骤如下。</p>
</blockquote>
<ul>
<li><p>进入项目文件夹后，使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello_world --bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用tree,查看到当前文件夹结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---hello_world</span><br><span class="line">	-- cargo.toml</span><br><span class="line">	-- src</span><br><span class="line">		-- main.rs</span><br></pre></td></tr></table></figure>
</li>
<li><p>hello_world文件夹内,使用cargo build命令编译项目<br>生成的可执行文件在./target/debug/文件夹内; 使用cargo build –release命令,则可以生成release版的可执行文件,比debug优化更好</p>
</li>
<li><p>使用./target/debug/hello_world命令,或者cargo run命令,可以执行我们刚生成的这个可执行程序</p>
</li>
</ul>
<p>进入hello_world的上一层文件夹，新建一个library项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new good_bye</span><br></pre></td></tr></table></figure></p>
<p>lib.rs文件是库项目的入口，打开这个文件，写入以下代码<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">say</span></span>()&#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"good bye"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用cargo build，编译通过。现在我们希望hello_world项目能引用good_bye项目。<br>打开hello_world项目的Cargo.toml文件，在依赖项下面添加对good_bye的引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">good_bye = &#123;path = <span class="string">"../good_bye"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这个写法是引用本地路径中的库。<br>如果要引用官方仓库中的库更简单</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">lazy_static = <span class="string">"1.0.0"</span></span><br></pre></td></tr></table></figure>
<p>现在在应用程序中调用这个库。打开main.rs源文件，修改代码为<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> create good_bye;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"Hello world!"</span>);</span><br><span class="line">	good_bye::say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再次使用cargo run编译执行，就可以看到我们正确调用了good_bye项目中的代码。</p>
<p>cargo只是一个包管理工具，并不是编译器。Rust的编译器是rustc，使用cargo编译工程实际上最后还是调用的rustc来完成的。<br>如果我们想知道cargo在后面是如何调用rustc完成编译的，可以使用cargo build –verbose选项查看详细的编译命令。</p>
<p>我们可以用cargo -h来查看其他用法</p>
<ul>
<li>checkcheck命令可以只检查编译错误，而不做代码优化以及生成可执行程序，非常适合在开发过程中快速检查语法、类型错误。</li>
<li>clean清理以前的编译结果。</li>
<li>doc生成该项目的文档。</li>
<li>test执行单元测试。</li>
<li>bench执行benchmark性能测试。</li>
<li>update升级所有依赖项的版本，重新生成Cargo.lock文件。</li>
<li>install安装可执行程序。</li>
<li>uninstall删除可执行程序。</li>
</ul>
<p>其中cargo install是一个非常有用的命令，它可以让用户自己扩展cargo的子命令，为它增加新功能。<br>比如我们可以使用<code>cargo install cargo-tree</code>,安装一个新的cargo子命令，接下来就可以使用<code>cargo tree</code></p>
<p><br></p>
<h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>在Cargo.toml文件中，我们可以指定一个crate依赖哪些项目。<br>这些依赖既可以是来自官方的crates.io，也可以是某个git仓库地址，还可以是本地文件路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">laze_static = &quot;1.0.0&quot;</span><br><span class="line">rand = &#123;git=https://github.com/rust-lang-nursery/rand, branch=&quot;master&quot;&#125;</span><br><span class="line">my_own_project=&#123;path=&quot;/my/local/path&quot;, version=&quot;0.1.0&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>下面详细讲一下在[dependencies]里面的几种依赖项的格式</p>
<ul>
<li><p>来自crates.io的依赖<br>只需指定它的名字及版本号即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">lazy_static = &quot;1.0&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>^符号,如^1.2.3代表1.2.3&lt;=version &lt; 2.0.0;</li>
<li>~符号,如~1.2.3代表1.2.3&lt;=version &lt; 1.3.0;</li>
<li><code>*</code>符号,如<code>1.*</code>代表1.0.0 &lt;= version &lt; 2.0.0;</li>
<li>比较符号, 比如&gt;=1.2.3, &gt;1.2.3多个限制条件合起来用逗号分开</li>
</ul>
</li>
<li><p>来自git仓库的依赖<br>  除了最简单的<code>git=&quot;…&quot;</code>指定repository之外，我们还可以指定对应的分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rand = &#123;git=https://github.com/rust-lang-nursery/rand, branch=&quot;next&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>  或者指定当前的commit号</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rand = &#123;git=https://github.com/rust-lang-nursery/rand, branch=&quot;master&quot;, rev=&quot;31f2663&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>  还可以指定对应的tag名字</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rang = &#123;git=https://github.com/rust-lang-nursery/rand, tag=&quot;0.3.15&quot;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>来自本地文件路径的依赖<br>  指定本地文件路径，既可以使用绝对路径也可以使用相对路径。</p>
</li>
</ul>
<p>当我们使用cargo build编译完项目后，项目文件夹内会产生一个新文件，名字叫Cargo.lock。<br>它实际上是一个纯文本文件，同样也是toml格式。它里面记录了当前项目所有依赖项目的具体版本。<br>每次编译项目的时候，如果该文件存在，cargo就会使用这个文件中记录的版本号编译项目；<br>如果该文件不存在，cargo就会使用Cargo.toml文件中记录的依赖项目信息，自动选择最合适的版本。</p>
<p>对于依赖项，我们不仅要在Cargo.toml文件中写出来，还要在源代码中写出来。<br>目前版本中，必须在crate的入口处（对库项目就是lib.rs文件，对可执行程序项目就是main.rs文件）写上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern crate hello;			// 声明外部依赖</span><br><span class="line">extern crate hello as hi;	// 可以重命名</span><br></pre></td></tr></table></figure></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>cargo也支持配置文件。<br>配置文件可以定制cargo的许多行为，就像我们给git设置配置文件一样。<br>类似的cargo的配置文件可以存在多份，它们之间有优先级关系。</p>
<p>你可以为某个文件夹单独提供一份配置文件，放置到当前文件夹的．cargo/config位置<br>也可以提供一个全局的默认配置，放在$HOME/.cargo/config位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[cargo-new]</span><br><span class="line">//可以配置默认的名字和email,这些会出现在新项目的Cargo.toml中</span><br><span class="line">name = &quot;...&quot;</span><br><span class="line">email = &quot;...&quot;</span><br><span class="line">[build]</span><br><span class="line">jobs = 1</span><br><span class="line">rustflags = [&quot;..&quot;, &quot;..&quot;]</span><br><span class="line">[term]</span><br><span class="line">verbose=false</span><br><span class="line">color=&quot;auto&quot;</span><br><span class="line">[alias]</span><br><span class="line">b=&quot;build&quot;</span><br><span class="line">t=&quot;test&quot;</span><br><span class="line">r=&quot;run&quot;</span><br><span class="line">rr=&quot;run --release&quot;</span><br></pre></td></tr></table></figure>
<h3 id="workspace"><a href="#workspace" class="headerlink" title="workspace"></a>workspace</h3><p>cargo的workspace概念，是为了解决多crate的互相协调问题而存在的。<br>假设现在我们有一个比较大的项目。我们把它拆分成了多个crate来组织，就会面临一个问题：不同的crate会有各自不同的Cargo.toml，编译的时候它们会各自产生不同的Cargo.lock文件，我们无法保证所有的crate对同样的依赖项使用的是同样的版本号。</p>
<p>为了让不同的crate之间能共享一些信息，cargo提供了一个workspace的概念。一个workspace可以包含多个项目；所有的项目共享一个Cargo.lock文件，共享同一个输出目录；一个workspace内的所有项目的公共依赖项都是同样的版本，输出的目标文件都在同一个文件夹内。</p>
<p>workspace同样是用Cargo.toml来管理的。我们可以把所有的项目都放到一个文件夹下面。在这个文件夹下写一个Cargo.toml来管理这里的所有项目。</p>
<p>Cargo.toml文件中要写一个[workspace]的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[workspace]</span><br><span class="line"></span><br><span class="line">members = [</span><br><span class="line">	&quot;project1&quot;, &quot;lib1&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>整个文件夹的目录结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--Cargo.lock</span><br><span class="line">--Cargo.toml</span><br><span class="line">--project1</span><br><span class="line">	--Cargo.toml</span><br><span class="line">	--src</span><br><span class="line">		--main.rs</span><br><span class="line">--lib1</span><br><span class="line">	--cargo.toml</span><br><span class="line">	--src</span><br><span class="line">		--lib.rs</span><br><span class="line">--target</span><br></pre></td></tr></table></figure></p>
<p>我们可以在workspace的根目录执行cargo build等命令。<br>请注意虽然每个crate都有自己的Cargo.toml文件，可以各自配置自己的依赖项，但是每个crate下面不再会各自生成一个Cargo.lock文件，而是统一在workspace下生成一个Cargo.lock文件。</p>
<p>如果多个crate都依赖一个外部库，那么它们必然都是依赖的同一个版本。</p>
<h3 id="build-rs"><a href="#build-rs" class="headerlink" title="build.rs"></a>build.rs</h3><p>cargo工具还允许用户在正式编译开始前执行一些自定义的逻辑。方法是在Cargo.toml中配置一个build的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[package]</span><br><span class="line"># ...</span><br><span class="line">build = &quot;build.rs&quot;</span><br></pre></td></tr></table></figure>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><ul>
<li>变量绑定\拷贝(浅拷贝只发生在栈上)\克隆(深拷贝：.clone)</li>
<li>获取变量的引用，称之为借用(borrowing)</li>
<li>引用与解引用</li>
<li>引用/可变引用</li>
<li>可变引用同时只能存在一个</li>
<li>可变引用与不可变引用不能同时存在</li>
<li>Rust 专门起了一个名字 —— Non-Lexical Lifetimes(NLL)，专门用于找到某个引用在作用域(})结束前就不再被使用的代码位置。</li>
<li>悬垂引用(Dangling References):意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在</li>
<li>#![allow(unused_variables)] 属性标记，该标记会告诉编译器忽略未使用的变量，不要抛出 warning 警告</li>
<li>unimplemented!() 告诉编译器该函数尚未实现，类似的标记还有 todo!()</li>
</ul>
<ul>
<li>如果我们使用 {} 来格式化输出，那对应的类型就必须实现 Display 特征，以前学习的基本类型，都默认实现了该特征</li>
<li>如果实现Debug特征, 那么对应的输出格式是{:?},#[derive(Debug)]</li>
<li>结构体较大时，我们可能希望能够有更好的输出表现，此时可以使用 {:#?} 来替代 {:?}</li>
<li>dbg! 输出到标准错误输出 stderr，而 println! 输出到标准输出 stdout</li>
</ul>
<ul>
<li>任何类型的数据都可以放入枚举成员中: 例如字符串、数值、结构体甚至另一个枚举。</li>
</ul>
<ul>
<li>Option 枚举用于处理空值</li>
<li>Option 枚举包含两个成员，一个成员表示含有值：Some(T), 另一个表示没有值：None</li>
<li>使用 Option<t> 值，需要编写处理每个成员的代码。你想要一些代码只当拥有 Some(T) 值时运行，允许这些代码使用其中的 T。也希望一些代码在值为 None 时运行，这些代码并没有一个可用的 T 值。match 表达式就是这么一个处理枚举的控制流结构：它会根据枚举的成员运行不同的代码，这些代码可以使用匹配到的值中的数据。</t></li>
<li>Option类型可以用unwrap, 但是会遇到panic</li>
</ul>
<ul>
<li>切片的长度可以与数组不同，并不是固定的，而是取决于你使用时指定的起始和结束位置</li>
<li>创建切片的代价非常小，因为切片只是针对底层数组的一个引用</li>
<li>切片类型[T]拥有不固定的大小，而切片引用类型&amp;[T]则具有固定的大小，因为 Rust 很多时候都需要固定大小数据类型，因此&amp;[T]更有用,&amp;str字符串切片也同理</li>
</ul>
<ul>
<li>for 元素 in 集合 {<br>// 使用元素干一些你懂我不懂的事情<br>}</li>
<li>for item in &amp;mut collection {<br>// 修改该元素，可以使用 mut 关键字<br>// …<br>}</li>
</ul>
<ul>
<li>match 的匹配必须要穷举出所有可能，因此这里用 _ 来代表未列出的所有可能性</li>
<li>match 的每一个分支都必须是一个表达式，且所有分支的表达式最终返回值的类型必须相同</li>
<li><p>X | Y，类似逻辑运算符 或，代表该分支可以匹配 X 也可以匹配 Y，只要满足一个即可</p>
</li>
<li><p>模式绑定:模式匹配的另外一个重要功能是从模式中取出绑定的值，例如下面双重match</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Direction</span></span>&#123;</span><br><span class="line">    East,</span><br><span class="line">    West,</span><br><span class="line">    North,</span><br><span class="line">    South,</span><br><span class="line">    Data(UsState)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dire = Direction::Data(Alabama);</span><br><span class="line"><span class="keyword">match</span> dire &#123;</span><br><span class="line">    Direction::Data(state) =&gt;&#123;</span><br><span class="line">        <span class="keyword">match</span> state &#123;</span><br><span class="line">            UsState::Alabama =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"Alabama"</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            _ =&gt;&#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"Alabama"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _=&gt;<span class="built_in">println!</span>(<span class="string">"Other"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>matches!:它可以将一个表达式跟模式进行匹配，然后返回匹配的结果 true or false。</p>
</li>
<li><p>变量覆盖: Some(age) = age, age代表的是内部解构的</p>
</li>
<li><p>全模式列表</p>
<ul>
<li>通过序列 ..= 匹配值的范围: ..= 语法允许你匹配一个闭区间序列内的值。当模式匹配任何在此序列内的值时，该分支会执行</li>
<li>解构并分解值:  let p = Point { x: 0, y: 7 }; let Point { x: a, y: b } = p;</li>
<li>解构枚举</li>
</ul>
</li>
</ul>
<ul>
<li>@绑定: @运算符允许为一个字段绑定另外一个变量</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    Hello &#123;id:<span class="built_in">i32</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">case18</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = Message::Hello&#123;id:<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Hello &#123;id: data @<span class="number">3</span>..=<span class="number">7</span>&#125;=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"符合:&#123;&#125;"</span>, data);</span><br><span class="line">        &#125;</span><br><span class="line">        _=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"不符合"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@前绑定后解构(Rust 1.56 新增)</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    x:<span class="built_in">i32</span>,</span><br><span class="line">    y:<span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">case19</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> p @Point&#123;x: px, y:py&#125; = Point&#123;x:<span class="number">10</span>, y:<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"px:&#123;&#125;, py:&#123;&#125;"</span>, p.x, p.y);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"px:&#123;&#125;, py:&#123;&#125;"</span>, px, py);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关联函数:在impl中且没有self的函数被称之为关联函数:因为它没有self，不能用f.read()的形式调用，因此它是一个函数而不是方法,它又在impl中,与结构体紧密关联,因此称为关联函数。</li>
</ul>
<blockquote>
<p>self关键字</p>
</blockquote>
<ul>
<li>self 表示 Rectangle 的所有权转移到该方法中，这种形式用的较少</li>
<li>&amp;self 表示该方法对 Rectangle 的不可变借用</li>
<li>&amp;mut self 表示可变借用</li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul>
<li>泛型 Generics:用同一功能的函数处理不同类型的数据</li>
<li>编译器建议我们给 T 添加一个类型限制：使用 std::cmp::PartialOrd 特征（Trait）对 T 进行限制,使其所有的类型都能进行比较</li>
<li>同样不是所有 T 类型都能进行相加操作，因此我们需要用 std::ops::Add<output =="" t=""> 对 T 进行限制：</output></li>
<li><p>结构体泛型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T,U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举泛型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法中使用泛型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point3</span></span>&lt;T&gt;&#123;</span><br><span class="line">    x:T,</span><br><span class="line">    y:T,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> &lt;T&gt; Point3&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt;&amp;T&#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数中使用泛型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T:Talk&gt;(item:&amp;T)&#123;</span><br><span class="line">    item.say2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>const 泛型（Rust 1.51 版本引入的重要特性） </p>
</li>
</ul>
<h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>特征 Trait</li>
<li>#[derive(Debug)]，它在我们定义的类型(struct)上自动派生 Debug 特征</li>
<li><p>默认实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize_author</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"(Read more from &#123;&#125;...)"</span>, <span class="keyword">self</span>.summarize_author())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特征约束(trait bound): T: Summary 被称为特征约束</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T:Talk&gt;(item:&amp;T)&#123;</span><br><span class="line">    item.say2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多重约束</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify2</span></span>(data:&amp;(<span class="keyword">impl</span> Talk + Look));</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify3</span></span>&lt;T:Talk + Look&gt;(data:&amp;T);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Where 约束</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify4</span></span>&lt;T:Display + <span class="built_in">Clone</span>, U:<span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(data1:T, data2:U)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;:?&#125;"</span>, data1, data2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify5</span></span>&lt;T,U&gt;(data1:T, data2:U)</span><br><span class="line">    <span class="keyword">where</span> T:Display + <span class="built_in">Clone</span>, U:<span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;:?&#125;"</span>, data1, data2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用特征约束有条件地实现方法或特征</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair5</span></span>&lt;T&gt;&#123;</span><br><span class="line">    x:T,</span><br><span class="line">    y:T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> &lt;T&gt;Pair5&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x:T, y:T) -&gt;<span class="keyword">Self</span>&#123;</span><br><span class="line">        <span class="keyword">Self</span>&#123;</span><br><span class="line">            x,y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> &lt;T:Display+<span class="built_in">Debug</span>+<span class="built_in">PartialOrd</span>&gt; Pair5&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cmp_display</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt; <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数返回中的 impl Trait,必须有imple当前的Trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">return1</span></span>(switch:<span class="built_in">bool</span>) -&gt; <span class="keyword">impl</span> Look&#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        Person3&#123;</span><br><span class="line">            age:<span class="number">10</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Person3&#123;</span><br><span class="line">            age:<span class="number">20</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 derive 派生特征: derive 派生出来的是 Rust 默认给我们提供的特征，在开发过程中极大的简化了自己手动实现相应特征的需求，当然，如果你有特殊的需求，还可以自己手动重载该实现。</p>
</li>
<li><p>调用方法需要引入特征</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::convert::TryInto;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> a: <span class="built_in">i32</span> = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> b: <span class="built_in">u16</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> b_ = b.try_into()</span><br><span class="line">            .unwrap();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> a &lt; b_ &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Ten is less than one hundred."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特征对象:特征对象指向实现了 xxx 特征的类型的实例</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Draw <span class="keyword">for</span> <span class="built_in">u8</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"str:&#123;:?&#125;"</span>, <span class="keyword">self</span>.to_string());</span><br><span class="line">        <span class="keyword">self</span>.to_string()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="function"><span class="keyword">fn</span> <span class="title">print_draw</span></span>(x:<span class="built_in">Box</span>&lt;dyn Draw&gt;)&#123;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_draw</span></span>(x:<span class="built_in">Box</span>&lt;<span class="keyword">impl</span> Draw&gt;)&#123;</span><br><span class="line">    x.draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">case38</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> n :<span class="built_in">Box</span>&lt;<span class="built_in">u8</span>&gt;= <span class="built_in">Box</span>::new(<span class="number">10</span>);</span><br><span class="line">    print_draw(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在动态类型语言中，有一个很重要的概念：鸭子类型(duck typing)，</span><br><span class="line">简单来说，就是只关心值长啥样，而不关心它实际是什么。</span><br><span class="line">当一个东西走起来像鸭子，叫起来像鸭子，那么它就是一只鸭子</span><br><span class="line">就算它实际上是一个奥特曼，也不重要，我们就当它是鸭子。</span><br><span class="line"></span><br><span class="line">在上例中，Screen 在 run 的时候，我们并不需要知道各个组件的具体类型是什么。</span><br><span class="line">它也不检查组件到底是 Button 还是 SelectBox 的实例</span><br><span class="line">只要它实现了 Draw 特征，就能通过 Box::new 包装成 Box&lt;dyn Draw&gt; 特征对象，然后被渲染在屏幕上。</span><br></pre></td></tr></table></figure>
<h2 id="特征的分发"><a href="#特征的分发" class="headerlink" title="特征的分发"></a>特征的分发</h2><ul>
<li><p>特征对象的动态分发<br>编译器会为每一个泛型参数对应的具体类型生成一份代码，这种方式是静态分发(static dispatch)<br>因为是在编译期完成的，对于运行期性能完全没有任何影响。<br>与静态分发相对应的是动态分发(dynamic dispatch)，直到运行时才能确定需要调用什么方法。<br>之前代码中的关键字 dyn 正是在强调这一“动态”的特点。</p>
</li>
<li><p>静态分发 Box<t> 和动态分发 Box<dyn trait=""><br>动态的除了ptr还有vptr</dyn></t></p>
</li>
</ul>
<h2 id="Self-与-self"><a href="#Self-与-self" class="headerlink" title="Self 与 self"></a>Self 与 self</h2><p>在 Rust 中，有两个self，一个指代当前的实例对象，一个指代特征或者方法类型的别名：</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|param1, param2,...| &#123;</span><br><span class="line">    语句1;</span><br><span class="line">    语句2;</span><br><span class="line">    返回表达式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|param1| 返回表达式</span><br></pre></td></tr></table></figure>
<ul>
<li>捕获作用域中的值</li>
<li>闭包对内存的影响<br>当闭包从环境中捕获一个值时，会分配内存去存储这些值。对于有些场景来说，这种额外的内存分配会成为一种负担。<br>与之相比函数就不会去捕获这些环境值，因此定义和使用函数不会拥有这种内存负担。</li>
</ul>
<h2 id="三种-Fn-特征"><a href="#三种-Fn-特征" class="headerlink" title="三种 Fn 特征"></a>三种 Fn 特征</h2><ul>
<li>FnOnce，该类型的闭包会拿走被捕获变量的所有权。<br>  Once 顾名思义，说明该闭包只能运行一次</li>
<li>FnMut，它以可变借用的方式捕获了环境中的值，因此可以修改该值</li>
<li>Fn 特征，它以不可变借用的方式捕获环境中的值 让我们把上面的代码中 exec 的 F 泛型参数类型修改为 Fn(&amp;’a str)：</li>
</ul>
<p>三种 Fn 的关系<br>实际上，一个闭包并不仅仅实现某一种 Fn 特征，规则如下：</p>
<p>所有的闭包都自动实现了 FnOnce 特征，因此任何一个闭包都至少可以被调用一次<br>没有移出所捕获变量的所有权的闭包自动实现了 FnMut 特征<br>不需要对捕获变量进行改变的闭包自动实现了 Fn 特征</p>
<h2 id="move-和-Fn"><a href="#move-和-Fn" class="headerlink" title="move 和 Fn"></a>move 和 Fn</h2><p>实际上使用了 move 的闭包依然可能实现了 Fn 或 FnMut 特征。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="三条消除规则"><a href="#三条消除规则" class="headerlink" title="三条消除规则"></a>三条消除规则</h3><ul>
<li>每一个引用参数都会获得独自的生命周期</li>
<li>若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期，也就是所有返回值的生命周期都等于该输入生命周期</li>
<li>若存在多个输入生命周期，且其中一个是 &amp;self 或 &amp;mut self，则 &amp;self 的生命周期被赋给所有的输出生命周期</li>
</ul>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><blockquote>
<p>智能指针往往是基于结构体实现,它与我们自定义的结构体最大的区别在于它实现了 Deref 和 Drop 特征：</p>
</blockquote>
<ul>
<li>Deref 可以让智能指针像引用那样工作，这样你就可以写出同时支持智能指针和引用的代码，例如 *T</li>
<li>Drop 允许你指定智能指针超出作用域后自动执行的代码，例如做一些数据清除等收尾工作</li>
</ul>
<blockquote>
<p>智能指针在 Rust 中很常见，我们在本章不会全部讲解，而是挑选几个最常用、最有代表性的进行讲解：</p>
</blockquote>
<ul>
<li>Box<t>，可以将值分配到堆上</t></li>
<li>Rc<t>，引用计数类型，允许多所有权存在</t></li>
<li>Ref<t> 和 RefMut<t>，允许将借用规则检查从编译期移动到运行期进行</t></t></li>
</ul>
<h2 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h2><p>在 Rust 中，main 线程的栈大小是 8MB，普通线程是 2MB，在函数调用时会在其中创建一个临时栈空间，调用结束后 Rust 会让这个栈空间里的对象自动进入 Drop 流程</p>
<h2 id="Deref解引用"><a href="#Deref解引用" class="headerlink" title="Deref解引用"></a>Deref解引用</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> &lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x:T) -&gt;MyBox&lt;T&gt;&#123;</span><br><span class="line">        MyBox(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> &lt;T&gt; Deref <span class="keyword">for</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;Self::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">case57</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> myBox = MyBox(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"myBox:&#123;&#125;"</span>, *myBox)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数和方法中的隐式 Deref 转换:仅引用类型的实参才会触发自动解引用</li>
</ul>
<blockquote>
<p>连续的隐式 Deref 转换</p>
</blockquote>
<p>使用了之前自定义的智能指针 MyBox，并将其通过连续的隐式转换变成 &amp;str 类型</p>
<ul>
<li>首先 MyBox 被 Deref 成 String 类型，结果并不能满足 display 函数参数的要求</li>
<li>编译器发现 String 还可以继续 Deref 成 &amp;str，最终成功的匹配了函数参数。</li>
</ul>
<blockquote>
<p>引用归一化</p>
</blockquote>
<p>Rust 会在解引用时自动把智能指针和 &amp;&amp;&amp;&amp;v 做引用归一化操作，转换成 &amp;v 形式，最终再对 &amp;v 进行解引用：</p>
<ul>
<li>把智能指针（比如在库中定义的，Box、Rc、Arc、Cow 等）从结构体脱壳为内部的引用类型，也就是转成结构体内部的 &amp;v</li>
<li>把多重&amp;，例如 &amp;&amp;&amp;&amp;&amp;&amp;&amp;v，归一成 &amp;v</li>
</ul>
<blockquote>
<p>三种Deref转换</p>
</blockquote>
<ul>
<li>当 T: Deref&lt;Target=U&gt;，可以将 &amp;T 转换成 &amp;U，也就是我们之前看到的例子</li>
<li>当 T: DerefMut&lt;Target=U&gt;，可以将 &amp;mut T 转换成 &amp;mut U</li>
<li>当 T: Deref&lt;Target=U&gt;，可以将 &amp;mut T 转换成 &amp;U</li>
</ul>
<h2 id="Drop-释放资源"><a href="#Drop-释放资源" class="headerlink" title="Drop 释放资源"></a>Drop 释放资源</h2><blockquote>
<p>Drop 的顺序</p>
<ul>
<li>变量级别，按照逆序的方式，<code>_x</code>在<code>_foo</code>之前创建，因此<code>_x</code>在<code>_foo</code>之后被 drop</li>
<li>结构体内部，按照顺序的方式，结构体<code>_x</code>中的字段按照定义中的顺序依次 drop</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rust 自动为几乎所有类型都实现了 Drop 特征</span><br><span class="line">因此就算你不手动为结构体实现 Drop，它依然会调用默认实现的 drop 函数</span><br><span class="line">同时再调用每个字段的 drop 方法</span><br></pre></td></tr></table></figure>
<blockquote>
<p>手动回收</p>
</blockquote>
<p>对于 Rust 而言，不允许显式地调用析构函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> Foo &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping Foo!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> foo = Foo;</span><br><span class="line">    foo.<span class="built_in">drop</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Running!:&#123;:?&#125;"</span>, foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应订正为</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo11</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> Foo11 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping Foo!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">case59</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> foo = Foo11;</span><br><span class="line">    std::mem::<span class="built_in">drop</span>(foo);</span><br><span class="line">    <span class="comment">//println!("Running!:&#123;:?&#125;", foo);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他们的区别在于</p>
<ul>
<li>Drop::drop 只是借用了目标值的可变引用，所以，就算你提前调用了 drop，后面的代码依然可以使用目标值，但是这就会访问一个并不存在的值，非常不安全</li>
<li>std::mem::drop完美拿走了所有权，而且这种实现保证了后续的使用必定会导致编译错误，因此非常安全</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">手动drop调用的是std::mem::drop()，自动drop调用的是std::ops::Drop::drop()。</span><br><span class="line">std::ops::Drop::drop()是不能手动调用的。</span><br><span class="line"></span><br><span class="line">手动std::mem::drop()是假的，不释放内存，只是把所有权转移到一个临时位置不能访问了。</span><br><span class="line">实际释放资源依然是在离开作用域时，调用std::ops::Drop::drop()来实现。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Drop 使用场景</p>
</blockquote>
<p>对于 Drop 而言，主要有两个功能：</p>
<ul>
<li>回收内存资源</li>
<li>执行一些收尾工作</li>
</ul>
<p>我们都无需手动去 drop 以回收内存资源，因为 Rust 会自动帮我们完成这些工作，<br>但是确实有极少数情况，需要你自己来回收资源的，例如文件描述符、网络 socket 等</p>
<blockquote>
<p>互斥的 Copy 和 Drop</p>
</blockquote>
<p>无法为一个类型同时实现 Copy 和 Drop 特征。<br>因为实现了 Copy 的特征会被编译器隐式的复制，因此非常难以预测析构函数执行的时间和频率。<br>因此这些实现了 Copy 的类型无法拥有析构函数。</p>
<p><br><br><br></p>
<h2 id="Rc-与-Arc"><a href="#Rc-与-Arc" class="headerlink" title="Rc 与 Arc"></a>Rc 与 Arc</h2><p>Rust 所有权机制要求一个值只能有一个所有者，在大多数情况下，都没有问题，但是考虑以下情况：</p>
<ul>
<li>在图数据结构中，多个边可能会拥有同一个节点，该节点直到没有边指向它时，才应该被释放清理</li>
<li>在多线程中，多个线程可能会持有同一个数据，但是你受限于 Rust 的安全机制，无法同时获取该数据的可变引用</li>
</ul>
<p>Rust 在所有权机制之外又引入了额外的措施来简化相应的实现:通过引用计数的方式，允许一个数据资源在同一时刻拥有多个所有者。</p>
<h3 id="Rc"><a href="#Rc" class="headerlink" title="Rc"></a>Rc<t></t></h3><p> Rc 正是引用计数的英文缩写。当我们希望在堆上分配一个对象供程序的多个部分使用且无法确定哪个部分最后一个结束时，就可以使用 Rc 成为数据值的所有者，例如之前提到的多线程场景就非常适合。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">case60</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"test"</span>);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">Box</span>::new(s);</span><br><span class="line">    <span class="comment">// let b = Box::new(s); 无法在被转移给b了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">case61</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello case61"</span>);</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(s);</span><br><span class="line">    <span class="keyword">let</span> b = Rc::clone(&amp;a); <span class="comment">//rc就轻松解决了</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a:&#123;&#125;, b:&#123;&#125;"</span>, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rc::clone:只是引用计数增加到2,并没有克隆数据<br>通过Rc::strong_count(&amp;a)查看引用计数</p>
<h3 id="不可变引用"><a href="#不可变引用" class="headerlink" title="不可变引用"></a>不可变引用</h3><p>事实上，Rc<t> 是指向底层数据的不可变的引用，因此你无法通过它来修改数据，这也符合 Rust 的借用规则：要么存在多个不可变借用，要么只能存在一个可变借用。</t></p>
<h3 id="Rc-简单总结"><a href="#Rc-简单总结" class="headerlink" title="Rc 简单总结"></a>Rc 简单总结</h3><ul>
<li>Rc/Arc 是不可变引用，你无法修改它指向的值，只能进行读取，如果要修改，需要配合后面章节的内部可变性 RefCell 或互斥锁 Mutex</li>
<li>一旦最后一个拥有者消失，则资源会自动被回收，这个生命周期是在编译期就确定下来的</li>
<li>Rc 只能用于同一线程内部，想要用于线程之间的对象共享，你需要使用 Arc</li>
<li>Rc<t> 是一个智能指针，实现了 Deref 特征，因此你无需先解开 Rc 指针，再使用里面的 T，而是可以直接使用 T，例如上例中的 gadget1.owner.name</t></li>
</ul>
<h3 id="Arc"><a href="#Arc" class="headerlink" title="Arc"></a>Arc</h3><p>Rc<t> 不能在线程间安全的传递，实际上是因为它没有实现 Send 特征，而该特征是恰恰是多线程间传递数据的关键，我们会在多线程章节中进行讲解。<br>当然还有更深层的原因：由于 Rc<t> 需要管理引用计数，但是该计数器并没有使用任何并发原语，因此无法实现原子化的计数操作，最终会导致计数错误。<br>好在天无绝人之路，一起来看看 Rust 为我们提供的功能类似但是多线程安全的 Arc。</t></t></p>
<p>Arc 是 Atomic Rc 的缩写，顾名思义：原子化的 Rc<t> 智能指针。原子化是一种并发原语</t></p>
<h3 id="Arc-的性能损耗"><a href="#Arc-的性能损耗" class="headerlink" title="Arc 的性能损耗"></a>Arc 的性能损耗</h3><p>原子化或者其它锁虽然可以带来的线程安全，但是都会伴随着性能损耗，而且这种性能损耗还不小。因此 Rust 把这种选择权交给你，毕竟需要线程安全的代码其实占比并不高，大部分时候我们开发的程序都在一个线程内。</p>
<h2 id="Cell与RefCell内部可变性"><a href="#Cell与RefCell内部可变性" class="headerlink" title="Cell与RefCell内部可变性"></a>Cell与RefCell内部可变性</h2><table>
<thead>
<tr>
<th>Rust 规则</th>
<th>智能指针带来的额外规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>一个数据只有一个所有者</td>
<td>Rc/Arc让一个数据可以拥有多个所有者</td>
</tr>
<tr>
<td>要么多个不可变借用，要么一个可变借用</td>
<td>RefCell实现编译期可变、不可变引用共存</td>
</tr>
<tr>
<td>违背规则导致编译错误</td>
<td>违背规则导致运行时panic</td>
</tr>
</tbody>
</table>
<blockquote>
<p>RefCell 简单总结</p>
<ul>
<li>与 Cell 用于可 Copy 的值不同，RefCell 用于引用</li>
<li>RefCell 只是将借用规则从编译期推迟到程序运行期，并不能帮你绕过这个规则</li>
<li>RefCell 适用于编译期误报或者一个引用被在多处代码使用、修改以至于难于管理借用关系时</li>
<li>使用 RefCell 时，违背借用规则会导致运行期的 panic</li>
</ul>
</blockquote>
<blockquote>
<p>选择 Cell 还是 RefCell</p>
<ul>
<li>Cell 只适用于 Copy 类型，用于提供值，而 RefCell 用于提供引用</li>
<li>Cell 不会 panic，而 RefCell 会</li>
</ul>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code snipet 1</span></span><br><span class="line"><span class="keyword">let</span> x = Cell::new(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> y = &amp;x;</span><br><span class="line"><span class="keyword">let</span> z = &amp;x;</span><br><span class="line">x.set(<span class="number">2</span>);</span><br><span class="line">y.set(<span class="number">3</span>);</span><br><span class="line">z.set(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// code snipet 2</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line"><span class="keyword">let</span> z = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">*y = <span class="number">3</span>;</span><br><span class="line">*z = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br></pre></td></tr></table></figure>
<p>虽然性能一致，但代码 1 拥有代码 2 不具有的优势：它能编译成功:)</p>
<p>总之当非要使用内部可变性时，首选 Cell，只有你的类型没有实现 Copy 时，才去选择 RefCell。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能对一个不可变的值进行可变借用，这会破坏 Rust 的安全性保证<br>相反你可以对一个可变值进行不可变借用。<br>原因是：当值不可变时，可能会有多个不可变的引用指向它，此时若将修改其中一个为可变的，会造成可变引用与不可变引用共存的情况;<br>而当值可变时，最多只会有一个可变引用指向它，将其修改为不可变，那么最终依然是只有一个不可变的引用指向它。</p>
<p><br><br><br></p>
<h1 id="循环引用与自引用"><a href="#循环引用与自引用" class="headerlink" title="循环引用与自引用"></a>循环引用与自引用</h1><h2 id="Weak与循环引用"><a href="#Weak与循环引用" class="headerlink" title="Weak与循环引用"></a>Weak与循环引用</h2><table>
<thead>
<tr>
<th>Weak</th>
<th>Rc</th>
</tr>
</thead>
<tbody>
<tr>
<td>不计数</td>
<td>引用计数</td>
</tr>
<tr>
<td>不拥有所有权</td>
<td>拥有值的所有权</td>
</tr>
<tr>
<td>不阻止值被释放(drop)</td>
<td>所有权计数归零，才能 drop</td>
</tr>
<tr>
<td>引用的值存在返回 Some，不存在返回 None</td>
<td>引用的值必定存在</td>
</tr>
<tr>
<td>通过 upgrade 取到 Option&lt;Rc<t>&gt;，然后再取值</t></td>
<td>通过 Deref 自动解引用，取值无需任何操作</td>
</tr>
</tbody>
</table>
<p><br><br><br></p>
<h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p>在 Rust 中宏分为两大类：声明式宏( declarative macros ) macro_rules! 和三种过程宏( procedural macros ):</p>
<ul>
<li>[derive]，在之前多次见到的派生宏，可以为目标结构体或枚举派生指定的代码，例如 Debug 特征</li>
<li>类属性宏(Attribute-like macro)，用于为目标添加自定义的属性</li>
<li>类函数宏(Function-like macro)，看上去就像是函数调用</li>
</ul>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2022/07/09/rust/';
        this.page.title = 'Rust知识集锦';
        this.page.identifier = '2022/07/09/rust/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
