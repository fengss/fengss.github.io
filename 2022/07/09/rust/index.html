<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Rust基础语法 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="Rust 语法体系

Box是“指针”，指向一个在堆上分配的对象;
Vec是“指针”，指向一组同类型的顺序排列的堆上分配的对象，且携带有当前缓存空间总大小和元素个数大小的元数据；
Rc和Arc也是某种形式的、携带了额外元数据的“指针”，它们提供的是一种“共享”的所有权，当所有的引用计数指针都销毁之后，它们所指向的内存空间才会被释放。

Trait静态方法12345678910111213141516// 静态方法struct T(i32);impl T&amp;#123;	fn func(this:&amp;a">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Go/Rust</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">系统内核</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">威胁追踪</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">数据库</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Trait"><span class="toc-number">1.</span> <span class="toc-text">Trait</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#静态方法"><span class="toc-number">1.1.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展方法"><span class="toc-number">1.2.</span> <span class="toc-text">扩展方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完整函数调用语法"><span class="toc-number">1.3.</span> <span class="toc-text">完整函数调用语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trait约束和继承"><span class="toc-number">1.4.</span> <span class="toc-text">trait约束和继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Derive"><span class="toc-number">1.5.</span> <span class="toc-text">Derive</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trait别名"><span class="toc-number">1.6.</span> <span class="toc-text">trait别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组和字符串"><span class="toc-number">2.</span> <span class="toc-text">数组和字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">2.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内置方法"><span class="toc-number">2.1.1.</span> <span class="toc-text">内置方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多维数组"><span class="toc-number">2.1.2.</span> <span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组切片"><span class="toc-number">2.1.3.</span> <span class="toc-text">数组切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DST和胖指针"><span class="toc-number">2.1.4.</span> <span class="toc-text">DST和胖指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Range"><span class="toc-number">2.1.5.</span> <span class="toc-text">Range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#边界检查"><span class="toc-number">2.1.6.</span> <span class="toc-text">边界检查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">2.2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#amp-str"><span class="toc-number">2.2.1.</span> <span class="toc-text">&amp;str</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">2.2.2.</span> <span class="toc-text">String</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#容器与迭代器"><span class="toc-number">3.</span> <span class="toc-text">容器与迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#容器"><span class="toc-number">3.1.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vec"><span class="toc-number">3.1.1.</span> <span class="toc-text">Vec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VecDeque"><span class="toc-number">3.1.2.</span> <span class="toc-text">VecDeque</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">3.1.3.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTreeMap"><span class="toc-number">3.1.4.</span> <span class="toc-text">BTreeMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器"><span class="toc-number">3.2.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现迭代器"><span class="toc-number">3.2.1.</span> <span class="toc-text">实现迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器的组合"><span class="toc-number">3.2.2.</span> <span class="toc-text">迭代器的组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for循环"><span class="toc-number">3.2.3.</span> <span class="toc-text">for循环</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#生成器"><span class="toc-number">4.</span> <span class="toc-text">生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">4.1.</span> <span class="toc-text">简介</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#项目和模块"><span class="toc-number">5.</span> <span class="toc-text">项目和模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cargo"><span class="toc-number">5.1.</span> <span class="toc-text">cargo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#项目依赖"><span class="toc-number">5.2.</span> <span class="toc-text">项目依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#配置"><span class="toc-number">5.2.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#workspace"><span class="toc-number">5.2.2.</span> <span class="toc-text">workspace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#build-rs"><span class="toc-number">5.2.3.</span> <span class="toc-text">build.rs</span></a></li></ol></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            Rust基础语法
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2022/07/09/rust/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2022-07-09T04:15:20.000Z" itemprop="datePublished">2022-07-09</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/go/">go</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>Rust 语法体系<br><a id="more"></a></p>
<ul>
<li>Box<t>是“指针”，指向一个在堆上分配的对象;</t></li>
<li>Vec<t>是“指针”，指向一组同类型的顺序排列的堆上分配的对象，且携带有当前缓存空间总大小和元素个数大小的元数据；</t></li>
<li>Rc<t>和Arc<t>也是某种形式的、携带了额外元数据的“指针”，它们提供的是一种“共享”的所有权，当所有的引用计数指针都销毁之后，它们所指向的内存空间才会被释放。</t></t></li>
</ul>
<h1 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h1><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span></span>(<span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> T&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">func</span></span>(this:&amp;<span class="keyword">Self</span>)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"value:&#123;&#125;"</span>, this.<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> x = T(<span class="number">66</span>);</span><br><span class="line">	T::func(&amp;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>trait中也可以定义静态函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Default</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">default</span></span>() -&gt; <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>trait包含default函数,无参数的函数,返回的类型是实现该trait的具体类型<br>Rust中没有构造函数的概念, Default trait实际上可以看作一个针对无参数构造函数的统一抽象</p>
<p>与C+相比, Rust定义静态函数无需使用Static关键字,因为它把self参数显式在参数列表中列出来了</p>
<p><br></p>
<h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><p>trait给其他类型添加成员方法, 哪怕这个类型不是自己写的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Double</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">double</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Double <span class="keyword">for</span> <span class="built_in">i32</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">double</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span>&#123;</span><br><span class="line">		*<span class="keyword">self</span> * <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> x:<span class="built_in">i32</span> = <span class="number">10</span>.double();</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="完整函数调用语法"><a href="#完整函数调用语法" class="headerlink" title="完整函数调用语法"></a>完整函数调用语法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chef</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Cook <span class="keyword">for</span> Chef&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">start</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"Cook::start"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Wash <span class="keyword">for</span> Chef&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">start</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"Wash::start"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> me = Chef;</span><br><span class="line">	<span class="comment">// me.start();</span></span><br><span class="line">	<span class="comment">// 定义两个trait start()函数有同样方法签名</span></span><br><span class="line">	<span class="comment">// 会出现编译错误 multiple applicable items in scope</span></span><br><span class="line">	<span class="comment">// 这个时候有必要使用完整的函数调用语法进行方法调用</span></span><br><span class="line">	<span class="comment">// 只有这样才能清晰明白无歧义表达清楚期望调用哪个函数</span></span><br><span class="line">	&lt;Cook&gt;::start(&amp;me);</span><br><span class="line">	&lt;Chef <span class="keyword">as</span> Wash&gt;::start(&amp;me);</span><br><span class="line">	<span class="comment">// 或者</span></span><br><span class="line">	<span class="comment">//&lt;Wash&gt;::start(&amp;me);</span></span><br><span class="line">	<span class="comment">//&lt;Cook&gt;::start(&amp;me);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>成员方法和普通函数没本质区别</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span></span>(<span class="built_in">usize</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> T&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">get1</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;<span class="keyword">self</span>.<span class="number">0</span>&#125;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">get2</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;<span class="keyword">self</span>.<span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get3</span></span>(t: &amp;T) -&gt; <span class="built_in">usize</span> &#123;t.<span class="number">0</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_type</span></span>(_:<span class="function"><span class="keyword">fn</span></span>(&amp;T)-&gt;<span class="built_in">usize</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	check_type(T::get1);</span><br><span class="line">	check_type(T::get2);</span><br><span class="line">	check_type(get3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="trait约束和继承"><a href="#trait约束和继承" class="headerlink" title="trait约束和继承"></a>trait约束和继承</h2><p>Rust的trait另一个用处是作为泛型约束使用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">my_print</span></span>&lt;T:<span class="built_in">Debug</span>&gt;(x:T)&#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"The value is &#123;:?&#125;"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">	my_print(<span class="string">"China"</span>);</span><br><span class="line">	my_print(<span class="number">41_i32</span>);</span><br><span class="line">	my_print(<span class="literal">true</span>);</span><br><span class="line">	my_print([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>my_print函数引入一个泛型T, 所以参数不是具体的类型, 而是一组类型<br>冒号后面加trait名字,就是泛型参数约束条件, 要求T类型实现Debug这个trait</p>
<p>泛型约束另一种写法是where子句<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"><span class="comment">// fn my_print&lt;T:Debug&gt;(x:T)&#123;</span></span><br><span class="line"><span class="comment">// 	println!("The value is &#123;:?&#125;", x);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">my_print</span></span>&lt;T&gt;(x:T) <span class="keyword">where</span> T:<span class="built_in">Debug</span>&#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">	my_print(<span class="string">"China"</span>);</span><br><span class="line">	my_print(<span class="number">41_i32</span>);</span><br><span class="line">	my_print(<span class="literal">true</span>);</span><br><span class="line">	my_print([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>trait允许继承,类似这样</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Base</span></span> &#123;</span><br><span class="line">	<span class="comment">// add code here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Derived</span></span>:Base &#123;</span><br><span class="line">	<span class="comment">// add code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后impl满足的时候两个都需要</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Base</span></span> &#123;</span><br><span class="line">	<span class="comment">// add code here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Derived</span></span>:Base &#123;</span><br><span class="line">	<span class="comment">// add code here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Derived <span class="keyword">for</span> T&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Base <span class="keyword">for</span> T&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实trait Derived:Base{}等同于trait Derived where Slef:Base{}</p>
<p><br></p>
<h2 id="Derive"><a href="#Derive" class="headerlink" title="Derive"></a>Derive</h2><p>Rust里面为类型impl某些trait的时候,逻辑是非常机械化的<br>许多类型重复而单调地impl某些trait是非常鼓噪地<br>为此Rust提供了特殊的attribute,自动impl某些trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy,Clone,Default, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">	data: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> v1 = Foo&#123;data:<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">let</span> v2 = v1;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的语法是在你希望impl trait类型前面写#[derive(…)], 括号里面是你希望impl地trait地名字<br>这样写了之后,编译器就帮你自动加上impl块,类似如下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="built_in">Copy</span> <span class="keyword">for</span> Foo&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Clone</span> <span class="keyword">for</span> Foo&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Debug</span> <span class="keyword">for</span> Foo&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Default</span> <span class="keyword">for</span> Foo&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> Hash <span class="keyword">for</span> Foo&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">PartialEq</span> <span class="keyword">for</span> Foo&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这些都是特殊地trait,帮我们自动实现默认的逻辑</p>
<p><br></p>
<h2 id="trait别名"><a href="#trait别名" class="headerlink" title="trait别名"></a>trait别名</h2><p>跟type alias类似,trait也可以起别名 trait alias</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Service</span></span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Request</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Response</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Error</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Future</span></span>:Future&lt;Item=Slef::Response, Error=Self::Error&gt;;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>, req:Self::Request) -&gt; Self::Future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HttpService</span></span> = Service&lt;Request=http::Request,</span><br><span class="line">	Response=http::Response,</span><br><span class="line">	Error=http::Error&gt;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>trait本身可以携带泛型参数；</li>
<li>trait可以用在泛型参数的约束中；</li>
<li>trait可以为一组类型impl，也可以单独为某一个具体类型impl，而且它们可以同时存在；</li>
<li>trait可以为某个trait impl，而不是为某个具体类型impl；</li>
<li>trait可以包含关联类型，而且还可以包含类型构造器，实现高阶类型的某些功能；</li>
<li>trait可以实现泛型代码的静态分派，也可以通过trait object实现动态分派；</li>
<li>trait可以不包含任何方法，用于给类型做标签（marker），以此来描述类型的一些重要特性；</li>
<li>trait可以包含常量。</li>
</ul>
<p><br><br><br></p>
<h1 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一个容器，它在一块连续空间内存中，存储了一系列的同样类型的数据。<br>数组中元素的占用空间大小必须是编译期确定的。数组本身所容纳的元素个数也必须是编译期确定的，执行阶段不可变。<br>如果需要使用变长的容器，可以使用标准库中的Vec/LinkedList等</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定长数组</span></span><br><span class="line"><span class="keyword">let</span> xs:[<span class="built_in">i32</span>, <span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 所有元素,如果初始化为同样数据,可以使用如下语法</span></span><br><span class="line"><span class="keyword">let</span> ys:[<span class="built_in">i32</span>, <span class="number">500</span>] = [<span class="number">0</span>;<span class="number">500</span>];</span><br></pre></td></tr></table></figure>
<p>在Rust中，对于两个数组类型，只有元素类型和元素个数都完全相同，这两个数组才是同类型的。<br>数组与指针之间不能隐式转换。同类型的数组之间可以互相赋值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> xs:[<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> ys:[<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line">xs = ys;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"arry &#123;:?&#125;"</span>, xs);</span><br></pre></td></tr></table></figure>
<p>把数组xs作为参数传给一个函数，这个数组并不会退化成一个指针。<br>而是会将这个数组完整复制进这个函数。<br>函数体内对数组的改动不会影响到外面的数组。</p>
<p>对数组内部元素的访问，可以使用中括号索引的方式</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> xs:[<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> ys:[<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line">xs = ys;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"arry &#123;:?&#125;"</span>, xs);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"index item:&#123;:?&#125;"</span>, xs[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h3><blockquote>
<p>比较</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">let</span> v2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>];</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, v1 &lt; v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以对数组执行遍历操作</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v1 = [<span class="number">0_i32</span>; <span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> &amp;v1&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>既然[T; n]是一个合法的类型，那么它的元素T当然也可以是数组类型，因此[[T; m]; n]类型自然也是合法类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v :[[<span class="built_in">i32</span>; <span class="number">2</span>]; <span class="number">3</span>] = [[<span class="number">0</span>,<span class="number">1</span>], [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>]];</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h3><p>对数组取借用borrow操作，可以生成一个“数组切片”（Slice）。<br>数组切片对数组没有“所有权”，我们可以把数组切片看作专门用于指向数组的指针，是对数组的另外一个“视图”。<br>比如我们有一个数组[T; n]，它的借用指针的类型就是&amp;[T; n]。<br>它可以通过编译器内部魔法转换为数组切片类型&amp;[T]。<br>数组切片实质上还是指针，它不过是在类型系统中丢弃了编译阶段定长数组类型的长度信息，而将此长度信息存储为运行期的值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">mut_array</span></span>(a: &amp;<span class="keyword">mut</span>[<span class="built_in">i32</span>])&#123;</span><br><span class="line">		a[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"size of &#123;:?&#125;"</span>, std::mem::size_of::&lt;&amp;[<span class="built_in">i32</span>;<span class="number">3</span>]&gt;());</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"size of &#123;:?&#125;"</span>, std::mem::size_of::&lt;&amp;[<span class="built_in">i32</span>]&gt;());</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> v:[<span class="built_in">i32</span>;<span class="number">3</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">let</span> s:&amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>;<span class="number">3</span>] = &amp;<span class="keyword">mut</span> v;</span><br><span class="line">		mut_array(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, v);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量v是[i32; 3]类型；变量s是&amp;mut [i32; 3]类型，占用的空间大小与指针相同。它可以自动转换为&amp;mut [i32]数组切片类型传入函数mut_array，占用的空间大小等于两个指针的空间大小。<br>通过这个指针，在函数内部，修改了外部的数组v的值。</p>
<h3 id="DST和胖指针"><a href="#DST和胖指针" class="headerlink" title="DST和胖指针"></a>DST和胖指针</h3><p>Slice与普通的指针是不同的，它有一个非常形象的名字：胖指针（fat pointer）。<br>与这个概念相对应的概念是“动态大小类型”（Dynamic Sized Type, DST）。<br>所谓的DST指的是编译阶段无法确定占用空间大小的类型。为了安全性，指向DST的指针一般是胖指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于不定长数组类型[T]，有对应的胖指针&amp;[T]类型；</span><br><span class="line">对于不定长字符串str类型，有对应的胖指针&amp;str类型；以及在后文中会出现的Trait Object;等等。</span><br></pre></td></tr></table></figure>
<p>由于不定长数组类型[T]在编译阶段是无法判断该类型占用空间的大小的，目前我们不能在栈上声明一个不定长大小数组的变量实例，也不能用它作为函数的参数、返回值。<br>但是指向不定长数组的胖指针的大小是确定的，&amp;[T]类型可以用做变量实例、函数参数、返回值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">raw_slice</span></span>(arr:&amp;[<span class="built_in">i32</span>])&#123;</span><br><span class="line">	<span class="keyword">unsafe</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> (val1, val2): (<span class="built_in">usize</span>, <span class="built_in">usize</span>) = std::mem::transmute(arr);</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"val1:&#123;:x&#125;"</span>, val1);</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"val2:&#123;:x&#125;"</span>, val2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> arr:[<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">let</span> address :&amp;[<span class="built_in">i32</span>;<span class="number">5</span>] = &amp;arr;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"arr:&#123;:p&#125;"</span>, address);</span><br><span class="line">	raw_slice(address <span class="keyword">as</span> &amp;[<span class="built_in">i32</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们arr是长度为5的i32类型的数组。address是一个普通的指向arr的借用指针。<br>我们可以用as关键字把address转换为一个胖指针&amp;[i32]，并传递给raw_slice函数。<br>在raw_slice函数内部，我们利用了unsafe的transmute函数。<br>我们可以把它看作一个强制类型转换，类似reinterpret_cast，通过这个函数，我们把胖指针的内部数据转换成了两个usize大小的整数来看待</p>
<p>对于DST类型，Rust有如下限制：</p>
<ul>
<li>只能通过指针来间接创建和操作DST类型，&amp;[T] Box&lt;[T]&gt;可以，[T]不可以；</li>
<li>局部变量和函数参数的类型不能是DST类型，因为局部变量和函数参数必须在编译阶段知道它的大小因为目前unsized rvalue功能还没有实现；</li>
<li>enum中不能包含DST类型，struct中只有最后一个元素可以是DST，其他地方不行，如果包含有DST类型，那么这个结构体也就成了DST类型。</li>
</ul>
<p>Rust设计出DST类型，使得类型暂时系统更完善，也有助于消除一些C/C++中容易出现的bug。这一设计的好处有：</p>
<ul>
<li>首先，DST类型虽然有一些限制条件，但我们依然可以把它当成合法的类型看待，比如，可以为这样的类型实现trait、添加方法、用在泛型参数中等；</li>
<li>胖指针的设计，避免了数组类型作为参数传递时自动退化为裸指针类型，丢失了长度信息的问题，保证了类型安全；</li>
<li>这一设计依然保持了与“所有权”“生命周期”等概念相容的特点。</li>
</ul>
<p>数组切片不只是提供了“数组到指针”的安全转换，配合上Range功能，它还能提供数组的局部切片功能。</p>
<p><br></p>
<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>Rust中的Range代表一个“区间”，一个“范围”，它有内置的语法支持，就是两个小数点..</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> r = <span class="number">1</span>..<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> r &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;\t"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是在begin..end这个语法中，前面是闭区间，后面是开区间。<br>这个语法实际上生成的是一个<code>std::ops::Range&lt;_&gt;</code>类型的变量</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Range;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> r = Range&#123;start:<span class="number">1</span>, end:<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> r &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类型本身实现了Iterator trait，因此它可以直接应用到循环语句中。<br>Range具有迭代器的全部功能，因此它能调用迭代器的成员方法。<br>比如我们要实现从100递减到10，中间间隔为10的序列，可以这么做</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">use</span> std::iter::<span class="built_in">Iterator</span>;</span><br><span class="line">	<span class="keyword">let</span> r = (<span class="number">1i32</span>..<span class="number">11</span>).rev().map(|i|i * <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> r&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;\t"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Rust中，还有其他的几种Range，包括</p>
<ul>
<li>std::ops::RangeFrom代表只有起始没有结束的范围，语法为start..，含义是[start, +∞)；</li>
<li>std::ops::RangeTo代表没有起始只有结束的范围，语法为．.end，对有符号数的含义是(-∞,end)，对无符号数的含义是[0, end)；</li>
<li>std::ops::RangeFull代表没有上下限制的范围，语法为．.，对有符号数的含义是(-∞, +∞)，对无符号数的含义是[0, +∞)。</li>
</ul>
<p>数组和Range之间最常用的配合就是使用Range进行索引操作</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_slice</span></span>(arr:&amp;[<span class="built_in">i32</span>])&#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"Length:&#123;&#125;"</span>, arr.len());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> item <span class="keyword">in</span> arr &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;&#125;\t"</span>, item);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> arr:[<span class="built_in">i32</span>;<span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">	print_slice(&amp;arr[..]);	<span class="comment">//Full Range</span></span><br><span class="line">	<span class="keyword">let</span> slice = &amp;arr[<span class="number">2</span>..];	<span class="comment">//RangeFrom</span></span><br><span class="line">	print_slice(slice);</span><br><span class="line">	<span class="keyword">let</span> slice2 = &amp;slice[..<span class="number">2</span>];<span class="comment">//RangeTo</span></span><br><span class="line">	print_slice(slice2);</span><br><span class="line">	print_slice(&amp;arr[<span class="number">2</span>..<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="边界检查"><a href="#边界检查" class="headerlink" title="边界检查"></a>边界检查</h3><p>我们的“索引”都是一个合法的值，没有超过数组的长度。<br>如果我们给“索引”一个非法的值会怎样呢?</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v= [<span class="number">10i32</span>, <span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">let</span> index:<span class="built_in">usize</span> = std::env::args().nth(<span class="number">1</span>).map(|x|x.parse().unwrap_or(<span class="number">0</span>)).unwrap_or(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, v[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行thread ‘main’ panicked at ‘index out of bounds : the len is 5 but the index is 10’。<br>可以看出如果用/test 10，则会出现数组越界，Rust目前还无法任意索引执行编译阶段边界检查，但是在运行阶段执行了边界检查。</p>
<p>在Rust中，“索引”操作也是一个通用的运算符，是可以自行扩展的。<br>如果希望某个类型可以执行“索引”读操作，就需要该类型实现std::ops::Index trait<br>如果希望某个类型可以执行“索引”写操作，就需要该类型实现std::ops::IndexMut trait。</p>
<p>为了防止索引操作导致程序崩溃，如果我们不确定使用的“索引”是否合法，应该使用get()方法调用来获取数组中的元素，这个方法不会引起panic!，它的返回类型是Option<t></t></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v= [<span class="number">10i32</span>, <span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">let</span> first = v.get(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">let</span> tenth = v.get(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125; &#123;:?&#125;"</span>, first, tenth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：“Some（10）None”</p>
<p>对于明显的数组越界行为，在Rust中可以通过lint检查来发现。大家可以参考“clippy”这个项目，它可以检查出这种明显的常量索引越界的现象。<br>总体来说，在Rust里面，靠编译阶段静态检查是无法消除数组越界的行为的。</p>
<p><br><br><br></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Rust的字符串涉及两种类型，一种是&amp;str，另外一种是String。</p>
<h3 id="amp-str"><a href="#amp-str" class="headerlink" title="&amp;str"></a>&amp;str</h3><p>str是Rust的内置类型。<br>&amp;str是对str的借用。Rust的字符串内部默认是使用utf-8编码格式的。<br>而内置的char类型是4字节长度的，存储的内容是Unicode Scalar Value。<br>所以Rust里面的字符串不能视为char类型的数组，而更接近u8类型的数组。<br>实际上str类型有一种方法：<code>fn as_ptr(&amp;self) -&gt; ＊const u8</code>。它内部无须做任何计算，只需做一个强制类型转换即可</p>
<p>这样设计有一个缺点，就是不能支持O(1)时间复杂度的索引操作。如果我们要找一个字符串s内部的第n个字符，不能直接通过s[n]得到，这一点跟其他许多语言不一样。<br>在Rust中，这样的需求可以通过下面的语句实现：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.chars().nth(n)</span><br></pre></td></tr></table></figure></p>
<p>它的时间复杂度是O(n)，因为utf-8是变长编码，如果我们不从头开始过一遍，根本不知道第n个字符的地址在什么地方。<br>但是综合来看，选择utf-8作为内部默认编码格式是缺陷最少的一种方式了。</p>
<p>相比其他的编码格式，它有相当多的优点。比如：它是大小端无关的，它跟ASCII码兼容，它是互联网上的首选编码等等。</p>
<blockquote>
<p>[T]是DST类型，对应的str是DST类型。<br>&amp;[T]是数组切片类型，对应的&amp;str是字符串切片类型。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> greeting : &amp;<span class="built_in">str</span> = <span class="string">"hello"</span>;</span><br><span class="line">	<span class="keyword">let</span> substr : &amp;<span class="built_in">str</span> = &amp;greeting[<span class="number">2</span>..];</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, substr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&amp;str类型也是一个胖指针</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, std::mem::size_of::&lt;*<span class="keyword">const</span>()&gt;());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, std::mem::size_of::&lt;&amp;<span class="built_in">str</span>&gt;());</span><br></pre></td></tr></table></figure>
<p>它内部实际上包含了一个指向字符串片段头部的指针和一个长度。<br>所以它跟C/C++的字符串不同：C/C++里面的字符串以’\0’结尾，而Rust的字符串是可以中间包含’\0’字符的。</p>
<p><br></p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>它跟&amp;str类型的主要区别是，它有管理内存空间的权力。关于“所有权”和“借用”的关系<br>&amp;str类型是对一块字符串区间的借用，它对所指向的内存空间没有所有权，哪怕&amp;mut str也一样</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"Hello"</span>);</span><br><span class="line">	s.push(<span class="string">' '</span>);</span><br><span class="line">	s.push_str(<span class="string">"world."</span>);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String可以后面追加内容,这是因为String类型在堆上动态申请了一块内存空间，它有权对这块内存空间进行扩容，内部实现类似于std::Vec<u8>类型。<br>所以我们可以把这个类型作为容纳字符串的容器使用。</u8></p>
<p><br><br><br></p>
<h1 id="容器与迭代器"><a href="#容器与迭代器" class="headerlink" title="容器与迭代器"></a>容器与迭代器</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p><img src="/2022/07/09/rust/image-01.png" width="700px"></p>
<h3 id="Vec"><a href="#Vec" class="headerlink" title="Vec"></a>Vec</h3><p>Vec是最常用的一个容器，对应C++里面的vector。<br>它就是一个可以自动扩展容量的动态数组。<br>它重载了Index运算符，可以通过中括号取下标的形式访问内部成员。<br>它还重载了Deref / DerefMut运算符，因此可以自动被解引用为数组切片</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v1 = <span class="built_in">Vec</span>::&lt;<span class="built_in">i32</span>&gt;::new();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> v2:<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::with_capacity(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> v3 = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> v4 = <span class="built_in">Vec</span>::new();</span><br><span class="line">	v4.push(<span class="number">1</span>);</span><br><span class="line">	v4.extend_from_slice(&amp;[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>]);</span><br><span class="line">	v4.insert(<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"capacity:&#123;&#125;, length:&#123;&#125;"</span>, v4.capacity(), v4.len());</span><br><span class="line"></span><br><span class="line">	v4[<span class="number">5</span>] = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">let</span> i = v4[<span class="number">5</span>];</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">	<span class="comment">// index运算符直接访问,如果越界会造成panic,而get方法不会,因为它返回一个Optional&lt;T&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(i) = v4.get(<span class="number">6</span>)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// index运算符支持使用各种Range作为索引</span></span><br><span class="line">	<span class="keyword">let</span> slice = &amp;v4[<span class="number">4</span>..];</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, slice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个Vec中能存储的元素个数最多为std::usize::MAX个，超过了会发生panic。<br>因为它记录元素个数，用的就是usize类型。<br>如果我们指定元素的类型是0大小的类型，那么这个Vec根本不需要在堆上分配任何空间。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">Vec</span>::&lt;ZeroSized&gt;::new();</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"capacity:&#123;&#125; length:&#123;&#125;"</span>, v.capacity(), v.len());</span><br><span class="line"></span><br><span class="line">	v.push(ZeroSized&#123;&#125;);</span><br><span class="line">	v.push(ZeroSized&#123;&#125;);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"capacity:&#123;&#125; length:&#123;&#125;"</span>, v.capacity(), v.len());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// p永远指向align_of::&lt;ZeroSized&gt;(),不需要调用allocator</span></span><br><span class="line">	<span class="keyword">let</span> p = v.as_ptr();</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"ptr:&#123;:p&#125;"</span>, p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> size1 = std::mem::size_of::&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt;();</span><br><span class="line">	<span class="keyword">let</span> size2 = std::mem::size_of::&lt;<span class="built_in">Option</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt;&gt;();</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"size of Vec:&#123;&#125;, size of option vec:&#123;&#125;"</span>, size1, size2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">λ .\hello_world.exe</span><br><span class="line">capacity:<span class="number">18446744073709551615</span> length:<span class="number">0</span></span><br><span class="line">capacity:<span class="number">18446744073709551615</span> length:<span class="number">2</span></span><br><span class="line">ptr:<span class="number">0x1</span></span><br><span class="line">size of <span class="built_in">Vec</span>:<span class="number">24</span>, size of option vec:<span class="number">24</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="VecDeque"><a href="#VecDeque" class="headerlink" title="VecDeque"></a>VecDeque</h3><p>VecDeque是一个双向队列。在它的头部或者尾部执行添加或者删除操作，都是效率很高的。<br>它的用法和Vec非常相似，主要是多了pop_front() push_front()等方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> queue = VecDeque::with_capacity(<span class="number">64</span>);</span><br><span class="line">	<span class="comment">// 向尾部按顺序插入一堆数据</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>&#123;</span><br><span class="line">		queue.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从头部按顺序一个个取出来</span></span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(i) = queue.pop_front() &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">λ .\hello_world.exe</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap&lt;K, V, S&gt;是基于hash算法的存储一组键值对（key-value-pair）的容器。<br>其中泛型参数K是键的类型，V是值的类型，S是哈希算法的类型。</p>
<p>hash算法的关键是，将记录的存储地址和key之间建立一个确定的对应关系。<br>这样当想查找某条记录时，我们根据记录的key，通过一次函数计算，就可以得到它的存储地址，进而快速判断这条记录是否存在、存储在哪里。</p>
<p>因此Rust的HashMap要求，key要满足Eq + Hash的约束。<br>Eq trait代表这个类型可以作相等比较，并且一定满足下列三个性质：</p>
<ul>
<li>自反性——对任意a，满足a == a；</li>
<li>对称性——如果a == b成立，则b == a成立；</li>
<li>传递性——如果a == b且b == c成立，则a == c成立。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Hash</span></span>&#123;</span><br><span class="line">	fh hash&lt;H:Haser&gt;(&amp;<span class="keyword">self</span>, state:&amp;<span class="keyword">mut</span> H);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Haser</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">finish</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u64</span>;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, bytes:&amp;[<span class="built_in">u8</span>]);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器提供derive帮助实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Hash)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	first_name: <span class="built_in">String</span>,</span><br><span class="line">	last_name: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>完整使用hashMap示例</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> book = HashMap::new();</span><br><span class="line">	book.insert(Person::new(<span class="string">"John"</span>, <span class="string">"Smith"</span>), <span class="string">"521-8976"</span>);</span><br><span class="line">	book.insert(Person::new(<span class="string">"Sandra"</span>, <span class="string">"Dee"</span>), <span class="string">"521-8976"</span>);</span><br><span class="line">	book.insert(Person::new(<span class="string">"Ted"</span>, <span class="string">"Baker"</span>), <span class="string">"521-8976"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> p = Person::new(<span class="string">"John"</span>, <span class="string">"Smith"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找键对应的值</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(phone) = book.get(&amp;p)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"Phone number found:&#123;&#125;"</span>, phone);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除</span></span><br><span class="line">	book.remove(&amp;p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查询是否存在</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"Find key:&#123;&#125;"</span>, book.contains_key(&amp;p));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找并插入</span></span><br><span class="line">	<span class="keyword">if</span> map.contains_key(key)&#123;</span><br><span class="line">		map.insert(key, value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更方便的查找并插入</span></span><br><span class="line">	map.entry(key).or_insert(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">λ .\hello_world.exe</span><br><span class="line">Phone number found:<span class="number">521</span>-<span class="number">8976</span></span><br><span class="line">Find key:<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="BTreeMap"><a href="#BTreeMap" class="headerlink" title="BTreeMap"></a>BTreeMap</h3><p>BTreeMap&lt;K, V&gt;是基于B树数据结构的存储一组键值对（key-value-pair）的容器。<br>它跟HashMap的用途相似，但是内部存储的机制不同。<br>B树的每个节点包含多个连续存储的元素，以及多个子节点。</p>
<p><img src="/2022/07/09/rust/image-02.png" width="500px"></p>
<p>BTreeMap对key的要求是满足Ord约束，即具备“全序”特征。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BTreeMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Ord,PartialOrd, Eq, PartialEq, Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	first_name:<span class="built_in">String</span>,</span><br><span class="line">	last_name:<span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Person&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(first:&amp;<span class="built_in">str</span>, last:&amp;<span class="built_in">str</span>) -&gt;<span class="keyword">Self</span>&#123;</span><br><span class="line">		Person&#123;</span><br><span class="line">			first_name: first.to_string(),</span><br><span class="line">			last_name: last.to_string(),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> book = BTreeMap::new();</span><br><span class="line">	book.insert(Person::new(<span class="string">"John"</span>, <span class="string">"Smith"</span>), <span class="string">"521-8976"</span>);</span><br><span class="line">	book.insert(Person::new(<span class="string">"Sandra"</span>, <span class="string">"Dee"</span>), <span class="string">"521-8976"</span>);</span><br><span class="line">	book.insert(Person::new(<span class="string">"Ted"</span>, <span class="string">"Baker"</span>), <span class="string">"521-8976"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> p = Person::new(<span class="string">"John"</span>, <span class="string">"Smith"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找键对应的值</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(phone) = book.get(&amp;p)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"Phone number found:&#123;&#125;"</span>, phone);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除</span></span><br><span class="line">	book.remove(&amp;p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查询是否存在</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"Find key:&#123;&#125;"</span>, book.contains_key(&amp;p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">λ .\hello_world.exe</span><br><span class="line">Phone number found:<span class="number">521</span>-<span class="number">8976</span></span><br><span class="line">Find key:<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>BTreeMap比HashMap多的一项功能是，它不仅可以查询单个key的结果，还可以查询一个区间的结果</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BTreeMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> map = BTreeMap::new();</span><br><span class="line">	map.insert(<span class="number">3</span>, <span class="string">"a"</span>);</span><br><span class="line">	map.insert(<span class="number">5</span>, <span class="string">"b"</span>);</span><br><span class="line">	map.insert(<span class="number">8</span>, <span class="string">"c"</span>);</span><br><span class="line">	<span class="keyword">for</span> (k,v) <span class="keyword">in</span> map.range(<span class="number">2</span>..<span class="number">6</span>)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;&#125; : &#123;&#125;"</span>, k, v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Itertor</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它最主要的一个方法就是next()，返回一个Option<item>。<br>一般情况返回Some(Item)；如果迭代完成，就返回None。</item></p>
<h3 id="实现迭代器"><a href="#实现迭代器" class="headerlink" title="实现迭代器"></a>实现迭代器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::iter::<span class="built_in">Iterator</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seq</span></span> &#123;</span><br><span class="line">	current: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Seq&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span>&#123;</span><br><span class="line">		Seq &#123; current:<span class="number">0</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Iterator</span> <span class="keyword">for</span> Seq&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = <span class="built_in">i32</span>;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;&#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">self</span>.current &lt; <span class="number">100</span>&#123;</span><br><span class="line">			<span class="keyword">self</span>.current += <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">Some</span>(<span class="keyword">self</span>.current);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> seq = Seq::new();</span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(i) = seq.next() &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="迭代器的组合"><a href="#迭代器的组合" class="headerlink" title="迭代器的组合"></a>迭代器的组合</h3><p>Rust标准库有一个命名规范，从容器创造出迭代器一般有三种方法</p>
<ul>
<li>iter()创造一个Item是&amp;T类型的迭代器;</li>
<li>iter_mut()创造一个Item是&amp;mut T类型的迭代器;</li>
<li>into_iter()创造一个Item是T类型的迭代器。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> iter = v.iter();</span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(i) = iter.next() &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust的迭代器有一个重要特点，那它就是可组合的(composability)</p>
<p>Iterator trait里面还有一大堆的方法，比如nth、map、filter、skip_while、take等等，这些方法都有默认实现，它们可以统称为adapters(适配器)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> iter = v.iter()</span><br><span class="line">		.take(<span class="number">5</span>)</span><br><span class="line">		.filter(|&amp;x| x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		.map(|&amp;x| x*x)</span><br><span class="line">		.enumerate();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>((i,v)) = iter.next() &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>, i, v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">λ .\hello_world.exe</span><br><span class="line"><span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>之前都是手工直接调用迭代器的next()方法，然后使用while let语法来做循环。<br>实际上Rust里面更简洁、更自然地使用迭代器的方式是使用for循环</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> v &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> map:HashMap&lt;<span class="built_in">i32</span>, <span class="built_in">char</span>&gt; = [(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>)].iter().cloned().collect();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">λ .\hello_world.exe</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>Rust的<code>for &lt;item&gt; in &lt;container&gt; { &lt;body&gt; }</code>语法结构就是一个语法糖。<br>这个语法的原理其实就是调用<code>&lt;container&gt;.into_iter()</code>方法来获得迭代器，然后不断循环调用迭代器的next()方法，将返回值解包，赋值给<item>，然后调用<body>语句块。</body></item></p>
<p>只要某个类型实现了IntoIterator，那么调用into_iter()方法就可以得到对应的迭代器。<br>这个into_iter()方法的receiver是self，而不是&amp;self，执行的是move语义。<br>这么做可以同时支持Item类型为T、&amp;T或者&amp;mut T，用户有选择的权力。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">IntoIterator</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">IntoIter</span></span>:<span class="built_in">Iterator</span>&lt;Item=Self::Item&gt;;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">into_iter</span></span>(<span class="keyword">self</span>) -&gt; Self::IntoIter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个容器类型，标准库里面对它impl了三次IntoIterator。</p>
<ul>
<li>当Self类型为BTreeMap的时候，Item类型为(K, V)，这意味着，每次next()方法都是把内部的元素move出来了;</li>
<li>当Self类型为&amp;BTreeMap的时候，Item类型为(&amp;K, &amp;V)，每次next()方法返回的是借用;</li>
<li>当Self类型为&amp;mut BTreeMap的时候，Item类型为(&amp;K,&amp;mut V)，每次next()方法返回的key是只读的，value是可读写的。</li>
</ul>
<p>所以如果有个变量m，其类型为BTreeMap，那么用户可以选择使用m.into_iter()或者(&amp;m).into_iter()或者(&amp;mut m).into_iter()，分别达到不同的目的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// container在循环之后生命周期就结束了，循环过程中的每个item是从container中move出来的</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> container &#123;&#125;</span><br><span class="line"><span class="comment">//迭代器中只包含container的&amp;型引用，循环过程中的每个item都是container中元素的借用</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> &amp;container &#123;&#125;</span><br><span class="line"><span class="comment">//迭代器中包含container的&amp;mut型引用，循环过程中的每个item都是指向container中元素的可变借用</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> &amp;<span class="keyword">mut</span> container &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>在Rust里面，协程（Coroutine）是编写高性能异步程序的关键设施，生成器（Generator）是协程的基础。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>生成器的语法很像前面讲过的闭包，但它与闭包有一个区别，即yield关键字。<br>当闭包中有yield关键字的时候，它就不是一个闭包，而是一个生成器。</p>
<p><br><br><br></p>
<h1 id="项目和模块"><a href="#项目和模块" class="headerlink" title="项目和模块"></a>项目和模块</h1><p>Rust用了两个概念来管理项目:一个是crate，一个是mod</p>
<ul>
<li>crate简单理解就是一个项目。crate是Rust中的独立编译单元。每个crate对应生成一个库或者可执行文件（如lib .dll .so .exe等）。<br>  官方有一个crate仓库<a href="https://crates.io/，可以供用户发布各种各样的库，用户也可以直接使用这里面的开源库。" target="_blank" rel="noopener">https://crates.io/，可以供用户发布各种各样的库，用户也可以直接使用这里面的开源库。</a></li>
<li>mod简单理解就是命名空间。mod可以嵌套，还可以控制内部元素的可见性。</li>
</ul>
<p>crate和mod有一个重要区别是：crate之间不能出现循环引用；而mod是无所谓的，mod1要使用mod2的内容，同时mod2要使用mod1的内容，是完全没问题的。</p>
<p>在Rust里面，crate才是一个完整的编译单元（compile unit）。<br>也就是说rustc编译器必须把整个crate的内容全部读进去才能执行编译，rustc不是基于单个的．rs文件或者mod来执行编译的。<br>作为对比C/C++里面的编译单元是单独的．c/.cpp文件以及它们所有的include文件。<br>每个．c/. cpp文件都是单独编译，生成．o文件，再把这些．o文件链接起来。</p>
<h2 id="cargo"><a href="#cargo" class="headerlink" title="cargo"></a>cargo</h2><p>Cargo是Rust的包管理工具，是随着编译器一起发布的。<br>在使用rustup安装了官方发布的Rust开发套装之后，Cargo工具就已经安装好了，无须单独安装。<br>我们可以使用cargo命令来查看它的基本用法。<br>Cargo的官方使用文档在这个地址：<a href="https://doc.rust-lang.org/cargo/。" target="_blank" rel="noopener">https://doc.rust-lang.org/cargo/。</a></p>
<p>Cargo可以用于创建和管理项目、编译、执行、测试、管理外部下载的包和可执行文件等。<br>我们创建一个新的工程，这个工程会生成一个可执行程序。</p>
<blockquote>
<p>步骤如下。</p>
</blockquote>
<ul>
<li><p>进入项目文件夹后，使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello_world --bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用tree,查看到当前文件夹结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---hello_world</span><br><span class="line">	-- cargo.toml</span><br><span class="line">	-- src</span><br><span class="line">		-- main.rs</span><br></pre></td></tr></table></figure>
</li>
<li><p>hello_world文件夹内,使用cargo build命令编译项目<br>生成的可执行文件在./target/debug/文件夹内; 使用cargo build –release命令,则可以生成release版的可执行文件,比debug优化更好</p>
</li>
<li><p>使用./target/debug/hello_world命令,或者cargo run命令,可以执行我们刚生成的这个可执行程序</p>
</li>
</ul>
<p>进入hello_world的上一层文件夹，新建一个library项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new good_bye</span><br></pre></td></tr></table></figure></p>
<p>lib.rs文件是库项目的入口，打开这个文件，写入以下代码<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">say</span></span>()&#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"good bye"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用cargo build，编译通过。现在我们希望hello_world项目能引用good_bye项目。<br>打开hello_world项目的Cargo.toml文件，在依赖项下面添加对good_bye的引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">good_bye = &#123;path = <span class="string">"../good_bye"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这个写法是引用本地路径中的库。<br>如果要引用官方仓库中的库更简单</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">lazy_static = <span class="string">"1.0.0"</span></span><br></pre></td></tr></table></figure>
<p>现在在应用程序中调用这个库。打开main.rs源文件，修改代码为<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> create good_bye;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"Hello world!"</span>);</span><br><span class="line">	good_bye::say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再次使用cargo run编译执行，就可以看到我们正确调用了good_bye项目中的代码。</p>
<p>cargo只是一个包管理工具，并不是编译器。Rust的编译器是rustc，使用cargo编译工程实际上最后还是调用的rustc来完成的。<br>如果我们想知道cargo在后面是如何调用rustc完成编译的，可以使用cargo build –verbose选项查看详细的编译命令。</p>
<p>我们可以用cargo -h来查看其他用法</p>
<ul>
<li>checkcheck命令可以只检查编译错误，而不做代码优化以及生成可执行程序，非常适合在开发过程中快速检查语法、类型错误。</li>
<li>clean清理以前的编译结果。</li>
<li>doc生成该项目的文档。</li>
<li>test执行单元测试。</li>
<li>bench执行benchmark性能测试。</li>
<li>update升级所有依赖项的版本，重新生成Cargo.lock文件。</li>
<li>install安装可执行程序。</li>
<li>uninstall删除可执行程序。</li>
</ul>
<p>其中cargo install是一个非常有用的命令，它可以让用户自己扩展cargo的子命令，为它增加新功能。<br>比如我们可以使用<code>cargo install cargo-tree</code>,安装一个新的cargo子命令，接下来就可以使用<code>cargo tree</code></p>
<p><br></p>
<h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>在Cargo.toml文件中，我们可以指定一个crate依赖哪些项目。<br>这些依赖既可以是来自官方的crates.io，也可以是某个git仓库地址，还可以是本地文件路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">laze_static = &quot;1.0.0&quot;</span><br><span class="line">rand = &#123;git=https://github.com/rust-lang-nursery/rand, branch=&quot;master&quot;&#125;</span><br><span class="line">my_own_project=&#123;path=&quot;/my/local/path&quot;, version=&quot;0.1.0&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>下面详细讲一下在[dependencies]里面的几种依赖项的格式</p>
<ul>
<li><p>来自crates.io的依赖<br>只需指定它的名字及版本号即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">lazy_static = &quot;1.0&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>^符号,如^1.2.3代表1.2.3&lt;=version &lt; 2.0.0;</li>
<li>~符号,如~1.2.3代表1.2.3&lt;=version &lt; 1.3.0;</li>
<li><code>*</code>符号,如<code>1.*</code>代表1.0.0 &lt;= version &lt; 2.0.0;</li>
<li>比较符号, 比如&gt;=1.2.3, &gt;1.2.3多个限制条件合起来用逗号分开</li>
</ul>
</li>
<li><p>来自git仓库的依赖<br>  除了最简单的<code>git=&quot;…&quot;</code>指定repository之外，我们还可以指定对应的分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rand = &#123;git=https://github.com/rust-lang-nursery/rand, branch=&quot;next&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>  或者指定当前的commit号</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rand = &#123;git=https://github.com/rust-lang-nursery/rand, branch=&quot;master&quot;, rev=&quot;31f2663&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>  还可以指定对应的tag名字</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rang = &#123;git=https://github.com/rust-lang-nursery/rand, tag=&quot;0.3.15&quot;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>来自本地文件路径的依赖<br>  指定本地文件路径，既可以使用绝对路径也可以使用相对路径。</p>
</li>
</ul>
<p>当我们使用cargo build编译完项目后，项目文件夹内会产生一个新文件，名字叫Cargo.lock。<br>它实际上是一个纯文本文件，同样也是toml格式。它里面记录了当前项目所有依赖项目的具体版本。<br>每次编译项目的时候，如果该文件存在，cargo就会使用这个文件中记录的版本号编译项目；<br>如果该文件不存在，cargo就会使用Cargo.toml文件中记录的依赖项目信息，自动选择最合适的版本。</p>
<p>对于依赖项，我们不仅要在Cargo.toml文件中写出来，还要在源代码中写出来。<br>目前版本中，必须在crate的入口处（对库项目就是lib.rs文件，对可执行程序项目就是main.rs文件）写上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern crate hello;			// 声明外部依赖</span><br><span class="line">extern crate hello as hi;	// 可以重命名</span><br></pre></td></tr></table></figure></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>cargo也支持配置文件。<br>配置文件可以定制cargo的许多行为，就像我们给git设置配置文件一样。<br>类似的cargo的配置文件可以存在多份，它们之间有优先级关系。</p>
<p>你可以为某个文件夹单独提供一份配置文件，放置到当前文件夹的．cargo/config位置<br>也可以提供一个全局的默认配置，放在$HOME/.cargo/config位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[cargo-new]</span><br><span class="line">//可以配置默认的名字和email,这些会出现在新项目的Cargo.toml中</span><br><span class="line">name = &quot;...&quot;</span><br><span class="line">email = &quot;...&quot;</span><br><span class="line">[build]</span><br><span class="line">jobs = 1</span><br><span class="line">rustflags = [&quot;..&quot;, &quot;..&quot;]</span><br><span class="line">[term]</span><br><span class="line">verbose=false</span><br><span class="line">color=&quot;auto&quot;</span><br><span class="line">[alias]</span><br><span class="line">b=&quot;build&quot;</span><br><span class="line">t=&quot;test&quot;</span><br><span class="line">r=&quot;run&quot;</span><br><span class="line">rr=&quot;run --release&quot;</span><br></pre></td></tr></table></figure>
<h3 id="workspace"><a href="#workspace" class="headerlink" title="workspace"></a>workspace</h3><p>cargo的workspace概念，是为了解决多crate的互相协调问题而存在的。<br>假设现在我们有一个比较大的项目。我们把它拆分成了多个crate来组织，就会面临一个问题：不同的crate会有各自不同的Cargo.toml，编译的时候它们会各自产生不同的Cargo.lock文件，我们无法保证所有的crate对同样的依赖项使用的是同样的版本号。</p>
<p>为了让不同的crate之间能共享一些信息，cargo提供了一个workspace的概念。一个workspace可以包含多个项目；所有的项目共享一个Cargo.lock文件，共享同一个输出目录；一个workspace内的所有项目的公共依赖项都是同样的版本，输出的目标文件都在同一个文件夹内。</p>
<p>workspace同样是用Cargo.toml来管理的。我们可以把所有的项目都放到一个文件夹下面。在这个文件夹下写一个Cargo.toml来管理这里的所有项目。</p>
<p>Cargo.toml文件中要写一个[workspace]的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[workspace]</span><br><span class="line"></span><br><span class="line">members = [</span><br><span class="line">	&quot;project1&quot;, &quot;lib1&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>整个文件夹的目录结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--Cargo.lock</span><br><span class="line">--Cargo.toml</span><br><span class="line">--project1</span><br><span class="line">	--Cargo.toml</span><br><span class="line">	--src</span><br><span class="line">		--main.rs</span><br><span class="line">--lib1</span><br><span class="line">	--cargo.toml</span><br><span class="line">	--src</span><br><span class="line">		--lib.rs</span><br><span class="line">--target</span><br></pre></td></tr></table></figure></p>
<p>我们可以在workspace的根目录执行cargo build等命令。<br>请注意虽然每个crate都有自己的Cargo.toml文件，可以各自配置自己的依赖项，但是每个crate下面不再会各自生成一个Cargo.lock文件，而是统一在workspace下生成一个Cargo.lock文件。</p>
<p>如果多个crate都依赖一个外部库，那么它们必然都是依赖的同一个版本。</p>
<h3 id="build-rs"><a href="#build-rs" class="headerlink" title="build.rs"></a>build.rs</h3><p>cargo工具还允许用户在正式编译开始前执行一些自定义的逻辑。方法是在Cargo.toml中配置一个build的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[package]</span><br><span class="line"># ...</span><br><span class="line">build = &quot;build.rs&quot;</span><br></pre></td></tr></table></figure>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2022/07/09/rust/';
        this.page.title = 'Rust基础语法';
        this.page.identifier = '2022/07/09/rust/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
