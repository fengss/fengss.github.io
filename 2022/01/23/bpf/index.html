<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Linux-BPF原理 | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="Linux-bpf笔记知识详解笔记
BPF技术原理BPF 是 Linux 内核中一个非常灵活与高效的类虚拟机(virtual machine-like)组件,能够在许多内核 hook 点安全地执行字节码(bytecode )。很多内核子系统都已经使用了 BPF,例如常见的网络(networking)、跟踪( tracing)与安全(security ,例如沙盒)。eBPF 最早出现在 3.18 内核中,此后原来的 BPF 就被称为“经典”BPF(classic BPF, cBPF),cBPF 现">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java栈</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">C/C++</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Go/Rust</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">系统内核</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">威胁追踪</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">数据库</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nosql/">Nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rust/">Rust</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#BPF技术原理"><span class="toc-number">1.</span> <span class="toc-text">BPF技术原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BPF-架构"><span class="toc-number">1.1.</span> <span class="toc-text">BPF 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指令集"><span class="toc-number">1.1.1.</span> <span class="toc-text">指令集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#指令集-1"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">指令集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BPF-寄存器和调用约定"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">BPF 寄存器和调用约定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BPF-指令格式"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">BPF 指令格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#辅助函数"><span class="toc-number">1.1.2.</span> <span class="toc-text">辅助函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maps"><span class="toc-number">1.1.3.</span> <span class="toc-text">Maps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-Pinning-钉住对象"><span class="toc-number">1.1.4.</span> <span class="toc-text">Object Pinning(钉住对象)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尾调用-Tail-Calls"><span class="toc-number">1.1.5.</span> <span class="toc-text">尾调用(Tail Calls)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BPF-to-BPF-Calls"><span class="toc-number">1.1.6.</span> <span class="toc-text">BPF to BPF Calls</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JIT"><span class="toc-number">1.1.7.</span> <span class="toc-text">JIT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Offloads"><span class="toc-number">1.1.8.</span> <span class="toc-text">Offloads</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工具链"><span class="toc-number">1.2.</span> <span class="toc-text">工具链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iproute2"><span class="toc-number">1.2.1.</span> <span class="toc-text">iproute2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#加载-XDP-BPF-对象文件"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">加载 XDP BPF 对象文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#XDP-工作模式"><span class="toc-number">1.2.1.1.1.</span> <span class="toc-text">XDP 工作模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加载-tc-BPF-对象文件"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">加载 tc BPF 对象文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#用-tc-加载-BPF-程序"><span class="toc-number">1.2.1.2.1.</span> <span class="toc-text">用 tc 加载 BPF 程序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查看已经-attach-的程序"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">查看已经 attach 的程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#程序优先级-pref-和句柄-handle"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">程序优先级(pref)和句柄(handle)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用-tc-删除-BPF-程序"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">用 tc 删除 BPF 程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#offload-到网卡"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">offload 到网卡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bpftool"><span class="toc-number">1.2.2.</span> <span class="toc-text">bpftool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序类型"><span class="toc-number">1.3.</span> <span class="toc-text">程序类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XDP"><span class="toc-number">1.3.1.</span> <span class="toc-text">XDP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BPF-程序返回码"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">BPF 程序返回码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XDP-工作模式-1"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">XDP 工作模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#驱动支持"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">驱动支持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tc"><span class="toc-number">1.3.2.</span> <span class="toc-text">tc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tc和XDP的不同"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">tc和XDP的不同</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#输入上下文"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">输入上下文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hook-触发点"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">hook 触发点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#是否依赖驱动支持"><span class="toc-number">1.3.2.1.3.</span> <span class="toc-text">是否依赖驱动支持</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cls-bpf-分类器"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">cls_bpf 分类器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tc-BPF-程序返回码"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">tc BPF 程序返回码</span></a></li></ol></li></ol></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            Linux-BPF原理
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2022/01/23/bpf/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2022-01-23T03:33:42.000Z" itemprop="datePublished">2022-01-23</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Linux/">Linux</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>Linux-bpf笔记知识详解笔记<br><a id="more"></a></p>
<h1 id="BPF技术原理"><a href="#BPF技术原理" class="headerlink" title="BPF技术原理"></a>BPF技术原理</h1><p>BPF 是 Linux 内核中一个非常灵活与高效的类虚拟机(virtual machine-like)组件,能够在许多内核 hook 点安全地执行字节码(bytecode )。<br>很多内核子系统都已经使用了 BPF,例如常见的网络(networking)、跟踪( tracing)与安全(security ,例如沙盒)。<br>eBPF 最早出现在 3.18 内核中,此后原来的 BPF 就被称为<code>“经典”</code>BPF(classic BPF, cBPF),cBPF 现在基本已经过时了。<br>很多人知道 cBPF 是因为它是 tcpdump 的包过滤语言。</p>
<blockquote>
<p>Cilium 在其数据平面(datapath)中重度使用了 BPF 技术,更多信息可参考其 eBPF datapath 架构文档。<br>本文的目标是提供一份 BPF 参考指南,这份指南能帮助我们更深入地理解 BPF、BPF 网络相关的使用方式(例如用 tc 加载 BPF 程序,XDP 程序 ),以及更好地开发 Cilium 中的 BPF 模板。</p>
</blockquote>
<h2 id="BPF-架构"><a href="#BPF-架构" class="headerlink" title="BPF 架构"></a>BPF 架构</h2><blockquote>
<p>BPF 不仅仅是一个指令集,它还提供了围绕自身的一些基础设施</p>
</blockquote>
<ul>
<li>BPF map：高效的 key/value 存储</li>
<li>辅助函数(helper function)：可以更方便地利用内核功能或与内核交互</li>
<li>尾调用(tail call)：高效地调用其他 BPF 程序</li>
<li>安全加固原语(security hardening primitives)</li>
<li>用于 pin/unpin 对象(例如 map、程序)的伪文件系统(bpffs),实现持久存储</li>
<li>支持 BPF offload(例如 offload 到网卡)的基础设施</li>
</ul>
<p>LLVM 提供了一个 BPF 后端(back end),因此使用 clang 这样的工具就可以将 C 代码编译成 BPF 对象文件(object file)然后再加载到内核。<br>BPF 深度绑定 Linux 内核,可以在不牺牲原生内核性能的前提下,实现对内核的完全可编程 (full programmability)。</p>
<blockquote>
<p>另外使用了 BPF 的内核子系统也是 BPF 基础设施的一部分。本文将主要讨论 tc和 XDP 这两个子系统,二者都支持 attach(附着)BPF 程序。</p>
</blockquote>
<p>XDP BPF 程序会被 attach 到网络驱动的最早阶段(earliest networking driver stage),驱动收到包之后就会触发 BPF 程序的执行。<br>从定义上来说,这可以取得最好的包处理性能,因为这已经是软件中最早可以处理包的位置了。但也正因为 这一步的处理在网络栈中是如此之早,协议栈此时还没有从包中提取出元数据(因此 XDP BPF 程序无法利用这些元数据)。</p>
<p>tc BPF 程序在内核栈中稍后面的一些地方执行,因此它们能够访问更多的元数据和一些核心的内核功能。<br>除了 tc 和 XDP 程序之外,还有很多其他内核子系统也在使用 BPF,例如跟踪子系统( <code>kprobes</code>、<code>uprobes</code>、<code>tracepoints</code>等等)。</p>
<p><br></p>
<h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><h4 id="指令集-1"><a href="#指令集-1" class="headerlink" title="指令集"></a>指令集</h4><p>BPF 是一个通用目的 RISC 指令集,其最初的设计目标是：</p>
<ul>
<li>用 C 语言的一个子集编写程序,</li>
<li>然后用一个编译器后端(例如 LLVM)将其编译成 BPF 指令,</li>
<li>稍后内核再通过一个位于内核中的(in-kernel)即时编译器(JIT Compiler) 将 BPF 指令映射成处理器的原生指令(opcode ),以获得在内核中的最佳执行性能。</li>
</ul>
<blockquote>
<p>将这些指令下放到内核中可以带来如下好处</p>
</blockquote>
<ul>
<li>无需在内核/用户空间切换就可以实现内核的可编程。<br>  <code>例如Cilium 这种和网络相关的 BPF 程序能直接在内核中实现灵活的容器策略、负载均衡等功能,而无需将包送先 到用户空间,处理之后再送回内核。需要在 BPF 程序之间或内核/用户空间之间共享状态时,可以使用 BPF map。</code></li>
<li>可编程 datapath 具有很大的灵活性,因此程序能在编译时将不需要的特性禁用掉, 从而极大地优化程序的性能。<br>  <code>例如如果容器不需要 IPv4,那编写 BPF 程序时就可以只处理 IPv6 的情况,从而节省了快速路径(fast path)中的资源。</code></li>
<li>对于网络场景(例如 tc 和 XDP),BPF 程序可以在无需重启内核、系统服务或容器的 情况下实现原子更新,并且不会导致网络中断。另外更新 BPF map 不会导致程序状态(program state)的丢失。</li>
<li>BPF 给用户空间提供了一个稳定的 ABI,而且不依赖任何第三方内核模块。<br>  <code>BPF 是 Linux 内核的一个核心组成部分,而 Linux 已经得到了广泛的部署,因此可以保证现 有的 BPF 程序能在新的内核版本上继续运行。这种保证与系统调用(内核提供给用 户态应用的接口)是同一级别的。另外BPF 程序在不同平台上是可移植的。</code></li>
<li>BPF 程序与内核协同工作,复用已有的内核基础设施(例如驱动、netdevice、 隧道、协议栈和 socket)和工具(例如 iproute2),以及内核提供的安全保证。和内核模块不同 BPF 程序会被一个位于内核中的校验器(in-kernel verifier)进行校验, 以确保它们不会造成内核崩溃、程序永远会终止等等。<br>  <code>例如XDP 程序会复用已有的内核驱动,能够直接操作存放在 DMA 缓冲区中的数据帧,而不用像某些模型(例如 DPDK) 那样将这些数据帧甚至整个驱动暴露给用户空间。
  而且XDP 程序复用内核协议栈而不是绕过它。BPF 程序可以看做是内核设施之间的通用“胶水代码”, 基于 BPF 可以设计巧妙的程序,解决特定的问题。</code></li>
</ul>
<blockquote>
<p>BPF 程序在内核中的执行总是事件驱动的！例如</p>
</blockquote>
<ul>
<li>如果网卡的 ingress 路径上 attach 了 BPF 程序,那当网卡收到包之后就会触发这个 BPF 程序的执行。</li>
<li>在某个有 kprobe 探测点的内核地址 attach 一段 BPF 程序后,当 内核执行到这个地址时会发生陷入(trap),进而唤醒 kprobe 的回调函数,后 者又会触发 attach 的 BPF 程序的执行。</li>
</ul>
<p><br></p>
<h4 id="BPF-寄存器和调用约定"><a href="#BPF-寄存器和调用约定" class="headerlink" title="BPF 寄存器和调用约定"></a>BPF 寄存器和调用约定</h4><p>BPF 由下面几部分组成</p>
<ul>
<li>11 个 64 位寄存器(这些寄存器包含 32 位子寄存器)</li>
<li>一个程序计数器(program counter,PC)</li>
<li>一个 512 字节大小的 BPF 栈空间(从实现的层面理解为什么有 512 字节的限制, 可参考 (译) Linux Socket Filtering (LSF, aka BPF)(Kernel,2021),译注。)</li>
</ul>
<p>寄存器的名字从 r0 到 r10。<br>默认的运行模式是 64 位,32 位子寄存器只能通过特殊的 ALU(arithmetic logic unit)访问。向 32 位子寄存器写入时,会用 0 填充 到 64 位。</p>
<p>r10 是唯一的只读寄存器,其中存放的是访问 BPF 栈空间的栈帧指针(frame pointer) 地址。r0 - r9 是可以被读/写的通用目的寄存器。<br>BPF 程序可以调用核心内核(而不是内核模块)预定义的一些辅助函数。BPF 调用约定 定义如下：</p>
<ul>
<li><code>r0</code>存放被调用的辅助函数的返回值</li>
<li><code>r1</code> - <code>r5</code> 存放 BPF 调用内核辅助函数时传递的参数</li>
<li><code>r6</code> - <code>r9</code> 由被调用方(callee)保存,在函数返回之后调用方(caller)可以读取</li>
</ul>
<p>每个 BPF 程序的最大指令数限制在 4096 条以内,这意味着从设计上就可以保证每个程序都会很快结束。对于内核 5.1+,这个限制放大到了 100 万条。</p>
<p><br></p>
<h4 id="BPF-指令格式"><a href="#BPF-指令格式" class="headerlink" title="BPF 指令格式"></a>BPF 指令格式</h4><p>BPF 指令格式(instruction format)建模为两操作数指令(two operand instructions)<br>这种格式可以在 JIT 阶段将 BPF 指令映射(mapping)为原生指令。<br>指令集是固定长度的,这意味着每条指令都是 64 比特编码的。<br>目前已经实现了 87 条指令,并且在需要时可以对指令集进行进一步扩展</p>
<p><code>op:8, dst_reg:4, src_reg:4, off:16, imm:32</code></p>
<ul>
<li><code>off</code>和<code>imm</code>都是有符号类型<br>  所有的 op 指令可以分为若干类别。<br>  op 字段分为( 从 MSB 到 LSB)：code:4, source:1 和 class:3。<ul>
<li><code>class</code>是指令类型</li>
<li><code>code</code>指特定类型的指令中的某种特定操作码(operational code)</li>
<li><code>source</code>可以告诉我们源操作数(source operand)是一个寄存器还是一个立即数</li>
</ul>
</li>
<li><code>op</code>定了将要执行的操作</li>
<li><code>dst_reg</code>和<code>src_reg</code>都提供了寄存器操作数(register operands,例如 r0 - r9)的额外信息。</li>
<li><code>off</code>用于表示一个相对偏移量(offset),</li>
</ul>
<blockquote>
<p>可能的指令类别包括</p>
</blockquote>
<ul>
<li><code>BPF_LDX</code>：加载操作(load operations)</li>
<li><code>BPF_STX</code>：存储操作(store operations)</li>
<li><code>BPF_ALU</code>,<code>BPF_ALU64</code>：逻辑运算操作(ALU operations)</li>
</ul>
<p><br></p>
<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>辅助函数(Helper functions)使得 BPF 能够通过一组内核定义的函数调用(function call)来从内核中查询数据,或者将数据推送到内核。<br>不同类型的 BPF 程序能够使用的 辅助函数可能是不同的</p>
<p>所有的辅助函数都共享同一个通用的、和系统调用类似的函数签名。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u64 <span class="title">fn</span><span class="params">(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)</span></span></span><br></pre></td></tr></table></figure></p>
<p>内核将辅助函数抽象成 BPF_CALL_0() 到 BPF_CALL_5() 几个宏,形式和相应类型的系统调用类似。<br>下面的例子是从某个辅助函数中抽取出来的,可以看到它通过调用相应 map 的回调函数完成更新 map 元素的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BPF_CALL_4(bpf_map_update_elem, struct bpf_map *, <span class="built_in">map</span>, <span class="keyword">void</span> *, key,</span><br><span class="line">           <span class="keyword">void</span> *, value, u64, flags)</span><br><span class="line">&#123;</span><br><span class="line">    WARN_ON_ONCE(!rcu_read_lock_held());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="built_in">map</span>, key, value, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_func_proto</span> <span class="title">bpf_map_update_elem_proto</span> = &#123;</span></span><br><span class="line">    .func           = bpf_map_update_elem,</span><br><span class="line">    .gpl_only       = <span class="literal">false</span>,</span><br><span class="line">    .ret_type       = RET_INTEGER,</span><br><span class="line">    .arg1_type      = ARG_CONST_MAP_PTR,</span><br><span class="line">    .arg2_type      = ARG_PTR_TO_MAP_KEY,</span><br><span class="line">    .arg3_type      = ARG_PTR_TO_MAP_VALUE,</span><br><span class="line">    .arg4_type      = ARG_ANYTHING,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种方式有很多优点：虽然 cBPF 允许其加载指令(load instructions)进行 超出范围的访问(overload),以便从一个看似不可能的包偏移量(packet offset,负的)位置获取数据以唤醒多功能辅助函数,但每个 cBPF JIT 仍然需要为这个 cBPF extension 实现对应的支持。</p>
<p><br></p>
<h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><p><img src="/2022/01/23/bpf/image-58.png" width="400px"></p>
<p>map 是驻留在内核空间中的高效键值仓库(key/value store)。<br>map 中的数据可以被 BPF 程序访问,如果想在多次 BPF 程序调用(invoke)之间保存状态,可以将状态信息放到 map。<br>map 还可以从用户空间通过文件描述符访问,可以在任意 BPF 程序以及用户空间应用之间共享。</p>
<p>共享 map 的 BPF 程序不要求是相同的程序类型,例如 tracing 程序可以和网络程序共享 map。<br>单个 BPF 程序目前最多可直接访问 64 个不同 map。</p>
<p>map 的实现由核心内核(core kernel)提供。<br>有 per-CPU 及 non-per-CPU 的通用 map,这些 map 可以读/写任意数据,也有一些和辅助函数一起使用的非通用 map。</p>
<blockquote>
<p>当前可用的通用 map</p>
</blockquote>
<ul>
<li><code>BPF_MAP_TYPE_HASH</code></li>
<li><code>BPF_MAP_TYPE_ARRAY</code></li>
<li><code>BPF_MAP_TYPE_PERCPU_HASH</code></li>
<li><code>BPF_MAP_TYPE_PERCPU_ARRAY</code></li>
<li><code>BPF_MAP_TYPE_LRU_HASH</code></li>
<li><code>BPF_MAP_TYPE_LRU_PERCPU_HASH</code></li>
<li><code>BPF_MAP_TYPE_LPM_TRIE</code></li>
</ul>
<p>以上 map 都使用相同的一组 BPF 辅助函数来执行查找、更新或删除操作</p>
<blockquote>
<p>当前内核中的非通用 map</p>
</blockquote>
<ul>
<li><code>BPF_MAP_TYPE_PROG_ARRAY</code></li>
<li><code>BPF_MAP_TYPE_PERF_EVENT_ARRAY</code></li>
<li><code>BPF_MAP_TYPE_CGROUP_ARRAY</code></li>
<li><code>BPF_MAP_TYPE_STACK_TRACE</code></li>
<li><code>BPF_MAP_TYPE_ARRAY_OF_MAPS</code></li>
<li><code>BPF_MAP_TYPE_HASH_OF_MAPS</code></li>
</ul>
<p>这些类型的 map 都针对特定的问题,不适合单单通过一个 BPF 辅助函数实现,因为它们需要在各次 BPF 程序调用 (invoke)之间时保持额外的(非数据)状态。</p>
<p><br></p>
<h3 id="Object-Pinning-钉住对象"><a href="#Object-Pinning-钉住对象" class="headerlink" title="Object Pinning(钉住对象)"></a>Object Pinning(钉住对象)</h3><p><img src="/2022/01/23/bpf/image-59.png" width="400px"></p>
<p>BPF map 和程序作为内核资源只能通过文件描述符访问,其背后是内核中的匿名 inode。</p>
<blockquote>
<p>这带来了很多优点,例如：</p>
</blockquote>
<ul>
<li>用户空间应用能够使用大部分文件描述符相关的 API,</li>
<li>在 Unix socket 中传递文件描述符是透明的,等等。</li>
</ul>
<blockquote>
<p>但同时也有很多缺点：文件描述符受限于进程的生命周期,使得 map 共享之类的操作非常笨重。</p>
</blockquote>
<p>因此这给某些特定的场景带来了很多复杂性,例如 iproute2,其中的 tc 或 XDP 在准备环境、加载程序到内核之后最终会退出。在这种情况下,从用户空间也无法访问这些 map 了,而本来这些 map 其实是很有用的,例如,在 data path 的 ingress 和 egress 位置共享的 map(可以统计包数、字节数、PPS 等信息)。另外第三方应用可能希望在 BPF 程序运行时监控或更新 map。</p>
<p>为了解决这个问题,内核实现了一个最小内核空间 BPF 文件系统,BPF map 和 BPF 程序 都可以钉到(pin)这个文件系统内,这个过程称为 object pinning(钉住对象)。相应地 BPF 系统调用进行了扩展,添加了两个新命令,分别用于钉住(BPF_OBJ_PIN)一个对象和获取(BPF_OBJ_GET)一个被钉住的对象(pinned objects)。</p>
<p>例如tc 之类的工具可以利用这个基础设施在 ingress 和 egress 之间共享 map。BPF 相关的文件系统不是单例模式(singleton),它支持多挂载实例、硬链接、软连接等等。</p>
<p><br></p>
<h3 id="尾调用-Tail-Calls"><a href="#尾调用-Tail-Calls" class="headerlink" title="尾调用(Tail Calls)"></a>尾调用(Tail Calls)</h3><p>尾调用的机制是：一个 BPF 程序可以调用另一个 BPF 程序,并且调用完成后不用返回到原来的程序。<br>和普通函数调用相比,这种调用方式开销最小,因为它是用长跳转(long jump)实现的,复用了原来的栈帧 (stack frame)。</p>
<p>类型相同的 BPF 程序才可以尾调用,而且还要与 JIT 编译器相匹配, 因此一个给定的 BPF 程序要么是 JIT编译执行,要么是解释器执行(invoke interpreted programs),而不能同时使用两种方式。</p>
<blockquote>
<p>尾调用执行涉及两个步骤</p>
</blockquote>
<ul>
<li>设置一个称为“程序数组”(program array)的特殊 map(map 类型 BPF_MAP_TYPE_PROG_ARRAY ),这个 map 可以从用户空间通过 key/value 操作,</li>
<li>调用辅助函数 bpf_tail_call()。两个参数：一个对程序数组的引用(a reference to the program array),一个查询 map 所用的 key。内核将这个辅助函数调用内联( inline)到一个特殊的 BPF 指令内。目前这样的程序数组在用户空间侧是只写模式( write-only from user space side)。</li>
</ul>
<p>内核根据传入的文件描述符查找相关的 BPF 程序,自动替换给定的 map slot(槽) 处的 程序指针。如果没有找到给定的 key 对应的 value,内核会跳过(fall through)这一步 ,继续执行 bpf_tail_call() 后面的指令。<br>尾调用是一个强大的功能,例如可以通过尾调用结构化地解析网络头(network headers)。<br>cilium其实也使用到了bpf_tail_call功能比如<code>from-netdev</code>物理网卡到容器种用了<code>tail_call_dynamic</code></p>
<p><br></p>
<h3 id="BPF-to-BPF-Calls"><a href="#BPF-to-BPF-Calls" class="headerlink" title="BPF to BPF Calls"></a>BPF to BPF Calls</h3><p>除了 BPF 辅助函数和 BPF 尾调用之外,BPF 核心基础设施最近刚加入了一个新特性：BPF 到 BPF 调用(BPF to BPF calls)。<br>在这个特性引入内核之前,典型的 BPF C 程序必须 将所有需要复用的代码进行特殊处理,例如在头文件中声明为 always_inline。当 LLVM 编译和生成 BPF 对象文件时,所有这些函数将被内联,因此会在生成的对象文件中重复多次,导致代码尺寸膨胀</p>
<p>从 Linux 4.16 和 LLVM 6.0 开始,这个限制得到了解决,BPF 程序不再需要到处使用 always_inline 声明了。<br>BPF 到 BPF 调用是一个重要的性能优化,极大减小了生成的 BPF 代码大小,因此对 CPU 指令缓存(instruction cache,i-cache)更友好。</p>
<p>内核 5.9 版本之前,BPF 尾调用和 BPF-to-BPF 调用是互斥的,只能二选一。 尾调用的缺点是生成的程序镜像大、加载时间长。<br>内核 5.10 最终解决了这一问题,允许同时使用者两种调用类型,充分利用二者各自的优点。</p>
<p>但混合使用者两种调用类型是有限制的,否则会导致内核栈溢出。 来看下面的例子</p>
<p><img src="/2022/01/23/bpf/image-60.png" width="700px"></p>
<p>如上图所示,尾调用在真正跳转到目标程序(func3)之前,只会展开(unwind)它当前所处层级的栈帧(stack frame)。<br>也就是说如果尾调用是从某个子函数发起的,例如 subfunc1 –tailcall–&gt; func2,那当程序在执行 func2 时, 所有 subfunc1 之前的栈帧(在这里是 func1 的栈帧)都会出现在栈上。<br>只有当最后一个函数(这里是 func3)执行结束时,所有前面的栈帧才将被展开(unwinded),然后控制返回到 BPF 程序的调用者(BPF program caller)。</p>
<p>内核引入了额外的逻辑来检测这种混用的情况。整个调用链中,每个子程序的栈空间( stack size)不能超过 256 字节(如果校验器检测到 bpf2bpf 调用,那主函数也会被当做子函数)。<br>有了这个限制,BPF 程序调用链最多能使用 8KB 的栈空间,计算方式：256 byte/stack 乘以尾调用数量上限 33。<br>如果没有这个限制,BPF 程序将使用 512 字节栈空间,最终消耗最多 16KB 的总栈空间,在某些架构上会导致栈溢出。</p>
<p>另外需要说明,这种混合调用目前只有<code>x86-64</code>架构支持。</p>
<p><br></p>
<h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><p><img src="/2022/01/23/bpf/image-61.png" width="500px"></p>
<p>JIT 编译器可以极大加速 BPF 程序的执行,因为与解释器相比,它们可以降低每个指令的开销(reduce the per instruction cost)。<br>通常指令可以 1:1 映射到底层架构的原生指令。另外,这也会减少生成的可执行镜像的大小,因此对 CPU 的指令缓存更友好。</p>
<blockquote>
<p>开启方式</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> echo 1 &gt; /proc/sys/net/core/bpf_jit_enable</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="Offloads"><a href="#Offloads" class="headerlink" title="Offloads"></a>Offloads</h3><p>BPF 网络程序,尤其是 tc 和 XDP BPF 程序在内核中都有一个 offload 到硬件的接口,这样就可以直接在网卡上执行 BPF 程序。</p>
<p>当前,Netronome 公司的 nfp 驱动支持通过 JIT 编译器 offload BPF,它会将 BPF 指令 翻译成网卡实现的指令集。<br>另外它还支持将 BPF maps offload 到网卡,因此 offloaded BPF 程序可以执行 map 查找、更新和删除操作。</p>
<p><br></p>
<h2 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h2><h3 id="iproute2"><a href="#iproute2" class="headerlink" title="iproute2"></a>iproute2</h3><p>很多前端工具,例如 bcc、perf、iproute2,都可以将 BPF 程序加载到内核<br>但通常来说,不同前端在实现 BPF 程序时,语法和语义稍有不同。<br>本节主要关注如何使用 iproute2 提供的 BPF 前端加载 XDP、tc 或 lwt 类型的网络程序,因为 Cilium 的 BPF 程序就是面向这个加载器实现的。<br>将来 Cilium 会实现自己原生的 BPF 加载器,但为了开发和调试方便,程序仍会保持与 iproute2 套件的兼容性。</p>
<h4 id="加载-XDP-BPF-对象文件"><a href="#加载-XDP-BPF-对象文件" class="headerlink" title="加载 XDP BPF 对象文件"></a>加载 XDP BPF 对象文件</h4><p>给定一个为 XDP 编译的 BPF 对象文件<code>prog.o</code>,可以用 ip 命令加载到支持 XDP 的 netdevice<code>em1</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ip link set dev em1 xdp obj prog.o  等价于 ip link set dev em1 xdp obj prog.o sec prog</span><br></pre></td></tr></table></figure>
<p>以上命令假设程序代码存储在默认的<code>section</code>,在 XDP 的场景下就是<code>prog section</code>。如果是在其他<code>section</code>,例如 foobar,那就需要用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ip link set dev em1 xdp obj prog.o sec foobar</span><br></pre></td></tr></table></figure>
<p>我们还可以从默认的<code>.text section</code>加载程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __section</span></span><br><span class="line"> define __section(NAME)                  \</span><br><span class="line">   __attribute__((section(NAME), used))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xdp_drop</span><span class="params">(struct xdp_md *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> __license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br></pre></td></tr></table></figure>
<p>然后通过如下命令加载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ip link set dev em1 xdp obj prog.o sec .text</span><br></pre></td></tr></table></figure>
<p>默认情况下,如果 XDP 程序已经 attach 到网络接口,那再次加载会报错,这样设计是为了防止程序被无意中覆盖。<br>要强制替换当前正在运行的 XDP 程序,必须指定<code>-force</code>参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ip -force link set dev em1 xdp obj prog.o</span><br></pre></td></tr></table></figure>
<p>今天大部分支持 XDP 的驱动都能够在不会引起流量中断(traffic interrupt)的前提下,原子地替换运行中的程序。<br>出于性能考虑,支持 XDP 的驱动只允许 attach 一个程序 ,不支持程序链(a chain of programs)。<br>但正如上一节讨论的,如果有必要,可以通过尾调用来对程序进行拆分,以达到与程序链类似的效果。</p>
<p>如果一个接口上有 XDP 程序 attach,ip link 命令会显示一个 xdp 标记。</p>
<ul>
<li>因此可以用<code>ip link | grep xdp</code>列出所有有 XDP 程序在运行的网络接口。</li>
<li><code>ip -d link</code>可以查看进一步信息；</li>
<li>另外bpftool 指定 BPF 程序 ID 可以获取 attached 程序的信息,其中程序 ID 可以通过<code>ip link</code>看到。</li>
</ul>
<p>从接口删除 XDP 程序,执行下面的命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ip link set dev em1 xdp off</span><br></pre></td></tr></table></figure></p>
<h5 id="XDP-工作模式"><a href="#XDP-工作模式" class="headerlink" title="XDP 工作模式"></a>XDP 工作模式</h5><p>XDP 总共支持三种工作模式,这三种模式<code>iproute2</code>都实现了：</p>
<ul>
<li><p>xdpdrv<br>xdpdrv 表示 native XDP(原生 XDP), 意味着 BPF 程序直接在驱动的接收路 径上运行,理论上这是软件层最早可以处理包的位置(the earliest possible point)。这是常规/传统的 XDP 模式,需要驱动实现对 XDP 的支持,目前 Linux 内核中主流的 10G/40G 网卡都已经支持。</p>
</li>
<li><p>xdpgeneric<br>xdpgeneric 表示 generic XDP(通用 XDP),用于给那些还没有原生支持 XDP 的驱动进行试验性测试。generic XDP hook 位于内核协议栈的主接收路径(main receive path)上,接受的是 skb 格式的包,但由于 这些 hook 位于 ingress 路 径的很后面(a much later point),因此与 native XDP 相比性能有明显下降。因 此,xdpgeneric 大部分情况下只能用于试验目的,很少用于生产环境。</p>
</li>
<li><p>xdpoffload<br>最后一些智能网卡(例如支持 Netronome’s nfp 驱动的网卡)实现了 xdpoffload 模式 ,允许将整个 BPF/XDP 程序 offload 到硬件,因此程序在网卡收到包时就直接在网卡进行处理。<br>这提供了比 native XDP 更高的性能,虽然在这种模式中某些 BPF map 类型和 BPF 辅助函数是不能用的。<br>BPF 校验器检测到这种情况时会直接报错,告诉用户哪些东西是不支持的。除了这些不支持的 BPF 特性之外,其他方面与 native XDP 都是一样的。</p>
</li>
</ul>
<p>执行<code>ip link set dev em1 xdp obj [...]</code>命令时,内核会先尝试以 native XDP 模 式加载程序,如果驱动不支持再自动回退到 generic XDP 模式。<br>如果显式指定了 xdpdrv 而不是 xdp,那驱动不支持 native XDP 时加载就会直接失败,而不再尝试 generic XDP 模式。</p>
<blockquote>
<p>一个例子：以 native XDP 模式强制加载一个 BPF/XDP 程序,打印链路详情,最后再卸载程序：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ip -force link set dev em1 xdpdrv obj prog.o</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ip link show</span><br><span class="line">[...]</span><br><span class="line">6: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdp qdisc mq state UP mode DORMANT group default qlen 1000</span><br><span class="line">    link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    prog/xdp id 1 tag 57cd311f2e27366b</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ip link set dev em1 xdpdrv off</span><br></pre></td></tr></table></figure>
<p>还是这个例子,但强制以 generic XDP 模式加载(即使驱动支持 native XDP),另外用 bpftool 打印 attached 的这个 dummy 程序内具体的 BPF 指令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ip -force link set dev em1 xdpgeneric obj prog.o</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ip link show</span><br><span class="line">[...]</span><br><span class="line">6: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdpgeneric qdisc mq state UP mode DORMANT group default qlen 1000</span><br><span class="line">    link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    prog/xdp id 4 tag 57cd311f2e27366b                &lt;-- BPF program ID 4</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> bpftool prog dump xlated id 4                       &lt;-- Dump of instructions running on em1</span><br><span class="line">0: (b7) r0 = 1</span><br><span class="line">1: (95) exit</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ip link set dev em1 xdpgeneric off</span><br></pre></td></tr></table></figure>
<p>最后卸载 XDP,用 bpftool 打印程序信息,查看其中的一些元数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ip -force link set dev em1 xdpoffload obj prog.o</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ip link show</span><br><span class="line">[...]</span><br><span class="line">6: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdpoffload qdisc mq state UP mode DORMANT group default qlen 1000</span><br><span class="line">    link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    prog/xdp id 8 tag 57cd311f2e27366b</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> bpftool prog show id 8</span><br><span class="line">8: xdp  tag 57cd311f2e27366b dev em1                  &lt;-- Also indicates a BPF program offloaded to em1</span><br><span class="line">    loaded_at Apr 11/20:38  uid 0</span><br><span class="line">    xlated 16B  not jited  memlock 4096B</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ip link set dev em1 xdpoffload off</span><br></pre></td></tr></table></figure>
<p>注意每个程序只能选择用一种 XDP 模式加载,无法同时使用多种模式,例如 xdpdrv 和 xdpgeneric。</p>
<p>无法原子地在不同 XDP 模式之间切换,例如从 generic 模式切换到 native 模式。但重复设置为同一种模式是可以的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ip -force link set dev em1 xdpgeneric obj prog.o</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ip -force link set dev em1 xdpoffload obj prog.o</span><br><span class="line">RTNETLINK answers: File exists</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ip -force link set dev em1 xdpdrv obj prog.o</span><br><span class="line">RTNETLINK answers: File exists</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ip -force link set dev em1 xdpgeneric obj prog.o    &lt;-- Succeeds due to xdpgeneric</span><br></pre></td></tr></table></figure>
<p>在不同模式之间切换时,需要先退出当前的操作模式,然后才能进入新模式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ip -force link set dev em1 xdpgeneric obj prog.o</span><br><span class="line"><span class="meta">$</span> ip -force link set dev em1 xdpgeneric off</span><br><span class="line"><span class="meta">$</span> ip -force link set dev em1 xdpoffload obj prog.o</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ip l</span><br><span class="line">[...]</span><br><span class="line">6: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdpoffload qdisc mq state UP mode DORMANT group default qlen 1000</span><br><span class="line">    link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    prog/xdp id 17 tag 57cd311f2e27366b</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ip -force link set dev em1 xdpoffload off</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="加载-tc-BPF-对象文件"><a href="#加载-tc-BPF-对象文件" class="headerlink" title="加载 tc BPF 对象文件"></a>加载 tc BPF 对象文件</h4><h5 id="用-tc-加载-BPF-程序"><a href="#用-tc-加载-BPF-程序" class="headerlink" title="用 tc 加载 BPF 程序"></a>用 tc 加载 BPF 程序</h5><p>给定一个为 tc 编译的 BPF 对象文件<code>prog.o</code>,可以通过 tc 命令将其加载到一个网络设备(netdevice)。<br>但与 XDP 不同,设备是否支持 attach BPF 程序并不依赖驱动 (即任何网络设备都支持 tc BPF)。</p>
<p>下面的命令可以将程序 attach 到<code>em1</code>的<code>ingress</code>网络：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tc qdisc add dev em1 clsact</span><br><span class="line"><span class="meta">$</span> tc filter add dev em1 ingress bpf da obj prog.o</span><br></pre></td></tr></table></figure>
<p>第一步创建了一个<code>clsact</code> qdisc (Linux 排队规则,Linux queueing discipline)。</p>
<ul>
<li><code>clsact</code> 是一个 dummy qdisc,和 ingress qdisc 类似,用于 持有(hold)分类器和动作(classifier and actions),但 不执行真正的排队(queueing)。后面 attach bpf 分类器需要用到它。</li>
<li><code>clsact</code> qdisc 提供了两个特殊的 hook：ingress and egress,分类器可以 attach 到这两个 hook 点。这两个 hook 都位于 datapath 的关键收发路径上,设备 em1 的每个包都会经过这两个点。二者的内核调用路径：<ul>
<li><code>ingress hook：__netif_receive_skb_core() -&gt; sch_handle_ingress()</code></li>
<li><code>egress hook：__dev_queue_xmit() -&gt; sch_handle_egress()</code><br>类似地,将程序 attach 到<code>egress</code>hook 的命令：<code>tc filter add dev em1 egress bpf da obj prog.o</code></li>
</ul>
</li>
<li><code>clsact</code> qdisc 在 ingress 和 egress 方向以无锁(lockless)方式执行, 而且可以 attach 到<code>虚拟的、无队列的设备</code>(virtual, queue-less devices),例如连接容器和宿主机的 veth 设备。</li>
</ul>
<p>第二步命令,tc filter 选择了在 da(direct-action)模式中使用 bpf。</p>
<p>da 是 推荐的模式,并且应该永远指定这个参数。粗略地说,da 模式表示 bpf 分类器不需要调用外部的 tc action 模块。<br>事实上 bpf 分类器也完全不需要调用外部模块,因为所有的 packet mangling、转发或其他类型的 action 都可以在这单个 BPF 程序内完成 ,因此执行会明显更快。</p>
<blockquote>
<p>配置了这两条命令之后,程序就 attach 完成了,接下来只要有包经过这个设备,就会触发这个程序执行。<br>和 XDP 类似,如果没有使用默认 section 名字,那可以在加载时指定,例如指定 section 为 foobar：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc filter add dev em1 egress bpf da obj prog.o sec foobar</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="查看已经-attach-的程序"><a href="#查看已经-attach-的程序" class="headerlink" title="查看已经 attach 的程序"></a>查看已经 attach 的程序</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tc filter show dev em1 ingress</span><br><span class="line">filter protocol all pref 49152 bpf</span><br><span class="line">filter protocol all pref 49152 bpf handle 0x1 prog.o:[ingress] direct-action id 1 tag c5f7825e5dac396f</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> tc filter show dev em1 egress</span><br><span class="line">filter protocol all pref 49152 bpf</span><br><span class="line">filter protocol all pref 49152 bpf handle 0x1 prog.o:[egress] direct-action id 2 tag b2fd5adc0f262714</span><br></pre></td></tr></table></figure>
<p>输出中的 prog.o:[ingress] 表示<code>section ingress</code>中的程序是从文件 prog.o 加载的,而且 bpf 工作在 direct-action 模式。<br>上面还打印了程序的 id 和 tag, 其中 tag 是指令流(instruction stream)的哈希,可以关联到对应的对象文件或用 perf 查看调用栈信息。<br>id 是一个操作系统层唯一的 BPF 程序标识符,可以用 bpftool 进一步查看或 dump 相关的程序信息。</p>
<p>tc 可以 attach 多个 BPF 程序,并提供了其他的一些分类器,这些分类器可以 chain 到一起使用。<br>但是attach 单个 BPF 程序已经完全足够了,因为有了 da 模式,所有的包操作都可以放到同一个程序中,这意味着 BPF 程序自身将会返回<code>tc action verdict</code></p>
<p>例如<code>TC_ACT_OK</code>、<code>TC_ACT_SHOT</code>等等。出于最佳性能和灵活性考虑,这(da 模式)是推荐的使用方式。</p>
<p><br></p>
<h4 id="程序优先级-pref-和句柄-handle"><a href="#程序优先级-pref-和句柄-handle" class="headerlink" title="程序优先级(pref)和句柄(handle)"></a>程序优先级(pref)和句柄(handle)</h4><p>在上面的 show 命令中,tc 还打印出了 pref 49152 和 handle 0x1。如果之前没有 通过命令行显式指定,这两个数据就会自动生成。</p>
<ul>
<li><code>pref</code>表示优先级,如果指定了多个分类器,它们会按照优先级从高到低依次执行；</li>
<li><code>handle</code>是一个标识符,在加载了同一分类器的多个实例并且它们的优先级(pref)都一样的情况下会用到这个标识符。</li>
</ul>
<p>因为在 BPF 的场景下,单个程序就足够了,因此 pref 和 handle 通常情况下都可以忽略。</p>
<ul>
<li>除非打算后面原子地替换 attached BPF 程序,否则不建议在加载时显式指定 pref 和 handle。</li>
<li>显式指定这两个参数的好处是,后面执行 replace 操作时,就不需要再去动态地查询这两个值。</li>
</ul>
<blockquote>
<p>显式指定 pref 和 handle 时的加载命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tc filter add dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> tc filter show dev em1 ingress</span><br><span class="line">filter protocol all pref 1 bpf</span><br><span class="line">filter protocol all pref 1 bpf handle 0x1 prog.o:[foobar] direct-action id 1 tag c5f7825e5dac396f</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对应的原子 replace 命令:将<code>ingress hook</code>处的已有程序替换为<code>prog.o</code>文件中<code>foobar section</code>中的新 BPF 程序,</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tc filter replace dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="用-tc-删除-BPF-程序"><a href="#用-tc-删除-BPF-程序" class="headerlink" title="用 tc 删除 BPF 程序"></a>用 tc 删除 BPF 程序</h4><p>最后,要分别从<code>ingress</code>和<code>egress</code>删除所有 attach 的程序执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tc filter del dev em1 ingress</span><br><span class="line"><span class="meta">$</span> tc filter del dev em1 egress</span><br></pre></td></tr></table></figure>
<p>要从<code>netdevice</code>删除整个<code>clsact qdisc</code>(会隐式地删除 attach 到<code>ingress</code>和<code>egress</code>hook上面的所有程序)执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tc qdisc del dev em1 clsact</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="offload-到网卡"><a href="#offload-到网卡" class="headerlink" title="offload 到网卡"></a>offload 到网卡</h4><p>和 XDP BPF 程序类似,如果网卡驱动支持 tc BPF 程序,那也可以将它们 offload 到网卡 。<br>Netronome 的 nfp 网卡对 XDP 和 tc BPF 程序都支持 offload。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tc qdisc add dev em1 clsact</span><br><span class="line"><span class="meta">$</span> tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o</span><br><span class="line">Error: TC offload is disabled on net device.</span><br><span class="line">We have an error talking to the kernel</span><br></pre></td></tr></table></figure>
<p>如果显式以上错误,那需要先启用网卡的 hw-tc-offload 功能：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ethtool -K em1 hw-tc-offload on</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> tc qdisc add dev em1 clsact</span><br><span class="line"><span class="meta">$</span> tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o</span><br><span class="line"><span class="meta">$</span> tc filter show dev em1 ingress</span><br><span class="line">filter protocol all pref 1 bpf</span><br><span class="line">filter protocol all pref 1 bpf handle 0x1 prog.o:[classifier] direct-action skip_sw in_hw id 19 tag 57cd311f2e27366b</span><br></pre></td></tr></table></figure>
<p>其中的<code>in_hw</code>标志表示这个程序已经被 offload 到网卡了。</p>
<p><br></p>
<h3 id="bpftool"><a href="#bpftool" class="headerlink" title="bpftool"></a>bpftool</h3><p>bpftool 是查看和调试 BPF 程序的主要工具。它随内核一起开发,在内核中的路径是<code>tools/bpf/bpftool/</code>。</p>
<blockquote>
<p>这个工具可以完成</p>
</blockquote>
<ul>
<li>dump 当前已经加载到系统中的所有 BPF 程序和 map</li>
<li>列出和指定程序相关的所有 BPF map</li>
<li>dump 整个 map 中的 key/value 对</li>
<li>查看、更新、删除特定 key</li>
<li>查看给定 key 的相邻 key(neighbor key)</li>
</ul>
<p>要执行这些操作可以指定 BPF 程序、map ID,或者指定 BPF 文件系统中程序或 map 的位置。<br>另外这个工具还提供了将 map 或程序钉(pin)到 BPF 文件系统的功能</p>
<blockquote>
<p>查看系统当前已经加载的 BPF 程序</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bpftool prog</span><br><span class="line">398: sched_cls  tag 56207908be8ad877</span><br><span class="line">   loaded_at Apr 09/16:24  uid 0</span><br><span class="line">   xlated 8800B  jited 6184B  memlock 12288B  map_ids 18,5,17,14</span><br><span class="line">399: sched_cls  tag abc95fb4835a6ec9</span><br><span class="line">   loaded_at Apr 09/16:24  uid 0</span><br><span class="line">   xlated 344B  jited 223B  memlock 4096B  map_ids 18</span><br><span class="line">400: sched_cls  tag afd2e542b30ff3ec</span><br><span class="line">   loaded_at Apr 09/16:24  uid 0</span><br><span class="line">   xlated 1720B  jited 1001B  memlock 4096B  map_ids 17</span><br><span class="line">401: sched_cls  tag 2dbbd74ee5d51cc8</span><br><span class="line">   loaded_at Apr 09/16:24  uid 0</span><br><span class="line">   xlated 3728B  jited 2099B  memlock 4096B  map_ids 17</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>类似地查看所有的 active maps</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bpftool map</span><br><span class="line">5: hash  flags 0x0</span><br><span class="line">    key 20B  value 112B  max_entries 65535  memlock 13111296B</span><br><span class="line">6: hash  flags 0x0</span><br><span class="line">    key 20B  value 20B  max_entries 65536  memlock 7344128B</span><br><span class="line">7: hash  flags 0x0</span><br><span class="line">    key 10B  value 16B  max_entries 8192  memlock 790528B</span><br><span class="line">8: hash  flags 0x0</span><br><span class="line">    key 22B  value 28B  max_entries 8192  memlock 987136B</span><br><span class="line">9: hash  flags 0x0</span><br><span class="line">    key 20B  value 8B  max_entries 512000  memlock 49352704B</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>bpftool 的每个命令都提供了以 json 格式打印的功能,在命令末尾指定<code>--json</code>就行了。<br>另外<code>--pretty</code>会使得打印更加美观,看起来更清楚。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bpftool prog --json --pretty</span><br></pre></td></tr></table></figure>
<p>要<code>dump</code>特定 BPF 程序的<code>post-verifier</code>BPF 指令镜像(instruction image)<br>可以先从查看一个具体程序开始,例如查看 attach 到<code>tc ingress hook</code>上的程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tc filter show dev cilium_host egress</span><br><span class="line">filter protocol all pref 1 bpf chain 0</span><br><span class="line">filter protocol all pref 1 bpf chain 0 handle 0x1 bpf_host.o:[from-netdev] \</span><br><span class="line">                    direct-action not_in_hw id 406 tag e0362f5bd9163a0a jited</span><br></pre></td></tr></table></figure>
<p>这个程序是从对象文件 bpf_host.o 加载来的,程序位于对象文件的 from-netdev section,程序 ID 为 406。<br>基于以上信息 bpftool 可以提供一些关于这个程序的上层元数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bpftool prog show id 406</span><br><span class="line">406: sched_cls  tag e0362f5bd9163a0a</span><br><span class="line">     loaded_at Apr 09/16:24  uid 0</span><br><span class="line">     xlated 11144B  jited 7721B  memlock 12288B  map_ids 18,20,8,5,6,14</span><br></pre></td></tr></table></figure>
<p>从上面的输出可以看到：</p>
<ul>
<li>程序 ID 为 406,类型是<code>sched_cls(BPF_PROG_TYPE_SCHED_CLS)</code>,有一个 tag 为<code>e0362f5bd9163a0a</code>(指令序列的 SHA sum)</li>
<li>这个程序被 root uid 0 在<code>Apr 09/16:24</code>加载</li>
<li>BPF 指令序列有 11,144 bytes 长,JIT 之后的镜像有 7,721 bytes</li>
<li>程序自身(不包括 maps)占用了 12,288 bytes,这部分空间使用的是 uid 0 用户 的配额</li>
<li>BPF 程序使用了 ID 为 <code>18、20 8 5 6</code>和 <code>14</code>的 BPF map。可以用这些 ID 进一步 dump map 自身或相关信息</li>
</ul>
<p>另外bpftool 可以 dump 出运行中程序的 BPF 指令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bpftool prog dump xlated id 406</span><br><span class="line"> 0: (b7) r7 = 0</span><br><span class="line"> 1: (63) *(u32 *)(r1 +60) = r7</span><br><span class="line"> 2: (63) *(u32 *)(r1 +56) = r7</span><br><span class="line"> 3: (63) *(u32 *)(r1 +52) = r7</span><br><span class="line">[...]</span><br><span class="line">47: (bf) r4 = r10</span><br><span class="line">48: (07) r4 += -40</span><br><span class="line">49: (79) r6 = *(u64 *)(r10 -104)</span><br><span class="line">50: (bf) r1 = r6</span><br><span class="line">51: (18) r2 = map[id:18]                    &lt;-- BPF map id 18</span><br><span class="line">53: (b7) r5 = 32</span><br><span class="line">54: (85) call bpf_skb_event_output#5656112  &lt;-- BPF helper call</span><br><span class="line">55: (69) r1 = *(u16 *)(r6 +192)</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>由于程序被 JIT,因此真正执行的是生成的 JIT 镜像(从上面 xlated 中的指令生成的 ),这些指令也可以通过<code>bpftool</code>查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bpftool prog dump jited id 406</span><br><span class="line"> 0:        push   %rbp</span><br><span class="line"> 1:        mov    %rsp,%rbp</span><br><span class="line"> 4:        sub    $0x228,%rsp</span><br><span class="line"> b:        sub    $0x28,%rbp</span><br><span class="line"> f:        mov    %rbx,0x0(%rbp)</span><br><span class="line">13:        mov    %r13,0x8(%rbp)</span><br><span class="line">17:        mov    %r14,0x10(%rbp)</span><br><span class="line">1b:        mov    %r15,0x18(%rbp)</span><br><span class="line">1f:        xor    %eax,%eax</span><br><span class="line">21:        mov    %rax,0x20(%rbp)</span><br><span class="line">25:        mov    0x80(%rdi),%r9d</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>还可以指定在输出中将反汇编之后的指令关联到<code>opcodes</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bpftool prog dump jited id 406 opcodes</span><br><span class="line"> 0:        push   %rbp</span><br><span class="line">           55</span><br><span class="line"> 1:        mov    %rsp,%rbp</span><br><span class="line">           48 89 e5</span><br><span class="line"> 4:        sub    $0x228,%rsp</span><br><span class="line">           48 81 ec 28 02 00 00</span><br><span class="line"> b:        sub    $0x28,%rbp</span><br><span class="line">           48 83 ed 28</span><br><span class="line"> f:        mov    %rbx,0x0(%rbp)</span><br><span class="line">           48 89 5d 00</span><br><span class="line">13:        mov    %r13,0x8(%rbp)</span><br><span class="line">           4c 89 6d 08</span><br><span class="line">17:        mov    %r14,0x10(%rbp)</span><br><span class="line">           4c 89 75 10</span><br><span class="line">1b:        mov    %r15,0x18(%rbp)</span><br><span class="line">           4c 89 7d 18</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>也可以将常规的 BPF 指令关联到<code>opcodes</code>,有时在内核中进行调试时会比较有用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bpftool prog dump xlated id 406 opcodes</span><br><span class="line"> 0: (b7) r7 = 0</span><br><span class="line">    b7 07 00 00 00 00 00 00</span><br><span class="line"> 1: (63) *(u32 *)(r1 +60) = r7</span><br><span class="line">    63 71 3c 00 00 00 00 00</span><br><span class="line"> 2: (63) *(u32 *)(r1 +56) = r7</span><br><span class="line">    63 71 38 00 00 00 00 00</span><br><span class="line"> 3: (63) *(u32 *)(r1 +52) = r7</span><br><span class="line">    63 71 34 00 00 00 00 00</span><br><span class="line"> 4: (63) *(u32 *)(r1 +48) = r7</span><br><span class="line">    63 71 30 00 00 00 00 00</span><br><span class="line"> 5: (63) *(u32 *)(r1 +64) = r7</span><br><span class="line">    63 71 40 00 00 00 00 00</span><br><span class="line"> [...]</span><br></pre></td></tr></table></figure>
<p>此外还可以用<code>graphviz</code>以可视化的方式展示程序的基本组成部分</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bpftool prog dump xlated id 406 visual &amp;&gt; output.dot</span><br><span class="line"><span class="meta">$</span> dot -Tpng output.dot -o output.png</span><br></pre></td></tr></table></figure>
<p><code>map dump</code>子命令可以 dump 整个 map,它会遍历所有的 map 元素,输出 key/value。<br>如果 map 中没有可用的 BTF 数据,那<code>key/value</code>会以十六进制格式输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bpftool map dump id 5</span><br><span class="line">key:</span><br><span class="line">f0 0d 00 00 00 00 00 00  0a 66 00 00 00 00 8a d6</span><br><span class="line">02 00 00 00</span><br><span class="line">value:</span><br><span class="line">00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00</span><br><span class="line">key:</span><br><span class="line">0a 66 1c ee 00 00 00 00  00 00 00 00 00 00 00 00</span><br><span class="line">01 00 00 00</span><br><span class="line">value:</span><br><span class="line">00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00</span><br><span class="line">[...]</span><br><span class="line">Found 6 elements</span><br></pre></td></tr></table></figure>
<p>如果有 BTF 数据,map 就有了关于<code>key/value</code>结构体的调试信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bpftool map dump id 386</span><br><span class="line"> [&#123;</span><br><span class="line">      "key": 0,</span><br><span class="line">      "value": &#123;</span><br><span class="line">          "": &#123;</span><br><span class="line">              "value": 0,</span><br><span class="line">              "ifindex": 0,</span><br><span class="line">              "mac": []</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">      "key": 1,</span><br><span class="line">      "value": &#123;</span><br><span class="line">          "": &#123;</span><br><span class="line">              "value": 0,</span><br><span class="line">              "ifindex": 0,</span><br><span class="line">              "mac": []</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>此外还可以用<code>btf show</code>命令来 dump 系统中已经加载的所有 BTF 对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> bpftool btf show</span><br><span class="line">60: size 12243B  prog_ids 72  map_ids 126,130,131,127,129,128</span><br></pre></td></tr></table></figure>
<p>还可以用子命令 btf dump 来检查 BTF 中携带了哪些 debug 信息。<br>format 类型可以是<code>raw</code>或<code>c</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bpftool btf dump id 60 format c</span><br><span class="line">  [...]</span><br><span class="line">   struct ctl_value &#123;</span><br><span class="line">         union &#123;</span><br><span class="line">                 __u64 value;</span><br><span class="line">                 __u32 ifindex;</span><br><span class="line">                 __u8 mac[6];</span><br><span class="line">         &#125;;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   typedef unsigned int u32;</span><br><span class="line">   [...]</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="程序类型"><a href="#程序类型" class="headerlink" title="程序类型"></a>程序类型</h2><p>当前一共有 18 种不同的 BPF 程序类型<br>本节接下来进一步介绍其中两种和网络相关的类型,即 XDP BPF 程序和 tc BPF 程序。</p>
<h3 id="XDP"><a href="#XDP" class="headerlink" title="XDP"></a>XDP</h3><p>XDP(eXpress Data Path)提供了一个内核态、高性能、可编程 BPF 包处理框架。<br>这个框架在软件中最早可以处理包的位置(即网卡驱动收到包的 时刻)运行 BPF 程序。</p>
<p>XDP hook 位于网络驱动的快速路径上,XDP 程序直接从接收缓冲区(receive ring)中将 包拿下来,无需执行任何耗时的操作,例如分配 skb 然后将包推送到网络协议栈,或者将包推送给 GRO 引擎等等。<br>因此只要有 CPU 资源,XDP BPF 程序就能够在最早的位置执行处理。</p>
<p>XDP 和 Linux 内核及其基础设施协同工作,这意味着 XDP 并不会绕过(bypass)内核 ；<br>作为对比很多完全运行在用户空间的网络框架(例如 DPDK)是绕过内核的。将包留在内核空间可以带来几方面重要好处</p>
<ul>
<li>XDP 可以复用所有上游开发的内核网络驱动、用户空间工具,以及其他一些可用的内核 基础设施,例如 BPF 辅助函数在调用自身时可以使用系统路由表、socket 等等。</li>
<li>因为驻留在内核空间,因此 XDP 在访问硬件时与内核其他部分有相同的安全模型。</li>
<li>无需跨内核/用户空间边界,因为正在被处理的包已经在内核中,因此可以灵活地将 其转发到内核内的其他实体,例如容器的命名空间或内核网络栈自身。</li>
<li>将包从 XDP 送到内核中非常简单,可以复用内核中这个健壮、高效、使用广泛的 TCP/IP 协议栈,而不是像一些用户态框架一样需要自己维护一个独立的 TCP/IP 协 议栈。</li>
<li>基于 BPF 可以实现内核的完全可编程,保持 ABI 的稳定,保持内核的系统调用 ABI <code>“永远不会破坏用户空间的兼容性”</code>的保证。而且与内核模块(modules)方式相比,它还更加安全,这来源于 BPF 校验器,它能保证内核操作的稳定性。</li>
<li>XDP 轻松地支持在运行时(runtime)原子地创建(spawn)新程序,而不会导致任何网络流量中断,甚至不需要重启内核/系统。</li>
<li>XDP 允许对负载进行灵活的结构化(structuring of workloads),然后集成到内核。例如它可以工作在<code>“不停轮询”(busy polling)</code>或<code>“中断驱动”(interrupt driven)</code>模式。不需要显式地将专门 CPU 分配给 XDP。没有特殊的硬件需求,它也不依赖 hugepage(大页)。</li>
<li>XDP 不需要任何第三方内核模块或许可(licensing)。它是一个长期的架构型解决方案,是 Linux 内核的一个核心组件,而且是由内核社区开发的。</li>
<li>主流发行版中,4.8+ 的内核已经内置并启用了 XDP,并支持主流的 10G 及更高速网络驱动。</li>
</ul>
<blockquote>
<p>数据包在 XDP 中的表示形式是<code>xdp_buff</code>,这也是传递给 BPF 程序的结构体</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xdp_buff</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="keyword">void</span> *data_end;</span><br><span class="line">    <span class="keyword">void</span> *data_meta;</span><br><span class="line">    <span class="keyword">void</span> *data_hard_start;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xdp_rxq_info</span> *<span class="title">rxq</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>data</code>指向页面(page)中包数据的起始位置,从名字可以猜出</li>
<li><code>data_end</code>执行包数据 的结尾位置。</li>
<li><code>data_hard_start</code> XDP 支持 headroom,因此 data_hard_start 指向页面中最大可能的 headroom 开始位置,即当对包进行封装(加 header)时,data 会逐渐向 data_hard_start 靠近,这是通过 bpf_xdp_adjust_head() 实现的,该辅助函数还支 持解封装(去 header)。</li>
<li><code>data_meta</code>开始时指向与 data 相同的位置,bpf_xdp_adjust_meta() 能够将其朝着 data_hard_start 移动,这样可以给自定义元数据提供空间,这个空间对内核网络栈是不可见的,但对 tc BPF 程序可见,因为 tc 需要将它从 XDP 转移到 skb。 反之亦然,这个辅助函数也可以将 data_meta 移动到离 data_hard_start 比较远的位 置,这样就可以达到删除或缩小这个自定义空间的目的。 data_meta 还可以单纯用于在尾调用时传递状态,和 tc BPF 程序中用 skb-&gt;cb[] 控 制块(control block)类似。</li>
<li><code>rxq</code>字段指向某些额外的、和每个接收队列相关的元数据：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xdp_rxq_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    u32 queue_index;</span><br><span class="line">    u32 reg_state;</span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure>
<h4 id="BPF-程序返回码"><a href="#BPF-程序返回码" class="headerlink" title="BPF 程序返回码"></a>BPF 程序返回码</h4><p>XDP BPF 程序执行结束后会返回一个判决结果(verdict),告诉驱动接下来如何处理这个包</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> xdp_action &#123;</span><br><span class="line">    XDP_ABORTED = <span class="number">0</span>,</span><br><span class="line">    XDP_DROP,</span><br><span class="line">    XDP_PASS,</span><br><span class="line">    XDP_TX,</span><br><span class="line">    XDP_REDIRECT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>XDP_DROP</code>表示立即在驱动层将包丢弃。这样可以节省很多资源,对于 DDoS mitigation 或通用目的防火墙程序来说这尤其有用。</li>
<li><code>XDP_PASS</code>表示允许将这个包送到内核网络栈。同时,当前正在处理这个包的 CPU 会分配一个 skb,做一些初始化,然后将其送到 GRO 引擎。这是没有 XDP 时默认的包处理行为是一样的。</li>
<li><code>XDP_TX</code>是 BPF 程序的一个高效选项,能够在收到包的网卡上直接将包再发送出去。对 于实现防火墙+负载均衡的程序来说这非常有用,因为这些部署了 BPF 的节点可以作为一个 hairpin (发卡模式,从同一个设备进去再出来)模式的负载均衡器集群,将收到的包在 XDP BPF 程序中重写(rewrite)之后直接发送回去。</li>
<li><code>XDP_REDIRECT</code>与 XDP_TX 类似,但是通过另一个网卡将包发出去。另外, XDP_REDIRECT 还可以将包重定向到一个 BPF cpumap,即当前执行 XDP 程序的 CPU 可以将这个包交给某个远端 CPU,由后者将这个包送到更上层的内核栈,当前 CPU 则继 续在这个网卡执行接收和处理包的任务。这和 XDP_PASS 类似,但当前 CPU 不用去 做将包送到内核协议栈的准备工作(分配 skb,初始化等等),这部分开销还是很大的。</li>
<li><code>XDP_ABORTED</code>表示程序产生异常,其行为和 XDP_DROP,但 XDP_ABORTED 会经过 trace_xdp_exception tracepoint,因此可以通过 tracing 工具来监控这种非正常行为。</li>
</ul>
<p><br></p>
<h4 id="XDP-工作模式-1"><a href="#XDP-工作模式-1" class="headerlink" title="XDP 工作模式"></a>XDP 工作模式</h4><p>XDP 有三种工作模式,默认是<code>native(原生)</code>模式,当讨论 XDP 时通常隐含的都是指这种模式。</p>
<ul>
<li><p>Native XDP<br>默认模式,在这种模式中,XDP BPF 程序直接运行在网络驱动的早期接收路径上( early receive path)。大部分广泛使用的 10G 及更高速的网卡都已经支持这种模式 。</p>
</li>
<li><p>Offloaded XDP<br>在这种模式中,XDP BPF 程序直接 offload 到网卡,而不是在主机的 CPU 上执行。 因此,本来就已经很低的 per-packet 开销完全从主机下放到网卡,能够比运行在 native XDP 模式取得更高的性能。这种 offload 通常由智能网卡实现,这些网卡有多 线程、多核流处理器(flow processors),一个位于内核中的 JIT 编译器( in-kernel JIT compiler)将 BPF 翻译成网卡的原生指令。<br>支持 offloaded XDP 模式的驱动通常也支持 native XDP 模式,因为 BPF 辅助函数可 能目前还只支持后者。</p>
</li>
<li><p>Generic XDP<br>对于还没有实现 native 或 offloaded XDP 的驱动,内核提供了一个 generic XDP 选 项,这种模式不需要任何驱动改动,因为相应的 XDP 代码运行在网络栈很后面的一个位置。<br>这种设置主要面向的是用内核的 XDP API 来编写和测试程序的开发者,并且无法达到 前面两种模式能达到的性能。对于在生产环境使用 XDP,推荐要么选择 native 要么选择 offloaded 模式。</p>
</li>
</ul>
<h4 id="驱动支持"><a href="#驱动支持" class="headerlink" title="驱动支持"></a>驱动支持</h4><p>支持 native XDP 的驱动</p>
<ul>
<li>Broadcom<ul>
<li>bnxt</li>
</ul>
</li>
<li>Cavium<ul>
<li>thunderx</li>
</ul>
</li>
<li>Intel<ul>
<li>ixgbe</li>
<li>ixgbevf</li>
<li>i40e</li>
</ul>
</li>
<li>Mellanox<ul>
<li>mlx4</li>
<li>mlx5</li>
</ul>
</li>
<li>Netronome<ul>
<li>nfp</li>
</ul>
</li>
<li>Others<ul>
<li>tun</li>
<li>virtio_net</li>
</ul>
</li>
<li>Qlogic<ul>
<li>qede</li>
</ul>
</li>
</ul>
<p>支持 offloaded XDP 的驱动</p>
<ul>
<li>Netronome<ul>
<li>nfp</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="tc"><a href="#tc" class="headerlink" title="tc"></a>tc</h3><p>除了 XDP 等类型的程序之外,BPF 还可以用于内核数据路径的 tc (traffic control,流量控制)层。</p>
<h4 id="tc和XDP的不同"><a href="#tc和XDP的不同" class="headerlink" title="tc和XDP的不同"></a>tc和XDP的不同</h4><blockquote>
<p>从高层看,tc BPF 程序和 XDP BPF 程序有三点主要不同</p>
</blockquote>
<h5 id="输入上下文"><a href="#输入上下文" class="headerlink" title="输入上下文"></a>输入上下文</h5><p>BPF 的输入上下文(input context)是一个 sk_buff 而不是 xdp_buff。<br>当内核协议栈收到一个包时(说明包通过了 XDP 层),它会分配一个缓冲区,解析包,并存储包 的元数据。<br>表示这个包的结构体就是sk_buff。这个结构体会暴露给 BPF 输入上下文, 因此 tc ingress 层的 BPF 程序就可以利用这些(由协议栈提取的)包的元数据。<br>这些元数据很有用,但在包达到 tc 的 hook 点之前,协议栈执行的缓冲区分配、元数据提取和 其他处理等过程也是有开销的。<br>从定义来看xdp_buff 不需要访问这些元数据,因为 XDP hook 在协议栈之前就会被调用。这是 XDP 和 tc hook 性能差距的重要原因之一。</p>
<p>因此attach 到 tc BPF hook 的 BPF 程序可以读取 skb 的<code>mark</code>、<code>pkt_type</code>、<code>protocol</code>、<code>priority</code>、<code>queue_mapping</code>、<code>napi_id</code>、<code>cb[]</code>、<code>hash</code>、<code>tc_classid</code>、<code>tc_index</code>、<code>vlan</code>元数据、XDP 层传过来的自定义元数据以及其他信息。<br>tc BPF 的 BPF 上下文中使用了<code>struct __sk_buff</code>这个结构体中的所有成员字段都定义在 linux/bpf.h 系统头文件。</p>
<p>通常来说sk_buff 和 xdp_buff 完全不同,二者各有有略。<br>例如,sk_buff 修改 与其关联的元数据(its associated metadata)非常方便,但它包含了大量协议相关的信息(例如 GSO 相关的状态),这使得无法仅仅通过重写包数据来切换协议。<br>这是因为协议栈是基于元数据处理包的,而不是每次都去读包的内容。<br>因此BPF 辅助函数需要额外的转换,并且还要正确处理 sk_buff 内部信息。</p>
<p>xdp_buff 没有这些问题,因为它所处的阶段非常早,此时内核还没有分配 sk_buff,因此很容易实现各种类型的数据包重写(packet rewrite)。<br>但是,xdp_buff 的缺点是在它这个阶段进行 mangling 的时候,无法利用到 sk_buff 元数据。<br>解决这个问题的方式是从 XDP BPF 传递自定义的元数据到 tc BPF。<br>这样根据使用场景的不同,可以同时利用这两者 BPF 程序,以达到互补的效果。</p>
<h5 id="hook-触发点"><a href="#hook-触发点" class="headerlink" title="hook 触发点"></a>hook 触发点</h5><p>tc BPF 程序在数据路径上的 ingress 和 egress 点都可以触发；而 XDP BPF 程序 只能在 ingress 点触发。</p>
<p>内核两个 hook 点：</p>
<ul>
<li>ingress hook sch_handle_ingress()：由<code>__netif_receive_skb_core()</code>触发</li>
<li>egress hook sch_handle_egress()：由<code>__dev_queue_xmit()</code>触发</li>
</ul>
<p><code>__netif_receive_skb_core()</code>和<code>__dev_queue_xmit()</code>是 data path 的主要接收和 发送函数,不考虑 XDP 的话(XDP 可能会拦截或修改,导致不经过这两个 hook 点), 每个网络进入或离开系统的网络包都会经过这两个点,从而使得 tc BPF 程序具备完全可观测性。</p>
<h5 id="是否依赖驱动支持"><a href="#是否依赖驱动支持" class="headerlink" title="是否依赖驱动支持"></a>是否依赖驱动支持</h5><p>tc BPF 程序不需要驱动做任何改动,因为它们运行在网络栈通用层中的 hook 点。因 此它们可以 attach 到任何类型的网络设备上。</p>
<blockquote>
<p>Ingress</p>
</blockquote>
<p>这提供了很好的灵活性,但跟运行在原生 XDP 层的程序相比,性能要差一些。<br>然而tc BPF 程序仍然是内核的通用 data path 做完 GRO 之后、且处理任何协议之前最早的 处理点。<br>传统的 iptables 防火墙也是在这里处理的,例如<code>iptables PREROUTING</code>或<code>nftables ingress hook</code>或其他数据包包处理过程。</p>
<blockquote>
<p>Egress</p>
</blockquote>
<p>类似的,对于 egress,tc BPF 程序在将包交给驱动之前的最晚的地方(latest point)执 行,这个地方在传统 iptables 防火墙 hook 之后(例如 iptables POSTROUTING), 但在内核 GSO 引擎之前。</p>
<p>唯一需要驱动做改动的场景是:将 tc BPF 程序 offload 到网卡。<br>形式通常和 XDP offload 类似，只是特性列表不同，因为二者的 BPF 输入上下文、辅助函数和返回码（ verdict）不同。</p>
<p><br></p>
<h4 id="cls-bpf-分类器"><a href="#cls-bpf-分类器" class="headerlink" title="cls_bpf 分类器"></a>cls_bpf 分类器</h4><p>运行在 tc 层的 BPF 程序使用的是 <code>cls_bpf</code> 分类器。<br>在 tc 术语中<code>“BPF 附着点”</code>被 称为<code>“分类器”</code>，但这个词其实有点误导，因为它少描述了前者可以做的事情。<br>attachment point 是一个完全可编程的包处理器，不仅能够读取 skb 元数据 和包数据，还可以任意 mangle 这两者，最后结束 tc 处理过程，返回一个裁定结果。<br>因此 <code>cls_bpf</code> 可以认为是一个管理和执行 tc BPF 程序的自包含实体。</p>
<p><code>cls_bpf</code> 可以持有（hold）一个或多个 tc BPF 程序。<br>Cilium 在部署 <code>cls_bpf</code> 程序时 ，对于一个给定的 hook 点只会附着一个程序，并且用的是 direct-action 模式。<br>典型情况下，在传统 tc 方案中，分类器（classifier ）和动作模块（action modules） 之间是分开的，每个分类器可以 attach 多个 action，当匹配到这个分类器时这些 action 就会执行。</p>
<p><code>cls_bpf</code>是 tc 层中唯一支持这种快速路径（fast-path）的一个分类器模块。</p>
<p><code>cls_bpf</code>可以附着的 tc ingress 和 egress hook 点都是由一个名为<code>sch_clsact</code>的伪 qdisc 管理的，它是 ingress qdisc 的一个超集（superset），可以无缝替换后 者，因为它既可以管理 ingress tc hook 又可以管理 egress tc hook。<br>对于<code>__dev_queue_xmit()</code>内的 tc egress hook，需要注意的是这个 hook 并不是在内核的 qdisc root lock 下执行的。<br>因此ingress 和 egress hook 都是在快速路径中以无锁（ lockless）方式执行的。<br>不管是 ingress 还是 egress，抢占（preemption ）都被关闭， 执行发生在 RCU 读侧</p>
<p>通常在 egress 的场景下，有很多类型的 qdisc 会 attach 到 netdevice，例如 sch_mq, sch_fq, sch_fq_codel or sch_htb，其中某些是 classful qdiscs，这些 qdisc 包含 subclasses 因此需要一个对包进行分类的机制，决定将包 demux 到哪里。<br>这个机制是 由调用 tcf_classify() 实现的，这个函数会进一步调用 tc 分类器（如果提供了）。<br>在这种场景下cls_bpf 也可以被 attach 和使用。<br>这种操作通常发生在 qdisc root lock 下面，因此会面临锁竞争的问题。<br>sch_clsact qdisc 的 egress hook 点位于更前面，没有落入这个锁的范围内，因此完全独立于常规 egress qdisc 而执行。<br>因此对于 sch_htb 这种场景，sch_clsact qdisc 可以将繁重的包分类工作放到 tc BPF 程序，在 qdisc root lock 之外执行，在这些 tc BPF 程序中设置 skb-&gt;mark 或 skb-&gt;priority ，因此随后 sch_htb 只需要一个简单的映射，没有原来在 root lock 下面昂贵的包分类开销，还减少了锁竞争。</p>
<p>在 sch_clsact in combination with cls_bpf 场景下支持 Offloaded tc BPF 程序， 在这种场景下，原来加载到智能网卡驱动的 BPF 程序被 JIT，在网卡原生执行。<br>只有工作在 direct-action 模式的 cls_bpf 程序支持 offload。 cls_bpf 只支持 offload 单个程序，不支持同时 offload 多个程序。另外只有 ingress hook 支持 offloading BPF 程序。</p>
<p>一个 cls_bpf 实例内部可以 hold 多个 tc BPF 程序。<br>如果由多个程序， <code>TC_ACT_UNSPEC</code>程序返回码就是让继续执行列表中的下一个程序。<br>但这种方式的缺点是:每个程序都需要解析一遍数据包，性能会下降。</p>
<p><br></p>
<h4 id="tc-BPF-程序返回码"><a href="#tc-BPF-程序返回码" class="headerlink" title="tc BPF 程序返回码"></a>tc BPF 程序返回码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TC_ACT_UNSPEC         (-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TC_ACT_OK               0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TC_ACT_SHOT             2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TC_ACT_STOLEN           4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TC_ACT_REDIRECT         7</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>TC_ACT_REDIRECT</code></p>
</blockquote>
<p>这个返回码加上<code>bpf_redirect()</code>辅助函数，允许重定向一个 skb 到同一个或另一个设备的 ingress 或 egress 路径。<br>能够将包注入另一个设备的 ingress 或 egress 路径使得基于 BPF 的包转发具备了完全的灵活性。</p>
<blockquote>
<p><code>TC_ACT_SHOT</code>和<code>TC_ACT_STOLEN</code></p>
</blockquote>
<p>这两个返回码指示内核将包丢弃。这两个返回码很相似，只有少数几个区别：</p>
<ul>
<li><code>TC_ACT_SHOT</code>提示内核 skb 是通过<code>kfree_skb()</code>释放的，并返回<code>NET_XMIT_DROP</code>给调用方，作为立即反馈</li>
<li><code>TC_ACT_STOLEN</code>通过<code>consume_skb()</code>释放 skb，返回<code>NET_XMIT_SUCCESS</code>给上 层假装这个包已经被正确发送了</li>
</ul>
<p>perf 的丢包监控（drop monitor）是跟踪的<code>kfree_skb()</code>，因此在<code>TC_ACT_STOLEN</code>的 场景下它无法看到任何丢包统计，因为从语义上说，此时这些 skb 是被<code>”consumed”</code>或<code>queued</code> 而不是被<code>dropped</code>。</p>
<blockquote>
<p><code>TC_ACT_UNSPEC</code>和<code>TC_ACT_OK</code></p>
</blockquote>
<p><code>TC_ACT_UNSPEC</code>表示“未指定的动作”，在三种情况下会用到：</p>
<ul>
<li>attach 了一个 offloaded tc BPF 程序，tc ingress hook 正在运行，被 offload 的 程序的 cls_bpf 表示会返回<code>TC_ACT_UNSPEC</code></li>
<li>为了在 cls_bpf 多程序的情况下，继续下一个 tc BPF 程序。这种情况可以和 第一种情况中提到的 offloaded tc BPF 程序一起使用，此时第一种情况返回的<code>TC_ACT_UNSPEC</code>继续执行下一个没有被 offloaded BPF 程序？</li>
<li><code>TC_ACT_UNSPEC</code>还用于单个程序从场景，只是通知内核继续执行 skb 处理，但不要带 来任何副作用（without additional side-effects）。</li>
</ul>
<p><code>TC_ACT_UNSPEC</code>在某些方面和<code>TC_ACT_OK</code>非常类似，因为二者都是将 skb 向下一个 处理阶段传递，在 ingress 的情况下是传递给内核协议栈的更上层，在 egress 的情况下 是传递给网络设备驱动。</p>
<p>唯一的不同是<code>TC_ACT_OK</code>基于 tc BPF 程序设置的 classid 来 设置<code>skb-&gt;tc_index</code>，而<code>TC_ACT_UNSPEC</code>是通过 tc BPF 程序之外的 BPF 上下文中的<code>skb-&gt;tc_classid</code>设置。</p>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2022/01/23/bpf/';
        this.page.title = 'Linux-BPF原理';
        this.page.identifier = '2022/01/23/bpf/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
