<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Sharding-Jdbc | Coderss</title>
    <meta name="author" content="coder">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="">
    <meta name="description" content="sharding-jdbc 相关的源码详解笔记 
简介
从mybatis层开始,主要经过如下
12345678//Executor层DefaultSqlSession-&amp;gt;CachingExecutor-&amp;gt;BaseExecutor-&amp;gt;SimpleExecutor|//Statement层RoutingStatementHandler-&amp;gt;PreparedStatementHandler|//Sharding-jdbc Statement层ShardingPrepareStat">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="baidu-site-verification" content="F0CXvmUgA9">

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/back-end">Java后端</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cpp">Cpp嵌入式</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/go">Go云原生</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/cloud">Linux安全</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/reverse">Win安全</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/data">数据与算法</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/categories/work">工作相关</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">文章标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost库/">Boost库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp编程/">Cpp编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fescar/">Fescar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gc/">Gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Net/">Net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nosql/">Nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python计算库/">Python计算库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rust/">Rust</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SkyWalking/">SkyWalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Turi/">Turi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows系统/">Windows系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows驱动/">Windows驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/">assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-cpp语言/">c/cpp语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eth/">eth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-kernel/">go-kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mfc/">mfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-book/">python-book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skycoin/">skycoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/">spring-cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-Windows系统总结/">x86 Windows系统总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中台/">中台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件系统/">分布式文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/嵌入式/">嵌入式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息队列/">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">历史归档</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://www.coderss.cn"></form>

        
        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#解析"><span class="toc-number">1.1.</span> <span class="toc-text">解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#词法解析"><span class="toc-number">1.1.1.</span> <span class="toc-text">词法解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lexer-词法解析器"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">Lexer 词法解析器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Token-词法标记"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">Token 词法标记</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sql解析"><span class="toc-number">1.1.2.</span> <span class="toc-text">Sql解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SQLParser"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">SQLParser</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL表达式"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">SQL表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StatementParser"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">StatementParser</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SelectStatementParser"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">SelectStatementParser</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#InsertStatementParser"><span class="toc-number">1.1.2.3.2.</span> <span class="toc-text">InsertStatementParser</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UpdateStatementParser"><span class="toc-number">1.1.2.3.3.</span> <span class="toc-text">UpdateStatementParser</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DeleteStatementParser"><span class="toc-number">1.1.2.3.4.</span> <span class="toc-text">DeleteStatementParser</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#路由"><span class="toc-number">1.2.</span> <span class="toc-text">路由</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分片路由"><span class="toc-number">1.2.1.</span> <span class="toc-text">分片路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#直接路由"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">直接路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标准路由"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">标准路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#笛卡尔路由"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">笛卡尔路由</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#广播路由"><span class="toc-number">1.2.2.</span> <span class="toc-text">广播路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#全库表路由"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">全库表路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全库路由"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">全库路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全实例路由"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">全实例路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单播路由"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">单播路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#阻断路由"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">阻断路由</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#改写"><span class="toc-number">1.3.</span> <span class="toc-text">改写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#改写引擎"><span class="toc-number">1.3.1.</span> <span class="toc-text">改写引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流式归并优化"><span class="toc-number">1.3.2.</span> <span class="toc-text">流式归并优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行"><span class="toc-number">1.4.</span> <span class="toc-text">执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#准备阶段-SQLExecutePrepareTemplate"><span class="toc-number">1.4.1.</span> <span class="toc-text">准备阶段-SQLExecutePrepareTemplate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行阶段-SQLExecuteTemplate"><span class="toc-number">1.4.2.</span> <span class="toc-text">执行阶段-SQLExecuteTemplate</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#归并"><span class="toc-number">1.5.</span> <span class="toc-text">归并</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MergeEngineFactory-归并引擎工厂类"><span class="toc-number">1.5.1.</span> <span class="toc-text">MergeEngineFactory-归并引擎工厂类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DQLMergeEngine引擎"><span class="toc-number">1.5.2.</span> <span class="toc-text">DQLMergeEngine引擎</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分布式主键"><span class="toc-number">1.6.</span> <span class="toc-text">分布式主键</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DefaultKeyGenerator"><span class="toc-number">1.6.1.</span> <span class="toc-text">DefaultKeyGenerator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HostNameKeyGenerator"><span class="toc-number">1.6.2.</span> <span class="toc-text">HostNameKeyGenerator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPKeyGenerator"><span class="toc-number">1.6.3.</span> <span class="toc-text">IPKeyGenerator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPSectionKeyGenerator"><span class="toc-number">1.6.4.</span> <span class="toc-text">IPSectionKeyGenerator</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注意事项"><span class="toc-number">2.</span> <span class="toc-text">注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL"><span class="toc-number">2.1.</span> <span class="toc-text">SQL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#支持项"><span class="toc-number">2.2.</span> <span class="toc-text">支持项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不支持项"><span class="toc-number">2.3.</span> <span class="toc-text">不支持项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例"><span class="toc-number">2.4.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#支持的SQL"><span class="toc-number">2.4.1.</span> <span class="toc-text">支持的SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不支持的SQL"><span class="toc-number">2.4.2.</span> <span class="toc-text">不支持的SQL</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#性能测试"><span class="toc-number">3.</span> <span class="toc-text">性能测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单线程25w"><span class="toc-number">3.1.</span> <span class="toc-text">单线程25w</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程42w"><span class="toc-number">3.2.</span> <span class="toc-text">多线程42w</span></a></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
           Sharding-Jdbc
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/10/08/sharding-jdbc/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-10-08T07:57:44.000Z" itemprop="datePublished">2017-10-08</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Sharding-jdbc/">Sharding-jdbc</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>sharding-jdbc 相关的源码详解笔记<br><a id="more"></a> </p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><img src="/2017/10/08/sharding-jdbc/image_01.png" width="350px"></p>
<p>从<code>mybatis</code>层开始,主要经过如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Executor层</span></span><br><span class="line">DefaultSqlSession-&gt;CachingExecutor-&gt;BaseExecutor-&gt;SimpleExecutor</span><br><span class="line">|</span><br><span class="line"><span class="comment">//Statement层</span></span><br><span class="line">RoutingStatementHandler-&gt;PreparedStatementHandler</span><br><span class="line">|</span><br><span class="line"><span class="comment">//Sharding-jdbc Statement层</span></span><br><span class="line">ShardingPrepareStatement-&gt;PrepareStatementRoutingEngine-&gt;ParsingSQLRouter(解析Sql)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果我理得没错的话,应该是这样的 </span></span><br><span class="line"></span><br><span class="line">MasterSlaveStatement</span><br><span class="line">|</span><br><span class="line">RuntimeContext: sqlParserEngine(解析器),executorKernel(执行器), 从connection里拿到这个运行上下文再进行sql解析形成SQLStatement   `解析引擎`</span><br><span class="line">|</span><br><span class="line">RouteDecorator-&gt;MasterSlaveRouteDecorator: 通过SQLStatement装饰器模式再进行路由形成routeContext    `路由引擎`</span><br><span class="line">|</span><br><span class="line">Statement.executeUpdate: 在rootContext中最后遍历每个route节点去执行 </span><br><span class="line">|</span><br><span class="line">ShardingStatement.createExecutionContext: 执行前先进行sql改写  `改写引擎`</span><br><span class="line">|</span><br><span class="line">StatementExecutor.executeUpdate: 最后由这个statement执行器去执行</span><br><span class="line">|</span><br><span class="line">SqlExecutor.execute: 执行的时候流到 `执行引擎`</span><br><span class="line">|</span><br><span class="line">ShardingStatement.executeQuery: 在ShardingStatement如果执行的是executeQuery则后期会引入mergeQuery进行结果集合并</span><br><span class="line">|</span><br><span class="line">MergeEngine.merge-&gt;decorate: 采用装饰器模式流入  `归并引擎`</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><img src="/2017/10/08/sharding-jdbc/image-17.png" width="700px"></p>
<p><code>ParsingSQLRouter</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</span><br><span class="line">    GeneratedKey generatedKey = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> InsertStatement) &#123;</span><br><span class="line">        generatedKey = getGenerateKey(shardingRule, (InsertStatement) sqlStatement, parameters);</span><br><span class="line">    &#125;</span><br><span class="line">    SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement, generatedKey);</span><br><span class="line">    ShardingConditions shardingConditions = OptimizeEngineFactory.newInstance(shardingRule, sqlStatement, parameters, generatedKey).optimize();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != generatedKey) &#123;</span><br><span class="line">        setGeneratedKeys(result, generatedKey);</span><br><span class="line">    &#125;</span><br><span class="line">    RoutingResult routingResult = route(sqlStatement, shardingConditions);</span><br><span class="line">    SQLRewriteEngine rewriteEngine = <span class="keyword">new</span> SQLRewriteEngine(shardingRule, logicSQL, databaseType, sqlStatement, shardingConditions, parameters);</span><br><span class="line">    <span class="keyword">boolean</span> isSingleRouting = routingResult.isSingleRouting();</span><br><span class="line">    <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> SelectStatement &amp;&amp; <span class="keyword">null</span> != ((SelectStatement) sqlStatement).getLimit()) &#123;</span><br><span class="line">        processLimit(parameters, (SelectStatement) sqlStatement, isSingleRouting);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sql改写</span></span><br><span class="line">    SQLBuilder sqlBuilder = rewriteEngine.rewrite(!isSingleRouting);</span><br><span class="line">    <span class="keyword">for</span> (TableUnit each : routingResult.getTableUnits().getTableUnits()) &#123;</span><br><span class="line">        <span class="comment">//解析Sql并改写sql后add添加进去</span></span><br><span class="line">        result.getRouteUnits().add(<span class="keyword">new</span> RouteUnit(each.getDataSourceName(), rewriteEngine.generateSQL(each, sqlBuilder, shardingDataSourceMetaData)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (showSQL) &#123;</span><br><span class="line">        SQLLogger.logSQL(logicSQL, sqlStatement, result.getRouteUnits());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="词法解析"><a href="#词法解析" class="headerlink" title="词法解析"></a>词法解析</h3><h4 id="Lexer-词法解析器"><a href="#Lexer-词法解析器" class="headerlink" title="Lexer 词法解析器"></a>Lexer 词法解析器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分析下一个词法标记.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #currentToken</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #offset</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">nextToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    skipIgnoredToken();</span><br><span class="line">    <span class="keyword">if</span> (isVariableBegin()) &#123; <span class="comment">// 变量</span></span><br><span class="line">        currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanVariable();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isNCharBegin()) &#123; <span class="comment">// N\</span></span><br><span class="line">        currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, ++offset).scanChars();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isIdentifierBegin()) &#123; <span class="comment">// Keyword + Literals.IDENTIFIER</span></span><br><span class="line">        currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanIdentifier();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isHexDecimalBegin()) &#123; <span class="comment">// 十六进制</span></span><br><span class="line">        currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanHexDecimal();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isNumberBegin()) &#123; <span class="comment">// 数字（整数+浮点数）</span></span><br><span class="line">        currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanNumber();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSymbolBegin()) &#123; <span class="comment">// 符号</span></span><br><span class="line">        currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanSymbol();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCharsBegin()) &#123; <span class="comment">// 字符串，例如："abc"</span></span><br><span class="line">        currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanChars();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isEnd()) &#123; <span class="comment">// 结束</span></span><br><span class="line">        currentToken = <span class="keyword">new</span> Token(Assist.END, <span class="string">""</span>, offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 分析错误，无符合条件的词法标记</span></span><br><span class="line">        currentToken = <span class="keyword">new</span> Token(Assist.ERROR, <span class="string">""</span>, offset);</span><br><span class="line">    &#125;</span><br><span class="line">    offset = currentToken.getEndPosition();</span><br><span class="line">    <span class="comment">// System.out.println("| " + currentToken.getLiterals() + " | " + currentToken.getType() + " | " + currentToken.getEndPosition() + " |");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳过忽略的词法标记</span></span><br><span class="line"><span class="comment"> * 1. 空格</span></span><br><span class="line"><span class="comment"> * 2. SQL Hint</span></span><br><span class="line"><span class="comment"> * 3. SQL 注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">skipIgnoredToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空格</span></span><br><span class="line">    offset = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).skipWhitespace();</span><br><span class="line">    <span class="comment">// SQL Hint</span></span><br><span class="line">    <span class="keyword">while</span> (isHintBegin()) &#123;</span><br><span class="line">        offset = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).skipHint();</span><br><span class="line">        offset = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).skipWhitespace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// SQL 注释</span></span><br><span class="line">    <span class="keyword">while</span> (isCommentBegin()) &#123;</span><br><span class="line">        offset = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).skipComment();</span><br><span class="line">        offset = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).skipWhitespace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tokenizer负责<strong>分词</strong>。</p>
<p><code>*Lexer#nextToken()</code> 方法里，使用 <code>#skipIgnoredToken()</code> 方法跳过忽略的 Token，通过 <code>#isXXXX()</code>方法判断好下一个 Token 的类型后</p>
<p><strong>交给 Tokenizer 进行分词返回 Token</strong>。‼️</p>
<p><img src="/2017/10/08/sharding-jdbc/image-02.png" width="500px"></p>
<h4 id="Token-词法标记"><a href="#Token-词法标记" class="headerlink" title="Token 词法标记"></a>Token 词法标记</h4><p> Token 的例子，一共有 3 个属性：</p>
<ul>
<li>TokenType type ：词法标记类型</li>
<li>String literals ：词法字面量标记</li>
<li>int endPosition ：<code>literals</code> 在 SQL 里的结束位置</li>
</ul>
<p>TokenType 词法标记类型，一共分成 4 个大类：</p>
<ul>
<li>DefaultKeyword ：词法关键词</li>
<li>Literals ：词法字面量标记</li>
<li>Symbol ：词法符号标记</li>
<li>Assist ：词法辅助标记</li>
</ul>
<p><img src="/2017/10/08/sharding-jdbc/image-03.png" width="500px"></p>
<p><img src="/2017/10/08/sharding-jdbc/image-04.png" width="500px"></p>
<h3 id="Sql解析"><a href="#Sql解析" class="headerlink" title="Sql解析"></a>Sql解析</h3><p><img src="/2017/10/08/sharding-jdbc/image-05.png" width="500px"></p>
<p>Parser 有三个组件：</p>
<ul>
<li>SQLParsingEngine ：SQL 解析引擎</li>
<li>StatementParser ：SQL语句解析器</li>
<li>SQLParser ：SQL 解析器</li>
</ul>
<p>SQLParsingEngine 实例化合适的SqlParse</p>
<p>StatementParser 调用SQLParser 解析 SQL 表达式(SqlExpression)。</p>
<p>实例化最终的Select/Update/Delete/InsertStatement,并且SqlParse为最终的Statement组装最后执行语句</p>
<blockquote>
<p> SQLParsingEngine</p>
</blockquote>
<p>SQL 解析引擎。其 <code>#parse()</code> 方法作为 SQL 解析入口，本身不带复杂逻辑，通过调用 SQL 对应的 StatementParser 进行 SQL 解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQLParsingEngine.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取 SQL解析器</span></span><br><span class="line">   SQLParser sqlParser = getSQLParser();</span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   sqlParser.skipIfEqual(Symbol.SEMI); <span class="comment">// 跳过 ";"</span></span><br><span class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.WITH)) &#123; <span class="comment">// WITH Syntax</span></span><br><span class="line">       skipWith(sqlParser);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 获取对应 SQL语句解析器 解析SQL</span></span><br><span class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.SELECT)) &#123;</span><br><span class="line">       <span class="keyword">return</span> SelectParserFactory.newInstance(sqlParser).parse();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.INSERT)) &#123;</span><br><span class="line">       <span class="keyword">return</span> InsertParserFactory.newInstance(shardingRule, sqlParser).parse();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.UPDATE)) &#123;</span><br><span class="line">       <span class="keyword">return</span> UpdateParserFactory.newInstance(sqlParser).parse();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.DELETE)) &#123;</span><br><span class="line">       <span class="keyword">return</span> DeleteParserFactory.newInstance(sqlParser).parse();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingUnsupportedException(sqlParser.getLexer().getCurrentToken().getType());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2017/10/08/sharding-jdbc/image-06.png" width="1000px"></p>
<h4 id="SQLParser"><a href="#SQLParser" class="headerlink" title="SQLParser"></a>SQLParser</h4><p>SQLParser 看起来方法特别多，合并下一共 5 种：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>#parseExpression()</td>
<td>解析表达式</td>
</tr>
<tr>
<td>#parseAlias()</td>
<td>解析别名</td>
</tr>
<tr>
<td>#parseSingleTable()</td>
<td>解析单表</td>
</tr>
<tr>
<td>#skipJoin()</td>
<td>跳过表关联词法</td>
</tr>
<tr>
<td>#parseWhere()</td>
<td>解析查询条件</td>
</tr>
</tbody>
</table>
<p>SQLParser 不考虑 SQL 是 SELECT / INSERT / UPDATE / DELETE ，它考虑的是，<strong>给我的是 WHERE 处解析查询条件，或是 INSERT INTO 解析单表 等</strong>，提供 SELECT / INSERT / UPDATE / DELETE 需要的 SQL 块公用解析。</p>
<p><img src="/2017/10/08/sharding-jdbc/image-07.png" width="500px"></p>
<ul>
<li><p>parseAlias()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 解析别名.不仅仅是字段的别名，也可以是表的别名。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 别名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">parseAlias</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 解析带 AS 情况</span></span><br><span class="line">   <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.AS)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (equalAny(Symbol.values())) &#123;</span><br><span class="line">           <span class="keyword">return</span> Optional.absent();</span><br><span class="line">       &#125;</span><br><span class="line">       String result = SQLUtil.getExactlyValue(getLexer().getCurrentToken().getLiterals());</span><br><span class="line">       getLexer().nextToken();</span><br><span class="line">       <span class="keyword">return</span> Optional.of(result);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解析别名</span></span><br><span class="line">   <span class="comment">// TODO 增加哪些数据库识别哪些关键字作为别名的配置</span></span><br><span class="line">   <span class="keyword">if</span> (equalAny(Literals.IDENTIFIER, Literals.CHARS, DefaultKeyword.USER, DefaultKeyword.END, DefaultKeyword.CASE, DefaultKeyword.KEY, DefaultKeyword.INTERVAL, DefaultKeyword.CONSTRAINT)) &#123;</span><br><span class="line">       String result = SQLUtil.getExactlyValue(getLexer().getCurrentToken().getLiterals());</span><br><span class="line">       getLexer().nextToken();</span><br><span class="line">       <span class="keyword">return</span> Optional.of(result);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> Optional.absent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>parseSingleTable()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 解析单表.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> sqlStatement SQL语句对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseSingleTable</span><span class="params">(<span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> hasParentheses = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (skipIfEqual(Symbol.LEFT_PAREN)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (equalAny(DefaultKeyword.SELECT)) &#123; <span class="comment">// multiple-update 或者 multiple-delete</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support subquery"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       hasParentheses = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Table table;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> beginPosition = getLexer().getCurrentToken().getEndPosition() - getLexer().getCurrentToken().getLiterals().length();</span><br><span class="line">   String literals = getLexer().getCurrentToken().getLiterals();</span><br><span class="line">   getLexer().nextToken();</span><br><span class="line">   <span class="keyword">if</span> (skipIfEqual(Symbol.DOT)) &#123;</span><br><span class="line">       getLexer().nextToken();</span><br><span class="line">       <span class="keyword">if</span> (hasParentheses) &#123;</span><br><span class="line">           accept(Symbol.RIGHT_PAREN);</span><br><span class="line">       &#125;</span><br><span class="line">       table = <span class="keyword">new</span> Table(SQLUtil.getExactlyValue(literals), parseAlias());</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (hasParentheses) &#123;</span><br><span class="line">           accept(Symbol.RIGHT_PAREN);</span><br><span class="line">       &#125;</span><br><span class="line">       table = <span class="keyword">new</span> Table(SQLUtil.getExactlyValue(literals), parseAlias());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (skipJoin()) &#123; <span class="comment">// multiple-update 或者 multiple-delete</span></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support Multiple-Table."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   sqlStatement.getSqlTokens().add(<span class="keyword">new</span> TableToken(beginPosition, literals));</span><br><span class="line">   sqlStatement.getTables().add(table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>skipJoin()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQLParser.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 跳过表关联词法.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 是否表关联.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">skipJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.LEFT, DefaultKeyword.RIGHT, DefaultKeyword.FULL)) &#123;</span><br><span class="line">       skipIfEqual(DefaultKeyword.OUTER);</span><br><span class="line">       accept(DefaultKeyword.JOIN);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.INNER)) &#123;</span><br><span class="line">       accept(DefaultKeyword.JOIN);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.JOIN, Symbol.COMMA, DefaultKeyword.STRAIGHT_JOIN)) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.CROSS)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.JOIN, DefaultKeyword.APPLY)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.OUTER)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.APPLY)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>parseWhere()</p>
<p>解析 WHERE 查询条件。目前支持 AND 条件，不支持 OR 条件。近期 OR 条件支持的可能性比较低。另外条件这块对括号解析需要继续优化，实际使用请勿写冗余的括号。例如：<code>SELECT * FROM tbl_name1 WHERE ((val1=?) AND (val2=?)) AND val3 =?</code>。</p>
</li>
</ul>
<h4 id="SQL表达式"><a href="#SQL表达式" class="headerlink" title="SQL表达式"></a>SQL表达式</h4><p>SQLExpression。目前 6 种实现：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类</th>
<th>说明</th>
<th>对应Token</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SQLIdentifierExpression</td>
<td>标识表达式</td>
<td>Literals.IDENTIFIER</td>
</tr>
<tr>
<td style="text-align:center">SQLPropertyExpression</td>
<td>属性表达式</td>
<td>无</td>
</tr>
<tr>
<td style="text-align:center">SQLNumberExpression</td>
<td>数字表达式</td>
<td>Literals.INT, Literals.HEX</td>
</tr>
<tr>
<td style="text-align:center">SQLPlaceholderExpression</td>
<td>占位符表达式</td>
<td>Symbol.QUESTION</td>
</tr>
<tr>
<td style="text-align:center">SQLTextExpression</td>
<td>字符表达式</td>
<td>Literals.CHARS</td>
</tr>
<tr>
<td style="text-align:center">SQLIgnoreExpression</td>
<td>分片中无需关注的SQL表达式</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>通过SqlParse解析成SqlExpression<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQLParser.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 解析表达式.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 表达式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// TODO 完善Expression解析的各种场景</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SQLExpression <span class="title">parseExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 解析表达式</span></span><br><span class="line">   String literals = getLexer().getCurrentToken().getLiterals();</span><br><span class="line">   <span class="keyword">final</span> SQLExpression expression = getExpression(literals);</span><br><span class="line">   <span class="comment">// SQLIdentifierExpression 需要特殊处理。考虑自定义函数，表名.属性情况。</span></span><br><span class="line">   <span class="keyword">if</span> (skipIfEqual(Literals.IDENTIFIER)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (skipIfEqual(Symbol.DOT)) &#123; <span class="comment">// 例如，ORDER BY o.uid 中的 "o.uid"</span></span><br><span class="line">           String property = getLexer().getCurrentToken().getLiterals();</span><br><span class="line">           getLexer().nextToken();</span><br><span class="line">           <span class="keyword">return</span> skipIfCompositeExpression() ? <span class="keyword">new</span> SQLIgnoreExpression() : <span class="keyword">new</span> SQLPropertyExpression(<span class="keyword">new</span> SQLIdentifierExpression(literals), property);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (equalAny(Symbol.LEFT_PAREN)) &#123; <span class="comment">// 例如，GROUP BY DATE(create_time) 中的 "DATE(create_time)"</span></span><br><span class="line">           skipParentheses();</span><br><span class="line">           skipRestCompositeExpression();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SQLIgnoreExpression();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> skipIfCompositeExpression() ? <span class="keyword">new</span> SQLIgnoreExpression() : expression;</span><br><span class="line">   &#125;</span><br><span class="line">   getLexer().nextToken();</span><br><span class="line">   <span class="keyword">return</span> skipIfCompositeExpression() ? <span class="keyword">new</span> SQLIgnoreExpression() : expression;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获得 词法Token 对应的 SQLExpression</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> literals 词法字面量标记</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> SQLExpression</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SQLExpression <span class="title">getExpression</span><span class="params">(<span class="keyword">final</span> String literals)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (equalAny(Symbol.QUESTION)) &#123;</span><br><span class="line">       increaseParametersIndex();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLPlaceholderExpression(getParametersIndex() - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (equalAny(Literals.CHARS)) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLTextExpression(literals);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// TODO 考虑long的情况</span></span><br><span class="line">   <span class="keyword">if</span> (equalAny(Literals.INT)) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLNumberExpression(Integer.parseInt(literals));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (equalAny(Literals.FLOAT)) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLNumberExpression(Double.parseDouble(literals));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// TODO 考虑long的情况</span></span><br><span class="line">   <span class="keyword">if</span> (equalAny(Literals.HEX)) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLNumberExpression(Integer.parseInt(literals, <span class="number">16</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (equalAny(Literals.IDENTIFIER)) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLIdentifierExpression(SQLUtil.getExactlyValue(literals));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> SQLIgnoreExpression();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果是 复合表达式，跳过。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 是否跳过</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">skipIfCompositeExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (equalAny(Symbol.PLUS, Symbol.SUB, Symbol.STAR, Symbol.SLASH, Symbol.PERCENT, Symbol.AMP, Symbol.BAR, Symbol.DOUBLE_AMP, Symbol.DOUBLE_BAR, Symbol.CARET, Symbol.DOT, Symbol.LEFT_PAREN)) &#123;</span><br><span class="line">       skipParentheses();</span><br><span class="line">       skipRestCompositeExpression();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 跳过剩余复合表达式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">skipRestCompositeExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> (skipIfEqual(Symbol.PLUS, Symbol.SUB, Symbol.STAR, Symbol.SLASH, Symbol.PERCENT, Symbol.AMP, Symbol.BAR, Symbol.DOUBLE_AMP, Symbol.DOUBLE_BAR, Symbol.CARET, Symbol.DOT)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (equalAny(Symbol.QUESTION)) &#123;</span><br><span class="line">           increaseParametersIndex();</span><br><span class="line">       &#125;</span><br><span class="line">       getLexer().nextToken();</span><br><span class="line">       skipParentheses();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="StatementParser"><a href="#StatementParser" class="headerlink" title="StatementParser"></a>StatementParser</h4><p>StatementParser，SQL语句解析器。每种 SQL，都有相应的 SQL语句解析器实现。不同数据库，继承这些 SQL语句解析器，实现各自 SQL 上的差异</p>
<p><img src="/2017/10/08/sharding-jdbc/image-08.png" width="900px"></p>
<h5 id="SelectStatementParser"><a href="#SelectStatementParser" class="headerlink" title="SelectStatementParser"></a>SelectStatementParser</h5><p>由于每个数据库在遵守 SQL 语法规范的同时，又有各自独特的语法。</p>
<p>因此，在 Sharding-JDBC 里每个数据库都有自己的 SELECT 语句的解析器实现方式，当然绝大部分逻辑是相同的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SelectStatement.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectStatement</span> <span class="keyword">extends</span> <span class="title">AbstractSQLStatement</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否行 DISTINCT / DISTINCTROW / UNION</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> distinct;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否查询所有字段，即 SELECT *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> containStar;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后一个查询项下一个 Token 的开始位置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #items</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> selectListLastPosition;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后一个分组项下一个 Token 的开始位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> groupByLastPosition;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SelectItem&gt; items = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分组项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OrderItem&gt; groupByItems = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OrderItem&gt; orderByItems = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Limit limit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSQLStatement</span> <span class="keyword">implements</span> <span class="title">SQLStatement</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SQL 类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SQLType type;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Tables tables = <span class="keyword">new</span> Tables();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤条件。</span></span><br><span class="line"><span class="comment">     * 只有对路由结果有影响的条件，才添加进数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Conditions conditions = <span class="keyword">new</span> Conditions();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SQL标记对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2017/10/08/sharding-jdbc/image-09.png" width="500px"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MySQLSelectParser.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (getSqlParser().equalAny(DefaultKeyword.SELECT)) &#123;</span><br><span class="line">       getSqlParser().getLexer().nextToken();</span><br><span class="line">       parseDistinct();</span><br><span class="line">       getSqlParser().skipAll(MySQLKeyword.HIGH_PRIORITY, DefaultKeyword.STRAIGHT_JOIN, MySQLKeyword.SQL_SMALL_RESULT, MySQLKeyword.SQL_BIG_RESULT, MySQLKeyword.SQL_BUFFER_RESULT,</span><br><span class="line">               MySQLKeyword.SQL_CACHE, MySQLKeyword.SQL_NO_CACHE, MySQLKeyword.SQL_CALC_FOUND_ROWS);</span><br><span class="line">       parseSelectList(); <span class="comment">// 解析 查询字段</span></span><br><span class="line">       skipToFrom(); <span class="comment">// 跳到 FROM 处</span></span><br><span class="line">   &#125;</span><br><span class="line">   parseFrom();<span class="comment">// 解析 表（JOIN ON / FROM 单&amp;多表）</span></span><br><span class="line">   parseWhere(); <span class="comment">// 解析 WHERE 条件</span></span><br><span class="line">   parseGroupBy(); <span class="comment">// 解析 Group By 和 Having（目前不支持）条件</span></span><br><span class="line">   parseOrderBy(); <span class="comment">// 解析 Order By 条件</span></span><br><span class="line">   parseLimit(); <span class="comment">// 解析 分页 Limit 条件</span></span><br><span class="line">   <span class="comment">// [PROCEDURE] 暂不支持</span></span><br><span class="line">   <span class="keyword">if</span> (getSqlParser().equalAny(DefaultKeyword.PROCEDURE)) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingUnsupportedException(getSqlParser().getLexer().getCurrentToken().getType());</span><br><span class="line">   &#125;</span><br><span class="line">   queryRest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// https://dev.mysql.com/doc/refman/5.7/en/select.html</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    [ALL | <span class="keyword">DISTINCT</span> | <span class="keyword">DISTINCTROW</span> ]</span><br><span class="line">      [<span class="keyword">HIGH_PRIORITY</span>]</span><br><span class="line">      [<span class="keyword">STRAIGHT_JOIN</span>]</span><br><span class="line">      [<span class="keyword">SQL_SMALL_RESULT</span>] [<span class="keyword">SQL_BIG_RESULT</span>] [<span class="keyword">SQL_BUFFER_RESULT</span>]</span><br><span class="line">      [<span class="keyword">SQL_CACHE</span> | SQL_NO_CACHE] [<span class="keyword">SQL_CALC_FOUND_ROWS</span>]</span><br><span class="line">    select_expr [, select_expr ...]</span><br><span class="line">    [<span class="keyword">FROM</span> table_references</span><br><span class="line">      [<span class="keyword">PARTITION</span> partition_list]</span><br><span class="line">    [<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">    [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &#123;col_name | expr | <span class="keyword">position</span>&#125;</span><br><span class="line">      [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ... [<span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>]]</span><br><span class="line">    [<span class="keyword">HAVING</span> where_condition]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;col_name | expr | <span class="keyword">position</span>&#125;</span><br><span class="line">      [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ...]</span><br><span class="line">    [<span class="keyword">LIMIT</span> &#123;[<span class="keyword">offset</span>,] <span class="keyword">row_count</span> | <span class="keyword">row_count</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span>&#125;]</span><br><span class="line">    [<span class="keyword">PROCEDURE</span> procedure_name(argument_list)]</span><br><span class="line">    [<span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'file_name'</span></span><br><span class="line">        [<span class="built_in">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">        export_options</span><br><span class="line">      | <span class="keyword">INTO</span> <span class="keyword">DUMPFILE</span> <span class="string">'file_name'</span></span><br><span class="line">      | <span class="keyword">INTO</span> var_name [, var_name]]</span><br><span class="line">    [<span class="keyword">FOR</span> <span class="keyword">UPDATE</span> | <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>]]</span><br></pre></td></tr></table></figure>
<h5 id="InsertStatementParser"><a href="#InsertStatementParser" class="headerlink" title="InsertStatementParser"></a>InsertStatementParser</h5><p>MySQL INSERT 语法一共有 3 种 ：</p>
<ul>
<li>第一种：<code>INSERT {VALUES | VALUES}</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [<span class="keyword">LOW_PRIORITY</span> | <span class="keyword">DELAYED</span> | <span class="keyword">HIGH_PRIORITY</span>] [<span class="keyword">IGNORE</span>]</span><br><span class="line">    [<span class="keyword">INTO</span>] tbl_name</span><br><span class="line">    [<span class="keyword">PARTITION</span> (partition_name,...)]</span><br><span class="line">    [(col_name,...)]</span><br><span class="line">    &#123;<span class="keyword">VALUES</span> | <span class="keyword">VALUE</span>&#125; (&#123;expr | <span class="keyword">DEFAULT</span>&#125;,...),(...),...</span><br><span class="line">    [ <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span></span><br><span class="line">      col_name=expr</span><br><span class="line">        [, col_name=expr] ... ]</span><br></pre></td></tr></table></figure>
<ul>
<li>第二种：<code>INSERT SET</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [<span class="keyword">LOW_PRIORITY</span> | <span class="keyword">DELAYED</span> | <span class="keyword">HIGH_PRIORITY</span>] [<span class="keyword">IGNORE</span>]</span><br><span class="line">    [<span class="keyword">INTO</span>] tbl_name</span><br><span class="line">    [<span class="keyword">PARTITION</span> (partition_name,...)]</span><br><span class="line">    <span class="keyword">SET</span> col_name=&#123;expr | <span class="keyword">DEFAULT</span>&#125;, ...</span><br><span class="line">    [ <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span></span><br><span class="line">      col_name=expr</span><br><span class="line">        [, col_name=expr] ... ]</span><br></pre></td></tr></table></figure>
<ul>
<li>第三种：<code>INSERT SELECT</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [<span class="keyword">LOW_PRIORITY</span> | <span class="keyword">HIGH_PRIORITY</span>] [<span class="keyword">IGNORE</span>]</span><br><span class="line">    [<span class="keyword">INTO</span>] tbl_name</span><br><span class="line">    [<span class="keyword">PARTITION</span> (partition_name,...)]</span><br><span class="line">    [(col_name,...)]</span><br><span class="line">    <span class="keyword">SELECT</span> ...</span><br><span class="line">    [ <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span></span><br><span class="line">      col_name=expr</span><br><span class="line">        [, col_name=expr] ... ]</span><br></pre></td></tr></table></figure>
<p>Sharding-JDBC 目前支持：</p>
<ul>
<li>第一种：<code>INSERT {VALUES | VALUES}</code> <strong>单条记录</strong></li>
<li>第二种：<code>INSERT SET</code></li>
</ul>
<p>Sharding-JDBC 插入SQL解析主流程如下：</p>
<p><img src="/2017/10/08/sharding-jdbc/image-10.png" width="500px"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractInsertParser.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> InsertStatement <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   sqlParser.getLexer().nextToken(); <span class="comment">// 跳过 INSERT 关键字</span></span><br><span class="line">   parseInto(); <span class="comment">// 解析INTO</span></span><br><span class="line">   parseColumns(); <span class="comment">// 解析表</span></span><br><span class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.SELECT, Symbol.LEFT_PAREN)) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support subquery"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (getValuesKeywords().contains(sqlParser.getLexer().getCurrentToken().getType())) &#123; <span class="comment">// 第一种插入SQL情况</span></span><br><span class="line">       parseValues();</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getCustomizedInsertKeywords().contains(sqlParser.getLexer().getCurrentToken().getType())) &#123; <span class="comment">// 第二种插入SQL情况</span></span><br><span class="line">       parseCustomizedInsert();</span><br><span class="line">   &#125;</span><br><span class="line">   appendGenerateKey(); <span class="comment">// 自增主键</span></span><br><span class="line">   <span class="keyword">return</span> insertStatement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="UpdateStatementParser"><a href="#UpdateStatementParser" class="headerlink" title="UpdateStatementParser"></a>UpdateStatementParser</h5><p>MySQL UPDATE 语法一共有 2 种 ：</p>
<ul>
<li>第一种：<strong>Single-table syntax</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">IGNORE</span>] table_reference</span><br><span class="line">    <span class="keyword">SET</span> col_name1=&#123;expr1|<span class="keyword">DEFAULT</span>&#125; [, col_name2=&#123;expr2|<span class="keyword">DEFAULT</span>&#125;] ...</span><br><span class="line">    [<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]</span><br><span class="line">    [<span class="keyword">LIMIT</span> <span class="keyword">row_count</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>第二种：<strong>Multiple-table syntax</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">IGNORE</span>] table_references</span><br><span class="line">    <span class="keyword">SET</span> col_name1=&#123;expr1|<span class="keyword">DEFAULT</span>&#125; [, col_name2=&#123;expr2|<span class="keyword">DEFAULT</span>&#125;] ...</span><br><span class="line">    [<span class="keyword">WHERE</span> where_condition]</span><br></pre></td></tr></table></figure>
<p><img src="/2017/10/08/sharding-jdbc/image-11.png" width="500px"></p>
<p>Sharding-JDBC 目前仅支持第一种。业务场景上使用第二种的很少很少。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractUpdateParser.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UpdateStatement <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   sqlParser.getLexer().nextToken(); <span class="comment">// 跳过 UPDATE</span></span><br><span class="line">   skipBetweenUpdateAndTable(); <span class="comment">// 跳过关键字，例如：MYSQL 里的 LOW_PRIORITY、IGNORE</span></span><br><span class="line">   sqlParser.parseSingleTable(updateStatement); <span class="comment">// 解析表</span></span><br><span class="line">   parseSetItems(); <span class="comment">// 解析 SET</span></span><br><span class="line">   sqlParser.skipUntil(DefaultKeyword.WHERE);</span><br><span class="line">   sqlParser.setParametersIndex(parametersIndex);</span><br><span class="line">   sqlParser.parseWhere(updateStatement);</span><br><span class="line">   <span class="keyword">return</span> updateStatement; <span class="comment">// 解析 WHERE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="DeleteStatementParser"><a href="#DeleteStatementParser" class="headerlink" title="DeleteStatementParser"></a>DeleteStatementParser</h5><p>MySQL DELETE 语法一共有 2 种 ：</p>
<ul>
<li>第一种：<strong>Single-table syntax</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">QUICK</span>] [<span class="keyword">IGNORE</span>] <span class="keyword">FROM</span> tbl_name</span><br><span class="line">    [<span class="keyword">PARTITION</span> (partition_name,...)]</span><br><span class="line">    [<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]</span><br><span class="line">    [<span class="keyword">LIMIT</span> <span class="keyword">row_count</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>第二种：<strong>Multiple-table syntax</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">QUICK</span>] [<span class="keyword">IGNORE</span>]</span><br><span class="line">    tbl_name[.*] [, tbl_name[.*]] ...</span><br><span class="line">    <span class="keyword">FROM</span> table_references</span><br><span class="line">    [<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">    </span><br><span class="line">【<span class="keyword">OR</span>】</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">QUICK</span>] [<span class="keyword">IGNORE</span>]</span><br><span class="line">    <span class="keyword">FROM</span> tbl_name[.*] [, tbl_name[.*]] ...</span><br><span class="line">    <span class="keyword">USING</span> table_references</span><br><span class="line">    [<span class="keyword">WHERE</span> where_condition]</span><br></pre></td></tr></table></figure>
<p>Sharding-JDBC 目前仅支持第一种。业务场景上使用第二种的很少很少。</p>
<p><img src="/2017/10/08/sharding-jdbc/image-12.png" width="500px"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractDeleteParser.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DeleteStatement <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   sqlParser.getLexer().nextToken(); <span class="comment">// 跳过 DELETE</span></span><br><span class="line">   skipBetweenDeleteAndTable(); <span class="comment">// // 跳过关键字，例如：MYSQL 里的 LOW_PRIORITY、IGNORE 和 FROM</span></span><br><span class="line">   sqlParser.parseSingleTable(deleteStatement); <span class="comment">// 解析表</span></span><br><span class="line">   sqlParser.skipUntil(DefaultKeyword.WHERE); <span class="comment">// 跳到 WHERE</span></span><br><span class="line">   sqlParser.parseWhere(deleteStatement); <span class="comment">// 解析 WHERE</span></span><br><span class="line">   <span class="keyword">return</span> deleteStatement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p><code>StandardRoutingEngine</code>由此路由引擎决定语句的路由情况</p>
<p>根据解析上下文匹配数据库和表的分片策略，并生成路由路径。<br>对于携带分片键的SQL，根据分片键的不同可以划分为单片路由(分片键的操作符是等号)、多片路由(分片键的操作符是IN)和范围路由(分片键的操作符是BETWEEN)。 不携带分片键的SQL则采用广播路由。</p>
<p>分片策略通常可以采用由数据库内置或由用户方配置。<br>数据库内置的方案较为简单，内置的分片策略大致可分为尾数取模、哈希、范围、标签、时间等。 由用户方配置的分片策略则更加灵活，可以根据使用方需求定制复合分片策略。<br>如果配合数据自动迁移来使用，可以做到无需用户关注分片策略，自动由数据库中间层分片和平衡数据即可，进而做到使分布式数据库具有的弹性伸缩的能力。 </p>
<p>路由引擎的整体结构划分如下图</p>
<p><img src="/2017/10/08/sharding-jdbc/image-19.png" width="500px"></p>
<h3 id="分片路由"><a href="#分片路由" class="headerlink" title="分片路由"></a>分片路由</h3><p>分片路由又可分为直接路由、标准路由和笛卡尔积路由这3种类型。</p>
<h4 id="直接路由"><a href="#直接路由" class="headerlink" title="直接路由"></a>直接路由</h4><p>满足直接路由的条件相对苛刻，它需要通过Hint（使用HintAPI直接指定路由至库表）方式分片，并且是<code>只分库不分表</code>的前提下，则可以避免SQL解析和之后的结果归并。<br>因此它的兼容性最好，可以执行包括子查询、自定义函数等复杂情况的任意SQL。直接路由还可以用于分片键不在SQL中的场景。</p>
<p>设置用于数据库分片的键为3<br>假如路由算法为<code>value % 2</code>，当一个逻辑库t_order对应2个真实库t_order_0和t_order_1时，路由后SQL将在t_order_1上执行。下方是使用API的代码样例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"SELECT * FROM t_order"</span>;</span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">        HintManager hintManager = HintManager.getInstance();</span><br><span class="line">        Connection conn = dataSource.getConnection();</span><br><span class="line">        PreparedStatement pstmt = conn.prepareStatement(sql)) &#123;</span><br><span class="line">        hintManager.setDatabaseShardingValue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">try</span> (ResultSet rs = pstmt.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>直接路由源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseHintRoutingEngine</span> <span class="keyword">implements</span> <span class="title">RoutingEngine</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有分库的数据库名称集合，由于直接路由只支持分库，不支持分表，不需要维护分表的集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;String&gt; dataSourceNames;</span><br><span class="line">    <span class="comment">//直接路由使用Hint路由策略进行分库</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HintShardingStrategy databaseShardingStrategy;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取数据库分片值</span></span><br><span class="line">        Optional&lt;ShardingValue&gt; shardingValue = HintManagerHolder.getDatabaseShardingValue(HintManagerHolder.DB_TABLE_NAME);</span><br><span class="line">        <span class="comment">// 校验是否存在值</span></span><br><span class="line">        Preconditions.checkState(shardingValue.isPresent());</span><br><span class="line">        Collection&lt;String&gt; routingDataSources;</span><br><span class="line">        <span class="comment">//得到分片结果，Hint分片策略</span></span><br><span class="line">        routingDataSources = databaseShardingStrategy.doSharding(dataSourceNames, Collections.singletonList(shardingValue.get()));</span><br><span class="line">        Preconditions.checkState(!routingDataSources.isEmpty(), <span class="string">"no database route info"</span>);</span><br><span class="line">        RoutingResult result = <span class="keyword">new</span> RoutingResult();</span><br><span class="line">        <span class="comment">//遍历分片结果，填充到路由结果中</span></span><br><span class="line">        <span class="keyword">for</span> (String each : routingDataSources) &#123;</span><br><span class="line">        <span class="comment">//路由表单元集合，主要存储数据库名和路由表（包含逻辑表和实际表名称）返回这个结果便于在下一步的改写中，指定数据库和实际表的sql</span></span><br><span class="line">            result.getTableUnits().getTableUnits().add(<span class="keyword">new</span> TableUnit(each));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标准路由"><a href="#标准路由" class="headerlink" title="标准路由"></a>标准路由</h4><p>标准路由是ShardingSphere最为推荐使用的分片方式，它的适用范围是不包含关联查询或仅包含绑定表之间关联查询的SQL。 当分片运算符是等于号时，路由结果将落入单库（表），当分片运算符是BETWEEN或IN时，则路由结果不一定落入唯一的库（表），因此一条逻辑SQL最终可能被拆分为多条用于执行的真实SQL。 举例说明，如果按照order_id的奇数和偶数进行数据分片，一个单表查询的SQL如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>那么路由的结果应为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_0 <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_1 <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>绑定表的关联查询与单表查询复杂度和性能相当。<br>举例说明，如果一个包含绑定表的关联查询的SQL如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o <span class="keyword">JOIN</span> t_order_item i <span class="keyword">ON</span> o.order_id=i.order_id  <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>那么路由的结果应为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id=i.order_id  <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id=i.order_id  <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>标准路由源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardRoutingEngine</span> <span class="keyword">implements</span> <span class="title">RoutingEngine</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分片策略接口，具体实现有外部指定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingRule shardingRule;</span><br><span class="line">    <span class="comment">//逻辑表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String logicTableName;</span><br><span class="line">    <span class="comment">//分片条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingConditions shardingConditions;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> generateRoutingResult(getDataNodes(shardingRule.getTableRuleByLogicTableName(logicTableName)));</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成路由结果</span></span><br><span class="line"><span class="comment">     * DataNode包含如下三个属性</span></span><br><span class="line"><span class="comment">     * private static final String DELIMITER = ".";</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * private final String dataSourceName;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * private final String tableName;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RoutingResult <span class="title">generateRoutingResult</span><span class="params">(<span class="keyword">final</span> Collection&lt;DataNode&gt; routedDataNodes)</span> </span>&#123;</span><br><span class="line">        RoutingResult result = <span class="keyword">new</span> RoutingResult();</span><br><span class="line">        <span class="comment">//与直接路由中相同，最终都是组装路由表单元集合</span></span><br><span class="line">        <span class="keyword">for</span> (DataNode each : routedDataNodes) &#123;</span><br><span class="line">          <span class="comment">//创建路由表单元实例，并指定数据库名</span></span><br><span class="line">            TableUnit tableUnit = <span class="keyword">new</span> TableUnit(each.getDataSourceName());</span><br><span class="line">            <span class="comment">//赋值路由表 逻辑表和实际表</span></span><br><span class="line">            tableUnit.getRoutingTables().add(<span class="keyword">new</span> RoutingTable(logicTableName, each.getTableName()));</span><br><span class="line">            result.getTableUnits().getTableUnits().add(tableUnit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取DataNode节点集合，参数为表规则配置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">getDataNodes</span><span class="params">(<span class="keyword">final</span> TableRule tableRule)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//判断是否是指定表的规则</span></span><br><span class="line">        <span class="keyword">if</span> (isRoutingByHint(tableRule)) &#123;</span><br><span class="line">            <span class="keyword">return</span> routeByHint(tableRule);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是否根据分片条件路由</span></span><br><span class="line">        <span class="keyword">if</span> (isRoutingByShardingConditions(tableRule)) &#123;</span><br><span class="line">            <span class="keyword">return</span> routeByShardingConditions(tableRule);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有路由条件，则使用混合方式</span></span><br><span class="line">        <span class="keyword">return</span> routeByMixedConditions(tableRule);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRoutingByHint</span><span class="params">(<span class="keyword">final</span> TableRule tableRule)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//数据库分片策略是Hint分片策略 且表分片策略也是Hint分片策略</span></span><br><span class="line">        <span class="keyword">return</span> shardingRule.getDatabaseShardingStrategy(tableRule) <span class="keyword">instanceof</span> HintShardingStrategy &amp;&amp; shardingRule.getTableShardingStrategy(tableRule) <span class="keyword">instanceof</span> HintShardingStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Hint路由方式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">routeByHint</span><span class="params">(<span class="keyword">final</span> TableRule tableRule)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> route(tableRule, getDatabaseShardingValuesFromHint(), getTableShardingValuesFromHint());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRoutingByShardingConditions</span><span class="params">(<span class="keyword">final</span> TableRule tableRule)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//数据库和表的分片策略都是不是Hint分片方式</span></span><br><span class="line">        <span class="keyword">return</span> !(shardingRule.getDatabaseShardingStrategy(tableRule) <span class="keyword">instanceof</span> HintShardingStrategy || shardingRule.getTableShardingStrategy(tableRule) <span class="keyword">instanceof</span> HintShardingStrategy);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//分片条件路由方式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">routeByShardingConditions</span><span class="params">(<span class="keyword">final</span> TableRule tableRule)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shardingConditions.getShardingConditions().isEmpty() ? route(tableRule, Collections.&lt;ShardingValue&gt;emptyList(), Collections.&lt;ShardingValue&gt;emptyList())</span><br><span class="line">                : routeByShardingConditionsWithCondition(tableRule);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//路由条件不为空，根据表分片规则进行路由</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">routeByShardingConditionsWithCondition</span><span class="params">(<span class="keyword">final</span> TableRule tableRule)</span> </span>&#123;</span><br><span class="line">        Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ShardingCondition each : shardingConditions.getShardingConditions()) &#123;</span><br><span class="line">            Collection&lt;DataNode&gt; dataNodes = route(tableRule, getShardingValuesFromShardingConditions(shardingRule.getDatabaseShardingStrategy(tableRule).getShardingColumns(), each),</span><br><span class="line">                    getShardingValuesFromShardingConditions(shardingRule.getTableShardingStrategy(tableRule).getShardingColumns(), each));</span><br><span class="line">            reviseShardingConditions(each, dataNodes);</span><br><span class="line">            result.addAll(dataNodes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">routeByMixedConditions</span><span class="params">(<span class="keyword">final</span> TableRule tableRule)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shardingConditions.getShardingConditions().isEmpty() ? routeByMixedConditionsWithHint(tableRule) : routeByMixedConditionsWithCondition(tableRule);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">routeByMixedConditionsWithCondition</span><span class="params">(<span class="keyword">final</span> TableRule tableRule)</span> </span>&#123;</span><br><span class="line">        Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ShardingCondition each : shardingConditions.getShardingConditions()) &#123;</span><br><span class="line">            Collection&lt;DataNode&gt; dataNodes = route(tableRule, getDatabaseShardingValues(tableRule, each), getTableShardingValues(tableRule, each));</span><br><span class="line">            reviseShardingConditions(each, dataNodes);</span><br><span class="line">            result.addAll(dataNodes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">routeByMixedConditionsWithHint</span><span class="params">(<span class="keyword">final</span> TableRule tableRule)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shardingRule.getDatabaseShardingStrategy(tableRule) <span class="keyword">instanceof</span> HintShardingStrategy) &#123;</span><br><span class="line">            <span class="keyword">return</span> route(tableRule, getDatabaseShardingValuesFromHint(), Collections.&lt;ShardingValue&gt;emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> route(tableRule, Collections.&lt;ShardingValue&gt;emptyList(), getTableShardingValuesFromHint());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取数据库分片值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;ShardingValue&gt; <span class="title">getDatabaseShardingValues</span><span class="params">(<span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> ShardingCondition shardingCondition)</span> </span>&#123;</span><br><span class="line">        ShardingStrategy dataBaseShardingStrategy = shardingRule.getDatabaseShardingStrategy(tableRule);</span><br><span class="line">        <span class="keyword">return</span> isGettingShardingValuesFromHint(dataBaseShardingStrategy)</span><br><span class="line">                ? getDatabaseShardingValuesFromHint() : getShardingValuesFromShardingConditions(dataBaseShardingStrategy.getShardingColumns(), shardingCondition);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;ShardingValue&gt; <span class="title">getTableShardingValues</span><span class="params">(<span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> ShardingCondition shardingCondition)</span> </span>&#123;</span><br><span class="line">        ShardingStrategy tableShardingStrategy = shardingRule.getTableShardingStrategy(tableRule);</span><br><span class="line">        <span class="keyword">return</span> isGettingShardingValuesFromHint(tableShardingStrategy)</span><br><span class="line">                ? getTableShardingValuesFromHint() : getShardingValuesFromShardingConditions(tableShardingStrategy.getShardingColumns(), shardingCondition);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isGettingShardingValuesFromHint</span><span class="params">(<span class="keyword">final</span> ShardingStrategy shardingStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shardingStrategy <span class="keyword">instanceof</span> HintShardingStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;ShardingValue&gt; <span class="title">getDatabaseShardingValuesFromHint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Optional&lt;ShardingValue&gt; shardingValueOptional = HintManagerHolder.getDatabaseShardingValue(logicTableName);</span><br><span class="line">        <span class="keyword">return</span> shardingValueOptional.isPresent() ? Collections.singletonList(shardingValueOptional.get()) : Collections.&lt;ShardingValue&gt;emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;ShardingValue&gt; <span class="title">getTableShardingValuesFromHint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Optional&lt;ShardingValue&gt; shardingValueOptional = HintManagerHolder.getTableShardingValue(logicTableName);</span><br><span class="line">        <span class="keyword">return</span> shardingValueOptional.isPresent() ? Collections.singletonList(shardingValueOptional.get()) : Collections.&lt;ShardingValue&gt;emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;ShardingValue&gt; <span class="title">getShardingValuesFromShardingConditions</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; shardingColumns, <span class="keyword">final</span> ShardingCondition shardingCondition)</span> </span>&#123;</span><br><span class="line">        List&lt;ShardingValue&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingColumns.size());</span><br><span class="line">        <span class="keyword">for</span> (ShardingValue each : shardingCondition.getShardingValues()) &#123;</span><br><span class="line">            Optional&lt;BindingTableRule&gt; bindingTableRule = shardingRule.findBindingTableRule(logicTableName);</span><br><span class="line">            <span class="keyword">if</span> ((logicTableName.equals(each.getLogicTableName()) || bindingTableRule.isPresent() &amp;&amp; bindingTableRule.get().hasLogicTable(logicTableName)) </span><br><span class="line">                    &amp;&amp; shardingColumns.contains(each.getColumnName())) &#123;</span><br><span class="line">                result.add(each);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">route</span><span class="params">(<span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> List&lt;ShardingValue&gt; databaseShardingValues, <span class="keyword">final</span> List&lt;ShardingValue&gt; tableShardingValues)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; routedDataSources = routeDataSources(tableRule, databaseShardingValues);</span><br><span class="line">        Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String each : routedDataSources) &#123;</span><br><span class="line">            result.addAll(routeTables(tableRule, each, tableShardingValues));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">routeDataSources</span><span class="params">(<span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> List&lt;ShardingValue&gt; databaseShardingValues)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; availableTargetDatabases = tableRule.getActualDatasourceNames();</span><br><span class="line">        <span class="keyword">if</span> (databaseShardingValues.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> availableTargetDatabases;</span><br><span class="line">        &#125;</span><br><span class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(shardingRule.getDatabaseShardingStrategy(tableRule).doSharding(availableTargetDatabases, databaseShardingValues));</span><br><span class="line">        Preconditions.checkState(!result.isEmpty(), <span class="string">"no database route info"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">routeTables</span><span class="params">(<span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> String routedDataSource, <span class="keyword">final</span> List&lt;ShardingValue&gt; tableShardingValues)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; availableTargetTables = tableRule.getActualTableNames(routedDataSource);</span><br><span class="line">        Collection&lt;String&gt; routedTables = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(tableShardingValues.isEmpty() ? availableTargetTables</span><br><span class="line">                : shardingRule.getTableShardingStrategy(tableRule).doSharding(availableTargetTables, tableShardingValues));</span><br><span class="line">        Preconditions.checkState(!routedTables.isEmpty(), <span class="string">"no table route info"</span>);</span><br><span class="line">        Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String each : routedTables) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> DataNode(routedDataSource, each));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reviseShardingConditions</span><span class="params">(<span class="keyword">final</span> ShardingCondition each, <span class="keyword">final</span> Collection&lt;DataNode&gt; dataNodes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (each <span class="keyword">instanceof</span> InsertShardingCondition) &#123;</span><br><span class="line">            ((InsertShardingCondition) each).getDataNodes().addAll(dataNodes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="笛卡尔路由"><a href="#笛卡尔路由" class="headerlink" title="笛卡尔路由"></a>笛卡尔路由</h4><p>笛卡尔路由是最复杂的情况，它无法根据绑定表的关系定位分片规则，因此非绑定表之间的关联查询需要拆解为笛卡尔积组合执行。 如果上个示例中的SQL并未配置绑定表关系，那么路由的结果应为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id=i.order_id  <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id=i.order_id  <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id=i.order_id  <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id=i.order_id  <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>笛卡尔路由使用频率很低，就不做具体分析了</p>
<h3 id="广播路由"><a href="#广播路由" class="headerlink" title="广播路由"></a>广播路由</h3><p>对于不携带分片键的SQL，则采取广播路由的方式。根据SQL类型又可以划分为全库表路由、全库路由、全实例路由、单播路由和阻断路由这5种类型。</p>
<h4 id="全库表路由"><a href="#全库表路由" class="headerlink" title="全库表路由"></a>全库表路由</h4><p>全库表路由用于处理对数据库中与其逻辑表相关的所有真实表的操作，主要包括不带分片键的DQL和DML，以及DDL等。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> good_prority <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>则会遍历所有数据库中的所有表，逐一匹配逻辑表和真实表名，能够匹配得上则执行。路由后成为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_0 <span class="keyword">WHERE</span> good_prority <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_1 <span class="keyword">WHERE</span> good_prority <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_2 <span class="keyword">WHERE</span> good_prority <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_3 <span class="keyword">WHERE</span> good_prority <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>全库表路由源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TableBroadcastRoutingEngine</span> <span class="keyword">implements</span> <span class="title">RoutingEngine</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingRule shardingRule;</span><br><span class="line">    <span class="comment">//sql语句</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SQLStatement sqlStatement;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RoutingResult result = <span class="keyword">new</span> RoutingResult();</span><br><span class="line">        <span class="keyword">for</span> (String each : getLogicTableNames()) &#123;</span><br><span class="line">            result.getTableUnits().getTableUnits().addAll(getAllTableUnits(each));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//湖区哦v所有逻辑表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">getLogicTableNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isOperateIndexWithoutTable()) &#123;</span><br><span class="line">          <span class="comment">//通过分片策略获取逻辑表</span></span><br><span class="line">            <span class="keyword">return</span> Collections.singletonList(shardingRule.getLogicTableName(getIndexToken().getIndexName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sqlStatement.getTables().getTableNames();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOperateIndexWithoutTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlStatement <span class="keyword">instanceof</span> DDLStatement &amp;&amp; sqlStatement.getTables().isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取Token的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IndexToken <span class="title">getIndexToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;SQLToken&gt; sqlTokens = sqlStatement.getSQLTokens();</span><br><span class="line">        Preconditions.checkState(<span class="number">1</span> == sqlTokens.size());</span><br><span class="line">        <span class="keyword">return</span> (IndexToken) sqlTokens.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据逻辑表获取实际表，并封装为分片表单元实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;TableUnit&gt; <span class="title">getAllTableUnits</span><span class="params">(<span class="keyword">final</span> String logicTableName)</span> </span>&#123;</span><br><span class="line">        Collection&lt;TableUnit&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TableRule tableRule = shardingRule.getTableRuleByLogicTableName(logicTableName);</span><br><span class="line">        <span class="keyword">for</span> (DataNode each : tableRule.getActualDataNodes()) &#123;</span><br><span class="line">            TableUnit tableUnit = <span class="keyword">new</span> TableUnit(each.getDataSourceName());</span><br><span class="line">            tableUnit.getRoutingTables().add(<span class="keyword">new</span> RoutingTable(logicTableName, each.getTableName()));</span><br><span class="line">            result.add(tableUnit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="全库路由"><a href="#全库路由" class="headerlink" title="全库路由"></a>全库路由</h4><p>全库路由用于处理对数据库的操作，包括用于库设置的SET类型的数据库管理命令，以及TCL这样的事务控制语句。<br>在这种情况下，会根据逻辑库的名字遍历所有符合名字匹配的真实库，并在真实库中执行该命令</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>在t_order中执行，t_order有2个真实库。则实际会在t_order_0和t_order_1上都执行这个命令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseBroadcastRoutingEngine</span> <span class="keyword">implements</span> <span class="title">RoutingEngine</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingRule shardingRule;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RoutingResult result = <span class="keyword">new</span> RoutingResult();</span><br><span class="line">        <span class="keyword">for</span> (String each : shardingRule.getShardingDataSourceNames().getDataSourceNames()) &#123;</span><br><span class="line">            result.getTableUnits().getTableUnits().add(<span class="keyword">new</span> TableUnit(each));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="全实例路由"><a href="#全实例路由" class="headerlink" title="全实例路由"></a>全实例路由</h4><p>全实例路由用于DCL操作，授权语句针对的是数据库的实例。无论一个实例中包含多少个Schema，每个数据库的实例只执行一次。<br>例如:<code>CREATE USER customer@127.0.0.1 identified BY &#39;123&#39;</code>;<br>这个命令将在所有的真实数据库实例中执行，以确保customer用户可以访问每一个实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceBroadcastRoutingEngine</span> <span class="keyword">implements</span> <span class="title">RoutingEngine</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingRule shardingRule;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingDataSourceMetaData shardingDataSourceMetaData;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RoutingResult result = <span class="keyword">new</span> RoutingResult();</span><br><span class="line">        <span class="keyword">for</span> (String each : shardingRule.getShardingDataSourceNames().getDataSourceNames()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shardingDataSourceMetaData.getAllInstanceDataSourceNames().contains(each)) &#123;</span><br><span class="line">                result.getTableUnits().getTableUnits().add(<span class="keyword">new</span> TableUnit(each));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单播路由"><a href="#单播路由" class="headerlink" title="单播路由"></a>单播路由</h4><p>单播路由用于获取某一真实表信息的场景，它仅需要从任意库中的任意真实表中获取数据即可。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> t_order;</span><br></pre></td></tr></table></figure>
<p>t_order的两个真实表t_order_0，t_order_1的描述结构相同，所以这个命令在任意真实表上选择执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UnicastRoutingEngine</span> <span class="keyword">implements</span> <span class="title">RoutingEngine</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingRule shardingRule;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;String&gt; logicTables;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RoutingResult result = <span class="keyword">new</span> RoutingResult();</span><br><span class="line">        <span class="keyword">if</span> (shardingRule.isAllBroadcastTables(logicTables)) &#123;</span><br><span class="line">            List&lt;RoutingTable&gt; routingTables = <span class="keyword">new</span> ArrayList&lt;&gt;(logicTables.size());</span><br><span class="line">            <span class="keyword">for</span> (String each : logicTables) &#123;</span><br><span class="line">                routingTables.add(<span class="keyword">new</span> RoutingTable(each, each));</span><br><span class="line">            &#125;</span><br><span class="line">            TableUnit tableUnit = <span class="keyword">new</span> TableUnit(shardingRule.getShardingDataSourceNames().getDataSourceNames().iterator().next());</span><br><span class="line">            tableUnit.getRoutingTables().addAll(routingTables);</span><br><span class="line">            result.getTableUnits().getTableUnits().add(tableUnit);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (logicTables.isEmpty()) &#123;</span><br><span class="line">            result.getTableUnits().getTableUnits().add(<span class="keyword">new</span> TableUnit(shardingRule.getShardingDataSourceNames().getDataSourceNames().iterator().next()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == logicTables.size()) &#123;</span><br><span class="line">            String logicTableName = logicTables.iterator().next();</span><br><span class="line">            DataNode dataNode = shardingRule.findDataNode(logicTableName);</span><br><span class="line">            TableUnit tableUnit = <span class="keyword">new</span> TableUnit(dataNode.getDataSourceName());</span><br><span class="line">            tableUnit.getRoutingTables().add(<span class="keyword">new</span> RoutingTable(logicTableName, dataNode.getTableName()));</span><br><span class="line">            result.getTableUnits().getTableUnits().add(tableUnit);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String dataSourceName = <span class="keyword">null</span>;</span><br><span class="line">            List&lt;RoutingTable&gt; routingTables = <span class="keyword">new</span> ArrayList&lt;&gt;(logicTables.size());</span><br><span class="line">            <span class="keyword">for</span> (String each : logicTables) &#123;</span><br><span class="line">                DataNode dataNode = shardingRule.findDataNode(dataSourceName, each);</span><br><span class="line">                routingTables.add(<span class="keyword">new</span> RoutingTable(each, dataNode.getTableName()));</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == dataSourceName) &#123;</span><br><span class="line">                    dataSourceName = dataNode.getDataSourceName();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TableUnit tableUnit = <span class="keyword">new</span> TableUnit(dataSourceName);</span><br><span class="line">            tableUnit.getRoutingTables().addAll(routingTables);</span><br><span class="line">            result.getTableUnits().getTableUnits().add(tableUnit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="阻断路由"><a href="#阻断路由" class="headerlink" title="阻断路由"></a>阻断路由</h4><p>阻断路由用于屏蔽SQL对数据库的操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> order_db;</span><br></pre></td></tr></table></figure>
<p>这个命令不会在真实数据库中执行，因为ShardingSphere采用的是逻辑Schema的方式，无需将切换数据库Schema的命令发送至数据库中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IgnoreRoutingEngine</span> <span class="keyword">implements</span> <span class="title">RoutingEngine</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RoutingResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="改写"><a href="#改写" class="headerlink" title="改写"></a>改写</h2><p><code>SQLRewriteEngine</code>由此重写引擎决定语句的重写情况</p>
<p>初始SQL经历了解析和路由之后需要将SQL改写,根据分片规则指定需要对哪个库哪个表执行相应的SQL<br>即正确性改写:在包含分表的场景中,需要将分表配置中的逻辑表名称改写为路由之后所获取的真实表名称。仅分库则不需要表名称的改写。<br>除此之外,还包括补列和分页信息修正等内容。</p>
<p>改写引擎的整体结构划分如下图所示：</p>
<p><img src="/2017/10/08/sharding-jdbc/image-21.png" width="500px"></p>
<h3 id="改写引擎"><a href="#改写引擎" class="headerlink" title="改写引擎"></a>改写引擎</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLRewriteEngine</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分片规则</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingRule shardingRule;</span><br><span class="line">    <span class="comment">//初始SQL</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String originalSQL;</span><br><span class="line">    <span class="comment">//数据库类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DatabaseType databaseType;</span><br><span class="line">    <span class="comment">//SQL描述</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SQLStatement sqlStatement;</span><br><span class="line">    <span class="comment">//SQL的关键字Token</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens;</span><br><span class="line">    <span class="comment">//分片条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingConditions shardingConditions;</span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; parameters;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs SQL rewrite engine.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shardingRule databases and tables sharding rule</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> originalSQL original SQL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> databaseType database type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sqlStatement SQL statement</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shardingConditions sharding conditions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameters parameters</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SQLRewriteEngine</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> String originalSQL, <span class="keyword">final</span> DatabaseType databaseType,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> SQLStatement sqlStatement, <span class="keyword">final</span> ShardingConditions shardingConditions, <span class="keyword">final</span> List&lt;Object&gt; parameters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shardingRule = shardingRule;</span><br><span class="line">        <span class="keyword">this</span>.originalSQL = originalSQL;</span><br><span class="line">        <span class="keyword">this</span>.databaseType = databaseType;</span><br><span class="line">        <span class="keyword">this</span>.sqlStatement = sqlStatement;</span><br><span class="line">        sqlTokens = sqlStatement.getSQLTokens();</span><br><span class="line">        <span class="keyword">this</span>.shardingConditions = shardingConditions;</span><br><span class="line">        <span class="keyword">this</span>.parameters = parameters;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rewrite SQL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isSingleRouting is rewrite</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SQL builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SQLBuilder <span class="title">rewrite</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isSingleRouting)</span> </span>&#123;</span><br><span class="line">        SQLBuilder result = <span class="keyword">new</span> SQLBuilder(parameters);</span><br><span class="line">        <span class="comment">//如果初始SQL中没有token则返回原生的SQL</span></span><br><span class="line">        <span class="keyword">if</span> (sqlTokens.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">//单节点优化</span></span><br><span class="line">            <span class="keyword">return</span> appendOriginalLiterals(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//isSingleRouting通过路由引擎执行后路由的路径是否唯一</span></span><br><span class="line">        <span class="comment">//拼接非token的sql</span></span><br><span class="line">        appendInitialLiterals(!isSingleRouting, result);</span><br><span class="line">        <span class="comment">//拼接（重写）token和占位符</span></span><br><span class="line">        appendTokensAndPlaceholders(!isSingleRouting, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> SQLBuilder <span class="title">appendOriginalLiterals</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</span><br><span class="line">        sqlBuilder.appendLiterals(originalSQL);</span><br><span class="line">        <span class="keyword">return</span> sqlBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendInitialLiterals</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite, <span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isRewrite &amp;&amp; isContainsAggregationDistinctToken()) &#123;</span><br><span class="line">        <span class="comment">//拼接Distinct聚合函数的关键字</span></span><br><span class="line">            appendAggregationDistinctLiteral(sqlBuilder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//拼接第一个token之前的原生SQL</span></span><br><span class="line">            sqlBuilder.appendLiterals(originalSQL.substring(<span class="number">0</span>, sqlTokens.get(<span class="number">0</span>).getBeginPosition()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断原生SQL中是否包含Distinct关键字</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isContainsAggregationDistinctToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Iterators.tryFind(sqlTokens.iterator(), <span class="keyword">new</span> Predicate&lt;SQLToken&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(<span class="keyword">final</span> SQLToken input)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> input <span class="keyword">instanceof</span> AggregationDistinctToken;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).isPresent();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendAggregationDistinctLiteral</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//定位Distinct关键字的坐标位置</span></span><br><span class="line">        <span class="keyword">int</span> firstSelectItemStartPosition = ((SelectStatement) sqlStatement).getFirstSelectItemStartPosition();</span><br><span class="line">        <span class="comment">//拼接关键字之前的SQL</span></span><br><span class="line">        sqlBuilder.appendLiterals(originalSQL.substring(<span class="number">0</span>, firstSelectItemStartPosition));</span><br><span class="line">        <span class="comment">//拼接执行时需要的关键字DISTINCT </span></span><br><span class="line">        sqlBuilder.appendLiterals(<span class="string">"DISTINCT "</span>);</span><br><span class="line">        <span class="comment">//拼接DISTINCT到第一个token之间的SQL</span></span><br><span class="line">        sqlBuilder.appendLiterals(originalSQL.substring(firstSelectItemStartPosition, sqlTokens.get(<span class="number">0</span>).getBeginPosition()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写token和占位符</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendTokensAndPlaceholders</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite, <span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (SQLToken each : sqlTokens) &#123;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (each <span class="keyword">instanceof</span> TableToken) &#123;</span><br><span class="line">              <span class="comment">//  表名改写</span></span><br><span class="line">                appendTablePlaceholder(sqlBuilder, (TableToken) each, count);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> SchemaToken) &#123;</span><br><span class="line">              <span class="comment">//schema改写</span></span><br><span class="line">                appendSchemaPlaceholder(sqlBuilder, (SchemaToken) each, count);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> IndexToken) &#123;</span><br><span class="line">              <span class="comment">//索引改写</span></span><br><span class="line">                appendIndexPlaceholder(sqlBuilder, (IndexToken) each, count);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> ItemsToken) &#123;</span><br><span class="line">              <span class="comment">//列改写</span></span><br><span class="line">                appendItemsToken(sqlBuilder, (ItemsToken) each, count, isRewrite);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> InsertValuesToken) &#123;</span><br><span class="line">              <span class="comment">//批量插入拆分改写</span></span><br><span class="line">                appendInsertValuesToken(sqlBuilder, (InsertValuesToken) each, count);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> RowCountToken) &#123;</span><br><span class="line">              <span class="comment">//分页大写修正</span></span><br><span class="line">                appendLimitRowCount(sqlBuilder, (RowCountToken) each, count, isRewrite);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> OffsetToken) &#123;</span><br><span class="line">              <span class="comment">//分页偏移量修正</span></span><br><span class="line">                appendLimitOffsetToken(sqlBuilder, (OffsetToken) each, count, isRewrite);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> OrderByToken) &#123;</span><br><span class="line">              <span class="comment">//排序改写</span></span><br><span class="line">                appendOrderByToken(sqlBuilder, count, isRewrite);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> InsertColumnToken) &#123;</span><br><span class="line">              <span class="comment">//插入列名改写</span></span><br><span class="line">                appendSymbolToken(sqlBuilder, (InsertColumnToken) each, count);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> AggregationDistinctToken) &#123;</span><br><span class="line">              <span class="comment">//Distinct占位符改写</span></span><br><span class="line">                appendAggregationDistinctPlaceholder(sqlBuilder, (AggregationDistinctToken) each, count, isRewrite);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> RemoveToken) &#123;</span><br><span class="line">                appendRest(sqlBuilder, count, ((RemoveToken) each).getEndPosition());</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendTablePlaceholder</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> TableToken tableToken, <span class="keyword">final</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//  拼接重写表的占位符</span></span><br><span class="line">        sqlBuilder.appendPlaceholder(<span class="keyword">new</span> TablePlaceholder(tableToken.getTableName().toLowerCase(), tableToken.getOriginalLiterals()));</span><br><span class="line">        <span class="comment">// 表名在SQL中的起始位置</span></span><br><span class="line">        <span class="keyword">int</span> beginPosition = tableToken.getBeginPosition() + tableToken.getSkippedSchemaNameLength() + tableToken.getOriginalLiterals().length();</span><br><span class="line">        <span class="comment">//拼接表名</span></span><br><span class="line">        appendRest(sqlBuilder, count, beginPosition);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendSchemaPlaceholder</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> SchemaToken schemaToken, <span class="keyword">final</span> <span class="keyword">int</span> count)</span> </span>&#123;   </span><br><span class="line">      <span class="comment">//拼接schema占位符</span></span><br><span class="line">        sqlBuilder.appendPlaceholder(<span class="keyword">new</span> SchemaPlaceholder(schemaToken.getSchemaName().toLowerCase(), schemaToken.getTableName().toLowerCase()));</span><br><span class="line">        <span class="keyword">int</span> beginPosition = schemaToken.getBeginPosition() + schemaToken.getOriginalLiterals().length();</span><br><span class="line">        appendRest(sqlBuilder, count, beginPosition);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendIndexPlaceholder</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> IndexToken indexToken, <span class="keyword">final</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        String indexName = indexToken.getIndexName().toLowerCase();</span><br><span class="line">        String logicTableName = indexToken.getTableName().toLowerCase();</span><br><span class="line">        <span class="keyword">if</span> (Strings.isNullOrEmpty(logicTableName)) &#123;</span><br><span class="line">            logicTableName = shardingRule.getLogicTableName(indexName);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlBuilder.appendPlaceholder(<span class="keyword">new</span> IndexPlaceholder(indexName, logicTableName));</span><br><span class="line">        <span class="keyword">int</span> beginPosition = indexToken.getBeginPosition() + indexToken.getOriginalLiterals().length();</span><br><span class="line">        appendRest(sqlBuilder, count, beginPosition);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendItemsToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> ItemsToken itemsToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isRewriteItem = isRewrite || sqlStatement <span class="keyword">instanceof</span> InsertStatement;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; itemsToken.getItems().size() &amp;&amp; isRewriteItem; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (itemsToken.isFirstOfItemsSpecial() &amp;&amp; <span class="number">0</span> == i) &#123;</span><br><span class="line">                sqlBuilder.appendLiterals(SQLUtil.getOriginalValue(itemsToken.getItems().get(i), databaseType));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sqlBuilder.appendLiterals(<span class="string">", "</span>);</span><br><span class="line">                sqlBuilder.appendLiterals(SQLUtil.getOriginalValue(itemsToken.getItems().get(i), databaseType));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        appendRest(sqlBuilder, count, itemsToken.getBeginPosition());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendInsertValuesToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> InsertValuesToken insertValuesToken, <span class="keyword">final</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        sqlBuilder.appendPlaceholder(<span class="keyword">new</span> InsertValuesPlaceholder(insertValuesToken.getTableName().toLowerCase(), shardingConditions));</span><br><span class="line">        appendRest(sqlBuilder, count, ((InsertStatement) sqlStatement).getInsertValuesListLastPosition());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendLimitRowCount</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> RowCountToken rowCountToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite)</span> </span>&#123;</span><br><span class="line">        SelectStatement selectStatement = (SelectStatement) sqlStatement;</span><br><span class="line">        Limit limit = selectStatement.getLimit();</span><br><span class="line">        <span class="keyword">if</span> (!isRewrite) &#123;</span><br><span class="line">            sqlBuilder.appendLiterals(String.valueOf(rowCountToken.getRowCount()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!selectStatement.getGroupByItems().isEmpty() || !selectStatement.getAggregationSelectItems().isEmpty()) &amp;&amp; !selectStatement.isSameGroupByAndOrderByItems()) &#123;</span><br><span class="line">            sqlBuilder.appendLiterals(String.valueOf(Integer.MAX_VALUE));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sqlBuilder.appendLiterals(String.valueOf(limit.isNeedRewriteRowCount(databaseType) ? rowCountToken.getRowCount() + limit.getOffsetValue() : rowCountToken.getRowCount()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> beginPosition = rowCountToken.getBeginPosition() + String.valueOf(rowCountToken.getRowCount()).length();</span><br><span class="line">        appendRest(sqlBuilder, count, beginPosition);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendLimitOffsetToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> OffsetToken offsetToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite)</span> </span>&#123;</span><br><span class="line">        sqlBuilder.appendLiterals(isRewrite ? <span class="string">"0"</span> : String.valueOf(offsetToken.getOffset()));</span><br><span class="line">        <span class="keyword">int</span> beginPosition = offsetToken.getBeginPosition() + String.valueOf(offsetToken.getOffset()).length();</span><br><span class="line">        appendRest(sqlBuilder, count, beginPosition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序语句的重写</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendOrderByToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite)</span> </span>&#123;</span><br><span class="line">        SelectStatement selectStatement = (SelectStatement) sqlStatement;</span><br><span class="line">        <span class="keyword">if</span> (isRewrite) &#123;</span><br><span class="line">            StringBuilder orderByLiterals = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="comment">//拼接order by关键字</span></span><br><span class="line">            orderByLiterals.append(<span class="string">" "</span>).append(DefaultKeyword.ORDER).append(<span class="string">" "</span>).append(DefaultKeyword.BY).append(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//拼接排序的字段</span></span><br><span class="line">            <span class="keyword">for</span> (OrderItem each : selectStatement.getOrderByItems()) &#123;</span><br><span class="line">                String columnLabel = Strings.isNullOrEmpty(each.getColumnLabel()) ? String.valueOf(each.getIndex())</span><br><span class="line">                    : SQLUtil.getOriginalValue(each.getColumnLabel(), databaseType);</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == i) &#123;</span><br><span class="line">                    orderByLiterals.append(columnLabel).append(<span class="string">" "</span>).append(each.getOrderDirection().name());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    orderByLiterals.append(<span class="string">","</span>).append(columnLabel).append(<span class="string">" "</span>).append(each.getOrderDirection().name());</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            orderByLiterals.append(<span class="string">" "</span>);</span><br><span class="line">            sqlBuilder.appendLiterals(orderByLiterals.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//确定分组语句关键字的位置</span></span><br><span class="line">        <span class="keyword">int</span> beginPosition = selectStatement.getGroupByLastPosition();</span><br><span class="line">        appendRest(sqlBuilder, count, beginPosition);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendSymbolToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> InsertColumnToken insertColumnToken, <span class="keyword">final</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        sqlBuilder.appendLiterals(insertColumnToken.getColumnName());</span><br><span class="line">        appendRest(sqlBuilder, count, insertColumnToken.getBeginPosition());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendAggregationDistinctPlaceholder</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> AggregationDistinctToken distinctToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRewrite) &#123;</span><br><span class="line">            sqlBuilder.appendLiterals(distinctToken.getOriginalLiterals()); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sqlBuilder.appendPlaceholder(<span class="keyword">new</span> AggregationDistinctPlaceholder(distinctToken.getColumnName().toLowerCase(), <span class="keyword">null</span>, distinctToken.getAlias()));</span><br><span class="line">        &#125;</span><br><span class="line">        appendRest(sqlBuilder, count, distinctToken.getBeginPosition() + distinctToken.getOriginalLiterals().length());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendRest</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> <span class="keyword">int</span> beginPosition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</span><br><span class="line">        sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成SQL字符串</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableUnit route table unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sqlBuilder SQL builder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shardingDataSourceMetaData sharding data source meta data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SQL unit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SQLUnit <span class="title">generateSQL</span><span class="params">(<span class="keyword">final</span> TableUnit tableUnit, <span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> ShardingDataSourceMetaData shardingDataSourceMetaData)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//sqlBuilder中实现SQL转换为SQLUnit ，逻辑相对简单就不做详细说明</span></span><br><span class="line">        <span class="keyword">return</span> sqlBuilder.toSQL(tableUnit, getTableTokens(tableUnit), shardingRule, shardingDataSourceMetaData);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//获取表的token</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">getTableTokens</span><span class="params">(<span class="keyword">final</span> TableUnit tableUnit)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (RoutingTable each : tableUnit.getRoutingTables()) &#123;</span><br><span class="line">            String logicTableName = each.getLogicTableName().toLowerCase();</span><br><span class="line">            result.put(logicTableName, each.getActualTableName());</span><br><span class="line">            Optional&lt;BindingTableRule&gt; bindingTableRule = shardingRule.findBindingTableRule(logicTableName);</span><br><span class="line">            <span class="keyword">if</span> (bindingTableRule.isPresent()) &#123;</span><br><span class="line">                result.putAll(getBindingTableTokens(tableUnit.getDataSourceName(), each, bindingTableRule.get()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取绑定表的token</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">getBindingTableTokens</span><span class="params">(<span class="keyword">final</span> String dataSourceName, <span class="keyword">final</span> RoutingTable routingTable, <span class="keyword">final</span> BindingTableRule bindingTableRule)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String each : sqlStatement.getTables().getTableNames()) &#123;</span><br><span class="line">            String tableName = each.toLowerCase();</span><br><span class="line">            <span class="keyword">if</span> (!tableName.equals(routingTable.getLogicTableName().toLowerCase()) &amp;&amp; bindingTableRule.hasLogicTable(tableName)) &#123;</span><br><span class="line">                result.put(tableName, bindingTableRule.getBindingActualTable(dataSourceName, tableName, routingTable.getActualTableName()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="流式归并优化"><a href="#流式归并优化" class="headerlink" title="流式归并优化"></a>流式归并优化</h3><p>它仅为包含GROUP BY的SQL增加ORDER BY以及和分组项相同的排序项和排序顺序，用于将内存归并转化为流式归并。 在结果归并的部分中，将对流式归并和内存归并进行详细说明。</p>
<p>改写后的SQL当然是需要执行的，在sharding-jdbc之执行引擎中对sql执行原理进行分析。</p>
<p><br></p>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>ShardingSphere采用一套自动化的执行引擎,负责将路由和改写完成之后的真实SQL安全且高效发送到底层数据源执行。<br>它不是简单地将SQL通过JDBC直接发送至数据源执行;也并非直接将执行请求放入线程池去并发执行。<br>它更关注平衡数据源连接创建以及内存占用所产生的消耗,以及最大限度地合理利用并发等问题。 </p>
<p>执行引擎的目标是自动化的平衡资源控制与执行效率。</p>
<p><img src="/2017/10/08/sharding-jdbc/image-22.png" width="500px"></p>
<h3 id="准备阶段-SQLExecutePrepareTemplate"><a href="#准备阶段-SQLExecutePrepareTemplate" class="headerlink" title="准备阶段-SQLExecutePrepareTemplate"></a>准备阶段-SQLExecutePrepareTemplate</h3><p>顾名思义，此阶段用于准备执行的数据。它分为结果集分组和执行单元创建两个步骤。</p>
<p>结果集分组是实现内化连接模式概念的关键。执行引擎根据maxConnectionSizePerQuery配置项，结合当前路由结果，选择恰当的连接模式。 具体步骤如下：</p>
<ul>
<li>1 将SQL的路由结果按照数据源的名称进行分组。</li>
<li>2 通过下图的公式1-1，可以获得每个数据库实例在maxConnectionSizePerQuery的允许范围内，每个连接需要执行的SQL路由结果组，并计算出本次请求的最优连接模式。</li>
</ul>
<p><img src="/2017/10/08/sharding-jdbc/image-23.png" width="500px"></p>
<p><code>maxConnectionSizePerQuery</code>允许的范围内，当一个连接需要执行的请求数量大于1时，意味着当前的数据库连接无法持有相应的数据结果集，则必须采用内存归并； 反之，当一个连接需要执行的请求数量等于1时，意味着当前的数据库连接可以持有相应的数据结果集，则可以采用流式归并。</p>
<p>每一次的连接模式的选择，是针对每一个物理数据库的。也就是说，在同一次查询中，如果路由至一个以上的数据库，每个数据库的连接模式不一定一样，它们可能是混合存在的形态。</p>
<p>通过上一步骤获得的路由分组结果创建执行的单元。 当数据源使用数据库连接池等控制数据库连接数量的技术时，在获取数据库连接时，如果不妥善处理并发，则有一定几率发生死锁。 在多个请求相互等待对方释放数据库连接资源时，将会产生饥饿等待，造成交叉的死锁问题。</p>
<p>举例说明，假设一次查询需要在某一数据源上获取两个数据库连接，并路由至同一个数据库的两个分表查询。<br>则有可能出现查询A已获取到该数据源的1个数据库连接，并等待获取另一个数据库连接；而查询B也已经在该数据源上获取到的一个数据库连接，并同样等待另一个数据库连接的获取。<br>如果数据库连接池的允许最大连接数是2，那么这2个查询请求将永久的等待下去。</p>
<p>下图描绘了死锁的情况。</p>
<p><img src="/2017/10/08/sharding-jdbc/image-24.png" width="500px"></p>
<p>ShardingSphere为了避免死锁的出现，在获取数据库连接时进行了同步处理。 它在创建执行单元时，以原子性的方式一次性获取本次SQL请求所需的全部数据库连接[1]，杜绝了每次查询请求获取到部分资源的可能。 由于对数据库的操作非常频繁，每次获取数据库连接时时都进行锁定，会降低ShardingSphere的并发。因此，ShardingSphere在这里进行了2点优化：<br>1 避免锁定一次性只需要获取1个数据库连接的操作。因为每次仅需要获取1个连接，则不会发生两个请求相互等待的场景，无需锁定。 对于大部分OLTP的操作，都是使用分片键路由至唯一的数据节点，这会使得系统变为完全无锁的状态，进一步提升了并发效率。 除了路由至单分片的情况，读写分离也在此范畴之内。<br>2 仅针对内存限制模式时才进行资源锁定。在使用连接限制模式时，所有的查询结果集将在装载至内存之后释放掉数据库连接资源，因此不会产生死锁等待的问题。</p>
<p>SQLExecutePrepareTemplate源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLExecutePrepareTemplate</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过ShardingPropertiesConstant#MAX_CONNECTIONS_SIZE_PER_QUERY设置，用户可在配置文件中</span></span><br><span class="line">    <span class="comment">//max.connections.size.per.query = 10的方式配置这个值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxConnectionsSizePerQuery;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get execute unit groups.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routeUnits route units</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback SQL execute prepare callback</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> statement execute unit groups</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException SQL exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;ShardingExecuteGroup&lt;StatementExecuteUnit&gt;&gt; getExecuteUnitGroups(<span class="keyword">final</span> Collection&lt;RouteUnit&gt; routeUnits, <span class="keyword">final</span> SQLExecutePrepareCallback callback) <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> getSynchronizedExecuteUnitGroups(routeUnits, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Collection&lt;ShardingExecuteGroup&lt;StatementExecuteUnit&gt;&gt; getSynchronizedExecuteUnitGroups(</span><br><span class="line">            <span class="keyword">final</span> Collection&lt;RouteUnit&gt; routeUnits, <span class="keyword">final</span> SQLExecutePrepareCallback callback) <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="comment">//获取SQL执行信息，以数据库分组</span></span><br><span class="line">        Map&lt;String, List&lt;SQLUnit&gt;&gt; sqlUnitGroups = getSQLUnitGroups(routeUnits);</span><br><span class="line">        Collection&lt;ShardingExecuteGroup&lt;StatementExecuteUnit&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, List&lt;SQLUnit&gt;&gt; entry : sqlUnitGroups.entrySet()) &#123;</span><br><span class="line">        <span class="comment">//获取执行结果集分组</span></span><br><span class="line">            result.addAll(getSQLExecuteGroups(entry.getKey(), entry.getValue(), callback));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;SQLUnit&gt;&gt; getSQLUnitGroups(<span class="keyword">final</span> Collection&lt;RouteUnit&gt; routeUnits) &#123;</span><br><span class="line">        Map&lt;String, List&lt;SQLUnit&gt;&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(routeUnits.size(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (RouteUnit each : routeUnits) &#123;</span><br><span class="line">        <span class="comment">//创建以数据库维度的集合元素</span></span><br><span class="line">            <span class="keyword">if</span> (!result.containsKey(each.getDataSourceName())) &#123;</span><br><span class="line">                result.put(each.getDataSourceName(), <span class="keyword">new</span> LinkedList&lt;SQLUnit&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//填充SQLUnit</span></span><br><span class="line">            result.get(each.getDataSourceName()).add(each.getSqlUnit());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;ShardingExecuteGroup&lt;StatementExecuteUnit&gt;&gt; getSQLExecuteGroups(</span><br><span class="line">            <span class="keyword">final</span> String dataSourceName, <span class="keyword">final</span> List&lt;SQLUnit&gt; sqlUnits, <span class="keyword">final</span> SQLExecutePrepareCallback callback) <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        List&lt;ShardingExecuteGroup&lt;StatementExecuteUnit&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 根据公式1-1获取期望的分割数量</span></span><br><span class="line">        <span class="keyword">int</span> desiredPartitionSize = Math.max(<span class="number">0</span> == sqlUnits.size() % maxConnectionsSizePerQuery ? sqlUnits.size() / maxConnectionsSizePerQuery : sqlUnits.size() / maxConnectionsSizePerQuery + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        List&lt;List&lt;SQLUnit&gt;&gt; sqlUnitPartitions = Lists.partition(sqlUnits, desiredPartitionSize);</span><br><span class="line">        <span class="comment">//确定连接模式 ：连接限制模式 | 内存限制模式 |</span></span><br><span class="line">        ConnectionMode connectionMode = maxConnectionsSizePerQuery &lt; sqlUnits.size() ? ConnectionMode.CONNECTION_STRICTLY : ConnectionMode.MEMORY_STRICTLY;</span><br><span class="line">        <span class="comment">//获取连接，逻辑实现在AbstractConnectionAdapter#getConnections()中</span></span><br><span class="line">        List&lt;Connection&gt; connections = callback.getConnections(connectionMode, dataSourceName, sqlUnitPartitions.size());</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;SQLUnit&gt; each : sqlUnitPartitions) &#123;</span><br><span class="line">            result.add(getSQLExecuteGroup(connectionMode, connections.get(count++), dataSourceName, each, callback));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取执行结果集分组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ShardingExecuteGroup&lt;StatementExecuteUnit&gt; <span class="title">getSQLExecuteGroup</span><span class="params">(<span class="keyword">final</span> ConnectionMode connectionMode, <span class="keyword">final</span> Connection connection, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                                          <span class="keyword">final</span> String dataSourceName, <span class="keyword">final</span> List&lt;SQLUnit&gt; sqlUnitGroup, <span class="keyword">final</span> SQLExecutePrepareCallback callback)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        List&lt;StatementExecuteUnit&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (SQLUnit each : sqlUnitGroup) &#123;</span><br><span class="line">            result.add(callback.createStatementExecuteUnit(connection, <span class="keyword">new</span> RouteUnit(dataSourceName, each), connectionMode));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShardingExecuteGroup&lt;&gt;(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在准备阶段描述中(1),获取连接的逻辑实现在<code>AbstractConnectionAdapter</code>中,下面分析下<code>AbstractConnectionAdapter#getConnections()</code>方法;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get database connections.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> connectionMode connection mode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dataSourceName data source name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> connectionSize size of connection list to be get</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> database connections</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException SQL exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> List&lt;Connection&gt; <span class="title">getConnections</span><span class="params">(<span class="keyword">final</span> ConnectionMode connectionMode, <span class="keyword">final</span> String dataSourceName, <span class="keyword">final</span> <span class="keyword">int</span> connectionSize)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    DataSource dataSource = getDataSourceMap().get(dataSourceName);</span><br><span class="line">    Preconditions.checkState(<span class="keyword">null</span> != dataSource, <span class="string">"Missing the data source name: '%s'"</span>, dataSourceName);</span><br><span class="line">    Collection&lt;Connection&gt; connections;</span><br><span class="line">    <span class="keyword">synchronized</span> (cachedConnections) &#123;</span><br><span class="line">        connections = cachedConnections.get(dataSourceName);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Connection&gt; result;</span><br><span class="line">    <span class="comment">//缓存中的连接熟练重组</span></span><br><span class="line">    <span class="keyword">if</span> (connections.size() &gt;= connectionSize) &#123;</span><br><span class="line">        result = <span class="keyword">new</span> ArrayList&lt;&gt;(connections).subList(<span class="number">0</span>, connectionSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connections.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">//  不足，需要创建新的连接</span></span><br><span class="line">        result = <span class="keyword">new</span> ArrayList&lt;&gt;(connectionSize);</span><br><span class="line">        result.addAll(connections);</span><br><span class="line">        List&lt;Connection&gt; newConnections = createConnections(connectionMode, dataSource, connectionSize - connections.size());</span><br><span class="line">        result.addAll(newConnections);</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedConnections) &#123;</span><br><span class="line">            cachedConnections.putAll(dataSourceName, newConnections);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">new</span> ArrayList&lt;&gt;(createConnections(connectionMode, dataSource, connectionSize));</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedConnections) &#123;</span><br><span class="line">            cachedConnections.putAll(dataSourceName, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"SynchronizationOnLocalVariableOrMethodParameter"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Connection&gt; <span class="title">createConnections</span><span class="params">(<span class="keyword">final</span> ConnectionMode connectionMode, <span class="keyword">final</span> DataSource dataSource, <span class="keyword">final</span> <span class="keyword">int</span> connectionSize)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//获取单个连接时不需要锁定</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == connectionSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(createConnection(dataSource));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接限制模式时，所有的查询结果集将在装载至内存之后释放掉数据库连接资源，因此不会产生死锁等待的问题</span></span><br><span class="line">    <span class="keyword">if</span> (ConnectionMode.CONNECTION_STRICTLY == connectionMode) &#123;</span><br><span class="line">        <span class="keyword">return</span> createConnections(dataSource, connectionSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (dataSource) &#123;</span><br><span class="line">    <span class="comment">//(size != 1 &amp;&amp;  ConnectionMode.MEMORY_STRICTLY)仅针对内存限制模式时才进行资源锁定</span></span><br><span class="line">    <span class="comment">//如执行引擎的整体结构图中描述的相同</span></span><br><span class="line">        <span class="keyword">return</span> createConnections(dataSource, connectionSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Connection&gt; <span class="title">createConnections</span><span class="params">(<span class="keyword">final</span> DataSource dataSource, <span class="keyword">final</span> <span class="keyword">int</span> connectionSize)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    List&lt;Connection&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(connectionSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectionSize; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result.add(createConnection(dataSource));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Connection each : result) &#123;</span><br><span class="line">                each.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(String.format(<span class="string">"Could't get %d connections one time, partition succeed connection(%d) have released!"</span>, connectionSize, result.size()), ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">createConnection</span><span class="params">(<span class="keyword">final</span> DataSource dataSource)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Connection result = dataSource.getConnection();</span><br><span class="line">    replayMethodsInvocation(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行阶段-SQLExecuteTemplate"><a href="#执行阶段-SQLExecuteTemplate" class="headerlink" title="执行阶段-SQLExecuteTemplate"></a>执行阶段-SQLExecuteTemplate</h3><p>该阶段用于真正的执行SQL，它分为分组执行和归并结果集生成两个步骤。</p>
<p>分组执行将准备执行阶段生成的执行单元分组下发至底层并发执行引擎，并针对执行过程中的每个关键步骤发送事件。 如:执行开始事件、执行成功事件以及执行失败事件。<br>执行引擎仅关注事件的发送，它并不关心事件的订阅者。 ShardingSphere的其他模块，如：分布式事务、调用链路追踪等，会订阅感兴趣的事件，并进行相应的处理。</p>
<p>ShardingSphere通过在执行准备阶段的获取的连接模式，生成内存归并结果集或流式归并结果集，并将其传递至结果归并引擎，以进行下一步的工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">executeGroup</span><span class="params">(<span class="keyword">final</span> Collection&lt;ShardingExecuteGroup&lt;? extends StatementExecuteUnit&gt;&gt; sqlExecuteGroups,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> SQLExecuteCallback&lt;T&gt; firstCallback, <span class="keyword">final</span> SQLExecuteCallback&lt;T&gt; callback)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//调用执行引擎的方法，分组执行</span></span><br><span class="line">        <span class="keyword">return</span> executeEngine.groupExecute((Collection) sqlExecuteGroups, firstCallback, callback);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</span><br><span class="line">        ExecutorExceptionHandler.handleException(ex);</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行引擎源码<code>ShardingExecuteEngine</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingExecuteEngine</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingExecutorService shardingExecutorService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ListeningExecutorService executorService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShardingExecuteEngine</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> executorSize)</span> </span>&#123;</span><br><span class="line">        shardingExecutorService = <span class="keyword">new</span> ShardingExecutorService(executorSize);</span><br><span class="line">        executorService = shardingExecutorService.getExecutorService();</span><br><span class="line">    &#125;</span><br><span class="line">.......................</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Execute for group.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputGroups input groups</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback sharding execute callback</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;I&gt; type of input value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;O&gt; type of return value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> execute result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException throw if execute failure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;I, O&gt; <span class="function">List&lt;O&gt; <span class="title">groupExecute</span><span class="params">(<span class="keyword">final</span> Collection&lt;ShardingExecuteGroup&lt;I&gt;&gt; inputGroups, <span class="keyword">final</span> ShardingGroupExecuteCallback&lt;I, O&gt; callback)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> groupExecute(inputGroups, <span class="keyword">null</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Execute for group.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputGroups input groups</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback sharding execute callback</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstCallback first sharding execute callback</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;I&gt; type of input value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;O&gt; type of return value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> execute result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException throw if execute failure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;I, O&gt; <span class="function">List&lt;O&gt; <span class="title">groupExecute</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> Collection&lt;ShardingExecuteGroup&lt;I&gt;&gt; inputGroups, <span class="keyword">final</span> ShardingGroupExecuteCallback&lt;I, O&gt; firstCallback, <span class="keyword">final</span> ShardingGroupExecuteCallback&lt;I, O&gt; callback)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inputGroups.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;ShardingExecuteGroup&lt;I&gt;&gt; inputGroupsIterator = inputGroups.iterator();</span><br><span class="line">        ShardingExecuteGroup&lt;I&gt; firstInputs = inputGroupsIterator.next();</span><br><span class="line">        <span class="comment">//多线程并行执行</span></span><br><span class="line">        Collection&lt;ListenableFuture&lt;Collection&lt;O&gt;&gt;&gt; restResultFutures = asyncGroupExecute(Lists.newArrayList(inputGroupsIterator), callback);</span><br><span class="line">        <span class="comment">//同步执行，等待子线程执行结束</span></span><br><span class="line">        <span class="keyword">return</span> getGroupResults(syncGroupExecute(firstInputs, <span class="keyword">null</span> == firstCallback ? callback : firstCallback), restResultFutures);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> &lt;I, O&gt; Collection&lt;ListenableFuture&lt;Collection&lt;O&gt;&gt;&gt; asyncGroupExecute(<span class="keyword">final</span> List&lt;ShardingExecuteGroup&lt;I&gt;&gt; inputGroups, <span class="keyword">final</span> ShardingGroupExecuteCallback&lt;I, O&gt; callback) &#123;</span><br><span class="line">        Collection&lt;ListenableFuture&lt;Collection&lt;O&gt;&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ShardingExecuteGroup&lt;I&gt; each : inputGroups) &#123;</span><br><span class="line">            result.add(asyncGroupExecute(each, callback));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> &lt;I, O&gt; ListenableFuture&lt;Collection&lt;O&gt;&gt; asyncGroupExecute(<span class="keyword">final</span> ShardingExecuteGroup&lt;I&gt; inputGroup, <span class="keyword">final</span> ShardingGroupExecuteCallback&lt;I, O&gt; callback) &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, Object&gt; dataMap = ShardingExecuteDataMap.getDataMap();</span><br><span class="line">        <span class="keyword">return</span> executorService.submit(<span class="keyword">new</span> Callable&lt;Collection&lt;O&gt;&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Collection&lt;O&gt; <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            <span class="comment">//回调方法执行，事件发送 （异步）</span></span><br><span class="line">                <span class="keyword">return</span> callback.execute(inputGroup.getInputs(), <span class="keyword">false</span>, dataMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> &lt;I, O&gt; <span class="function">Collection&lt;O&gt; <span class="title">syncGroupExecute</span><span class="params">(<span class="keyword">final</span> ShardingExecuteGroup&lt;I&gt; executeGroup, <span class="keyword">final</span> ShardingGroupExecuteCallback&lt;I, O&gt; callback)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">     <span class="comment">//回调方法执行，事件发送（同步）</span></span><br><span class="line">        <span class="keyword">return</span> callback.execute(executeGroup.getInputs(), <span class="keyword">true</span>, ShardingExecuteDataMap.getDataMap());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> &lt;O&gt; <span class="function">List&lt;O&gt; <span class="title">getGroupResults</span><span class="params">(<span class="keyword">final</span> Collection&lt;O&gt; firstResults, <span class="keyword">final</span> Collection&lt;ListenableFuture&lt;Collection&lt;O&gt;&gt;&gt; restFutures)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        List&lt;O&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        result.addAll(firstResults);</span><br><span class="line">        <span class="keyword">for</span> (ListenableFuture&lt;Collection&lt;O&gt;&gt; each : restFutures) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result.addAll(each.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException | ExecutionException ex) &#123;</span><br><span class="line">                <span class="keyword">return</span> throwException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> &lt;O&gt; <span class="function">List&lt;O&gt; <span class="title">throwException</span><span class="params">(<span class="keyword">final</span> Exception ex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ex.getCause() <span class="keyword">instanceof</span> SQLException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (SQLException) ex.getCause();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ShardingException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        shardingExecutorService.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SQLExecuteCallback事件发送</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;T&gt; <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Collection&lt;StatementExecuteUnit&gt; statementExecuteUnits, <span class="keyword">final</span> <span class="keyword">boolean</span> isTrunkThread,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">final</span> Map&lt;String, Object&gt; shardingExecuteDataMap)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Collection&lt;T&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (StatementExecuteUnit each : statementExecuteUnits) &#123;</span><br><span class="line">        result.add(execute0(each, isTrunkThread, shardingExecuteDataMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">execute0</span><span class="params">(<span class="keyword">final</span> StatementExecuteUnit statementExecuteUnit, <span class="keyword">final</span> <span class="keyword">boolean</span> isTrunkThread, <span class="keyword">final</span> Map&lt;String, Object&gt; shardingExecuteDataMap)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ExecutorExceptionHandler.setExceptionThrown(isExceptionThrown);</span><br><span class="line">    DataSourceMetaData dataSourceMetaData = DataSourceMetaDataFactory.newInstance(databaseType, statementExecuteUnit.getDatabaseMetaData().getURL());</span><br><span class="line">    <span class="comment">//创建钩子实例</span></span><br><span class="line">    SQLExecutionHook sqlExecutionHook = <span class="keyword">new</span> SPISQLExecutionHook();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//事务开始事件</span></span><br><span class="line">        sqlExecutionHook.start(statementExecuteUnit.getRouteUnit(), dataSourceMetaData, isTrunkThread, shardingExecuteDataMap);</span><br><span class="line">        T result = executeSQL(statementExecuteUnit);</span><br><span class="line">        <span class="comment">//事务成功事件</span></span><br><span class="line">        sqlExecutionHook.finishSuccess();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</span><br><span class="line">      <span class="comment">//事务失败事件</span></span><br><span class="line">        sqlExecutionHook.finishFailure(ex);</span><br><span class="line">        ExecutorExceptionHandler.handleException(ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于事件监听，在分布式事务、调用链路追踪等，会订阅感兴趣的事件，并进行相应的处理，这部分将在后续分布式事务中分析。</p>
<p><br></p>
<h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><p><code>MergeEngine</code>分片结果集归并引擎。</p>
<blockquote>
<p>支持的结果归并从功能上分为遍历、排序、分组、分页和聚合5种类型，它们是组合而非互斥的关系<br>从结构划分:可分为流式归并、内存归并和装饰者归并。<br>流式归并和内存归并是互斥的,装饰者归并可以在流式归并和内存归并之上做进一步的处理。</p>
</blockquote>
<p>由于从数据库中返回的结果集是逐条返回的，并不需要将所有的数据一次性加载至内存中，因此在进行结果归并时，沿用数据库返回结果集的方式进行归并，能够极大减少内存的消耗，是归并方式的优先选择。</p>
<blockquote>
<p>流式归并是指每一次从结果集中获取到的数据，都能够通过逐条获取的方式返回正确的单条数据，它与数据库原生的返回结果集的方式最为契合。遍历、排序以及流式分组都属于流式归并的一种。<br>内存归并则是需要将结果集的所有数据都遍历并存储在内存中，再通过统一的分组、排序以及聚合等计算之后，再将其封装成为逐条访问的数据结果集返回。<br>装饰者归并是对所有的结果集归并进行统一的功能增强，目前装饰者归并有分页归并和聚合归并这2种类型。</p>
</blockquote>
<p><img src="/2017/10/08/sharding-jdbc/image-18.png" width="500px"></p>
<blockquote>
<p>以下是具体的实现类 </p>
</blockquote>
<p><img src="/2017/10/08/sharding-jdbc/image-20.png" width="750px"></p>
<p>上图中红框内是分页和聚合两种结果集的归并，在整个结果集归并的过程中，这两种归并以装饰器模式的方式对结果集进行处理。下面就从源码中找寻物种归并方式的使用流程。</p>
<h3 id="MergeEngineFactory-归并引擎工厂类"><a href="#MergeEngineFactory-归并引擎工厂类" class="headerlink" title="MergeEngineFactory-归并引擎工厂类"></a>MergeEngineFactory-归并引擎工厂类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建归并引擎的实例 ，根据SQL语句的类型不同，创建DQLMergeEngine或者DALMergeEngine</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MergeEngine <span class="title">newInstance</span><span class="params">(<span class="keyword">final</span> DatabaseType databaseType, <span class="keyword">final</span> ShardingRule shardingRule, </span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">final</span> SQLStatement sqlStatement, <span class="keyword">final</span> ShardingTableMetaData shardingTableMetaData, <span class="keyword">final</span> List&lt;QueryResult&gt; queryResults)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> SelectStatement) &#123;</span><br><span class="line">    <span class="comment">//  创建DQLMergeEngine实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DQLMergeEngine(databaseType, (SelectStatement) sqlStatement, queryResults);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> DALStatement) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DALMergeEngine(shardingRule, queryResults, (DALStatement) sqlStatement, shardingTableMetaData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(String.format(<span class="string">"Cannot support type '%s'"</span>, sqlStatement.getType()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DQLMergeEngine引擎"><a href="#DQLMergeEngine引擎" class="headerlink" title="DQLMergeEngine引擎"></a>DQLMergeEngine引擎</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DQLMergeEngine</span> <span class="keyword">implements</span> <span class="title">MergeEngine</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数据库类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DatabaseType databaseType;</span><br><span class="line">    <span class="comment">//查询语句</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelectStatement selectStatement;</span><br><span class="line">    <span class="comment">//查询结果集</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;QueryResult&gt; queryResults;</span><br><span class="line">    <span class="comment">//列标签索引Map集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; columnLabelIndexMap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DQLMergeEngine</span><span class="params">(<span class="keyword">final</span> DatabaseType databaseType, <span class="keyword">final</span> SelectStatement selectStatement, <span class="keyword">final</span> List&lt;QueryResult&gt; queryResults)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.databaseType = databaseType;</span><br><span class="line">        <span class="keyword">this</span>.selectStatement = selectStatement;</span><br><span class="line">        <span class="keyword">this</span>.queryResults = getRealQueryResults(queryResults);</span><br><span class="line">        columnLabelIndexMap = getColumnLabelIndexMap(<span class="keyword">this</span>.queryResults.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;QueryResult&gt; <span class="title">getRealQueryResults</span><span class="params">(<span class="keyword">final</span> List&lt;QueryResult&gt; queryResults)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == queryResults.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> queryResults;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!selectStatement.getAggregationDistinctSelectItems().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getDividedQueryResults(<span class="keyword">new</span> AggregationDistinctQueryResult(queryResults, selectStatement.getAggregationDistinctSelectItems()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (selectStatement.getDistinctSelectItem().isPresent()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getDividedQueryResults(<span class="keyword">new</span> DistinctQueryResult(queryResults, <span class="keyword">new</span> ArrayList&lt;&gt;(selectStatement.getDistinctSelectItem().get().getDistinctColumnLabels())));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queryResults;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;QueryResult&gt; <span class="title">getDividedQueryResults</span><span class="params">(<span class="keyword">final</span> DistinctQueryResult distinctQueryResult)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Lists.transform(distinctQueryResult.divide(), <span class="keyword">new</span> Function&lt;DistinctQueryResult, QueryResult&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> QueryResult <span class="title">apply</span><span class="params">(<span class="keyword">final</span> DistinctQueryResult input)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> input;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, Integer&gt; <span class="title">getColumnLabelIndexMap</span><span class="params">(<span class="keyword">final</span> QueryResult queryResult)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; result = <span class="keyword">new</span> TreeMap&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= queryResult.getColumnCount(); i++) &#123;</span><br><span class="line">            result.put(SQLUtil.getExactlyValue(queryResult.getColumnLabel(i)), i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取结果集需要调用的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MergedResult <span class="title">merge</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//查询结果集数量为1时只需调用遍历结果集归并</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == queryResults.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> IteratorStreamMergedResult(queryResults);</span><br><span class="line">        &#125;</span><br><span class="line">        selectStatement.setIndexForItems(columnLabelIndexMap);</span><br><span class="line">        <span class="comment">//build-分组、排序结果集归并 decorate 分页结果集归并</span></span><br><span class="line">        <span class="keyword">return</span> decorate(build());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> MergedResult <span class="title">build</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">//查询语句中分组语句或者聚合函数不为空，则执行分组归并</span></span><br><span class="line">        <span class="keyword">if</span> (!selectStatement.getGroupByItems().isEmpty() || !selectStatement.getAggregationSelectItems().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getGroupByMergedResult();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序语句不为空，则执行排序结果集归并</span></span><br><span class="line">        <span class="keyword">if</span> (!selectStatement.getOrderByItems().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> OrderByStreamMergedResult(queryResults, selectStatement.getOrderByItems());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后执行遍历结果集归并</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IteratorStreamMergedResult(queryResults);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> MergedResult <span class="title">getGroupByMergedResult</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">//分组结果集归并，如果分组条件和排序条件相同则执行流式分组归并方式，否则使用内存分组归并</span></span><br><span class="line">        <span class="keyword">if</span> (selectStatement.isSameGroupByAndOrderByItems()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GroupByStreamMergedResult(columnLabelIndexMap, queryResults, selectStatement);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GroupByMemoryMergedResult(columnLabelIndexMap, queryResults, selectStatement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用装饰器模式对结果集进行分页归并</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MergedResult <span class="title">decorate</span><span class="params">(<span class="keyword">final</span> MergedResult mergedResult)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Limit limit = selectStatement.getLimit();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == limit || <span class="number">1</span> == queryResults.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> mergedResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据数据库类型的不同执行相应的分页结果集归并</span></span><br><span class="line">        <span class="keyword">if</span> (DatabaseType.MySQL == databaseType || DatabaseType.PostgreSQL == databaseType || DatabaseType.H2 == databaseType) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LimitDecoratorMergedResult(mergedResult, selectStatement.getLimit());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DatabaseType.Oracle == databaseType) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RowNumberDecoratorMergedResult(mergedResult, selectStatement.getLimit());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DatabaseType.SQLServer == databaseType) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TopAndRowNumberDecoratorMergedResult(mergedResult, selectStatement.getLimit());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergedResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="分布式主键"><a href="#分布式主键" class="headerlink" title="分布式主键"></a>分布式主键</h2><p><img src="/2017/10/08/sharding-jdbc/image-13.png" width="500px"></p>
<p><code>DefaultKeyGenerator</code>该生成器采用 Twitter Snowflake 算法实现，生成 <strong>64 Bits</strong> 的 <strong>Long</strong> 型编号。国内另外一款数据库中间件 MyCAT 分布式主键也是基于该算法实现。</p>
<h3 id="DefaultKeyGenerator"><a href="#DefaultKeyGenerator" class="headerlink" title="DefaultKeyGenerator"></a>DefaultKeyGenerator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultKeyGenerator</span> <span class="keyword">implements</span> <span class="title">KeyGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间偏移量，从2016年11月1日零点开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EPOCH;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自增量占用比特</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEQUENCE_BITS = <span class="number">12L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作进程ID比特</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WORKER_ID_BITS = <span class="number">10L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自增量掩码（最大值）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEQUENCE_MASK = (<span class="number">1</span> &lt;&lt; SEQUENCE_BITS) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作进程ID左移比特数（位数）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WORKER_ID_LEFT_SHIFT_BITS = SEQUENCE_BITS;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间戳左移比特数（位数）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIMESTAMP_LEFT_SHIFT_BITS = WORKER_ID_LEFT_SHIFT_BITS + WORKER_ID_BITS;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作进程ID最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WORKER_ID_MAX_VALUE = <span class="number">1L</span> &lt;&lt; WORKER_ID_BITS;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TimeService timeService = <span class="keyword">new</span> TimeService();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作进程ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> workerId;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.set(<span class="number">2016</span>, Calendar.NOVEMBER, <span class="number">1</span>);</span><br><span class="line">        calendar.set(Calendar.HOUR_OF_DAY, <span class="number">0</span>);</span><br><span class="line">        calendar.set(Calendar.MINUTE, <span class="number">0</span>);</span><br><span class="line">        calendar.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">        calendar.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br><span class="line">        EPOCH = calendar.getTimeInMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后自增量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后生成编号时间戳，单位：毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置工作进程Id.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId 工作进程Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setWorkerId</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> workerId)</span> </span>&#123;</span><br><span class="line">        Preconditions.checkArgument(workerId &gt;= <span class="number">0L</span> &amp;&amp; workerId &lt; WORKER_ID_MAX_VALUE);</span><br><span class="line">        DefaultKeyGenerator.workerId = workerId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成Id.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回@&#123;<span class="doctag">@link</span> Long&#125;类型的Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Number <span class="title">generateKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保证当前时间大于最后时间。时间回退会导致产生重复id</span></span><br><span class="line">        <span class="keyword">long</span> currentMillis = timeService.getCurrentMillis();</span><br><span class="line">        Preconditions.checkState(lastTime &lt;= currentMillis, <span class="string">"Clock is moving backwards, last time is %d milliseconds, current time is %d milliseconds"</span>, lastTime, currentMillis);</span><br><span class="line">        <span class="comment">// 获取序列号</span></span><br><span class="line">        <span class="keyword">if</span> (lastTime == currentMillis) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0L</span> == (sequence = ++sequence &amp; SEQUENCE_MASK)) &#123; <span class="comment">// 当获得序号超过最大值时，归0，并去获得新的时间</span></span><br><span class="line">                currentMillis = waitUntilNextTime(currentMillis);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置最后时间戳</span></span><br><span class="line">        lastTime = currentMillis;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"&#123;&#125;-&#123;&#125;-&#123;&#125;"</span>, <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>).format(<span class="keyword">new</span> Date(lastTime)), workerId, sequence);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成编号</span></span><br><span class="line">        <span class="keyword">return</span> ((currentMillis - EPOCH) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (workerId &lt;&lt; WORKER_ID_LEFT_SHIFT_BITS) | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不停获得时间，直到大于最后时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTime 最后时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">waitUntilNextTime</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> lastTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> time = timeService.getCurrentMillis();</span><br><span class="line">        <span class="keyword">while</span> (time &lt;= lastTime) &#123;</span><br><span class="line">            time = timeService.getCurrentMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HostNameKeyGenerator"><a href="#HostNameKeyGenerator" class="headerlink" title="HostNameKeyGenerator"></a>HostNameKeyGenerator</h3><blockquote>
<p>根据<strong>机器名最后的数字编号</strong>获取工作进程编号。<br>如果线上机器命名有统一规范,建议使用此种方式。<br>例如，机器的 HostName 为: <code>dangdang-db-sharding-dev-01</code>(公司名-部门名-服务名-环境名-编号)，会截取 HostName 最后的编号 01 作为工作进程编号( workId )。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HostNameKeyGenerator.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initWorkerId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   InetAddress address;</span><br><span class="line">   Long workerId;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       address = InetAddress.getLocalHost();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> UnknownHostException e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot get LocalHost InetAddress, please check your network!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   String hostName = address.getHostName();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       workerId = Long.valueOf(hostName.replace(hostName.replaceAll(<span class="string">"\\d+$"</span>, <span class="string">""</span>), <span class="string">""</span>));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NumberFormatException e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"Wrong hostname:%s, hostname must be end with number!"</span>, hostName));</span><br><span class="line">   &#125;</span><br><span class="line">   DefaultKeyGenerator.setWorkerId(workerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IPKeyGenerator"><a href="#IPKeyGenerator" class="headerlink" title="IPKeyGenerator"></a>IPKeyGenerator</h3><blockquote>
<p>根据<strong>机器IP</strong>获取工作进程编号。<br>如果线上机器的IP二进制表示的最后10位不重复,建议使用此种方式。<br>例如，机器的IP为192.168.1.108，二进制表示:<code>11000000 10101000 00000001 01101100</code>，截取最后 10 位 <code>01 01101100</code>，转为十进制 364，设置工作进程编号为 364。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPKeyGenerator.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initWorkerId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   InetAddress address;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       address = InetAddress.getLocalHost();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> UnknownHostException e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot get LocalHost InetAddress, please check your network!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">byte</span>[] ipAddressByteArray = address.getAddress();</span><br><span class="line">   DefaultKeyGenerator.setWorkerId((<span class="keyword">long</span>) (((ipAddressByteArray[ipAddressByteArray.length - <span class="number">2</span>] &amp; <span class="number">0B11</span>) &lt;&lt; Byte.SIZE)</span><br><span class="line">           + (ipAddressByteArray[ipAddressByteArray.length - <span class="number">1</span>] &amp; <span class="number">0xFF</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IPSectionKeyGenerator"><a href="#IPSectionKeyGenerator" class="headerlink" title="IPSectionKeyGenerator"></a>IPSectionKeyGenerator</h3><p>来自 <strong>DogFc</strong> 贡献，对 IPKeyGenerator 进行改造。</p>
<blockquote>
<p>浏览 IPKeyGenerator 工作进程编号生成的规则后，感觉对服务器IP后10位（特别是IPV6）数值比较约束。<br>有以下优化思路：<br>因为工作进程编号最大限制是 2^10，我们生成的工程进程编号只要满足小于 1024 即可。<br>1.针对IPV4:<br>….IP最大 255.255.255.255。而（255+255+255+255) &lt; 1024。<br>….因此采用IP段数值相加即可生成唯一的workerId，不受IP位限制。</p>
<ol>
<li>针对IPV6:<br>….IP最大 ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff<br>….为了保证相加生成出的工程进程编号 &lt; 1024,思路是将每个 Bit 位的后6位相加。这样在一定程度上也可以满足workerId不重复的问题。<br>使用这种 IP 生成工作进程编号的方法,必须保证IP段相加不能重复</li>
</ol>
</blockquote>
<p>对于 IPV6 ：2^ 6 = 64。64 * 8 = 512 &lt; 1024。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPSectionKeyGenerator.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initWorkerId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   InetAddress address;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       address = InetAddress.getLocalHost();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> UnknownHostException e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot get LocalHost InetAddress, please check your network!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">byte</span>[] ipAddressByteArray = address.getAddress();</span><br><span class="line">   <span class="keyword">long</span> workerId = <span class="number">0L</span>;</span><br><span class="line">   <span class="comment">// IPV4</span></span><br><span class="line">   <span class="keyword">if</span> (ipAddressByteArray.length == <span class="number">4</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">byte</span> byteNum : ipAddressByteArray) &#123;</span><br><span class="line">           workerId += byteNum &amp; <span class="number">0xFF</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="comment">// IPV6</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ipAddressByteArray.length == <span class="number">16</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">byte</span> byteNum : ipAddressByteArray) &#123;</span><br><span class="line">           workerId += byteNum &amp; <span class="number">0B111111</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Bad LocalHost InetAddress, please check your network!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   DefaultKeyGenerator.setWorkerId(workerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>由于SQL语法灵活复杂，分布式数据库和单机数据库的查询场景又不完全相同，难免有和单机数据库不兼容的SQL出现。</p>
<p>本文详细罗列出已明确可支持的SQL种类以及已明确不支持的SQL种类，尽量让使用者避免踩坑。</p>
<p>其中必然有未涉及到的SQL欢迎补充，未支持的SQL也尽量会在未来的版本中支持。</p>
<h2 id="支持项"><a href="#支持项" class="headerlink" title="支持项"></a>支持项</h2><p>全面支持DQL、DML和DDL。支持分页、排序、分组、聚合、关联查询（不支持跨库关联）。以下用最为复杂的DQL举例：</p>
<ul>
<li>SELECT主语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> select_expr [, select_expr ...] <span class="keyword">FROM</span> table_reference [, table_reference ...]</span><br><span class="line">[<span class="keyword">WHERE</span> where_condition] </span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> &#123;col_name | <span class="keyword">position</span>&#125; [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]] </span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;col_name | <span class="keyword">position</span>&#125; [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ...] </span><br><span class="line">[<span class="keyword">LIMIT</span> &#123;[<span class="keyword">offset</span>,] <span class="keyword">row_count</span> | <span class="keyword">row_count</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span>&#125;]</span><br></pre></td></tr></table></figure>
<ul>
<li>select_expr</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* | </span><br><span class="line">COLUMN_NAME [AS] [alias] | </span><br><span class="line">(MAX | MIN | SUM | AVG)(COLUMN_NAME | alias) [AS] [alias] | </span><br><span class="line">COUNT(* | COLUMN_NAME | alias) [AS] [alias]</span><br></pre></td></tr></table></figure>
<ul>
<li>table_reference</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tbl_name [AS] alias] [index_hint_list] | </span><br><span class="line">table_reference ([INNER] | &#123;LEFT|RIGHT&#125; [OUTER]) JOIN table_factor [JOIN ON conditional_expr | USING (column_list)] |</span><br></pre></td></tr></table></figure>
<h2 id="不支持项"><a href="#不支持项" class="headerlink" title="不支持项"></a>不支持项</h2><p>不支持冗余括号、CASE WHEN、DISTINCT、HAVING、UNION (ALL)，有限支持子查询。</p>
<p>除了分页子查询的支持之外(详情请参考<a href="http://shardingsphere.io/document/current/cn/features/sharding/usage-standard/pagination" target="_blank" rel="noopener">分页</a>)，也支持同等模式的子查询。无论嵌套多少层，Sharding-Sphere都可以解析至第一个包含数据表的子查询，一旦在下层嵌套中再次找到包含数据表的子查询将直接抛出解析异常。</p>
<p>例如，以下子查询可以支持：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o)</span><br></pre></td></tr></table></figure>
<p>以下子查询不支持：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o <span class="keyword">WHERE</span> o.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> <span class="keyword">status</span> = ?))</span><br></pre></td></tr></table></figure>
<p>简单来说，通过子查询进行非功能需求，在大部分情况下是可以支持的。比如分页、统计总数等；而通过子查询实现业务查询当前并不能支持。</p>
<p>由于归并的限制，子查询中包含聚合函数目前无法支持。</p>
<p>不支持包含schema的SQL。因为Sharding-Sphere的理念是像使用一个数据源一样使用多数据源，因此对SQL的访问都是在同一个逻辑schema之上。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="支持的SQL"><a href="#支持的SQL" class="headerlink" title="支持的SQL"></a>支持的SQL</h3><table>
<thead>
<tr>
<th>SQL</th>
<th>必要条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>SELECT * FROM tbl_name</td>
<td></td>
</tr>
<tr>
<td>SELECT * FROM tbl_name WHERE (col1 = ? or col2 = ?) and col3 = ?</td>
<td></td>
</tr>
<tr>
<td>SELECT * FROM tbl_name WHERE col1 = ? ORDER BY col2 DESC LIMIT ?</td>
<td></td>
</tr>
<tr>
<td>SELECT COUNT(*), SUM(col1), MIN(col1), MAX(col1), AVG(col1) FROM tbl_name WHERE col1 = ?</td>
<td></td>
</tr>
<tr>
<td>SELECT COUNT(col1) FROM tbl_name WHERE col2 = ? GROUP BY col1 ORDER BY col3 DESC LIMIT ?, ?</td>
<td></td>
</tr>
<tr>
<td>INSERT INTO tbl_name (col1, col2,…) VALUES (?, ?, ….)</td>
<td></td>
</tr>
<tr>
<td>INSERT INTO tbl_name VALUES (?, ?,….)</td>
<td></td>
</tr>
<tr>
<td>INSERT INTO tbl_name (col1, col2, …) VALUES (?, ?, ….), (?, ?, ….)</td>
<td></td>
</tr>
<tr>
<td>UPDATE tbl_name SET col1 = ? WHERE col2 = ?</td>
<td></td>
</tr>
<tr>
<td>DELETE FROM tbl_name WHERE col1 = ?</td>
<td></td>
</tr>
<tr>
<td>CREATE TABLE tbl_name (col1 int, …)</td>
<td></td>
</tr>
<tr>
<td>ALTER TABLE tbl_name ADD col1 varchar(10)</td>
<td></td>
</tr>
<tr>
<td>DROP TABLE tbl_name</td>
<td></td>
</tr>
<tr>
<td>TRUNCATE TABLE tbl_name</td>
<td></td>
</tr>
<tr>
<td>CREATE INDEX idx_name ON tbl_name</td>
<td></td>
</tr>
<tr>
<td>DROP INDEX idx_name ON tbl_name</td>
<td></td>
</tr>
<tr>
<td>DROP INDEX idx_name</td>
<td>TableRule中配置logic-index</td>
</tr>
</tbody>
</table>
<h3 id="不支持的SQL"><a href="#不支持的SQL" class="headerlink" title="不支持的SQL"></a>不支持的SQL</h3><table>
<thead>
<tr>
<th>SQL</th>
<th>不支持原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSERT INTO tbl_name (col1, col2, …) SELECT col1, col2, … FROM tbl_name WHERE col3 = ?</td>
<td>INSERT .. SELECT</td>
</tr>
<tr>
<td>INSERT INTO tbl_name SET col1 = ?</td>
<td>INSERT .. SET</td>
</tr>
<tr>
<td>SELECT DISTINCT * FROM tbl_name WHERE column1 = ?</td>
<td>DISTINCT</td>
</tr>
<tr>
<td>SELECT COUNT(col1) as count_alias FROM tbl_name GROUP BY col1 HAVING count_alias &gt; ?</td>
<td>HAVING</td>
</tr>
<tr>
<td>SELECT <em> FROM tbl_name1 UNION SELECT </em> FROM tbl_name2</td>
<td>UNION</td>
</tr>
<tr>
<td>SELECT <em> FROM tbl_name1 UNION ALL SELECT </em> FROM tbl_name2</td>
<td>UNION ALL</td>
</tr>
<tr>
<td>SELECT * FROM tbl_name1 WHERE (val1=?) AND (val1=?)</td>
<td>冗余括号</td>
</tr>
<tr>
<td>SELECT * FROM ds.tbl_name1</td>
<td>包含schema</td>
</tr>
</tbody>
</table>
<h1 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h1><h2 id="单线程25w"><a href="#单线程25w" class="headerlink" title="单线程25w"></a>单线程25w</h2><p>单线程批量插入25w数据</p>
<blockquote>
<p>测试代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取并添加</span></span><br><span class="line">        <span class="comment">//读取并添加</span></span><br><span class="line">Connection connection = dataSource.getConnection();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ps = connection.prepareStatement(</span><br><span class="line">                <span class="string">"SELECT * FROM iks_user_amount_record_shengyuancoin_tab;"</span></span><br><span class="line">                ,ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">        ps.setFetchSize(Integer.MIN_VALUE);</span><br><span class="line">        ResultSet rs = ps.executeQuery();</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            recordDOList.add(RecordDO.builder()</span><br><span class="line">                    .recordNo(rs.getString(<span class="string">"recordNo"</span>))</span><br><span class="line">                    .userId(rs.getInt(<span class="string">"userId"</span>))</span><br><span class="line">                    .shengyuanCoin(rs.getBigDecimal(<span class="string">"shengyuanCoin"</span>))</span><br><span class="line">                    .paymentType(rs.getInt(<span class="string">"paymentType"</span>))</span><br><span class="line">                    .remarks(rs.getString(<span class="string">"remarks"</span>))</span><br><span class="line">                    .fromType(rs.getString(<span class="string">"fromType"</span>))</span><br><span class="line">                    .addTime(rs.getTimestamp(<span class="string">"addTime"</span>))</span><br><span class="line">                    .build());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> diff = System.currentTimeMillis() - start;</span><br><span class="line">    System.out.println(<span class="string">"diff:"</span> + diff + <span class="string">",listSize:"</span> + recordDOList.size());</span><br><span class="line"></span><br><span class="line">    start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//执行批量插入操作</span></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH, <span class="keyword">false</span>);</span><br><span class="line">    RecordDao recordDao = sqlSession.getMapper(RecordDao.class);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; recordDOList.size(); i++)&#123;</span><br><span class="line">        RecordDO recordDO = recordDOList.get(i);</span><br><span class="line">        recordDao.insertData(recordDO);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">10000</span>==<span class="number">9999</span>)&#123;<span class="comment">//每10000条提交一次防止内存溢出</span></span><br><span class="line">            System.out.println(<span class="string">"插入成功 i:"</span> + i);</span><br><span class="line">            sqlSession.commit();</span><br><span class="line">            sqlSession.clearCache();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.clearCache();</span><br><span class="line"></span><br><span class="line">    diff = System.currentTimeMillis() - start;</span><br><span class="line">    System.out.println(<span class="string">"diff:"</span> + diff);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 内存变化曲线</p>
</blockquote>
<p><img src="/2017/10/08/sharding-jdbc/image-14.png" alt="image-20181023104717903"></p>
<h2 id="多线程42w"><a href="#多线程42w" class="headerlink" title="多线程42w"></a>多线程42w</h2><blockquote>
<p>代码信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> core = <span class="number">20</span>;</span><br><span class="line">threadPoolExecutor = Executors.newFixedThreadPool(core);</span><br><span class="line"><span class="comment">//读取并添加</span></span><br><span class="line">Connection connection = dataSource.getConnection();</span><br><span class="line"><span class="comment">//获取当前的总数量值</span></span><br><span class="line">PreparedStatement ps = connection.prepareStatement(</span><br><span class="line">        <span class="string">"SELECT count(*) as `count` FROM iks_user_amount_record_shengyuancoin_tab;"</span>);</span><br><span class="line">ps.executeQuery();</span><br><span class="line">ResultSet rs = ps.getResultSet();</span><br><span class="line"><span class="keyword">long</span> count = rs.getLong(<span class="string">"count"</span>);</span><br><span class="line"><span class="keyword">long</span> length = count / core;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;core; j++)&#123;</span><br><span class="line">    threadPoolExecutor.submit(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">int</span> current = atomicInteger.getAndIncrement();</span><br><span class="line">        log.info(<span class="string">"current:&#123;&#125;"</span>, current);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        PreparedStatement innerPs = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;RecordDO&gt; recordDOList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String sql = <span class="string">"SELECT * FROM iks_user_amount_record_shengyuancoin_tab limit "</span> + length*current +<span class="string">","</span> + length;</span><br><span class="line">            log.info(<span class="string">"Sql:&#123;&#125;"</span>, sql);</span><br><span class="line">            innerPs = connection.prepareStatement(sql,ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">            innerPs.setFetchSize(Integer.MIN_VALUE);</span><br><span class="line">            ResultSet innerRs = innerPs.executeQuery();</span><br><span class="line">            <span class="keyword">while</span> (innerRs.next()) &#123;</span><br><span class="line">                recordDOList.add(RecordDO.builder()</span><br><span class="line">                        .recordNo(innerRs.getString(<span class="string">"recordNo"</span>))</span><br><span class="line">                        .userId(innerRs.getInt(<span class="string">"userId"</span>))</span><br><span class="line">                        .shengyuanCoin(innerRs.getBigDecimal(<span class="string">"shengyuanCoin"</span>))</span><br><span class="line">                        .paymentType(innerRs.getInt(<span class="string">"paymentType"</span>))</span><br><span class="line">                        .remarks(innerRs.getString(<span class="string">"remarks"</span>))</span><br><span class="line">                        .fromType(innerRs.getString(<span class="string">"fromType"</span>))</span><br><span class="line">                        .addTime(innerRs.getTimestamp(<span class="string">"addTime"</span>))</span><br><span class="line">                        .build());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> diff = System.currentTimeMillis() - start;</span><br><span class="line">        log.info(<span class="string">"current:&#123;&#125;,diff:&#123;&#125;,listSize:&#123;&#125;"</span>, current, diff, recordDOList.size());</span><br><span class="line"></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//执行批量插入操作</span></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH, <span class="keyword">false</span>);</span><br><span class="line">        RecordDao recordDao = sqlSession.getMapper(RecordDao.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; recordDOList.size(); i++)&#123;</span><br><span class="line">            RecordDO recordDO = recordDOList.get(i);</span><br><span class="line">            recordDao.insertData(recordDO);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">10000</span>==<span class="number">9999</span>)&#123;<span class="comment">//每10000条提交一次防止内存溢出</span></span><br><span class="line">                log.info(<span class="string">"插入成功 i:&#123;&#125;"</span>, i);</span><br><span class="line">                sqlSession.commit();</span><br><span class="line">                sqlSession.clearCache();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.clearCache();</span><br><span class="line"></span><br><span class="line">        diff = System.currentTimeMillis() - start;</span><br><span class="line">        log.info(<span class="string">"diff:&#123;&#125;"</span>, diff);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>CPU: 2 GHz Intel Core i7</li>
<li>内存: 8 GB 1600 MHz DDR3</li>
<li>环境: JDK 1.8 SpringBoot1.5.8.RELEASE Mybatis+Druid+Sharding-Jdbc</li>
</ul>
<p>线程数: 20,所花时间12分钟</p>
<p>内存曲线图</p>
<p><img src="/2017/10/08/sharding-jdbc/image-16.png" alt="image-20181023144941430"></p>

        
    </section>
</article>



<div class="comments">
    <div id="disqus_thread">
        <p class="comment-tips">国内查看评论需要代理~</p>
    </div>
    <script>
    window.disqus_config = function () {
        this.language = 'zh';
        this.page.url = 'http://www.coderss.cn/2017/10/08/sharding-jdbc/';
        this.page.title = 'Sharding-Jdbc';
        this.page.identifier = '2017/10/08/sharding-jdbc/';
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://name.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>

<script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1234567890&amp;web_id=1234567890"></script>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript" src="/js/scrollspy.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
            $(document.body).scrollspy({target: '#aside-inner'});
            
        });
    </script>

</body>
</html>
